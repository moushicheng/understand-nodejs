<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="通过源码分析 Node.js 原理"><meta name=author content=theanarkh><link href=https://github.com/theanarkh/understand-nodejs/chapter08-DNS/ rel=canonical><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.2.2, mkdocs-material-7.2.8"><title>08-DNS - Node.js 源码剖析</title><link rel=stylesheet href=../assets/stylesheets/main.92558b1b.min.css><link rel=stylesheet href=../assets/stylesheets/palette.3f5d1f46.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script> <script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#81-ip class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=.. title="Node.js 源码剖析" class="md-header__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5V2M6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Node.js 源码剖析 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 08-DNS </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=blue data-md-color-accent=blue aria-label="Switch to light mode" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z"/></svg> </label> </form> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08z"/></svg> </a> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/theanarkh/understand-nodejs/ title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-tabs__link> 前言 </a> </li> <li class=md-tabs__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-tabs__link> Node.js基础和架构 </a> </li> <li class=md-tabs__item> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class="md-tabs__link md-tabs__link--active"> Node.js核心模块的实现 </a> </li> <li class=md-tabs__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-tabs__link> 其他 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="Node.js 源码剖析" class="md-nav__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5V2M6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5z"/></svg> </a> Node.js 源码剖析 </label> <div class=md-nav__source> <a href=https://github.com/theanarkh/understand-nodejs/ title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> Home </a> </li> <li class=md-nav__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-nav__link> 前言 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Node.js基础和架构 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Node.js基础和架构 data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Node.js基础和架构 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-nav__link> 01-Node.js组成和原理 </a> </li> <li class=md-nav__item> <a href=../chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/ class=md-nav__link> 02-Libuv数据结构和通用逻辑 </a> </li> <li class=md-nav__item> <a href=../chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/ class=md-nav__link> 03-事件循环 </a> </li> <li class=md-nav__item> <a href=../chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> 04-线程池 </a> </li> <li class=md-nav__item> <a href=../chapter05-Libuv%E6%B5%81/ class=md-nav__link> 05-Libuv流 </a> </li> <li class=md-nav__item> <a href=../chapter06-C%2B%2B%E5%B1%82/ class=md-nav__link> 06-C++层 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4> Node.js核心模块的实现 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Node.js核心模块的实现 data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Node.js核心模块的实现 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class=md-nav__link> 07-信号处理 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> 08-DNS <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> 08-DNS </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#81-ip class=md-nav__link> 8.1 通过域名找IP </a> </li> <li class=md-nav__item> <a href=#82-cares class=md-nav__link> 8.2 cares </a> <nav class=md-nav aria-label="8.2 cares"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#821-cares class=md-nav__link> 8.2.1 cares使用和原理 </a> </li> <li class=md-nav__item> <a href=#822-cares_wrapcc class=md-nav__link> 8.2.2 cares_wrap.cc的通用逻辑 </a> </li> <li class=md-nav__item> <a href=#823 class=md-nav__link> 8.2.3 具体实现 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../chapter09-Unix%E5%9F%9F/ class=md-nav__link> 09-Unix域 </a> </li> <li class=md-nav__item> <a href=../chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/ class=md-nav__link> 10-定时器 </a> </li> <li class=md-nav__item> <a href=../chapter11-setImmediate%E5%92%8CnextTick/ class=md-nav__link> 11-setImmediate和nextTick </a> </li> <li class=md-nav__item> <a href=../chapter12-%E6%96%87%E4%BB%B6/ class=md-nav__link> 12-文件 </a> </li> <li class=md-nav__item> <a href=../chapter13-%E8%BF%9B%E7%A8%8B/ class=md-nav__link> 13-进程 </a> </li> <li class=md-nav__item> <a href=../chapter14-%E7%BA%BF%E7%A8%8B/ class=md-nav__link> 14-线程 </a> </li> <li class=md-nav__item> <a href=../chapter15-Cluster/ class=md-nav__link> 15-Cluster </a> </li> <li class=md-nav__item> <a href=../chapter16-UDP/ class=md-nav__link> 16-UDP </a> </li> <li class=md-nav__item> <a href=../chapter17-TCP/ class=md-nav__link> 17-TCP </a> </li> <li class=md-nav__item> <a href=../chapter18-HTTP/ class=md-nav__link> 18-HTTP </a> </li> <li class=md-nav__item> <a href=../chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/ class=md-nav__link> 19-模块加载 </a> </li> <li class=md-nav__item> <a href=../chapter21-JS%20Stream/ class=md-nav__link> 20-JS Stream </a> </li> <li class=md-nav__item> <a href=../chapter22-events%E6%A8%A1%E5%9D%97/ class=md-nav__link> 21-events模块 </a> </li> <li class=md-nav__item> <a href=../chapter23-Async%20hooks/ class=md-nav__link> 22-Async hooks </a> </li> <li class=md-nav__item> <a href=../chapter24-Inspector/ class=md-nav__link> 23-Inspector </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5> 其他 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=其他 data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> 其他 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-nav__link> 24-拓展Node.js </a> </li> <li class=md-nav__item> <a href=../chapter25-Node.js子线程调试和诊断指南 class=md-nav__link> 25-Node.js子线程调试和诊断指南 </a> </li> <li class=md-nav__item> <a href=../chapter26-vscode%E8%B0%83%E8%AF%95Node.js/ class=md-nav__link> 26-vscode调试Node.js </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#81-ip class=md-nav__link> 8.1 通过域名找IP </a> </li> <li class=md-nav__item> <a href=#82-cares class=md-nav__link> 8.2 cares </a> <nav class=md-nav aria-label="8.2 cares"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#821-cares class=md-nav__link> 8.2.1 cares使用和原理 </a> </li> <li class=md-nav__item> <a href=#822-cares_wrapcc class=md-nav__link> 8.2.2 cares_wrap.cc的通用逻辑 </a> </li> <li class=md-nav__item> <a href=#823 class=md-nav__link> 8.2.3 具体实现 </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/theanarkh/understand-nodejs/edit/main/docs/chapter08-DNS.md title=编辑此页 class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg> </a> <h1>08-DNS</h1> <p>Node.js的DNS模块使用了cares库和Libuv的线程池实现。cares是一个异步DNS解析库，它自己实现了DNS协议的封包和解析，配合Libuv事件驱动机制，在Node.js中实现异步的DNS解析。另外通过IP查询域名或者域名查询IP是直接调用操作系统提供的接口实现的，因为这两个函数是阻塞式的API，所以Node.js是通过Libuv的线程池实现异步查询。除了提供直接的DNS查询外，Node.js还提供了设置DNS服务器、新建一个DNS解析实例（Resolver）等功能。这些功能是使用cares实现的。下面我们开始分析DNS模块的原理和实现。 </p> <h2 id=81-ip>8.1 通过域名找IP<a class=headerlink href=#81-ip title="Permanent link">&para;</a></h2> <p>我们看一下在Node.js中如何查询一个域名对于的IP的信息</p> <div class=highlight><pre><span></span><code>1.  dns.lookup(&#39;www.a.com&#39;, function(err, address, family) {  
2.      console.log(address);  
3.  });  
</code></pre></div> <p>DNS功能的JS层实现在dns.js中</p> <div class=highlight><pre><span></span><code>1.  const req = new GetAddrInfoReqWrap();  
2.  req.callback = callback;  
3.  req.family = family;  
4.  req.hostname = hostname;  
5.  req.oncomplete = all ? onlookupall : onlookup;  
6.    
7.  const err = cares.getaddrinfo(  
8.    req, toASCII(hostname), family, hints, verbatim  
9.  );  
</code></pre></div> <p>Node.js设置了一些参数后，调用cares_wrap.cc的getaddrinfo方法，在care_wrap.cc的初始化函数中我们看到， getaddrinfo函数对应的函数是GetAddrInfo。</p> <div class=highlight><pre><span></span><code>1.  void Initialize(Local&lt;Object&gt; target,  
2.                  Local&lt;Value&gt; unused,  
3.                  Local&lt;Context&gt; context) {  
4.    Environment* env = Environment::GetCurrent(context); 
5.    env-&gt;SetMethod(target, &quot;getaddrinfo&quot;, GetAddrInfo);  
6.    ...  
7.  }  
</code></pre></div> <p>GetAddrInfo的主要逻辑如下</p> <div class=highlight><pre><span></span><code>1.  auto req_wrap = new GetAddrInfoReqWrap(env, req_wrap_obj, args[4]-&gt;IsTrue());  
2.    
3.  struct addrinfo hints;  
4.  memset(&amp;hints, 0, sizeof(struct addrinfo));  
5.  hints.ai_family = family;  
6.  hints.ai_socktype = SOCK_STREAM;  
7.  hints.ai_flags = flags;  
8.    
9.  int err = uv_getaddrinfo(env-&gt;event_loop(),
10.                             req_wrap-&gt;req(), 
11.                             AfterGetAddrInfo,
12.                             *hostname,
13.                             nullptr,
14.                             &amp;hints);  
</code></pre></div> <p>GetAddrInfo是对uv_getaddrinfo的封装，回调函数是AfterGetAddrInfo</p> <div class=highlight><pre><span></span><code>1.  int uv_getaddrinfo(uv_loop_t* loop,  
2.                      // 上层传进来的req  
3.                     uv_getaddrinfo_t* req,  
4.                     // 解析完后的上层回调  
5.                     uv_getaddrinfo_cb cb,  
6.                     // 需要解析的名字  
7.                     const char* hostname,  
8.                     /* 
9.                             查询的过滤条件：服务名。比如
10.                                         http smtp。也可以是一个端口。
11.                                         见下面注释 
12.                               */  
13.                    const char* service,  
14.                    // 其它查询过滤条件  
15.                    const struct addrinfo* hints) {  
16.    
17.   size_t hostname_len;  
18.   size_t service_len;  
19.   size_t hints_len;  
20.   size_t len;  
21.   char* buf;  
22.   
23.   hostname_len = hostname ? strlen(hostname) + 1 : 0;  
24.   service_len = service ? strlen(service) + 1 : 0;  
25.   hints_len = hints ? sizeof(*hints) : 0;  
26.   buf = uv__malloc(hostname_len + service_len + hints_len);  
27.   uv__req_init(loop, req, UV_GETADDRINFO);  
28.   req-&gt;loop = loop;  
29.   // 设置请求的回调  
30.   req-&gt;cb = cb;  
31.   req-&gt;addrinfo = NULL;  
32.   req-&gt;hints = NULL;  
33.   req-&gt;service = NULL;  
34.   req-&gt;hostname = NULL;  
35.   req-&gt;retcode = 0;  
36.   len = 0;  
37.   
38.   if (hints) {  
39.     req-&gt;hints = memcpy(buf + len, hints, sizeof(*hints));  
40.     len += sizeof(*hints);  
41.   }  
42.   
43.   if (service) {  
44.     req-&gt;service = memcpy(buf + len, service, service_len); 
45.     len += service_len;  
46.   }  
47.   
48.   if (hostname)  
49.     req-&gt;hostname = memcpy(buf + len, hostname, hostname_len);
50.   // 传了cb则是异步  
51.   if (cb) {  
52.     uv__work_submit(loop,  
53.             &amp;req-&gt;work_req,  
54.             UV__WORK_SLOW_IO,  
55.             uv__getaddrinfo_work,  
56.             uv__getaddrinfo_done);  
57.     return 0;  
58.   } else {  
59.     // 阻塞式查询，然后执行回调  
60.     uv__getaddrinfo_work(&amp;req-&gt;work_req);  
61.     uv__getaddrinfo_done(&amp;req-&gt;work_req, 0);  
62.     return req-&gt;retcode;  
63.   }  
64. }  
</code></pre></div> <p>我们看到这个函数首先是对一个request进行初始化，然后根据是否传了回调，决定走异步还是同步的模式。同步的方式比较简单，就是直接阻塞Libuv事件循环，直到解析完成。如果是异步，则给线程池提交一个慢IO的任务。其中工作函数是uv__getaddrinfo_work。回调是uv__getaddrinfo_done。我们看一下这两个函数。</p> <div class=highlight><pre><span></span><code>1.  // 解析的工作函数  
2.  static void uv__getaddrinfo_work(struct uv__work* w) {  
3.    uv_getaddrinfo_t* req;  
4.    int err;  
5.    // 根据结构体的字段获取结构体首地址  
6.    req = container_of(w, uv_getaddrinfo_t, work_req);  
7.    // 阻塞在这  
8.    err = getaddrinfo(req-&gt;hostname, 
9.                          req-&gt;service, 
10.                         req-&gt;hints, 
11.                         &amp;req-&gt;addrinfo);  
12.   req-&gt;retcode = uv__getaddrinfo_translate_error(err);  
13. }  
</code></pre></div> <p>uv__getaddrinfo_work函数主要是调用了系统提供的getaddrinfo去做解析。该函数会导致进程阻塞。结果返回后，执行uv__getaddrinfo_done。</p> <div class=highlight><pre><span></span><code>1.  static void uv__getaddrinfo_done(struct uv__work* w, int status) {  
2.    uv_getaddrinfo_t* req;  
3.    
4.    req = container_of(w, uv_getaddrinfo_t, work_req);  
5.    uv__req_unregister(req-&gt;loop, req);  
6.    // 释放初始化时申请的内存  
7.    if (req-&gt;hints)  
8.      uv__free(req-&gt;hints);  
9.    else if (req-&gt;service)  
10.     uv__free(req-&gt;service);  
11.   else if (req-&gt;hostname)  
12.     uv__free(req-&gt;hostname);  
13.   else  
14.     assert(0);  
15.   
16.   req-&gt;hints = NULL;  
17.   req-&gt;service = NULL;  
18.   req-&gt;hostname = NULL;  
19.   // 解析请求被用户取消了  
20.   if (status == UV_ECANCELED) {  
21.     assert(req-&gt;retcode == 0);  
22.     req-&gt;retcode = UV_EAI_CANCELED;  
23.   }  
24.   // 执行上层回调  
25.   if (req-&gt;cb)  
26.     req-&gt;cb(req, req-&gt;retcode, req-&gt;addrinfo);  
27.   
28. }  
</code></pre></div> <p>uv__getaddrinfo_done会执行C++层的回调，从而执行JS层的回调。</p> <h2 id=82-cares>8.2 cares<a class=headerlink href=#82-cares title="Permanent link">&para;</a></h2> <p>除了通过IP查询域名和域名查询IP外，其余的DNS功能都由cares实现，我们看一下cares的基本用法。</p> <h3 id=821-cares>8.2.1 cares使用和原理<a class=headerlink href=#821-cares title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code>1.  // channel是cares的核心结构体
2.  ares_channel channel;  
3.  struct ares_options options;  
4.  // 初始化channel
5.  status = ares_init_options(&amp;channel, &amp;options, optmask);  
6.  // 把 argv的数据存到addr
7.  ares_inet_pton(AF_INET, *argv, &amp;addr4);
8.  // 把addr数据存到channel并发起DNS查询
9.  ares_gethostbyaddr(channel, 
10.                    &amp;addr4, 
11.                    sizeof(addr4), 
12.                    AF_INET, 
13.                    callback,*argv);  
14. for (;;)  
15.     {  
16.       int res;  
17.       FD_ZERO(&amp;read_fds);  
18.       FD_ZERO(&amp;write_fds);  
19.       // 把channel对应的fd存到read_fd和write_fds  
20.       nfds = ares_fds(channel, &amp;read_fds, &amp;write_fds);  
21.       if (nfds == 0)  
22.         break;  
23.       // 设置超时时间  
24.       tvp = ares_timeout(channel, NULL, &amp;tv);  
25.       // 阻塞在select，等待DNS回包  
26.       res = select(nfds, &amp;read_fds, &amp;write_fds, NULL, tvp);
27.       if (-1 == res)  
28.         break;  
29.       // 处理DNS相应  
30.       ares_process(channel, &amp;read_fds, &amp;write_fds);  
31.     }  
</code></pre></div> <p>上面是一个典型的事件驱动模型，首先初始化一些信息，然后发起一个非阻塞的请求，接着阻塞在多路复用API，该API返回后，执行触发了事件的回调。</p> <h3 id=822-cares_wrapcc>8.2.2 cares_wrap.cc的通用逻辑<a class=headerlink href=#822-cares_wrapcc title="Permanent link">&para;</a></h3> <p>在Node.js中，Node.js和cares的整体交互如图8-1所示。 <br> <img alt src="https://img-blog.csdnimg.cn/cf528843e4ac4b1c8ce03407f502083d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图8-1. </p> <p>我们通过cares_wrap.cc分析其中的原理。我们从DNS模块提供的resolveCname函数开始。resolveCname函数由以下代码导出（dns.js）。 <div class=highlight><pre><span></span><code>bindDefaultResolver(module.exports, getDefaultResolver())  
</code></pre></div> 我们看一下这两个函数（dns/utils.js）。</p> <div class=highlight><pre><span></span><code>1.  class Resolver {  
2.    constructor() {  
3.      this._handle = new ChannelWrap();  
4.    }  
5.    // ...  
6.  }  
7.    
8.  let defaultResolver = new Resolver();  
9.    
10. function getDefaultResolver() {  
11.   return defaultResolver;  
12. }  
13.   
14. function resolver(bindingName) {  
15.   function query(name, /* options, */ callback) {  
16.     let options;  
17.     const req = new QueryReqWrap();  
18.     req.bindingName = bindingName;  
19.     req.callback = callback;  
20.     req.hostname = name;  
21.     req.oncomplete = onresolve;  
22.     req.ttl = !!(options &amp;&amp; options.ttl);  
23.     const err = this._handle[bindingName](req, toASCII(name));  
24.     if (err) throw dnsException(err, bindingName, name);  
25.     return req;  
26.   }  
27.   ObjectDefineProperty(query, &#39;name&#39;, { value: bindingName });  
28.   return query;  
29. }  
30. // 给原型链注入一个新的属性，defaultResolver中也生效  
31. Resolver.prototype.resolveCname = resolveMap.CNAME = resolver(&#39;queryCname&#39;);  
</code></pre></div> <p>getDefaultResolver导出的是一个Resolve对象，里面有resolveCname等一系列方法。接着看一下bindDefaultResolver，我们一会再看ChannelWrap。</p> <div class=highlight><pre><span></span><code>1.  const resolverKeys = [ 
2.    &#39;resolveCname &#39;,  
3.    // …
4.  ]  
5.  function bindDefaultResolver(target, source) {  
6.    resolverKeys.forEach((key) =&gt; {  
7.      target[key] = source[key].bind(defaultResolver);  
8.    });  
9.  }  
</code></pre></div> <p>看起来很绕，其实就是把Resolve对象的方法导出到DNS模块。这样用户就可以使用了。我们看到resolveCname是由resolver函数生成的，resolver函数对cares系列函数进行了封装，最终调用的是this._handle.queryCname函数。我们来看一下这个handle（ChannelWrap类对象）的实现（cares_wrap.cc）。我们先看一下cares_wrap.cc模块导出的API。</p> <div class=highlight><pre><span></span><code>1.  Local&lt;FunctionTemplate&gt; channel_wrap = env-&gt;NewFunctionTemplate(ChannelWrap::New);  
2.  channel_wrap-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);  
3.  channel_wrap-&gt;Inherit(AsyncWrap::GetConstructorTemplate(env));  
4.  // Query是C++函数模板
5.  env-&gt;SetProtoMethod(channel_wrap, 
6.                        &quot;queryCname&quot;, 
7.                        Query&lt;QueryCnameWrap&gt;);  
8.  // ...  
9.  Local&lt;String&gt; channelWrapString = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;ChannelWrap&quot;);  
10. channel_wrap-&gt;SetClassName(channelWrapString);  
11. target-&gt;Set(env-&gt;context(), 
12. channelWrapString,channel_wrap-&gt;GetFunction(context).ToLocalChecked()).Check();  
</code></pre></div> <p>handle对应的就是以上代码导出的对象。当我们在JS层执行new ChannelWrap的时候。 最终会调用C++层创建一个对象，并且执行ChannelWrap::New。</p> <div class=highlight><pre><span></span><code>1.  void ChannelWrap::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
2.    Environment* env = Environment::GetCurrent(args);  
3.    new ChannelWrap(env, args.This());  
4.  }  
</code></pre></div> <p>我们看一下类ChannelWrap的定义。</p> <div class=highlight><pre><span></span><code>1.  class ChannelWrap : public AsyncWrap {  
2.   public:  
3.    // ...  
4.    
5.   private:  
6.    // 超时管理  
7.    uv_timer_t* timer_handle_;  
8.    // cares数据类型  
9.    ares_channel channel_;  
10.   // 标记查询结果  
11.   bool query_last_ok_;  
12.   // 使用的DNS服务器  
13.   bool is_servers_default_;  
14.   // 是否已经初始化cares库  
15.   bool library_inited_;  
16.   // 正在发起的查询个数  
17.   int active_query_count_;  
18.   // 发起查询的任务队列  
19.   node_ares_task_list task_list_;  
20. };  
</code></pre></div> <p>接着我们看看ChannelWrap构造函数的代码。</p> <div class=highlight><pre><span></span><code>1.  ChannelWrap::ChannelWrap(...) {  
2.    Setup();  
3.  }  
</code></pre></div> <p>ChannelWrap里直接调用了Setup</p> <div class=highlight><pre><span></span><code>1.  void ChannelWrap::Setup() {  
2.    struct ares_options options;  
3.    memset(&amp;options, 0, sizeof(options));  
4.    options.flags = ARES_FLAG_NOCHECKRESP;   
5.    /*
6.      caresd socket状态（读写）发生变更时，执行的函数，
7.      第一个入参是sock_state_cb_data
8.    */
9.    options.sock_state_cb = ares_sockstate_cb;  
10.  options.sock_state_cb_data = this;  
11.   
12.  // 还没初始化则初始化 
13.  if (!library_inited_) {  
14.    Mutex::ScopedLock lock(ares_library_mutex);  
15.    // 初始化cares库  
16.    ares_library_init(ARES_LIB_INIT_ALL);  
17.  }  
18.  // 设置使用cares的配置  
19.  ares_init_options(&amp;channel_,  
20.                        &amp;options,  
21.                        ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB);
22.  library_inited_ = true;  
23. }  
</code></pre></div> <p>我们看到，Node.js在这里初始化cares相关的逻辑。其中最重要的就是设置了cares socket状态变更时执行的回调ares_sockstate_cb（比如socket需要读取数据或者写入数据）。前面的cares使用例子中讲到了cares和事件驱动模块的配合使用，那么cares和Libuv是如何配合的呢？cares提供了一种机制，就是socket状态变更时通知事件驱动模块。DNS解析本质上也是网络IO，所以发起一个DNS查询也就是对应一个socket。DNS查询是由cares发起的，这就意味着socket是在cares中维护的，那Libuv怎么知道呢？正是cares提供的通知机制，使得Libuv知道发起DNS查询对应的socket，从而注册到Libuv中，等到事件触发后，再通知cares。下面我们看一下具体的实现。我们从发起一个cname查询开始分析。首先回顾一下cares_wrap模块导出的cname查询函数， env-&gt;SetProtoMethod(channel_wrap, "queryCname", Query<querycnamewrap>);Query是C++模板函数，QueryCnameWrap是C++类</p> <div class=highlight><pre><span></span><code>1.  template &lt;class Wrap&gt;  
2.  static void Query(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
3.    Environment* env = Environment::GetCurrent(args);  
4.    ChannelWrap* channel;  
5.      // Holder中保存了ChannelWrap对象，解包出来
6.    ASSIGN_OR_RETURN_UNWRAP(&amp;channel, args.Holder());  
7.    Local&lt;Object&gt; req_wrap_obj = args[0].As&lt;Object&gt;();  
8.    Local&lt;String&gt; string = args[1].As&lt;String&gt;();  
9.      /*
10.       根据参数新建一个对象，这里是QueryCnameWrap，
11.       并且保存对应的ChannelWrap对象和操作相关的对象
12.     */
13.   Wrap* wrap = new Wrap(channel, req_wrap_obj);  
14.   
15.   node::Utf8Value name(env-&gt;isolate(), string);
16.     // 发起请求数加一  
17.   channel-&gt;ModifyActivityQueryCount(1);  
18.     // 调用Send函数发起查询
19.   int err = wrap-&gt;Send(*name);  
20.   if (err) {  
21.     channel-&gt;ModifyActivityQueryCount(-1);  
22.     delete wrap;  
23.   }  
24.   
25.   args.GetReturnValue().Set(err);  
26. }  
</code></pre></div> <p>Query只实现了一些通用的逻辑，然后调用Send函数，具体的Send函数逻辑由各个具体的类实现。</p> <h3 id=823>8.2.3 具体实现<a class=headerlink href=#823 title="Permanent link">&para;</a></h3> <p>我们看一下QueryCnameWrap类。</p> <div class=highlight><pre><span></span><code>1.  class QueryCnameWrap: public QueryWrap {  
2.   public:  
3.    QueryCnameWrap(ChannelWrap* channel, 
4.                     Local&lt;Object&gt; req_wrap_obj)  
5.        : QueryWrap(channel, req_wrap_obj, &quot;resolveCname&quot;) {  
6.    }  
7.    
8.    int Send(const char* name) override {  
9.       AresQuery(name, ns_c_in, ns_t_cname);  
10.     return 0;  
11.   }  
12.   
13.  protected:  
14.   void Parse(unsigned char* buf, int len) override {  
15.     HandleScope handle_scope(env()-&gt;isolate());  
16.     Context::Scope context_scope(env()-&gt;context());  
17.   
18.     Local&lt;Array&gt; ret = Array::New(env()-&gt;isolate());  
19.     int type = ns_t_cname;  
20.     int status = ParseGeneralReply(env(), buf, len, &amp;type, ret);  
21.     if (status != ARES_SUCCESS) {  
22.       ParseError(status);  
23.       return;  
24.     }  
25.   
26.     this-&gt;CallOnComplete(ret);  
27.   }  
28. };  
</code></pre></div> <p>我们看到QueryCnameWrap类的实现非常简单，主要定义Send和Parse的实现，最终还是会调用基类对应的函数。我们看一下基类QueryWrap中AresQuery的实现。</p> <div class=highlight><pre><span></span><code>1.  void AresQuery(const char* name,  
2.          int dnsclass,  
3.          int type) {  
4.      ares_query(channel_-&gt;cares_channel(), 
5.                     name, 
6.                     dnsclass, 
7.                     type, 
8.                     Callback,  
9.            static_cast&lt;void*&gt;(this));  
10.   }  
</code></pre></div> <p>AresQuery函数提供统一发送查询操作。查询完成后执行Callback回调。接下来就涉及到cares和Node.js的具体交互了。Node.js把一个任务交给cares后，cares会新建一个socket，接着cares会通过Node.js设置的回调ares_sockstate_cb通知Node.js。我们看一下ares_query的关键逻辑。</p> <div class=highlight><pre><span></span><code>1.  void ares_query(ares_channel channel, const char *name, int dnsclass,  
2.                  int type, ares_callback callback, void *arg)  
3.  {  
4.    struct qquery *qquery;  
5.    unsigned char *qbuf;  
6.    int qlen, rd, status;  
7.    
8.    qquery = ares_malloc(sizeof(struct qquery));  
9.    // 保存Node.js的回调，查询完成时回调  
10.   qquery-&gt;callback = callback;  
11.   qquery-&gt;arg = arg;  
12.   ares_send(channel, qbuf, qlen, qcallback, qquery);  
13. }  
14. 
15. static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen)  
16. {  
17.   struct qquery *qquery = (struct qquery *) arg;  
18.   unsigned int ancount;  
19.   int rcode;  
20.   
21.   if (status != ARES_SUCCESS)  
22.     qquery-&gt;callback(qquery-&gt;arg, status, timeouts, abuf, alen);
23.   else  
24.     {  
25.       // ...  
26.       // 执行Node.js回调  
27.       qquery-&gt;callback(qquery-&gt;arg, 
28.                           status,
29.                           timeouts, 
30.                           abuf, 
31.                           alen);  
32.     }  
33.   ares_free(qquery);  
34. }  
35. 
</code></pre></div> <p>ares_query保存了Node.js的回调，并且设置回调qcallback，查询成功后会回调qcallback，qcallback再回调Node.js。接着执行ares_send，ares_send会调用ares__send_query。</p> <div class=highlight><pre><span></span><code>1.  void ares__send_query(ares_channel channel, 
2.                          struct query *query,  
3.                        struct timeval *now)  
4.  {  
5.      struct server_state *server = &amp;channel-&gt;servers[query-&gt;server];  
6.      if (server-&gt;udp_socket == ARES_SOCKET_BAD)  
7.          {  
8.            // 申请一个socket  
9.            if (open_udp_socket(channel, server) == -1)  
10.             {  
11.               skip_server(channel, query, query-&gt;server);  
12.               next_server(channel, query, now);  
13.               return;  
14.             }  
15.         }  
16.       // 发送DNS查询  
17.       if (socket_write(channel, server-&gt;udp_socket, query-&gt;qbuf, query-&gt;qlen) == -1)  
18.         {  
19.           skip_server(channel, query, query-&gt;server);  
20.           next_server(channel, query, now);  
21.           return;  
22.         }  
23. }  
</code></pre></div> <p>ares__send_query首先申请一个socket，然后发送数据。因为UDP不是面向连接的，可以直接发送。我们看一下open_udp_socket。</p> <div class=highlight><pre><span></span><code>1.  static int open_udp_socket(ares_channel channel, struct server_state *server)  
2.  {  
3.    ares_socket_t s;  
4.    ares_socklen_t salen;  
5.    union {  
6.      struct sockaddr_in  sa4;  
7.      struct sockaddr_in6 sa6;  
8.    } saddr;  
9.    struct sockaddr *sa;  
10.   
11.   // 申请一个socket  
12.   s = open_socket(channel, server-&gt;addr.family, SOCK_DGRAM, 0); 
13.   // 绑定服务器地址  
14.   connect_socket(channel, s, sa, salen)  
15.     
16.   // 通知Node.js，1,0表示对socket的读事件感兴趣，因为发送了请求，等待响应  
17.   SOCK_STATE_CALLBACK(channel, s, 1, 0);  
18.   // 保存socket
19.   server-&gt;udp_socket = s;  
20.   return 0;  
21. }  
22. 
23. #define SOCK_STATE_CALLBACK(c, s, r, w)                                 \  
24.   do {                                                                  \  
25.     if ((c)-&gt;sock_state_cb)                                             \  
26.       (c)-&gt;sock_state_cb((c)-&gt;sock_state_cb_data, (s), (r), (w));       \  
27.   } WHILE_FALSE  
28. 
</code></pre></div> <p>ares__send_query函数做了三件事 1 申请了socket， 2 通知Node.js 3 发送了DNS查询请求 这时候流程走到了Node.js，我们看一下cares回调Node.js的时候，Node.js怎么处理的</p> <div class=highlight><pre><span></span><code>1.  struct node_ares_task : public MemoryRetainer {  
2.    ChannelWrap* channel;  
3.    // 关联的socket  
4.    ares_socket_t sock;  
5.    // IO观察者和回调  
6.    uv_poll_t poll_watcher;  
7.  };  
8.    
9.  void ares_sockstate_cb(void* data,  
10.                        ares_socket_t sock,  
11.                        int read,  
12.                        int write) {  
13.   ChannelWrap* channel = static_cast&lt;ChannelWrap*&gt;(data);  
14.   node_ares_task* task;  
15.   // 任务  
16.   node_ares_task lookup_task;  
17.   lookup_task.sock = sock;  
18.   // 该任务是否已经存在  
19.   auto it = channel-&gt;task_list()-&gt;find(&amp;lookup_task);  
20.   
21.   task = (it == channel-&gt;task_list()-&gt;end()) ? nullptr : *it;  
22.   
23.   if (read || write) {  
24.     if (!task) {  
25.       // 开启定时器，超时后通知cares  
26.       channel-&gt;StartTimer();  
27.       // 创建一个任务  
28.       task = ares_task_create(channel, sock);  
29.       // 保存到任务列表  
30.       channel-&gt;task_list()-&gt;insert(task);  
31.     }  
32.     // 注册IO观察者到epoll，感兴趣的事件根据cares传的进行设置，有事件触发后执行回调ares_poll_cb  
33.     uv_poll_start(&amp;task-&gt;poll_watcher,  
34.                   (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),  
35.                   ares_poll_cb);  
36.   
37.   } else {  
38.     // socket关闭了，删除任务  
39.     channel-&gt;task_list()-&gt;erase(it);  
40.     // 关闭该任务对应观察者io，然后删除删除该任务  
41.     channel-&gt;env()-&gt;CloseHandle(&amp;task-&gt;poll_watcher, ares_poll_close_cb);  
42.     // 没有任务了，关闭定时器  
43.     if (channel-&gt;task_list()-&gt;empty()) {  
44.       channel-&gt;CloseTimer();  
45.     }  
46.   }  
47. }  
</code></pre></div> <p>每一个DNS查询的任务，在Node.js中用node_ares_task 管理。它封装了请求对应的channel、查询请求对应的socket和uv_poll_t。我们看一下ares_task_create</p> <div class=highlight><pre><span></span><code>1.  node_ares_task* ares_task_create(ChannelWrap* channel, ares_socket_t sock) {  
2.    auto task = new node_ares_task();  
3.    
4.    task-&gt;channel = channel;  
5.    task-&gt;sock = sock;  
6.    // 初始化uv_poll_t，保存文件描述符sock到uv_poll_t  
7.    if (uv_poll_init_socket(channel-&gt;env()-&gt;event_loop(),&amp;task-&gt;poll_watcher, sock) &lt; 0) {  
8.      delete task;  
9.      return nullptr;  
10.   }  
11.   
12.   return task;  
13. }  
</code></pre></div> <p>首先创建一个node_ares_task对象。然后初始化uv_poll_t并且把文件描述符保存到uv_poll_t。uv_poll_t是对文件描述符、回调、IO观察者的封装。文件描述符的事件触发时，会执行IO观察者的回调，从而执行uv_poll_t保存的回调。我们继续回到ares_sockstate_cb，当cares通知Node.js socket状态变更的时候，Node.js就会修改epoll节点的配置（感兴趣的事件）。当事件触发的时候，会执行ares_poll_cb。我们看一下该函数。</p> <div class=highlight><pre><span></span><code>1.  void ares_poll_cb(uv_poll_t* watcher, int status, int events) {  
2.    node_ares_task* task = ContainerOf(&amp;node_ares_task::poll_watcher, watcher);  
3.    ChannelWrap* channel = task-&gt;channel;  
4.    
5.    // 有事件触发，重置超时时间  
6.    uv_timer_again(channel-&gt;timer_handle());  
7.    
8.    // 通知cares处理响应  
9.    ares_process_fd(channel-&gt;cares_channel(),  
10.                   events &amp; UV_READABLE ? task-&gt;sock : ARES_SOCKET_BAD,  
11.                   events &amp; UV_WRITABLE ? task-&gt;sock : ARES_SOCKET_BAD);  
12. }  
</code></pre></div> <p>当socket上感兴趣的事件触发时，Node.js调ares_process_fd处理。真正的处理函数是processfds。</p> <div class=highlight><pre><span></span><code>1.  static void processfds(ares_channel channel,  
2.                         fd_set *read_fds, ares_socket_t read_fd,  
3.                         fd_set *write_fds, ares_socket_t write_fd)  
4.  {  
5.    struct timeval now = ares__tvnow();  
6.    
7.    write_tcp_data(channel, write_fds, write_fd, &amp;now);  
8.    read_tcp_data(channel, read_fds, read_fd, &amp;now);  
9.    read_udp_packets(channel, read_fds, read_fd, &amp;now);  
10.  process_timeouts(channel, &amp;now);  
11.  process_broken_connections(channel, &amp;now);  
12. }  
</code></pre></div> <p>processfds是统一的处理函数，在各自函数内会做相应的判断和处理。我们这里是收到了UDP响应。则会执行read_udp_packets</p> <div class=highlight><pre><span></span><code>1.  static void read_udp_packets(ares_channel channel, fd_set *read_fds,  
2.                               ares_socket_t read_fd, struct timeval *now){  
3.  // 读取响应  
4.  count = socket_recvfrom(channel, server-&gt;udp_socket, (void *)buf, sizeof(buf), 0, &amp;from.sa, &amp;fromlen);  
5.  // 处理响应，最终调用query-&gt;callback回调Node.js  
6.  process_answer(channel, buf, (int)count, i, 0, now);  
7.  }  
</code></pre></div> <p>Cares读取响应然后解析响应，最后回调Node.js。Node.js设置的回调函数是Callback</p> <div class=highlight><pre><span></span><code>1.  static void Callback(void* arg, int status, int timeouts,  
2.                         unsigned char* answer_buf, int answer_len) {  
3.      QueryWrap* wrap = FromCallbackPointer(arg);  
4.      unsigned char* buf_copy = nullptr;  
5.      if (status == ARES_SUCCESS) {  
6.        buf_copy = node::Malloc&lt;unsigned char&gt;(answer_len);  
7.        memcpy(buf_copy, answer_buf, answer_len);  
8.      }  
9.    
10.     wrap-&gt;response_data_ = std::make_unique&lt;ResponseData&gt;();  
11.     ResponseData* data = wrap-&gt;response_data_.get();  
12.     data-&gt;status = status;  
13.     data-&gt;is_host = false;  
14.     data-&gt;buf = MallocedBuffer&lt;unsigned char&gt;(buf_copy, answer_len);  
15.     // 执行QueueResponseCallback
16.     wrap-&gt;QueueResponseCallback(status);  
17. }  
18.   
19. void QueueResponseCallback(int status) {  
20.     BaseObjectPtr&lt;QueryWrap&gt; strong_ref{this};  
21.     // 产生一个native immediate任务，在check阶段执行  
22.     env()-&gt;SetImmediate([this, strong_ref](Environment*) {  
23.        // check阶段执行
24.       AfterResponse(); 
25.       // Delete once strong_ref goes out of scope.  
26.       Detach();  
27.     });  
28.   
29.     channel_-&gt;set_query_last_ok(status != ARES_ECONNREFUSED);  
30.     channel_-&gt;ModifyActivityQueryCount(-1);  
31. }  
32.   
33.   void AfterResponse() {  
34.     const int status = response_data_-&gt;status;  
35.     // 调用对应的子类的Parse  
36.     if (status != ARES_SUCCESS) {  
37.       ParseError(status);  
38.     } else if (!response_data_-&gt;is_host) {  
39.       Parse(response_data_-&gt;buf.data, response_data_-&gt;buf.size);
40.     } else {  
41.       Parse(response_data_-&gt;host.get());  
42.     }  
43.   }  
</code></pre></div> <p>任务完成后，Node.js会在check阶段（Node.js v10是使用async handle通知Libuv）加入一个节点，然后check阶段的时候执行对应子类的Parse函数，这里以QueryCnameWrap的Parse为例。</p> <div class=highlight><pre><span></span><code>1.  void Parse(unsigned char* buf, int len) override {  
2.      HandleScope handle_scope(env()-&gt;isolate());  
3.      Context::Scope context_scope(env()-&gt;context());  
4.    
5.      Local&lt;Array&gt; ret = Array::New(env()-&gt;isolate());  
6.      int type = ns_t_cname;  
7.      int status = ParseGeneralReply(env(), buf, len, &amp;type, ret);  
8.      if (status != ARES_SUCCESS) {  
9.        ParseError(status);  
10.       return;  
11.     }  
12.   
13.     this-&gt;CallOnComplete(ret);  
14.   }  
</code></pre></div> <p>收到DNS回复后，调用ParseGeneralReply解析回包，然后执行JS层DNS模块的回调。从而执行用户的回调。</p> <div class=highlight><pre><span></span><code>1.  void CallOnComplete(Local&lt;Value&gt; answer,  
2.                      Local&lt;Value&gt; extra = Local&lt;Value&gt;()) {  
3.    HandleScope handle_scope(env()-&gt;isolate());  
4.    Context::Scope context_scope(env()-&gt;context());  
5.    Local&lt;Value&gt; argv[] = {  
6.      Integer::New(env()-&gt;isolate(), 0),  
7.      answer,  
8.      extra  
9.    };  
10.   const int argc = arraysize(argv) - extra.IsEmpty();  
11.   MakeCallback(env()-&gt;oncomplete_string(), argc, argv);  
12. }  
</code></pre></div> </article> </div> </div> <a href=# class="md-top md-icon" data-md-component=top data-md-state=hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg> Back to top </a> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class="md-footer__link md-footer__link--prev" aria-label="上一页: 07-信号处理" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 上一页 </span> 07-信号处理 </div> </div> </a> <a href=../chapter09-Unix%E5%9F%9F/ class="md-footer__link md-footer__link--next" aria-label="下一页: 09-Unix域" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 下一页 </span> 09-Unix域 </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2021 theanarkh </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-footer-social> <a href=https://github.com/theanarkh target=_blank rel=noopener title=github.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> <a href=https://www.zhihu.com/people/theanarkh target=_blank rel=noopener title=www.zhihu.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 640 512"><path d="M170.54 148.13v217.54l23.43.01 7.71 26.37 42.01-26.37h49.53V148.13H170.54zm97.75 193.93h-27.94l-27.9 17.51-5.08-17.47-11.9-.04V171.75h72.82v170.31zm-118.46-94.39H97.5c1.74-27.1 2.2-51.59 2.2-73.46h51.16s1.97-22.56-8.58-22.31h-88.5c3.49-13.12 7.87-26.66 13.12-40.67 0 0-24.07 0-32.27 21.57-3.39 8.9-13.21 43.14-30.7 78.12 5.89-.64 25.37-1.18 36.84-22.21 2.11-5.89 2.51-6.66 5.14-14.53h28.87c0 10.5-1.2 66.88-1.68 73.44H20.83c-11.74 0-15.56 23.62-15.56 23.62h65.58C66.45 321.1 42.83 363.12 0 396.34c20.49 5.85 40.91-.93 51-9.9 0 0 22.98-20.9 35.59-69.25l53.96 64.94s7.91-26.89-1.24-39.99c-7.58-8.92-28.06-33.06-36.79-41.81L87.9 311.95c4.36-13.98 6.99-27.55 7.87-40.67h61.65s-.09-23.62-7.59-23.62v.01zm412.02-1.6c20.83-25.64 44.98-58.57 44.98-58.57s-18.65-14.8-27.38-4.06c-6 8.15-36.83 48.2-36.83 48.2l19.23 14.43zm-150.09-59.09c-9.01-8.25-25.91 2.13-25.91 2.13s39.52 55.04 41.12 57.45l19.46-13.73s-25.67-37.61-34.66-45.86h-.01zM640 258.35c-19.78 0-130.91.93-131.06.93v-101c4.81 0 12.42-.4 22.85-1.2 40.88-2.41 70.13-4 87.77-4.81 0 0 12.22-27.19-.59-33.44-3.07-1.18-23.17 4.58-23.17 4.58s-165.22 16.49-232.36 18.05c1.6 8.82 7.62 17.08 15.78 19.55 13.31 3.48 22.69 1.7 49.15.89 24.83-1.6 43.68-2.43 56.51-2.43v99.81H351.41s2.82 22.31 25.51 22.85h107.94v70.92c0 13.97-11.19 21.99-24.48 21.12-14.08.11-26.08-1.15-41.69-1.81 1.99 3.97 6.33 14.39 19.31 21.84 9.88 4.81 16.17 6.57 26.02 6.57 29.56 0 45.67-17.28 44.89-45.31v-73.32h122.36c9.68 0 8.7-23.78 8.7-23.78l.03-.01z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "..", "features": ["content.code.annotate", "navigation.indexes", "navigation.instant", "navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "search.suggest"], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.94ec81fe.min.js", "version": null}</script> <script src=../assets/javascripts/bundle.48dfec6c.min.js></script> </body> </html>