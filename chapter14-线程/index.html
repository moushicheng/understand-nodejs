<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="通过源码分析 Node.js 原理"><meta name=author content=theanarkh><link href=https://github.com/theanarkh/understand-nodejs/chapter14-%E7%BA%BF%E7%A8%8B/ rel=canonical><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.2.2, mkdocs-material-7.2.8"><title>14-线程 - Node.js 源码剖析</title><link rel=stylesheet href=../assets/stylesheets/main.92558b1b.min.css><link rel=stylesheet href=../assets/stylesheets/palette.3f5d1f46.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script> <script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#141 class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=.. title="Node.js 源码剖析" class="md-header__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5V2M6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Node.js 源码剖析 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 14-线程 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=blue data-md-color-accent=blue aria-label="Switch to light mode" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z"/></svg> </label> </form> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08z"/></svg> </a> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/theanarkh/understand-nodejs/ title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-tabs__link> 前言 </a> </li> <li class=md-tabs__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-tabs__link> Node.js基础和架构 </a> </li> <li class=md-tabs__item> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class="md-tabs__link md-tabs__link--active"> Node.js核心模块的实现 </a> </li> <li class=md-tabs__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-tabs__link> 其他 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="Node.js 源码剖析" class="md-nav__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5V2M6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5z"/></svg> </a> Node.js 源码剖析 </label> <div class=md-nav__source> <a href=https://github.com/theanarkh/understand-nodejs/ title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> Home </a> </li> <li class=md-nav__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-nav__link> 前言 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Node.js基础和架构 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Node.js基础和架构 data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Node.js基础和架构 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-nav__link> 01-Node.js组成和原理 </a> </li> <li class=md-nav__item> <a href=../chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/ class=md-nav__link> 02-Libuv数据结构和通用逻辑 </a> </li> <li class=md-nav__item> <a href=../chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/ class=md-nav__link> 03-事件循环 </a> </li> <li class=md-nav__item> <a href=../chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> 04-线程池 </a> </li> <li class=md-nav__item> <a href=../chapter05-Libuv%E6%B5%81/ class=md-nav__link> 05-Libuv流 </a> </li> <li class=md-nav__item> <a href=../chapter06-C%2B%2B%E5%B1%82/ class=md-nav__link> 06-C++层 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4> Node.js核心模块的实现 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Node.js核心模块的实现 data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Node.js核心模块的实现 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class=md-nav__link> 07-信号处理 </a> </li> <li class=md-nav__item> <a href=../chapter08-DNS/ class=md-nav__link> 08-DNS </a> </li> <li class=md-nav__item> <a href=../chapter09-Unix%E5%9F%9F/ class=md-nav__link> 09-Unix域 </a> </li> <li class=md-nav__item> <a href=../chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/ class=md-nav__link> 10-定时器 </a> </li> <li class=md-nav__item> <a href=../chapter11-setImmediate%E5%92%8CnextTick/ class=md-nav__link> 11-setImmediate和nextTick </a> </li> <li class=md-nav__item> <a href=../chapter12-%E6%96%87%E4%BB%B6/ class=md-nav__link> 12-文件 </a> </li> <li class=md-nav__item> <a href=../chapter13-%E8%BF%9B%E7%A8%8B/ class=md-nav__link> 13-进程 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> 14-线程 <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> 14-线程 </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#141 class=md-nav__link> 14.1 使用多线程 </a> </li> <li class=md-nav__item> <a href=#142 class=md-nav__link> 14.2 线程间通信数据结构 </a> <nav class=md-nav aria-label="14.2 线程间通信数据结构"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1422-messageportdata class=md-nav__link> 14.2.2 MessagePortData </a> </li> <li class=md-nav__item> <a href=#1423-messageport class=md-nav__link> 14.2.3 MessagePort </a> </li> <li class=md-nav__item> <a href=#1424-messagechannel class=md-nav__link> 14.2.4 MessageChannel </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#143 class=md-nav__link> 14.3 多线程的实现 </a> </li> <li class=md-nav__item> <a href=#144 class=md-nav__link> 14.4 线程间通信 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../chapter15-Cluster/ class=md-nav__link> 15-Cluster </a> </li> <li class=md-nav__item> <a href=../chapter16-UDP/ class=md-nav__link> 16-UDP </a> </li> <li class=md-nav__item> <a href=../chapter17-TCP/ class=md-nav__link> 17-TCP </a> </li> <li class=md-nav__item> <a href=../chapter18-HTTP/ class=md-nav__link> 18-HTTP </a> </li> <li class=md-nav__item> <a href=../chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/ class=md-nav__link> 19-模块加载 </a> </li> <li class=md-nav__item> <a href=../chapter21-JS%20Stream/ class=md-nav__link> 20-JS Stream </a> </li> <li class=md-nav__item> <a href=../chapter22-events%E6%A8%A1%E5%9D%97/ class=md-nav__link> 21-events模块 </a> </li> <li class=md-nav__item> <a href=../chapter23-Async%20hooks/ class=md-nav__link> 22-Async hooks </a> </li> <li class=md-nav__item> <a href=../chapter24-Inspector/ class=md-nav__link> 23-Inspector </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5> 其他 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=其他 data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> 其他 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-nav__link> 24-拓展Node.js </a> </li> <li class=md-nav__item> <a href=../chapter25-Node.js子线程调试和诊断指南 class=md-nav__link> 25-Node.js子线程调试和诊断指南 </a> </li> <li class=md-nav__item> <a href=../chapter26-vscode%E8%B0%83%E8%AF%95Node.js/ class=md-nav__link> 26-vscode调试Node.js </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#141 class=md-nav__link> 14.1 使用多线程 </a> </li> <li class=md-nav__item> <a href=#142 class=md-nav__link> 14.2 线程间通信数据结构 </a> <nav class=md-nav aria-label="14.2 线程间通信数据结构"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1422-messageportdata class=md-nav__link> 14.2.2 MessagePortData </a> </li> <li class=md-nav__item> <a href=#1423-messageport class=md-nav__link> 14.2.3 MessagePort </a> </li> <li class=md-nav__item> <a href=#1424-messagechannel class=md-nav__link> 14.2.4 MessageChannel </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#143 class=md-nav__link> 14.3 多线程的实现 </a> </li> <li class=md-nav__item> <a href=#144 class=md-nav__link> 14.4 线程间通信 </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/theanarkh/understand-nodejs/edit/main/docs/chapter14-线程.md title=编辑此页 class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg> </a> <h1>14-线程</h1> <p>线程是操作系统的最小调度单位，它本质上是进程中的一个执行流，我们知道，进程有代码段，线程其实就是进程代码段中的其中一段代码。线程的一种实现是作为进程来实现的（pthread线程库），通过调用clone，新建一个进程，然后执行父进程代码段里的一个代码片段，其中文件描述符、内存等信息都是共享的。因为内存是共享的，所以线程不能共享栈，否则访问栈的地址的时候，会映射到相同的物理地址，那样就会互相影响，所以每个线程会有自己独立的栈。在调用clone函数的时候会设置栈的范围，比如在堆上分配一块内存用于做线程的栈，并且支持设置子线程和主线程共享哪些资源。具体可以参考clone系统调用。</p> <p>由于Node.js是单线程的，虽然底层的Libuv实现了一个线程池，但是这个线程池只能执行C、C++层定义的任务。如果我们想自定义一些耗时的操作，那就只能在C++层处理，然后暴露接口给JS层调用，这个成本是非常高的，在早期的Node.js版本里，我们可以用进程去实现这样的需求。但是进程太重了，在新版的Node.js中，Node.js为我们提供了多线程的功能。这一章以Node.js多线程模块为背景，分析Node.js中多线程的原理，但是不分析Libuv的线程实现，它本质是对线程库的简单封装。Node.js中，线程的实现也非常复杂。虽然底层只是对线程库的封装，但是把它和Node.js原本的架构结合起来变得复杂起来。</p> <h2 id=141>14.1 使用多线程<a class=headerlink href=#141 title="Permanent link">&para;</a></h2> <p>对于同步文件操作、DNS解析等操作，Node.js使用了内置的线程池支持了异步。但是一些加解密、字符串运算、阻塞型API等操作。我们就不能在主线程里处理了，这时候就不得不使用线程，而且多线程还能利用多核的能力。Node.js的子线程本质上是一个新的事件循环，但是子线程和Node.js主线程共享一个Libuv线程池，所以如果在子线程里有文件、DNS等操作就会和主线程竞争Libuv线程池。如图14-1所示。<br> <img alt src="https://img-blog.csdnimg.cn/7b5d3376155d4521800749ca4a455b57.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图14-1<br> 我们看一下在Node.js中如何使用线程。</p> <div class=highlight><pre><span></span><code>1.  const { Worker, isMainThread, parentPort } = require(&#39;worker_threads&#39;);  
2.  if (isMainThread) {  
3.    const worker = new Worker(__filename);  
4.    worker.once(&#39;message&#39;, (message) =&gt; {  
5.      ...  
6.    });  
7.    worker.postMessage(&#39;Hello, world!&#39;);  
8.  } else {  
9.    // 做点耗时的事情  
10.   parentPort.once(&#39;message&#39;, (message) =&gt; {  
11.     parentPort.postMessage(message);  
12.   });  
13. }  
</code></pre></div> <p>上面这段代码会被执行两次，一次是在主线程，一次在子线程。所以首先通过isMainThread判断当前是主线程还是子线程。主线程的话，就创建一个子线程，然后监听子线程发过来的消息。子线程的话，首先执行业务相关的代码，还可以监听主线程传过来的消息。我们在子线程中可以做一些耗时或者阻塞性的操作，不会影响主线程的执行。我们也可以把这两个逻辑拆分到两个文件。</p> <p>主线程</p> <div class=highlight><pre><span></span><code>1.  const { Worker, isMainThread, parentPort } = require(&#39;worker_threads&#39;);  
2.  const worker = new Worker(‘子线程文件路径’);  
3.  worker.once(&#39;message&#39;, (message) =&gt; {  
4.    ...  
5.  });  
6.  worker.postMessage(&#39;Hello, world!&#39;);  
</code></pre></div> <p>子线程</p> <div class=highlight><pre><span></span><code>1.  const { Worker, isMainThread, parentPort } = require(&#39;worker_threads&#39;);  
2.  parentPort.once(&#39;message&#39;, (message) =&gt; {  
3.    parentPort.postMessage(message);  
4.  });  
</code></pre></div> <h2 id=142>14.2 线程间通信数据结构<a class=headerlink href=#142 title="Permanent link">&para;</a></h2> <p>进程间的通信一般需要借助操作系统提供公共的内存来完成。因为进程间的内存是独立的，和进程间通信不一样。多线程的内存是共享的，同个进程的内存，多个线程都可以访问，所以线程间通信可以基于进程内的内存来完成。在Node.js中，线程间通信使用的是MessageChannel实现的，它是全双工的，任意一端都可以随时发送信息。MessageChannel类似socket通信，它包括两个端点。定义一个MessageChannel相当于建立一个TCP连接，它首先申请两个端点（MessagePort），然后把它们关联起来。下面我们看一下线程间通信的实现中，比较重要的几个数据结构。<br> 1 Message代表一个消息。<br> 2 MessagePortData是对操作Message的封装和对消息的承载。<br> 3 MessagePort是代表通信的端点。<br> 4 MessageChannel是代表通信的两端，即两个MessagePort。<br> 下面我们看一下具体的实现。 14.2.1 Message Message类代表的是子线程间通信的一条消息。</p> <div class=highlight><pre><span></span><code>1.  class Message : public MemoryRetainer {  
2.   public:  
3.    explicit Message(MallocedBuffer&lt;char&gt;&amp;&amp; payload = MallocedBuffer&lt;char&gt;());  
4.    // 是否是最后一条消息，空消息代表是最后一条消息  
5.    bool IsCloseMessage() const;  
6.    // 线程间通信的数据需要通过序列化和反序列化处理  
7.    v8::MaybeLocal&lt;v8::Value&gt; Deserialize(Environment* env,  
8.                                          v8::Local&lt;v8::Context&gt; context);  
9.    v8::Maybe&lt;bool&gt; Serialize(Environment* env,  
10.                             v8::Local&lt;v8::Context&gt; context,  
11.                             v8::Local&lt;v8::Value&gt; input,  
12.                             const TransferList&amp; transfer_list,  
13.                             v8::Local&lt;v8::Object&gt; source_port =  
14.                                 v8::Local&lt;v8::Object&gt;());  
15.   
16.   // 传递SharedArrayBuffer型变量  
17.   void AddSharedArrayBuffer(std::shared_ptr&lt;v8::BackingStore&gt; backing_store);  
18.   // 传递MessagePort型变量  
19.   void AddMessagePort(std::unique_ptr&lt;MessagePortData&gt;&amp;&amp; data);  
20.   // 消息所属端口，端口是消息到达的地方  
21.   const std::vector&lt;std::unique_ptr&lt;MessagePortData&gt;&gt;&amp; message_ports() const {  
22.     return message_ports_;  
23.   }  
24.   
25.  private:  
26.   // 保存消息的内容  
27.   MallocedBuffer&lt;char&gt; main_message_buf_;  
28.   std::vector&lt;std::shared_ptr&lt;v8::BackingStore&gt;&gt; array_buffers_;  
29.   std::vector&lt;std::shared_ptr&lt;v8::BackingStore&gt;&gt; shared_array_buffers_;  
30.   std::vector&lt;std::unique_ptr&lt;MessagePortData&gt;&gt; message_ports_;  
31.   std::vector&lt;v8::CompiledWasmModule&gt; wasm_modules_;  
32. };  
</code></pre></div> <h3 id=1422-messageportdata>14.2.2 MessagePortData<a class=headerlink href=#1422-messageportdata title="Permanent link">&para;</a></h3> <p>MessagePortData是管理消息发送和接收的类。 </p> <div class=highlight><pre><span></span><code>1.  class MessagePortData : public MemoryRetainer {  
2.   public:  
3.    explicit MessagePortData(MessagePort* owner);  
4.    ~MessagePortData() override;  
5.    // 新增一个消息  
6.    void AddToIncomingQueue(Message&amp;&amp; message);  
7.    // 关联/解关联通信两端的端口  
8.    static void Entangle(MessagePortData* a, MessagePortData* b);  
9.    void Disentangle();  
10.     
11.  private:  
12.   // 用于多线程往对端消息队列插入消息时的互斥变量  
13.   mutable Mutex mutex_;  
14.   std::list&lt;Message&gt; incoming_messages_;  
15.   // 所属端口  
16.   MessagePort* owner_ = nullptr;  
17.   // 用于多线程访问对端sibling_属性时的互斥变量  
18.   std::shared_ptr&lt;Mutex&gt; sibling_mutex_ = std::make_shared&lt;Mutex&gt;();  
19.   // 指向通信对端的指针  
20.   MessagePortData* sibling_ = nullptr;  
21. };  
</code></pre></div> <p>我们看一下实现。</p> <div class=highlight><pre><span></span><code>1.  MessagePortData::MessagePortData(MessagePort* owner) : owner_(owner) { }  
2.    
3.  MessagePortData::~MessagePortData() {  
4.    // 析构时解除和对端的关系  
5.    Disentangle();  
6.  }  
7.    
8.  // 插入一个message  
9.  void MessagePortData::AddToIncomingQueue(Message&amp;&amp; message) {  
10.   // 先加锁，保证多线程安全，互斥访问  
11.   Mutex::ScopedLock lock(mutex_);  
12.   // 插入消息队列  
13.   incoming_messages_.emplace_back(std::move(message));  
14.   // 通知owner  
15.   if (owner_ != nullptr) {  
16.     owner_-&gt;TriggerAsync();  
17.   }  
18. }  
19.   
20. // 关联通信的对端，并保持对端的互斥变量，访问对端时需要使用  
21. void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) {  
22.   a-&gt;sibling_ = b;  
23.   b-&gt;sibling_ = a;  
24.   a-&gt;sibling_mutex_ = b-&gt;sibling_mutex_;  
25. }  
26.   
27. // 解除关联   
28. void MessagePortData::Disentangle() {  
29.   // 加锁操作对端的sibling字段  
30.   std::shared_ptr&lt;Mutex&gt; sibling_mutex = sibling_mutex_;  
31.   Mutex::ScopedLock sibling_lock(*sibling_mutex);  
32.   sibling_mutex_ = std::make_shared&lt;Mutex&gt;();  
33.   // 对端  
34.   MessagePortData* sibling = sibling_;  
35.   // 对端非空，则把对端的sibling也指向空，自己也指向空  
36.   if (sibling_ != nullptr) {  
37.     sibling_-&gt;sibling_ = nullptr;  
38.     sibling_ = nullptr;  
39.   }  
40.   
41.   // 插入一个空的消息通知对端和本端  
42.   AddToIncomingQueue(Message());  
43.   if (sibling != nullptr) {  
44.     sibling-&gt;AddToIncomingQueue(Message());  
45.   }  
46. }  
</code></pre></div> <h3 id=1423-messageport>14.2.3 MessagePort<a class=headerlink href=#1423-messageport title="Permanent link">&para;</a></h3> <p>MessagePort表示的是通信的一端。</p> <div class=highlight><pre><span></span><code>1.  class MessagePort : public HandleWrap {  
2.   public:  
3.    MessagePort(Environment* env,  
4.                v8::Local&lt;v8::Context&gt; context,  
5.                v8::Local&lt;v8::Object&gt; wrap);  
6.    ~MessagePort() override;  
7.    
8.     static MessagePort* New(Environment* env,  
9.                             v8::Local&lt;v8::Context&gt; context,  
10.                            std::unique_ptr&lt;MessagePortData&gt; data = nullptr);  
11.   // 发送消息  
12.   v8::Maybe&lt;bool&gt; PostMessage(Environment* env,  
13.                               v8::Local&lt;v8::Value&gt; message,  
14.                               const TransferList&amp; transfer);  
15.   
16.   // 开启/关闭接收消息  
17.   void Start();  
18.   void Stop();  
19.   
20.   static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);  
21.   // 提供JS层使用的方法  
22.   static void PostMessage(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);  
23.   static void Start(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);  
24.   static void Stop(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);  
25.   static void Drain(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);  
26.   static void ReceiveMessage(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);  
27.   // 关联对端  
28.   static void Entangle(MessagePort* a, MessagePort* b);  
29.   static void Entangle(MessagePort* a, MessagePortData* b);  
30.   
31.   // 解除MessagePortData和端口的关系  
32.   std::unique_ptr&lt;MessagePortData&gt; Detach();  
33.   // 关闭端口  
34.   void Close(  
35.       v8::Local&lt;v8::Value&gt; close_callback = v8::Local&lt;v8::Value&gt;()) override;  
36.   
37.   inline bool IsDetached() const;  
38.  private:  
39.   void OnClose() override;  
40.   void OnMessage();  
41.   void TriggerAsync();  
42.   v8::MaybeLocal&lt;v8::Value&gt; ReceiveMessage(v8::Local&lt;v8::Context&gt; context,  
43.                                            bool only_if_receiving);  
44.   // MessagePortData用于管理消息的发送和接收  
45.   std::unique_ptr&lt;MessagePortData&gt; data_ = nullptr;  
46.   // 是否开启接收消息标记  
47.   bool receiving_messages_ = false;  
48.   // 用于收到消息时通知事件循环，事件循环执行回调处理消息  
49.   uv_async_t async_;  
50. };  
</code></pre></div> <p>我们看一下实现，只列出部分函数。</p> <div class=highlight><pre><span></span><code>1.  // 端口是否不接收消息了  
2.  bool MessagePort::IsDetached() const {  
3.    return data_ == nullptr || IsHandleClosing();  
4.  }  
5.    
6.  // 有消息到达，通知事件循环执行回调  
7.  void MessagePort::TriggerAsync() {  
8.    if (IsHandleClosing()) return;  
9.    CHECK_EQ(uv_async_send(&amp;async_), 0);  
10. }  
11.   
12. // 关闭接收消息的端口  
13. void MessagePort::Close(v8::Local&lt;v8::Value&gt; close_callback) {  
14.   if (data_) {  
15.     // 持有锁，防止再接收消息  
16.     Mutex::ScopedLock sibling_lock(data_-&gt;mutex_);  
17.     HandleWrap::Close(close_callback);  
18.   } else {  
19.     HandleWrap::Close(close_callback);  
20.   }  
21. }  
22.   
23. // 新建一个端口，并且可以挂载一个MessagePortData  
24. MessagePort* MessagePort::New(  
25.     Environment* env,  
26.     Local&lt;Context&gt; context,  
27.     std::unique_ptr&lt;MessagePortData&gt; data) {  
28.   Context::Scope context_scope(context);  
29.   Local&lt;FunctionTemplate&gt; ctor_templ = GetMessagePortConstructorTemplate(env);  
30.   
31.   Local&lt;Object&gt; instance;  
32.   // JS层使用的对象  
33.   if (!ctor_templ-&gt;InstanceTemplate()-&gt;NewInstance(context).ToLocal(&amp;instance))  
34.     return nullptr;  
35.   // 新建一个消息端口  
36.   MessagePort* port = new MessagePort(env, context, instance);  
37.   
38.   // 需要挂载MessagePortData  
39.   if (data) {  
40.     port-&gt;Detach();  
41.     port-&gt;data_ = std::move(data);  
42.     Mutex::ScopedLock lock(port-&gt;data_-&gt;mutex_);  
43.     // 修改data的owner为当前消息端口  
44.     port-&gt;data_-&gt;owner_ = port;  
45.     // data中可能有消息  
46.     port-&gt;TriggerAsync();  
47.   }  
48.   return port;  
49. }  
50.   
51. // 开始接收消息  
52. void MessagePort::Start() {  
53.   Debug(this, &quot;Start receiving messages&quot;);  
54.   receiving_messages_ = true;  
55.   Mutex::ScopedLock lock(data_-&gt;mutex_);  
56.   // 有缓存的消息，通知上层  
57.   if (!data_-&gt;incoming_messages_.empty())  
58.     TriggerAsync();  
59. }  
60.   
61. // 停止接收消息  
62. void MessagePort::Stop() {  
63.   Debug(this, &quot;Stop receiving messages&quot;);  
64.   receiving_messages_ = false;  
65. }  
66. // JS层调用
67. void MessagePort::Start(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
68.   MessagePort* port;  
69.   ASSIGN_OR_RETURN_UNWRAP(&amp;port, args.This());  
70.   if (!port-&gt;data_) {  
71.     return;  
72.   }  
73.   port-&gt;Start();  
74. }  
75.   
76. void MessagePort::Stop(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
77.   MessagePort* port;  
78.   CHECK(args[0]-&gt;IsObject());  
79.   ASSIGN_OR_RETURN_UNWRAP(&amp;port, args[0].As&lt;Object&gt;());  
80.   if (!port-&gt;data_) {  
81.     return;  
82.   }  
83.   port-&gt;Stop();  
84. }  
85.   
86. // 读取消息  
87. void MessagePort::Drain(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
88.   MessagePort* port;  
89.   ASSIGN_OR_RETURN_UNWRAP(&amp;port, args[0].As&lt;Object&gt;());  
90.   port-&gt;OnMessage();  
91. }  
92.   
93. // 获取某个端口的消息  
94. void MessagePort::ReceiveMessage(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
95.   CHECK(args[0]-&gt;IsObject());  
96.   // 第一个参数是端口  
97.   MessagePort* port = Unwrap&lt;MessagePort&gt;(args[0].As&lt;Object&gt;());  
98.   // 调用对象的ReceiverMessage方法  
99.   MaybeLocal&lt;Value&gt; payload =  
100.          port-&gt;ReceiveMessage(port-&gt;object()-&gt;CreationContext(), false);  
101.      if (!payload.IsEmpty())  
102.        args.GetReturnValue().Set(payload.ToLocalChecked());  
103.    }  
104.      
105.    // 关联两个端口  
106.    void MessagePort::Entangle(MessagePort* a, MessagePort* b) {  
107.      Entangle(a, b-&gt;data_.get());  
108.    }  
109.      
110.    void MessagePort::Entangle(MessagePort* a, MessagePortData* b) {  
111.      MessagePortData::Entangle(a-&gt;data_.get(), b);  
112.    }  
</code></pre></div> <h3 id=1424-messagechannel>14.2.4 MessageChannel<a class=headerlink href=#1424-messagechannel title="Permanent link">&para;</a></h3> <p>MessageChannel表示线程间通信的两个端。</p> <div class=highlight><pre><span></span><code>1.  static void MessageChannel(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
2.    Environment* env = Environment::GetCurrent(args);  
3.     
4.    Local&lt;Context&gt; context = args.This()-&gt;CreationContext();  
5.    Context::Scope context_scope(context);  
6.    
7.    MessagePort* port1 = MessagePort::New(env, context);  
8.    MessagePort* port2 = MessagePort::New(env, context);  
9.    MessagePort::Entangle(port1, port2);  
10.   // port1-&gt;object()拿到JS层使用的对象，它关联了MessagePort对象
11.   args.This()-&gt;Set(context, env-&gt;port1_string(), port1-&gt;object())  
12.       .Check();  
13.   args.This()-&gt;Set(context, env-&gt;port2_string(), port2-&gt;object())  
14.       .Check();  
15. }  
</code></pre></div> <p>MessageChannel的逻辑比较简单，新建两个消息端口，并且关联起来，后续就可以基于这两个端口进行通信了。 Message、MessagePortData、MessagePort和MessageChannel的关系图如图14-2所示。<br> <img alt src="https://img-blog.csdnimg.cn/db442278f4b54e89ad6ba365e2646b57.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图14-2<br> 最后我们看一下线程间通信模块导出的一些功能。</p> <div class=highlight><pre><span></span><code>1.  static void InitMessaging(Local&lt;Object&gt; target,  
2.                            Local&lt;Value&gt; unused,  
3.                            Local&lt;Context&gt; context,  
4.                            void* priv) {  
5.    Environment* env = Environment::GetCurrent(context);  
6.    
7.    {  
8.      // 线程间通信的通道  
9.      Local&lt;String&gt; message_channel_string = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), 
10.                                                                        &quot;MessageChannel&quot;);  
11.     Local&lt;FunctionTemplate&gt; templ = env-&gt;NewFunctionTemplate(MessageChannel);  
12.     templ-&gt;SetClassName(message_channel_string);  
13.     target-&gt;Set(context,  
14.                 message_channel_string,  
15.                 templ-&gt;GetFunction(context).ToLocalChecked()).Check();  
16.   }  
17.   // 新建消息端口的构造函数  
18.   target-&gt;Set(context,  
19.               env-&gt;message_port_constructor_string(),  
20.               GetMessagePortConstructorTemplate(env)  
21.                   -&gt;GetFunction(context).ToLocalChecked()).Check();  
22.   
23.   env-&gt;SetMethod(target, &quot;stopMessagePort&quot;, MessagePort::Stop);  
24.   env-&gt;SetMethod(target, &quot;drainMessagePort&quot;, MessagePort::Drain);  
25.   env-&gt;SetMethod(target, &quot;receiveMessageOnPort&quot;, MessagePort::ReceiveMessage);  
26.   env-&gt;SetMethod(target, &quot;moveMessagePortToContext&quot;,  
27.                  MessagePort::MoveToContext);  
28. }  
</code></pre></div> <h2 id=143>14.3 多线程的实现<a class=headerlink href=#143 title="Permanent link">&para;</a></h2> <p>本节我们从worker_threads模块开始分析多线程的实现。这是一个C++模块。我们看一下它导出的功能。require("work_threads")的时候就是引用了InitWorker函数导出的功能。</p> <div class=highlight><pre><span></span><code>1.  void InitWorker(Local&lt;Object&gt; target,    
2.                  Local&lt;Value&gt; unused,    
3.                  Local&lt;Context&gt; context,    
4.                  void* priv) {    
5.    Environment* env = Environment::GetCurrent(context);    
6.      
7.    {      
8.      Local&lt;FunctionTemplate&gt; w = env-&gt;NewFunctionTemplate(Worker::New);    
9.      w-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);    
10.     w-&gt;Inherit(AsyncWrap::GetConstructorTemplate(env));    
11.     // 设置一系列原型方法，就不一一列举    
12.     env-&gt;SetProtoMethod(w, &quot;setEnvVars&quot;, Worker::SetEnvVars);    
13.     // 一系列原型方法    
14.     /*  
15.      导出函数模块对应的函数，即我们代码中 
16.      const { Worker } = require(&quot;worker_threads&quot;);中的Worker  
17.     */   
18.     Local&lt;String&gt; workerString = FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;Worker&quot;);    
19.     w-&gt;SetClassName(workerString);    
20.     target-&gt;Set(env-&gt;context(),    
21.                 workerString,    
22.                 w-&gt;GetFunction(env-&gt;context()).ToLocalChecked()).Check();    
23.      
24.      /*  
25.        导出getEnvMessagePort方法，获取线程接收消息的端口     
26.        const {getEnvMessagePort} = require(&quot;worker_threads&quot;); 
27.      */  
28.      env-&gt;SetMethod(target, &quot;getEnvMessagePort&quot;, GetEnvMessagePort);    
29.      /*  
30.        线程id，这个不是操作系统分配的那个，而是Node.js分配的, 
31.        在创建线程的时候设置  
32.        const { threadId } = require(&quot;worker_threads&quot;);  
33.      */    
34.     target-&gt;Set(env-&gt;context(),  
35.                   env-&gt;thread_id_string(),    
36.                   Number::New(env-&gt;isolate(),  
37.                   static_cast&lt;double&gt;(env-&gt;thread_id())))    
38.         .Check();    
39.     /*  
40.      是否是主线程， 
41.      const { isMainThread } = require(&quot;worker_threads&quot;);  
42.      这边变量在Node.js启动的时候设置为true，新开子线程的时候，没有设 
43.      置，所以是false  
44.     */    
45.     target-&gt;Set(env-&gt;context(),    
46.                 FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;isMainThread&quot;),   
47.                 Boolean::New(env-&gt;isolate(), env-&gt;is_main_thread()))  
48.                 .Check();    
49.     /*  
50.      如果不是主线程，导出资源限制的配置，  
51.      即在子线程中调用 
52.       const { resourceLimits } = require(&quot;worker_threads&quot;);  
53.     */    
54.     if (!env-&gt;is_main_thread()) {    
55.       target-&gt;Set(env-&gt;context(),    
56.             FIXED_ONE_BYTE_STRING(env-&gt;isolate(),   
57.                       &quot;resourceLimits&quot;),    
58.             env-&gt;worker_context()-&gt;GetResourceLimits(env-&gt;isolate())).Check();    
59.     }    
60.     // 导出几个常量    
61.     NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb);    
62.     NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb);    
63.     NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb);    
64.     NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount);    
65. }   
</code></pre></div> <p>了解work_threads模块导出的功能后，我们看在JS层执行new Worker的时候的逻辑。根据上面代码导出的逻辑，我们知道这时候首先会新建一个C++对象。然后执行New回调，并传入新建的C++对象。我们看New函数的逻辑。我们省略一系列的参数处理，主要代码如下。</p> <div class=highlight><pre><span></span><code>1.  // args.This()就是我们刚才传进来的this  
2.  Worker* worker = new Worker(env, args.This(),   
3.                  url, per_isolate_opts,  
4.                  std::move(exec_argv_out));  
</code></pre></div> <p>我们再看Worker类的声明。</p> <div class=highlight><pre><span></span><code>1.  class Worker : public AsyncWrap {  
2.   public:  
3.    // 函数声明  
4.    
5.   private:  
6.    
7.    std::shared_ptr&lt;PerIsolateOptions&gt; per_isolate_opts_;  
8.    std::vector&lt;std::string&gt; exec_argv_;  
9.    std::vector&lt;std::string&gt; argv_;  
10.   MultiIsolatePlatform* platform_;  
11.   v8::Isolate* isolate_ = nullptr;  
12.   bool start_profiler_idle_notifier_;  
13.   // 真正的线程id，底层返回的  
14.   uv_thread_t tid_;  
15.   
16.   // This mutex protects access to all variables listed below it.  
17.   mutable Mutex mutex_;  
18.   
19.   bool thread_joined_ = true;  
20.   const char* custom_error_ = nullptr;  
21.   int exit_code_ = 0;  
22.   // 线程id，Node.js分配，不是底层返回的  
23.   uint64_t thread_id_ = -1;  
24.   uintptr_t stack_base_ = 0;  
25.   
26.   // 线程资源限制配置  
27.   double resource_limits_[kTotalResourceLimitCount];  
28.   void UpdateResourceConstraints(v8::ResourceConstraints* constraints);  
29.   
30.   // 栈信息  
31.   static constexpr size_t kStackSize = 4 * 1024 * 1024;  
32.   static constexpr size_t kStackBufferSize = 192 * 1024;  
33.   
34.   std::unique_ptr&lt;MessagePortData&gt; child_port_data_;  
35.   std::shared_ptr&lt;KVStore&gt; env_vars_;  
36.   // 用于线程间通信  
37.   MessagePort* child_port_ = nullptr;  
38.   MessagePort* parent_port_ = nullptr;  
39.   // 线程状态  
40.   bool stopped_ = true;  
41.   // 是否影响事件循环退出  
42.   bool has_ref_ = true;  
43.   // 子线程执行时的环境变量，基类也定义了  
44.   Environment* env_ = nullptr;  
45. };  
</code></pre></div> <p>这里只讲一下env_的定义，因为这是一个非常重要的地方。我们看到Worker类继承AsyncWrap，AsyncWrap继承了BaseObject。BaseObject中也定义了env_属性。我们看一下在C++中如果子类父类都定义了一个属性时是怎样的。我们来看一个例子</p> <div class=highlight><pre><span></span><code>1.  #include &lt;iostream&gt;  
2.  using namespace std;  
3.    
4.  class A  
5.  {  
6.  public:  
7.      int value;  
8.      A()  
9.      {  
10.         value=1;  
11.     }  
12.     void console()  
13.     {  
14.         cout&lt;&lt;value&lt;&lt;endl;  
15.     }  
16.    
17. };  
18. class B: public A  
19. {  
20.    public:  
21.        int value;  
22.     B():A()  
23.     {  
24.         value=2;  
25.     }  
26. };  
27. int main()  
28. {  
29.     B b;  
30.     // b.value = 3;只会修改子类的，不会修改父类的  
31.     b.console();  
32.     cout&lt;&lt;b.value&lt;&lt;endl&lt;&lt;&quot;内存大小：&quot;&lt;&lt;sizeof(b)&lt;&lt;endl;  
33.     return 0;  
34. }  
</code></pre></div> <p>以上代码执行时输出 1. 1<br> 2. 2<br> 3. 内存大小：8<br> 由输出结果我们可以知道，b内存大小是8个字节。即两个int。所以b的内存布局中两个a属性都分配了内存。当我们通过b.console输出value时，因为console是在A上定义的，所以输出1，但是我们通过b.value访问时，输出的是2。因为访问的是B中定义的value，同理如果我们在B中定义console，输出也会是2。Worker中定义的env_我们后续会看到它的作用。接着我们看一下Worker类的初始化逻辑。</p> <div class=highlight><pre><span></span><code>1.  Worker::Worker(Environment* env,    
2.                 Local&lt;Object&gt; wrap,...)    
3.      : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER),    
4.        ...    
5.        // 分配线程id    
6.        thread_id_(Environment::AllocateThreadId()),   
7.        // 继承主线程的环境变量   
8.        env_vars_(env-&gt;env_vars()) {    
9.      
10.   // 新建一个端口和子线程通信    
11.   parent_port_ = MessagePort::New(env, env-&gt;context());    
12.   /*  
13.     关联起来，用于通信  
14.     const parent_port_ = {data: {sibling: null}};  
15.     const child_port_data_  = {sibling: null};  
16.     parent_port_.data.sibling = child_port_data_;  
17.     child_port_data_.sibling = parent_port_.data;  
18.   */    
19.   child_port_data_ = std::make_unique&lt;MessagePortData&gt;(nullptr);    
20.   MessagePort::Entangle(parent_port_, child_port_data_.get());    
21.   // 设置JS层Worker对象的messagePort属性为parent_port_    
22.   object()-&gt;Set(env-&gt;context(),    
23.                 env-&gt;message_port_string(),    
24.                 parent_port_-&gt;object()).Check();    
25.   // 设置Worker对象的线程id，即threadId属性    
26.   object()-&gt;Set(env-&gt;context(),    
27.                 env-&gt;thread_id_string(),    
28.                 Number::New(env-&gt;isolate(), static_cast&lt;double&gt;(thread_id_)))    
29.       .Check();    
30. }   
</code></pre></div> <p>新建一个Worker，结构如图14-3所示。<br> <img alt src="https://img-blog.csdnimg.cn/ec2cdce5275d4cf4b5c4ab5586f993c2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图14-3</p> <p>了解了new Worker的逻辑后，我们看在JS层是如何使用的。我们看JS层Worker类的构造函数。</p> <div class=highlight><pre><span></span><code>1.  constructor(filename, options = {}) {  
2.      super();  
3.      // 忽略一系列参数处理，new Worker就是上面提到的C++层的  
4.      this[kHandle] = new Worker(url, options.execArgv, parseResourceLimits(options.resourceLimits));  
5.      // messagePort指向_parent_port  
6.      this[kPort] = this[kHandle].messagePort;  
7.      this[kPort].on(&#39;message&#39;, (data) =&gt; this[kOnMessage](data));
8.      // 开始接收消息  
9.      this[kPort].start();  
10.     // 申请一个通信通道，两个端口  
11.     const { port1, port2 } = new MessageChannel();  
12.     this[kPublicPort] = port1;  
13.     this[kPublicPort].on(&#39;message&#39;, (message) =&gt; this.emit(&#39;message&#39;, message));  
14.     // 向另一端发送消息  
15.     this[kPort].postMessage({  
16.       argv,  
17.       type: messageTypes.LOAD_SCRIPT,  
18.       filename,  
19.       doEval: !!options.eval,  
20.       cwdCounter: cwdCounter || workerIo.sharedCwdCounter,  
21.       workerData: options.workerData,  
22.       publicPort: port2,  
23.       manifestSrc: getOptionValue(&#39;--experimental-policy&#39;) ?  
24.         require(&#39;internal/process/policy&#39;).src :  
25.         null,  
26.       hasStdin: !!options.stdin  
27.     }, [port2]);  
28.     // 开启线程  
29.     this[kHandle].startThread();  
30.   }  
</code></pre></div> <p>上面的代码主要逻辑如下<br> 1 保存messagePort，监听该端口的message事件，然后给messagePort的对端发送消息，但是这时候还没有接收端口，所以消息会缓存到MessagePortData，即child_port_data_ 中。另外我们看到主线程把通信端口port2发送给了子线程。<br> 2 申请一个通信通道port1和port2，用于主线程和子线程通信。_parent_port和child_port是给Node.js使用的，新申请的端口是给用户使用的。<br> 3 创建子线程。<br> 我们看创建线程的时候，做了什么。</p> <div class=highlight><pre><span></span><code>1.  void Worker::StartThread(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
2.    Worker* w;  
3.    ASSIGN_OR_RETURN_UNWRAP(&amp;w, args.This());  
4.    Mutex::ScopedLock lock(w-&gt;mutex_);  
5.    
6.    // The object now owns the created thread and should not be garbage collected  
7.    // until that finishes.  
8.    w-&gt;ClearWeak();  
9.    // 加入主线程维护的子线程数据结构  
10.   w-&gt;env()-&gt;add_sub_worker_context(w);  
11.   w-&gt;stopped_ = false;  
12.   w-&gt;thread_joined_ = false;  
13.   // 是否需要阻塞事件循环退出，默认true  
14.   if (w-&gt;has_ref_)  
15.     w-&gt;env()-&gt;add_refs(1);  
16.   // 是否需要栈和栈大小  
17.   uv_thread_options_t thread_options;  
18.   thread_options.flags = UV_THREAD_HAS_STACK_SIZE;  
19.   thread_options.stack_size = kStackSize;  
20.   // 创建线程  
21.   CHECK_EQ(uv_thread_create_ex(&amp;w-&gt;tid_, &amp;thread_options, [](void* arg) {  
22. 
23.     Worker* w = static_cast&lt;Worker*&gt;(arg);  
24.     const uintptr_t stack_top = reinterpret_cast&lt;uintptr_t&gt;(&amp;arg);  
25.     w-&gt;stack_base_ = stack_top - (kStackSize - kStackBufferSize);  
26.     // 执行主逻辑  
27.     w-&gt;Run();  
28.   
29.     Mutex::ScopedLock lock(w-&gt;mutex_);  
30.     // 给主线程提交一个任务，通知主线程子线程执行完毕，因为主线程不能直接执行join阻塞自己  
31.     w-&gt;env()-&gt;SetImmediateThreadsafe(  
32.         [w = std::unique_ptr&lt;Worker&gt;(w)](Environment* env) {  
33.           if (w-&gt;has_ref_)  
34.             env-&gt;add_refs(-1);  
35.           w-&gt;JoinThread();  
36.           // implicitly delete w  
37.         });  
38.   }, static_cast&lt;void*&gt;(w)), 0);  
39. }  
</code></pre></div> <p>StartThread新建了一个子线程，然后在子线程中执行Run，我们继续看Run</p> <div class=highlight><pre><span></span><code>1.  void Worker::Run() {  
2.    // 线程执行所需要的数据结构，比如loop，isolate，和主线程独立  
3.    WorkerThreadData data(this);  
4.     
5.    {  
6.      Locker locker(isolate_);  
7.      Isolate::Scope isolate_scope(isolate_);  
8.      SealHandleScope outer_seal(isolate_);  
9.      // std::unique_ptr&lt;Environment, FreeEnvironment&gt; env_;  
10.     DeleteFnPtr&lt;Environment, FreeEnvironment&gt; env_;  
11.     // 线程执行完后执行的清除函数  
12.     auto cleanup_env = OnScopeLeave([&amp;]() {  
13.     // ...  
14.     });  
15.   
16.     {  
17.       HandleScope handle_scope(isolate_);  
18.       Local&lt;Context&gt; context;  
19.       // 新建一个context，和主线程独立  
20.       context = NewContext(isolate_);  
21.       Context::Scope context_scope(context);  
22.       {  
23.         // 新建一个env并初始化，env中会和新的context关联  
24.         env_.reset(new Environment(data.isolate_data_.get(),  
25.                                    context,  
26.                                    std::move(argv_),  
27.                                    std::move(exec_argv_),  
28.                                    Environment::kNoFlags,  
29.                                    thread_id_));  
30.         env_-&gt;set_env_vars(std::move(env_vars_));  
31.         env_-&gt;set_abort_on_uncaught_exception(false);  
32.         env_-&gt;set_worker_context(this);  
33.   
34.         env_-&gt;InitializeLibuv(start_profiler_idle_notifier_);  
35.       }  
36.       {  
37.         Mutex::ScopedLock lock(mutex_);  
38.         // 更新子线程所属的env  
39.         this-&gt;env_ = env_.get();  
40.       }  
41.         
42.       {  
43.         if (!env_-&gt;RunBootstrapping().IsEmpty()) {  
44.           CreateEnvMessagePort(env_.get());  
45.           USE(StartExecution(env_.get(), &quot;internal/main/worker_thread&quot;));  
46.         }  
47.       }  
48.   
49.       {  
50.         SealHandleScope seal(isolate_);  
51.         bool more;  
52.         // 开始事件循环  
53.         do {  
54.           if (is_stopped()) break;  
55.           uv_run(&amp;data.loop_, UV_RUN_DEFAULT);  
56.           if (is_stopped()) break;  
57.   
58.           platform_-&gt;DrainTasks(isolate_);  
59.   
60.           more = uv_loop_alive(&amp;data.loop_);  
61.           if (more &amp;&amp; !is_stopped()) continue;  
62.   
63.           EmitBeforeExit(env_.get());  
64.   
65.           more = uv_loop_alive(&amp;data.loop_);  
66.         } while (more == true &amp;&amp; !is_stopped());  
67.       }  
68.     }  
69. }  
</code></pre></div> <p>我们分步骤分析上面的代码 1 新建Isolate、context和Environment，子线程在独立的环境执行。然后初始化Environment。这个在Node.js启动过程章节已经分析过，不再分析。<br> 2 更新子线程的env_。刚才已经分析过，Worker类中定义了env_属性，所以这里通过this.env_更新时，是不会影响基类（BaseObject）中的值的。因为子线程是在新的环境执行的，所以在新环境中使用该Worker实例时，需要使用新的环境变量。而在主线程使用该Worker实例时，是通过BaseObject的env()访问的。从而获取的是主线程的环境。因为Worker实例是在主线程和子线程之间共享的，Node.js在Worker类中重新定义了一个env_属性正是为了解决这个问题。<br> 3 CreateEnvMessagePort</p> <div class=highlight><pre><span></span><code>1.  void Worker::CreateEnvMessagePort(Environment* env) {  
2.    child_port_ = MessagePort::New(env,
3.                                       env-&gt;context(),  
4.                     std::move(child_port_data_));  
5.    if (child_port_ != nullptr)  
6.      env-&gt;set_message_port(child_port_-&gt;object(isolate_));  
7.  }  
</code></pre></div> <p>child_port_data_这个变量刚才我们已经看到过，在这里首先申请一个新的端口。并且和child_port_data_互相关联起来。然后在env缓存起来。后续会使用。这时候的关系图如图14-4所示。<br> <img alt src="https://img-blog.csdnimg.cn/04b747f85beb41048a588146806d16b4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图14-4</p> <p>4 执行internal/main/worker_thread.js</p> <div class=highlight><pre><span></span><code>1.  // 设置process对象  
2.  patchProcessObject();  
3.  // 获取刚才缓存的端口child_port_  
4.  onst port = getEnvMessagePort();  
5.  port.on(&#39;message&#39;, (message) =&gt; {  
6.    // 加载脚本  
7.    if (message.type === LOAD_SCRIPT) {  
8.      const {  
9.        argv,  
10.       cwdCounter,  
11.       filename,  
12.       doEval,  
13.       workerData,  
14.       publicPort,  
15.       manifestSrc,  
16.       manifestURL,  
17.       hasStdin  
18.     } = message;  
19.   
20.     const CJSLoader = require(&#39;internal/modules/cjs/loader&#39;);  
21.     loadPreloadModules();  
22.     /* 
23.      由主线程申请的MessageChannel中某一端的端口， 
24.      主线程传递过来的，保存用于和主线程通信 
25.     */  
26.     publicWorker.parentPort = publicPort;  
27.     // 执行时使用的数据  
28.     publicWorker.workerData = workerData;  
29.     // 通知主线程，正在执行脚本  
30.     port.postMessage({ type: UP_AND_RUNNING });  
31.     // 执行new Worker(filename)时传入的文件  
32.     CJSLoader.Module.runMain(filename);  
33. })  
34. // 开始接收消息  
35. port.start()  
</code></pre></div> <p>我们看到worker_thread.js中通过runMain完成了子线程的代码执行，然后开始事件循环。 我们看一下当事件循环结束时，Node.js的逻辑。</p> <div class=highlight><pre><span></span><code>1.  // 给主线程提交一个任务，通知主线程子线程执行完毕，因为主线程不能直接执行join阻塞自己    
2.  w-&gt;env()-&gt;SetImmediateThreadsafe(    
3.      [w = std::unique_ptr&lt;Worker&gt;(w)](Environment* env) {    
4.        if (w-&gt;has_ref_)    
5.          env-&gt;add_refs(-1);    
6.        w-&gt;JoinThread();    
7.        // implicitly delete w    
8.      });    
9.  }, static_cast&lt;void*&gt;(w)), 0);    
</code></pre></div> <p>通过w-&gt;env()获取的是主线程的执行环境。我们看一下SetImmediateThreadsafe。</p> <div class=highlight><pre><span></span><code>1.  template &lt;typename Fn&gt;  
2.  void Environment::SetImmediateThreadsafe(Fn&amp;&amp; cb) {  
3.    auto callback = std::make_unique&lt;NativeImmediateCallbackImpl&lt;Fn&gt;&gt;(  
4.        std::move(cb), false);  
5.    {  
6.      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);  
7.      native_immediates_threadsafe_.Push(std::move(callback));  
8.    }  
9.    uv_async_send(&amp;task_queues_async_);  
10. }  
</code></pre></div> <p>SetImmediateThreadsafe用于通知执行环境所在的事件循环有异步任务完成。并且是线程安全的。因为可能有多个线程会操作native_immediates_threadsafe_。在主线程事件循环的Poll IO阶段就会执行task_queues_async_回调。我们看一下task_queues_async_对应的回调。</p> <div class=highlight><pre><span></span><code>1.  uv_async_init(  
2.       event_loop(),  
3.       &amp;task_queues_async_,  
4.       [](uv_async_t* async) {  
5.         Environment* env = ContainerOf(  
6.             &amp;Environment::task_queues_async_, async);  
7.         env-&gt;CleanupFinalizationGroups();  
8.         env-&gt;RunAndClearNativeImmediates();  
9.       });  
</code></pre></div> <p>所以在Poll IO阶段执行的回调是RunAndClearNativeImmediates</p> <div class=highlight><pre><span></span><code>1.  void Environment::RunAndClearNativeImmediates(bool only_refed) {  
2.    TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),  
3.                                &quot;RunAndClearNativeImmediates&quot;, this);  
4.    size_t ref_count = 0;  
5.     
6.    if (native_immediates_threadsafe_.size() &gt; 0) {  
7.      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);  
8.      native_immediates_.ConcatMove(std::move(native_immediates_threadsafe_));  
9.    }  
10.   
11.   auto drain_list = [&amp;]() {  
12.     TryCatchScope try_catch(this);  
13.     DebugSealHandleScope seal_handle_scope(isolate());  
14.     while (std::unique_ptr&lt;NativeImmediateCallback&gt; head =  
15.                native_immediates_.Shift()) {  
16.       if (head-&gt;is_refed())  
17.         ref_count++;  
18.   
19.       if (head-&gt;is_refed() || !only_refed)  
20.         // 执行回调  
21.         head-&gt;Call(this);  
22.   
23.       head.reset();   
24.   };  
25. }  
</code></pre></div> <p>RunAndClearNativeImmediates会执行队列里的回调。对应Worker的JoinThread</p> <div class=highlight><pre><span></span><code>1.  void Worker::JoinThread() {  
2.    // 阻塞等待子线程结束，执行到这子线程已经结束了  
3.    CHECK_EQ(uv_thread_join(&amp;tid_), 0);  
4.    thread_joined_ = true;  
5.    // 从主线程数据结构中删除该线程对应的实例  
6.    env()-&gt;remove_sub_worker_context(this);  
7.    
8.    {  
9.      HandleScope handle_scope(env()-&gt;isolate());  
10.     Context::Scope context_scope(env()-&gt;context());  
11.   
12.     // Reset the parent port as we&#39;re closing it now anyway.  
13.     object()-&gt;Set(env()-&gt;context(),  
14.                   env()-&gt;message_port_string(),  
15.                   Undefined(env()-&gt;isolate())).Check();  
16.     // 子线程退出码  
17.     Local&lt;Value&gt; args[] = {  
18.       Integer::New(env()-&gt;isolate(), exit_code_),  
19.       custom_error_ != nullptr ?  
20.           OneByteString(env()-&gt;isolate(), custom_error_).As&lt;Value&gt;() :  
21.           Null(env()-&gt;isolate()).As&lt;Value&gt;(),  
22.     };  
23.     // 执行JS层回调，触发exit事件  
24.     MakeCallback(env()-&gt;onexit_string(), arraysize(args), args);  
25.   }  
26. }  
</code></pre></div> <p>最后我们看一下如果结束正在执行的子线程。在JS中我能可以通过terminate函数终止线程的执行。</p> <div class=highlight><pre><span></span><code>1.  terminate(callback) {  
2.      this[kHandle].stopThread();  
3.  }  
Terminate是对C++模块stopThread的封装。
1.  void Worker::StopThread(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
2.    Worker* w;  
3.    ASSIGN_OR_RETURN_UNWRAP(&amp;w, args.This());  
4.    w-&gt;Exit(1);  
5.  }  
6.    
7.  void Worker::Exit(int code) {  
8.    Mutex::ScopedLock lock(mutex_);  
9.    // env_是子线程执行的env 
10.   if (env_ != nullptr) {  
11.     exit_code_ = code;  
12.     Stop(env_);  
13.   } else {  
14.     stopped_ = true;  
15.   }  
16. }  
17.   
18.   
19. int Stop(Environment* env) {  
20.   env-&gt;ExitEnv();  
21.   return 0;  
22. }  
23.   
24. void Environment::ExitEnv() {  
25.   set_can_call_into_js(false);  
26.   set_stopping(true);  
27.   isolate_-&gt;TerminateExecution();  
28.   SetImmediateThreadsafe([](Environment* env) { uv_stop(env-&gt;event_loop()); });  
29. }  
</code></pre></div> <p>我们看到主线程最终通过SetImmediateThreadsafe给子线程所属的env提交了一个任务。子线程在Poll IO阶段会设置停止事件循环的标记，等到下一次事件循环开始的时候，就会跳出事件循环从而结束子线程的执行。</p> <h2 id=144>14.4 线程间通信<a class=headerlink href=#144 title="Permanent link">&para;</a></h2> <p>本节我们看一下线程间通信的过程。</p> <div class=highlight><pre><span></span><code>1.  const { Worker, isMainThread, parentPort } = require(&#39;worker_threads&#39;);  
2.  if (isMainThread) {  
3.    const worker = new Worker(__filename);  
4.    worker.once(&#39;message&#39;, (message) =&gt; {  
5.      ...  
6.    });  
7.    worker.postMessage(&#39;Hello, world!&#39;);  
8.  } else {  
9.    // 做点耗时的事情  
10.   parentPort.once(&#39;message&#39;, (message) =&gt; {  
11.     parentPort.postMessage(message);  
12.   });  
13. }  
</code></pre></div> <p>我们知道isMainThread在子线程里是false，parentPort就是messageChannel中的一端。用于和主线程通信，所以parentPort.postMessage给对端发送消息，就是给主线程发送消息，我们再看看worker.postMessage('Hello, world!')。</p> <div class=highlight><pre><span></span><code>1.  postMessage(...args) {  
2.     this[kPublicPort].postMessage(...args);  
3.  }  
</code></pre></div> <p>kPublicPort指向的就是messageChannel的一端。this[kPublicPort].postMessage(...args)即给另一端发送消息。我们看一下postMessage的实现。</p> <div class=highlight><pre><span></span><code>1.  void MessagePort::PostMessage(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {  
2.    Environment* env = Environment::GetCurrent(args);  
3.    Local&lt;Object&gt; obj = args.This();  
4.    Local&lt;Context&gt; context = obj-&gt;CreationContext();  
5.    
6.    TransferList transfer_list;  
7.    if (args[1]-&gt;IsObject()) {  
8.      // 处理transfer_list  
9.    }  
10.   // 拿到JS层使用的对象所关联的MessagePort  
11.   MessagePort* port = Unwrap&lt;MessagePort&gt;(args.This());  
12.   
13.   port-&gt;PostMessage(env, args[0], transfer_list);  
14. }  
</code></pre></div> <p>我们接着看port-&gt;PostMessage</p> <div class=highlight><pre><span></span><code>1.  Maybe&lt;bool&gt; MessagePort::PostMessage(Environment* env,  
2.                                       Local&lt;Value&gt; message_v,  
3.                                       const TransferList&amp; transfer_v) {  
4.    Isolate* isolate = env-&gt;isolate();  
5.    Local&lt;Object&gt; obj = object(isolate);  
6.    Local&lt;Context&gt; context = obj-&gt;CreationContext();  
7.    
8.    Message msg;  
9.    
10.   // 序列化  
11.   Maybe&lt;bool&gt; serialization_maybe =  
12.       msg.Serialize(env, context, message_v, transfer_v, obj);  
13.   // 拿到操作对端sibling的锁  
14.   Mutex::ScopedLock lock(*data_-&gt;sibling_mutex_);  
15.     
16.   // 把消息插入到对端队列  
17.   data_-&gt;sibling_-&gt;AddToIncomingQueue(std::move(msg));  
18.   return Just(true);  
19. }  
</code></pre></div> <p>PostMessage通过AddToIncomingQueue把消息插入对端的消息队列我们看一下AddToIncomingQueue</p> <div class=highlight><pre><span></span><code>1.  void MessagePortData::AddToIncomingQueue(Message&amp;&amp; message) {  
2.    // 加锁操作消息队列  
3.    Mutex::ScopedLock lock(mutex_);  
4.    incoming_messages_.emplace_back(std::move(message));  
5.    // 通知owner  
6.    if (owner_ != nullptr) {  
7.      owner_-&gt;TriggerAsync();  
8.    }  
9.  }  
</code></pre></div> <p>插入消息队列后，如果有关联的端口，则会通知Libuv。我们继续看TriggerAsync。</p> <div class=highlight><pre><span></span><code>1.  void MessagePort::TriggerAsync() {  
2.    if (IsHandleClosing()) return;  
3.    CHECK_EQ(uv_async_send(&amp;async_), 0);  
4.  }  
</code></pre></div> <p>Libuv在Poll IO阶段就会执行对应的回调。回调是在new MessagePort时设置的。</p> <div class=highlight><pre><span></span><code>1.  auto onmessage = [](uv_async_t* handle) {  
2.    MessagePort* channel = ContainerOf(&amp;MessagePort::async_, handle);  
3.    channel-&gt;OnMessage();  
4.  };  
5.  // 初始化async结构体，实现异步通信  
6.  CHECK_EQ(uv_async_init(env-&gt;event_loop(),  
7.                         &amp;async_,  
8.                         onmessage), 0);  
</code></pre></div> <p>我们继续看OnMessage。</p> <div class=highlight><pre><span></span><code>1.  void MessagePort::OnMessage() {  
2.    HandleScope handle_scope(env()-&gt;isolate());  
3.    Local&lt;Context&gt; context = object(env()-&gt;isolate())-&gt;CreationContext();  
4.    // 接收消息条数的阈值  
5.    size_t processing_limit;  
6.    {   
7.      // 加锁操作消息队列  
8.      Mutex::ScopedLock(data_-&gt;mutex_);  
9.      processing_limit = std::max(data_-&gt;incoming_messages_.size(),  
10.                                 static_cast&lt;size_t&gt;(1000));  
11.   }  
12.   while (data_) {  
13.     // 读取的条数达到阈值，通知Libuv下一轮Poll IO阶段继续读  
14.     if (processing_limit-- == 0) {  
15.       // 通知事件循环  
16.       TriggerAsync();  
17.       return;  
18.     }  
19.   
20.     HandleScope handle_scope(env()-&gt;isolate());  
21.     Context::Scope context_scope(context);  
22.   
23.     Local&lt;Value&gt; payload;  
24.     // 读取消息  
25.     if (!ReceiveMessage(context, true).ToLocal(&amp;payload)) break;  
26.     // 没有了  
27.     if (payload == env()-&gt;no_message_symbol()) break;  
28.   
29.     Local&lt;Object&gt; event;  
30.     Local&lt;Value&gt; cb_args[1];  
31.     // 新建一个MessageEvent对象，回调onmessage事件  
32.     if (!env()-&gt;message_event_object_template()-&gt;NewInstance(context)  
33.             .ToLocal(&amp;event) ||  
34.         event-&gt;Set(context, env()-&gt;data_string(), payload).IsNothing() ||  
35.         event-&gt;Set(context, env()-&gt;target_string(), object()).IsNothing() ||  
36.         (cb_args[0] = event, false) ||  
37.         MakeCallback(env()-&gt;onmessage_string(),  
38.                      arraysize(cb_args),  
39.                      cb_args).IsEmpty()) {  
40.       // 如果回调失败，通知Libuv下次继续读  
41.       if (data_)  
42.         TriggerAsync();  
43.       return;  
44.     }  
45.   }  
46. }  
</code></pre></div> <p>我们看到这里会不断地调用ReceiveMessage读取数据，然后回调JS层。直到达到阈值或者回调失败。我们看一下ReceiveMessage的逻辑。</p> <div class=highlight><pre><span></span><code>1.  MaybeLocal&lt;Value&gt; MessagePort::ReceiveMessage(Local&lt;Context&gt; context,  
2.                                                bool only_if_receiving) {  
3.    Message received;  
4.    {  
5.      // Get the head of the message queue.  
6.      // 互斥访问消息队列  
7.      Mutex::ScopedLock lock(data_-&gt;mutex_);  
8.    
9.      bool wants_message = receiving_messages_ || !only_if_receiving;  
10.     // 没有消息、不需要接收消息、消息是关闭消息  
11.     if (data_-&gt;incoming_messages_.empty() ||  
12.         (!wants_message &amp;&amp;  
13.          !data_-&gt;incoming_messages_.front().IsCloseMessage())) {  
14.       return env()-&gt;no_message_symbol();  
15.     }  
16.     // 获取队列第一个消息  
17.     received = std::move(data_-&gt;incoming_messages_.front());  
18.     data_-&gt;incoming_messages_.pop_front();  
19.   }  
20.   // 是关闭消息则关闭端口  
21.   if (received.IsCloseMessage()) {  
22.     Close();  
23.     return env()-&gt;no_message_symbol();  
24.   }  
25.   
26.   // 反序列化后返回  
27.   return received.Deserialize(env(), context);  
28. }  
</code></pre></div> <p>ReceiveMessage会消息进行反序列化返回。以上就是线程间通信的整个过程。具体步骤如图14-5所示。<br> <img alt src="https://img-blog.csdnimg.cn/56ef57375522428e92f3d53649fe3265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图14-5</p> </article> </div> </div> <a href=# class="md-top md-icon" data-md-component=top data-md-state=hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg> Back to top </a> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../chapter13-%E8%BF%9B%E7%A8%8B/ class="md-footer__link md-footer__link--prev" aria-label="上一页: 13-进程" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 上一页 </span> 13-进程 </div> </div> </a> <a href=../chapter15-Cluster/ class="md-footer__link md-footer__link--next" aria-label="下一页: 15-Cluster" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 下一页 </span> 15-Cluster </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2021 theanarkh </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-footer-social> <a href=https://github.com/theanarkh target=_blank rel=noopener title=github.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> <a href=https://www.zhihu.com/people/theanarkh target=_blank rel=noopener title=www.zhihu.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 640 512"><path d="M170.54 148.13v217.54l23.43.01 7.71 26.37 42.01-26.37h49.53V148.13H170.54zm97.75 193.93h-27.94l-27.9 17.51-5.08-17.47-11.9-.04V171.75h72.82v170.31zm-118.46-94.39H97.5c1.74-27.1 2.2-51.59 2.2-73.46h51.16s1.97-22.56-8.58-22.31h-88.5c3.49-13.12 7.87-26.66 13.12-40.67 0 0-24.07 0-32.27 21.57-3.39 8.9-13.21 43.14-30.7 78.12 5.89-.64 25.37-1.18 36.84-22.21 2.11-5.89 2.51-6.66 5.14-14.53h28.87c0 10.5-1.2 66.88-1.68 73.44H20.83c-11.74 0-15.56 23.62-15.56 23.62h65.58C66.45 321.1 42.83 363.12 0 396.34c20.49 5.85 40.91-.93 51-9.9 0 0 22.98-20.9 35.59-69.25l53.96 64.94s7.91-26.89-1.24-39.99c-7.58-8.92-28.06-33.06-36.79-41.81L87.9 311.95c4.36-13.98 6.99-27.55 7.87-40.67h61.65s-.09-23.62-7.59-23.62v.01zm412.02-1.6c20.83-25.64 44.98-58.57 44.98-58.57s-18.65-14.8-27.38-4.06c-6 8.15-36.83 48.2-36.83 48.2l19.23 14.43zm-150.09-59.09c-9.01-8.25-25.91 2.13-25.91 2.13s39.52 55.04 41.12 57.45l19.46-13.73s-25.67-37.61-34.66-45.86h-.01zM640 258.35c-19.78 0-130.91.93-131.06.93v-101c4.81 0 12.42-.4 22.85-1.2 40.88-2.41 70.13-4 87.77-4.81 0 0 12.22-27.19-.59-33.44-3.07-1.18-23.17 4.58-23.17 4.58s-165.22 16.49-232.36 18.05c1.6 8.82 7.62 17.08 15.78 19.55 13.31 3.48 22.69 1.7 49.15.89 24.83-1.6 43.68-2.43 56.51-2.43v99.81H351.41s2.82 22.31 25.51 22.85h107.94v70.92c0 13.97-11.19 21.99-24.48 21.12-14.08.11-26.08-1.15-41.69-1.81 1.99 3.97 6.33 14.39 19.31 21.84 9.88 4.81 16.17 6.57 26.02 6.57 29.56 0 45.67-17.28 44.89-45.31v-73.32h122.36c9.68 0 8.7-23.78 8.7-23.78l.03-.01z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "..", "features": ["content.code.annotate", "navigation.indexes", "navigation.instant", "navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "search.suggest"], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.94ec81fe.min.js", "version": null}</script> <script src=../assets/javascripts/bundle.48dfec6c.min.js></script> </body> </html>