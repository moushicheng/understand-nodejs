{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u901a\u8fc7\u6e90\u7801\u5206\u6790nodejs\u539f\u7406 \u00b6 \u77e5\u4e4e\uff1a Node.js\u6e90\u7801\u5206\u6790 \u4e3a\u4ec0\u4e48\u8981\u8bfbNode.js\u6e90\u7801\uff1f Node.js\u7684\u5e95\u5c42\u539f\u7406 \u300aNode.js\u6e90\u7801\u89e3\u67901.0.0\u5e26\u6807\u7b7e\u7248\u300b \u8ba9\u6211\u4eec\u5f00\u59cb\u5b66\u4e60 Node.js \u5427\ud83d\udd25 \u6700\u540e\u66f4\u65b0: 2021-09-22","title":"Home"},{"location":"#nodejs","text":"\u77e5\u4e4e\uff1a Node.js\u6e90\u7801\u5206\u6790 \u4e3a\u4ec0\u4e48\u8981\u8bfbNode.js\u6e90\u7801\uff1f Node.js\u7684\u5e95\u5c42\u539f\u7406 \u300aNode.js\u6e90\u7801\u89e3\u67901.0.0\u5e26\u6807\u7b7e\u7248\u300b \u8ba9\u6211\u4eec\u5f00\u59cb\u5b66\u4e60 Node.js \u5427\ud83d\udd25 \u6700\u540e\u66f4\u65b0: 2021-09-22","title":"\u901a\u8fc7\u6e90\u7801\u5206\u6790nodejs\u539f\u7406"},{"location":"chapter00-%E5%89%8D%E8%A8%80/","text":"\u524d\u8a00 \u00b6 \u6211\u5f88\u559c\u6b22JS\u8fd9\u95e8\u8bed\u8a00\uff0c\u611f\u89c9\u5b83\u548cC\u8bed\u8a00\u4e00\u6837\uff0c\u5728C\u8bed\u8a00\u91cc\uff0c\u5f88\u591a\u4e1c\u897f\u90fd\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\uff0c\u8ba9\u6211\u4eec\u53ef\u4ee5\u53d1\u6325\u65e0\u9650\u7684\u521b\u9020\u529b\u548c\u60f3\u8c61\u529b\u3002\u5728JS\u4e2d\uff0c\u867d\u7136\u5f88\u591a\u4e1c\u897f\u5728V8\u91cc\u5df2\u7ecf\u63d0\u4f9b\uff0c\u4f46\u662f\u7528JS\uff0c\u4f9d\u7136\u53ef\u4ee5\u521b\u9020\u5f88\u591a\u597d\u73a9\u7684\u4e1c\u897f\uff0c\u8fd8\u6709\u597d\u73a9\u7684\u5199\u6cd5\u3002\u53e6\u5916\uff0cJS\u5e94\u8be5\u6211\u89c1\u8fc7\u552f\u4e00\u7684\u4e00\u95e8\u6ca1\u6709\u5b9e\u73b0\u7f51\u7edc\u548c\u6587\u4ef6\u529f\u80fd\u7684\u8bed\u8a00\uff0c\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u80fd\u529b\uff0c\u5bf9\u4e8e\u7a0b\u5e8f\u5458\u6765\u8bf4\uff0c\u4e5f\u662f\u5f88\u6838\u5fc3\u5f88\u57fa\u7840\u7684\u77e5\u8bc6\u3002\u5f88\u5e78\u8fd0\uff0cNode.js\u88ab\u521b\u9020\u51fa\u6765\u4e86\uff0cNode.js\u5728JS\u7684\u57fa\u7840\u4e0a\uff0c\u4f7f\u7528V8\u548cLibuv\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u3001\u4e30\u5bcc\u4e86JS\u7684\u80fd\u529b\uff0c\u5c24\u5176\u662f\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u8fd9\u6837\u6211\u5c31\u4e0d\u4ec5\u53ef\u4ee5\u4f7f\u7528JS\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7f51\u7edc\u3001\u6587\u4ef6\u7b49\u529f\u80fd\uff0c\u8fd9\u662f\u6211\u9010\u6e10\u8f6c\u5411Node.js\u65b9\u5411\u7684\u539f\u56e0\u4e4b\u4e00\uff0c\u4e5f\u662f\u6211\u5f00\u59cb\u7814\u7a76Node.js\u6e90\u7801\u7684\u539f\u56e0\u4e4b\u4e00\u3002\u867d\u7136Node.js\u6ee1\u8db3\u4e86\u6211\u559c\u597d\u548c\u6280\u672f\u4e0a\u7684\u9700\u6c42\uff0c\u4e0d\u8fc7\u4e00\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u6211\u5e76\u6ca1\u6709\u5168\u8eab\u5fc3\u5730\u6295\u5165\u4ee3\u7801\u7684\u7814\u7a76\uff0c\u53ea\u662f\u5076\u5c14\u4f1a\u770b\u4e00\u4e0b\u67d0\u4e9b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u771f\u6b63\u7684\u5f00\u59cb\uff0c\u662f\u4e3a\u4e86\u505a\u300aNode.js\u662f\u5982\u4f55\u5229\u7528Libuv\u5b9e\u73b0\u4e8b\u4ef6\u5faa\u73af\u548c\u5f02\u6b65\u300b\u7684\u5206\u4eab\uff0c\u4ece\u90a3\u65f6\u5019\u8d77\uff0c\u5927\u90e8\u5206\u4e1a\u4f59\u65f6\u95f4\u548c\u7cbe\u529b\u90fd\u6295\u5165\u6e90\u7801\u7684\u7814\u7a76\u3002 \u6211\u9996\u5148\u4eceLibuv\u5f00\u59cb\u7814\u7a76\uff0c\u56e0\u4e3aLibuv\u662fNode.js\u7684\u6838\u5fc3\u4e4b\u4e00\u3002\u7531\u4e8e\u66fe\u7ecf\u7814\u7a76\u8fc7\u4e00\u4e9bLinux\u7684\u6e90\u7801\uff0c\u4e5f\u4e00\u76f4\u5728\u5b66\u4e60\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u539f\u7406\u548c\u5b9e\u73b0\uff0c\u6240\u4ee5\u5728\u9605\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u7b97\u662f\u6ca1\u6709\u9047\u5230\u592a\u5927\u7684\u56f0\u96be\uff0cC\u8bed\u8a00\u51fd\u6570\u7684\u4f7f\u7528\u548c\u539f\u7406\uff0c\u57fa\u672c\u90fd\u53ef\u4ee5\u770b\u660e\u767d\uff0c\u91cd\u70b9\u5728\u4e8e\u9700\u8981\u628a\u5404\u4e2a\u903b\u8f91\u634b\u6e05\u695a\u3002\u6211\u4f7f\u7528\u7684\u65b9\u6cd5\u5c31\u662f\u6ce8\u91ca\u548c\u753b\u56fe\uff0c\u6211\u4e2a\u4eba\u6bd4\u8f83\u559c\u6b22\u5199\u6ce8\u91ca\u3002\u867d\u7136\u8bf4\u4ee3\u7801\u662f\u6700\u597d\u7684\u6ce8\u91ca\uff0c\u4f46\u662f\u6211\u8fd8\u662f\u613f\u610f\u82b1\u65f6\u95f4\u7528\u6ce8\u91ca\u53bb\u628a\u4ee3\u7801\u7684\u80cc\u666f\u548c\u610f\u4e49\u9610\u8ff0\u4e00\u4e0b\uff0c\u800c\u4e14\u6ce8\u91ca\u4f1a\u8ba9\u5927\u90e8\u5206\u4eba\u66f4\u5feb\u5730\u80fd\u8bfb\u61c2\u4ee3\u7801\u7684\u542b\u4e49\u3002\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u4e5f\u7a7f\u63d2\u5730\u8bfb\u4e86\u4e00\u4e9bJS\u548cC++\u5c42\u7684\u4ee3\u7801\u3002\u6211\u9605\u8bfbNode.js\u6e90\u7801\u7684\u65b9\u5f0f\u662f\uff0c\u9009\u62e9\u4e00\u4e2a\u6a21\u5757\uff0c\u5782\u76f4\u5730\u4eceJS\u5c42\u5206\u6790\u5230C++\u5c42\uff0c\u7136\u540e\u5230Libuv\u5c42\u3002 \u8bfb\u5b8cLibuv\uff0c\u63a5\u4e0b\u6765\u8bfb\u7684\u662fJS\u5c42\u7684\u4ee3\u7801\uff0cJS\u867d\u7136\u5bb9\u6613\u770b\u61c2\uff0c\u4f46\u662fJS\u5c42\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u800c\u4e14\u6211\u611f\u89c9\u903b\u8f91\u4e0a\u4e5f\u975e\u5e38\u7ed5\uff0c\u6240\u4ee5\u81f3\u4eca\uff0c\u6211\u8fd8\u6709\u5f88\u591a\u6ca1\u6709\u7ec6\u8bfb\uff0c\u8fd9\u4e2a\u4f5c\u4e3a\u540e\u7eed\u7684\u8ba1\u5212\u3002Node.js\u4e2d\uff0cC++\u7b97\u662f\u80f6\u6c34\u5c42\uff0c\u5f88\u591a\u65f6\u5019\uff0c\u4e0d\u4f1aC++\uff0c\u5176\u5b9e\u4e5f\u4e0d\u5f71\u54cdNode.js\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u56e0\u4e3aC++\u5f88\u591a\u65f6\u5019\uff0c\u53ea\u662f\u4e00\u79cd\u900f\u4f20\u7684\u529f\u80fd\uff0c\u5b83\u628aJS\u5c42\u7684\u8bf7\u6c42\uff0c\u901a\u8fc7V8\uff0c\u4f20\u7ed9Libuv\uff0c\u7136\u540e\u518d\u53cd\u8fc7\u6765\uff0c\u6240\u4ee5C++\u5c42\u6211\u662f\u653e\u5230\u6700\u540e\u624d\u7ec6\u8bfb\u3002C++\u5c42\u6211\u89c9\u5f97\u662f\u6700\u96be\u7684\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u53c8\u4e0d\u5f97\u4e0d\u5f00\u59cb\u8bfbV8\u7684\u6e90\u7801\u4e86\uff0c\u7406\u89e3V8\u975e\u5e38\u96be\uff0c\u6211\u9009\u53d6\u7684\u51e0\u4e4e\u662f\u6700\u65e9\u7684\u7248\u672c0.1.5\uff0c\u7136\u540e\u7ed3\u54088.x\u7248\u672c\u3002\u901a\u8fc7\u65e9\u671f\u7248\u672c\uff0c\u5148\u5b66\u4e60V8\u7684\u5927\u6982\u539f\u7406\u548c\u4e00\u4e9b\u65e9\u671f\u5b9e\u73b0\u4e0a\u7684\u7ec6\u8282\u3002\u56e0\u4e3a\u540e\u7eed\u7684\u7248\u672c\u867d\u7136\u53d8\u5316\u5f88\u5927\uff0c\u4f46\u662f\u66f4\u591a\u53ea\u662f\u529f\u80fd\u7684\u589e\u5f3a\u548c\u4f18\u5316\uff0c\u6709\u5f88\u591a\u6838\u5fc3\u7684\u6982\u5ff5\u8fd8\u662f\u6ca1\u6709\u53d8\u5316\u7684\uff0c\u8fd9\u662f\u6211\u9009\u53d6\u65e9\u671f\u7248\u672c\u7684\u539f\u56e0\uff0c\u907f\u514d\u4e00\u5f00\u59cb\u5c31\u9677\u5165\u65e0\u7a77\u65e0\u5c3d\u7684\u4ee3\u7801\u4e2d\uff0c\u8ff7\u5931\u4e86\u65b9\u5411\uff0c\u5931\u53bb\u4e86\u52a8\u529b\u3002\u4f46\u662f\u54ea\u6015\u662f\u65e9\u671f\u7684\u7248\u672c\uff0c\u6709\u5f88\u591a\u5185\u5bb9\u4f9d\u7136\u975e\u5e38\u590d\u6742\uff0c\u7ed3\u5408\u65b0\u7248\u672c\u662f\u56e0\u4e3a\u6709\u4e9b\u529f\u80fd\u5728\u65e9\u671f\u7248\u672c\u91cc\u6ca1\u6709\u5b9e\u73b0\uff0c\u8fd9\u65f6\u5019\u8981\u660e\u767d\u5b83\u7684\u539f\u7406\uff0c\u5c31\u53ea\u80fd\u770b\u65b0\u7248\u7684\u4ee3\u7801\uff0c\u6709\u4e86\u65e9\u671f\u7248\u672c\u7684\u7ecf\u9a8c\uff0c\u9605\u8bfb\u65b0\u7248\u7684\u4ee3\u7801\u4e5f\u6709\u4e00\u5b9a\u7684\u597d\u5904\uff0c\u591a\u5c11\u4e5f\u77e5\u9053\u4e86\u4e00\u4e9b\u9605\u8bfb\u6280\u5de7\u3002 Node.js\u7684\u5927\u90e8\u5206\u4ee3\u7801\u90fd\u5728C++\u548cJS\u5c42\uff0c\u6240\u4ee5\u76ee\u524d\u4ecd\u7136\u662f\u5728\u4e0d\u65ad\u5730\u9605\u8bfb\u8fd9\u4e24\u5c42\u7684\u4ee3\u7801\u3002\u8fd8\u662f\u6309\u7167\u6a21\u5757\u5782\u76f4\u5206\u6790\u3002\u9605\u8bfbNode.js\u4ee3\u7801\uff0c\u8ba9\u6211\u66f4\u4e86\u89e3Node.js\u7684\u539f\u7406\uff0c\u4e5f\u66f4\u4e86\u89e3JS\u3002\u4e0d\u8fc7\u4ee3\u7801\u91cf\u975e\u5e38\u5927\uff0c\u9700\u8981\u6e90\u6e90\u4e0d\u65ad\u7684\u65f6\u95f4\u548c\u7cbe\u529b\u6295\u5165\u3002\u4f46\u662f\u505a\u6280\u672f\uff0c\u77e5\u5176\u7136\u77e5\u5176\u6240\u4ee5\u7136\u7684\u611f\u89c9\u662f\u975e\u5e38\u7f8e\u5999\u7684\uff0c\u4f60\u9760\u7740\u4e00\u95e8\u6280\u672f\u8c0b\u751f\uff0c\u5374\u5bf9\u5b83\u77e5\u4e4b\u751a\u5c11\uff0c\u8fd9\u79cd\u611f\u89c9\u5e76\u4e0d\u597d\u3002\u9605\u8bfb\u6e90\u7801\uff0c\u867d\u7136\u4e0d\u4f1a\u4e3a\u4f60\u5e26\u6765\u76f4\u63a5\u7684\u3001\u8fc5\u901f\u7684\u6536\u76ca\uff0c\u4f46\u662f\u6709\u51e0\u4e2a\u597d\u5904\u662f\u5fc5\u7136\u7684\u3002\u7b2c\u4e00\u662f\u5b83\u4f1a\u51b3\u5b9a\u4f60\u7684\u9ad8\u5ea6\uff0c\u7b2c\u4e8c\u4f60\u5199\u4ee3\u7801\u7684\u65f6\u5019\uff0c\u4f60\u770b\u5230\u7684\u4e0d\u518d\u662f\u4e00\u4e9b\u51b0\u51b7\u51b7\u3001\u65e0\u751f\u547d\u7684\u5b57\u7b26\u3002\u8fd9\u53ef\u80fd\u6709\u70b9\u5938\u5f20\uff0c\u4f46\u662f\u4f60\u4e86\u89e3\u4e86\u6280\u672f\u7684\u539f\u7406\uff0c\u4f60\u5728\u4f7f\u7528\u6280\u672f\u7684\u65f6\u5019\uff0c\u7684\u786e\u4f1a\u6709\u4e0d\u540c\u7684\u4f53\u9a8c\uff0c\u4f60\u7684\u601d\u7ef4\u4e5f\u4f1a\u6709\u4e86\u66f4\u591a\u7684\u53d8\u5316\u3002\u7b2c\u4e09\u662f\u63d0\u9ad8\u4e86\u4f60\u7684\u5b66\u4e60\u80fd\u529b\uff0c\u5f53\u4f60\u5bf9\u5e95\u5c42\u539f\u7406\u6709\u4e86\u66f4\u591a\u7684\u4e86\u89e3\u548c\u7406\u89e3\uff0c\u4f60\u5728\u5b66\u4e60\u5176\u5b83\u6280\u672f\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u66f4\u5feb\u5730\u5b66\u4f1a\uff0c\u6bd4\u5982\u4f60\u4e86\u89e3\u4e86epoll\u7684\u539f\u7406\uff0c\u90a3\u4f60\u770bNginx\u3001Redis\u3001Libuv\u7b49\u6e90\u7801\u7684\u65f6\u5019\uff0c\u5173\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u903b\u8f91\uff0c\u57fa\u672c\u4e0a\u5f88\u5feb\u5c31\u80fd\u770b\u61c2\u3002\u5f88\u9ad8\u5174\u6709\u8fd9\u4e9b\u7ecf\u5386\uff0c\u4e5f\u6295\u5165\u4e86\u5f88\u591a\u65f6\u95f4\u548c\u7ecf\u7cbe\u529b\uff0c\u5e0c\u671b\u4ee5\u540e\u5bf9Node.js\u6709\u66f4\u591a\u7684\u7406\u89e3\u548c\u4e86\u89e3\uff0c\u4e5f\u5e0c\u671b\u5728Node.js\u65b9\u5411\u6709\u66f4\u591a\u7684\u5b9e\u8df5\u3002 \u672c\u4e66\u7684\u76ee\u7684 \u00b6 \u9605\u8bfbNode.js\u6e90\u7801\u7684\u521d\u8877\u662f\u8ba9\u81ea\u5df1\u6df1\u5165\u7406\u89e3Node.js\u7684\u539f\u7406\uff0c\u4f46\u662f\u6211\u53d1\u73b0\u6709\u5f88\u591a\u540c\u5b66\u5bf9Node.js\u539f\u7406\u4e5f\u975e\u5e38\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u4e1a\u4f59\u65f6\u95f4\u91cc\u4e5f\u4e00\u76f4\u5728\u5199\u4e00\u4e9b\u5173\u4e8eNode.js\u6e90\u7801\u5206\u6790\u7684\u6587\u7ae0\uff08\u57fa\u4e8eNode.js V10\u548cV14\uff09\uff0c\u6240\u4ee5\u5c31\u6253\u7b97\u628a\u8fd9\u4e9b\u5185\u5bb9\u6574\u7406\u6210\u4e00\u672c\u6709\u4f53\u7cfb\u7684\u4e66\uff0c\u8ba9\u611f\u5174\u8da3\u7684\u540c\u5b66\u80fd\u7cfb\u7edf\u5730\u53bb\u4e86\u89e3\u548c\u7406\u89e3Node.js\u7684\u539f\u7406\u3002\u4e0d\u8fc7\u6211\u66f4\u5e0c\u671b\u7684\u662f\uff0c\u8bfb\u8005\u4ece\u4e66\u4e2d\u4e0d\u4ec5\u5b66\u5230Node.js\u7684\u77e5\u8bc6\uff0c\u800c\u4e14\u4e5f\u5b66\u5230\u5982\u4f55\u9605\u8bfbNode.js\u6e90\u7801\uff0c\u53ef\u4ee5\u81ea\u5df1\u72ec\u7acb\u5b8c\u6210\u6e90\u7801\u7684\u7814\u7a76\u3002\u4e5f\u5e0c\u671b\u66f4\u591a\u540c\u5b66\u5206\u4eab\u81ea\u5df1\u7684\u5fc3\u5f97\u3002\u672c\u4e66\u4e0d\u662fNode.js\u7684\u5168\u90e8\uff0c\u4f46\u662f\u5c3d\u91cf\u53bb\u8bb2\u5f97\u66f4\u591a\uff0c\u6e90\u7801\u975e\u5e38\u591a\uff0c\u9519\u7efc\u590d\u6742\uff0c\u7406\u89e3\u4e0a\u53ef\u80fd\u6709\u4e0d\u5bf9\u4e4b\u5904\uff0c\u6b22\u8fce\u4ea4\u6d41\u3002\u56e0\u4e3a\u770b\u8fc7Linux\u65e9\u671f\u5185\u6838\uff080.11\u548c1.2.13\uff09\u548c\u65e9\u671fV8\uff080.1.5\uff09\u7684\u4e00\u4e9b\u5b9e\u73b0\uff0c\u6587\u7ae0\u4f1a\u5f15\u7528\u5176\u4e2d\u7684\u4e00\u4e9b\u4ee3\u7801\uff0c\u76ee\u7684\u5728\u4e8e\u8ba9\u8bfb\u8005\u53ef\u4ee5\u66f4\u4e86\u89e3\u4e00\u4e2a\u77e5\u8bc6\u70b9\u7684\u5927\u81f4\u5b9e\u73b0\u539f\u7406\uff0c\u5982\u679c\u8bfb\u8005\u6709\u5174\u8da3\uff0c\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u76f8\u5173\u4ee3\u7801\u3002 \u672c\u4e66\u7ed3\u6784 \u00b6 \u672c\u4e66\u5171\u5206\u4e3a\u4e8c\u5341\u4e8c\u7ae0\uff0c\u8bb2\u89e3\u7684\u4ee3\u7801\u90fd\u662f\u57fa\u4e8eLinux\u7cfb\u7edf\u7684\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u7684\u7ec4\u6210\u548c\u6574\u4f53\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u53e6\u5916\u5206\u6790\u4e86Node.js\u542f\u52a8\u7684\u8fc7\u7a0b\uff0c\u6700\u540e\u4ecb\u7ecd\u4e86\u670d\u52a1\u5668\u67b6\u6784\u7684\u6f14\u53d8\u548cNode.js\u7684\u6240\u9009\u53d6\u7684\u67b6\u6784\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7684\u57fa\u7840\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u7684\u903b\u8f91\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4f1a\u7528\u5230\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u8fd9\u662fNode.js\u7684\u6838\u5fc3\u6240\u5728,\u672c\u7ae0\u5177\u4f53\u4ecb\u7ecd\u4e86\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6bcf\u4e2a\u9636\u6bb5\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\uff0cLibuv\u7ebf\u7a0b\u6c60\u5bf9Node.js\u6765\u8bf4\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0cNode.js\u4e2d\u5f88\u591a\u6a21\u5757\u90fd\u9700\u8981\u4f7f\u7528\u7ebf\u7a0b\u6c60\uff0c\u5305\u62eccrypto\u3001fs\u3001dns\u7b49\u3002\u5982\u679c\u6ca1\u6709\u7ebf\u7a0b\u6c60\uff0cNode.js\u7684\u529f\u80fd\u5c06\u4f1a\u5927\u6253\u6298\u6263\u3002\u540c\u65f6\u5206\u6790\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u3002\u540c\u6837\u9002\u5408\u5176\u5b83\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u6d41\u7684\u5b9e\u73b0\uff0c\u6d41\u5728Node.js\u6e90\u7801\u4e2d\u5f88\u591a\u5730\u65b9\u90fd\u7528\u5230\uff0c\u53ef\u4ee5\u8bf4\u662f\u975e\u5e38\u6838\u5fc3\u7684\u6982\u5ff5\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dC++\u5c42\u7684\u4e00\u4e9b\u91cd\u8981\u6a21\u5757\u548c\u901a\u7528\u903b\u8f91\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684\u4fe1\u53f7\u5904\u7406\u673a\u5236\uff0c\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684dns\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u5305\u62eccares\u7684\u4f7f\u7528\u548c\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dpipe\u6a21\u5757\uff08Unix\u57df\uff09\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\uff0cUnix\u57df\u662f\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u5b83\u89e3\u51b3\u4e86\u6ca1\u6709\u7ee7\u627f\u7684\u8fdb\u7a0b\u65e0\u6cd5\u901a\u4fe1\u7684\u95ee\u9898\u3002\u800c\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u6781\u5927\u5730\u589e\u5f3a\u4e86Node.js\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u5b9e\u73b0\u3002\u5b9a\u65f6\u5668\u662f\u5b9a\u65f6\u5904\u7406\u4efb\u52a1\u7684\u5229\u5668\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js setImmediate\u548cnextTick\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6587\u4ef6\u64cd\u4f5c\u662f\u6211\u4eec\u7ecf\u5e38\u4f1a\u7528\u5230\u7684\u529f\u80fd\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u8fdb\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u4f7f\u5f97Node.js\u53ef\u4ee5\u5229\u7528\u591a\u6838\u80fd\u529b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7ebf\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u548c\u591a\u7ebf\u7a0b\u6709\u7c7b\u4f3c\u7684\u529f\u80fd\u4f46\u662f\u4e5f\u6709\u4e00\u4e9b\u5dee\u5f02\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2dcluster\u6a21\u5757\u7684\u4f7f\u7528\u548c\u5b9e\u73b0\u539f\u7406\uff0ccluster\u6a21\u5757\u5c01\u88c5\u4e86\u591a\u8fdb\u7a0b\u80fd\u529b\uff0c\u4f7f\u5f97Node.j\u662f\u53ef\u4ee5\u4f7f\u7528\u591a\u8fdb\u7a0b\u7684\u670d\u52a1\u5668\u67b6\u6784\uff0c\u5229\u7528\u4e86\u591a\u6838\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dUDP\u7684\u5b9e\u73b0\u548c\u76f8\u5173\u5185\u5bb9\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dTCP\u6a21\u5757\u7684\u5b9e\u73b0\uff0cTCP\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\uff0c\u6211\u4eec\u5e38\u7528\u7684HTTP\uff0cHTTPS\u90fd\u662f\u57fa\u4e8enet\u6a21\u5757\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86HTTP\u6a21\u5757\u7684\u5b9e\u73b0\u4ee5\u53caHTTP\u534f\u8bae\u7684\u4e00\u4e9b\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5404\u79cd\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\uff0c\u6df1\u5165\u7406\u89e3Node.js\u7684require\u51fd\u6570\u6240\u505a\u7684\u4e8b\u60c5\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86\u4e00\u4e9b\u62d3\u5c55Node.js\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528Node.js\uff0c\u62d3\u5c55Node.js\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86JS\u5c42Stream\u7684\u5b9e\u73b0\uff0cStream\u6a21\u5757\u7684\u903b\u8f91\u5f88\u7ed5\uff0c\u5927\u6982\u8bb2\u89e3\u4e86\u4e00\u4e0b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2devent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cevent\u6a21\u5757\u867d\u7136\u7b80\u5355\uff0c\u4f46\u662f\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\u3002 \u9762\u5bf9\u7684\u8bfb\u8005 \u00b6 \u672c\u4e66\u9762\u5411\u6709\u4e00\u5b9aNode.js\u4f7f\u7528\u7ecf\u9a8c\u5e76\u5bf9Node.js\u539f\u7406\u611f\u5174\u8da3\u7684\u540c\u5b66\uff0c\u56e0\u4e3a\u672c\u4e66\u662fNode.js\u6e90\u7801\u7684\u89d2\u5ea6\u53bb\u5206\u6790Node.js\u7684\u539f\u7406\uff0c\u5176\u4e2d\u90e8\u5206\u662fC\u3001C++\uff0c\u6240\u4ee5\u9700\u8981\u8bfb\u8005\u6709\u4e00\u5b9a\u7684C\u3001C++\u57fa\u7840\uff0c\u53e6\u5916\uff0c\u6709\u4e00\u5b9a\u7684\u64cd\u4f5c\u7cfb\u7edf\u3001\u8ba1\u7b97\u673a\u7f51\u7edc\u3001V8\u57fa\u7840\u4f1a\u66f4\u597d\u3002 \u9605\u8bfb\u5efa\u8bae \u00b6 \u5efa\u8bae\u9996\u5148\u9605\u8bfb\u524d\u9762\u51e0\u79cd\u57fa\u7840\u548c\u901a\u7528\u7684\u5185\u5bb9\uff0c\u7136\u540e\u518d\u9605\u8bfb\u5355\u4e2a\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6700\u540e\u6709\u5174\u8da3\u7684\u8bdd\uff0c\u518d\u9605\u8bfb\u5982\u4f55\u62d3\u5c55Node.js\u7ae0\u8282\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u6bd4\u8f83\u719f\u6089Node.js\uff0c\u53ea\u662f\u5bf9\u67d0\u4e2a\u6a21\u5757\u6216\u5185\u5bb9\u6bd4\u8f83\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u9605\u8bfb\u67d0\u4e2a\u7ae0\u8282\u3002\u521a\u5f00\u59cb\u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u9009\u53d6\u7684\u662fV10.x\u7684\u7248\u672c\uff0c\u540e\u6765Node.js\u5df2\u7ecf\u66f4\u65b0\u5230\u4e86V14\uff0c\u6240\u4ee5\u4e66\u4e2d\u7684\u4ee3\u7801\u6709\u7684\u662fV10\u6709\u7684\u662fV14\u7684\u3002Libuv\u662fV1.23\u3002\u53ef\u4ee5\u5230\u6211\u7684github\u4e0a\u83b7\u53d6\u3002 \u6e90\u7801\u9605\u8bfb\u5efa\u8bae \u00b6 Node.js\u7684\u6e90\u7801\u7531JS\u3001C++\u3001C\u7ec4\u6210\u3002 1 Libuv\u662fC\u8bed\u8a00\u7f16\u5199\u3002\u7406\u89e3Libuv\u9664\u4e86\u9700\u8981\u4e86\u89e3C\u8bed\u6cd5\u5916\uff0c\u66f4\u591a\u7684\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edf\u548c\u7f51\u7edc\u7684\u7406\u89e3\uff0c\u6709\u4e9b\u7ecf\u5178\u7684\u4e66\u7c4d\u53ef\u4ee5\u53c2\u8003\uff0c\u6bd4\u5982\u300aUnix\u7f51\u7edc\u7f16\u7a0b\u300b1,2\u4e24\u518c\uff0c\u300aLinux\u7cfb\u7edf\u7f16\u7a0b\u624b\u518c\u300b\u4e0a\u4e0b\u4e24\u518c\uff0c\u300aTCP/IP\u6743\u5a01\u6307\u5357\u300b\u7b49\u7b49\u3002\u8fd8\u6709Linux\u7684API\u6587\u6863\u4ee5\u53ca\u7f51\u4e0a\u4f18\u79c0\u7684\u6587\u7ae0\u90fd\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u3002 2 C++\u4e3b\u8981\u662f\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\u5bf9JS\u8fdb\u884c\u62d3\u5c55\uff0c\u4e5f\u6709\u4e00\u90e8\u5206\u529f\u80fd\u4f7f\u7528C++\u5b9e\u73b0\uff0c\u603b\u7684\u6765\u8bf4C++\u7684\u4f5c\u7528\u66f4\u591a\u662f\u80f6\u6c34\u5c42\uff0c\u5229\u7528V8\u4f5c\u4e3a\u6865\u6881\uff0c\u8fde\u63a5Libuv\u548cJS\u3002\u4e0d\u4f1aC++\uff0c\u4e5f\u4e0d\u5b8c\u5168\u5f71\u54cd\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u4f46\u662f\u4f1aC++\u4f1a\u66f4\u597d\u3002\u9605\u8bfbC++\u5c42\u4ee3\u7801\uff0c\u9664\u4e86\u8bed\u6cd5\u5916\uff0c\u8fd8\u9700\u8981\u5bf9V8\u7684\u6982\u5ff5\u548c\u4f7f\u7528\u6709\u4e00\u5b9a\u7684\u4e86\u89e3\u548c\u7406\u89e3\u3002 3 JS\u4ee3\u7801\u76f8\u4fe1\u5b66\u4e60Node.js\u7684\u540c\u5b66\u90fd\u6ca1\u4ec0\u4e48\u95ee\u9898\u3002 \u5176\u5b83\u8d44\u6e90 \u00b6 \u4e2a\u4eba\u535a\u5ba2 csdn https://blog.csdn.net/THEANARKH \u77e5\u4e4e https://www.zhihu.com/people/theanarkh github https://github.com/theanarkh \u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u6240\u7528\u5230\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u6240\u4f5c\u79ef\u7d2f\u548c\u8bb0\u5f55\u51e0\u4e4e\u90fd\u5728\u4e0a\u9762\u7684\u535a\u5ba2\u4e2d\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u95ee\u9898\u53ef\u4ee5\u5230 https://github.com/theanarkh/understand-nodejs \u63d0issue\u6216\u8005\u8054\u7cfb\u6211\u3002","title":"\u524d\u8a00"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_1","text":"\u6211\u5f88\u559c\u6b22JS\u8fd9\u95e8\u8bed\u8a00\uff0c\u611f\u89c9\u5b83\u548cC\u8bed\u8a00\u4e00\u6837\uff0c\u5728C\u8bed\u8a00\u91cc\uff0c\u5f88\u591a\u4e1c\u897f\u90fd\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\uff0c\u8ba9\u6211\u4eec\u53ef\u4ee5\u53d1\u6325\u65e0\u9650\u7684\u521b\u9020\u529b\u548c\u60f3\u8c61\u529b\u3002\u5728JS\u4e2d\uff0c\u867d\u7136\u5f88\u591a\u4e1c\u897f\u5728V8\u91cc\u5df2\u7ecf\u63d0\u4f9b\uff0c\u4f46\u662f\u7528JS\uff0c\u4f9d\u7136\u53ef\u4ee5\u521b\u9020\u5f88\u591a\u597d\u73a9\u7684\u4e1c\u897f\uff0c\u8fd8\u6709\u597d\u73a9\u7684\u5199\u6cd5\u3002\u53e6\u5916\uff0cJS\u5e94\u8be5\u6211\u89c1\u8fc7\u552f\u4e00\u7684\u4e00\u95e8\u6ca1\u6709\u5b9e\u73b0\u7f51\u7edc\u548c\u6587\u4ef6\u529f\u80fd\u7684\u8bed\u8a00\uff0c\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u80fd\u529b\uff0c\u5bf9\u4e8e\u7a0b\u5e8f\u5458\u6765\u8bf4\uff0c\u4e5f\u662f\u5f88\u6838\u5fc3\u5f88\u57fa\u7840\u7684\u77e5\u8bc6\u3002\u5f88\u5e78\u8fd0\uff0cNode.js\u88ab\u521b\u9020\u51fa\u6765\u4e86\uff0cNode.js\u5728JS\u7684\u57fa\u7840\u4e0a\uff0c\u4f7f\u7528V8\u548cLibuv\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u3001\u4e30\u5bcc\u4e86JS\u7684\u80fd\u529b\uff0c\u5c24\u5176\u662f\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u8fd9\u6837\u6211\u5c31\u4e0d\u4ec5\u53ef\u4ee5\u4f7f\u7528JS\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7f51\u7edc\u3001\u6587\u4ef6\u7b49\u529f\u80fd\uff0c\u8fd9\u662f\u6211\u9010\u6e10\u8f6c\u5411Node.js\u65b9\u5411\u7684\u539f\u56e0\u4e4b\u4e00\uff0c\u4e5f\u662f\u6211\u5f00\u59cb\u7814\u7a76Node.js\u6e90\u7801\u7684\u539f\u56e0\u4e4b\u4e00\u3002\u867d\u7136Node.js\u6ee1\u8db3\u4e86\u6211\u559c\u597d\u548c\u6280\u672f\u4e0a\u7684\u9700\u6c42\uff0c\u4e0d\u8fc7\u4e00\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u6211\u5e76\u6ca1\u6709\u5168\u8eab\u5fc3\u5730\u6295\u5165\u4ee3\u7801\u7684\u7814\u7a76\uff0c\u53ea\u662f\u5076\u5c14\u4f1a\u770b\u4e00\u4e0b\u67d0\u4e9b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u771f\u6b63\u7684\u5f00\u59cb\uff0c\u662f\u4e3a\u4e86\u505a\u300aNode.js\u662f\u5982\u4f55\u5229\u7528Libuv\u5b9e\u73b0\u4e8b\u4ef6\u5faa\u73af\u548c\u5f02\u6b65\u300b\u7684\u5206\u4eab\uff0c\u4ece\u90a3\u65f6\u5019\u8d77\uff0c\u5927\u90e8\u5206\u4e1a\u4f59\u65f6\u95f4\u548c\u7cbe\u529b\u90fd\u6295\u5165\u6e90\u7801\u7684\u7814\u7a76\u3002 \u6211\u9996\u5148\u4eceLibuv\u5f00\u59cb\u7814\u7a76\uff0c\u56e0\u4e3aLibuv\u662fNode.js\u7684\u6838\u5fc3\u4e4b\u4e00\u3002\u7531\u4e8e\u66fe\u7ecf\u7814\u7a76\u8fc7\u4e00\u4e9bLinux\u7684\u6e90\u7801\uff0c\u4e5f\u4e00\u76f4\u5728\u5b66\u4e60\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u539f\u7406\u548c\u5b9e\u73b0\uff0c\u6240\u4ee5\u5728\u9605\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u7b97\u662f\u6ca1\u6709\u9047\u5230\u592a\u5927\u7684\u56f0\u96be\uff0cC\u8bed\u8a00\u51fd\u6570\u7684\u4f7f\u7528\u548c\u539f\u7406\uff0c\u57fa\u672c\u90fd\u53ef\u4ee5\u770b\u660e\u767d\uff0c\u91cd\u70b9\u5728\u4e8e\u9700\u8981\u628a\u5404\u4e2a\u903b\u8f91\u634b\u6e05\u695a\u3002\u6211\u4f7f\u7528\u7684\u65b9\u6cd5\u5c31\u662f\u6ce8\u91ca\u548c\u753b\u56fe\uff0c\u6211\u4e2a\u4eba\u6bd4\u8f83\u559c\u6b22\u5199\u6ce8\u91ca\u3002\u867d\u7136\u8bf4\u4ee3\u7801\u662f\u6700\u597d\u7684\u6ce8\u91ca\uff0c\u4f46\u662f\u6211\u8fd8\u662f\u613f\u610f\u82b1\u65f6\u95f4\u7528\u6ce8\u91ca\u53bb\u628a\u4ee3\u7801\u7684\u80cc\u666f\u548c\u610f\u4e49\u9610\u8ff0\u4e00\u4e0b\uff0c\u800c\u4e14\u6ce8\u91ca\u4f1a\u8ba9\u5927\u90e8\u5206\u4eba\u66f4\u5feb\u5730\u80fd\u8bfb\u61c2\u4ee3\u7801\u7684\u542b\u4e49\u3002\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u4e5f\u7a7f\u63d2\u5730\u8bfb\u4e86\u4e00\u4e9bJS\u548cC++\u5c42\u7684\u4ee3\u7801\u3002\u6211\u9605\u8bfbNode.js\u6e90\u7801\u7684\u65b9\u5f0f\u662f\uff0c\u9009\u62e9\u4e00\u4e2a\u6a21\u5757\uff0c\u5782\u76f4\u5730\u4eceJS\u5c42\u5206\u6790\u5230C++\u5c42\uff0c\u7136\u540e\u5230Libuv\u5c42\u3002 \u8bfb\u5b8cLibuv\uff0c\u63a5\u4e0b\u6765\u8bfb\u7684\u662fJS\u5c42\u7684\u4ee3\u7801\uff0cJS\u867d\u7136\u5bb9\u6613\u770b\u61c2\uff0c\u4f46\u662fJS\u5c42\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u800c\u4e14\u6211\u611f\u89c9\u903b\u8f91\u4e0a\u4e5f\u975e\u5e38\u7ed5\uff0c\u6240\u4ee5\u81f3\u4eca\uff0c\u6211\u8fd8\u6709\u5f88\u591a\u6ca1\u6709\u7ec6\u8bfb\uff0c\u8fd9\u4e2a\u4f5c\u4e3a\u540e\u7eed\u7684\u8ba1\u5212\u3002Node.js\u4e2d\uff0cC++\u7b97\u662f\u80f6\u6c34\u5c42\uff0c\u5f88\u591a\u65f6\u5019\uff0c\u4e0d\u4f1aC++\uff0c\u5176\u5b9e\u4e5f\u4e0d\u5f71\u54cdNode.js\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u56e0\u4e3aC++\u5f88\u591a\u65f6\u5019\uff0c\u53ea\u662f\u4e00\u79cd\u900f\u4f20\u7684\u529f\u80fd\uff0c\u5b83\u628aJS\u5c42\u7684\u8bf7\u6c42\uff0c\u901a\u8fc7V8\uff0c\u4f20\u7ed9Libuv\uff0c\u7136\u540e\u518d\u53cd\u8fc7\u6765\uff0c\u6240\u4ee5C++\u5c42\u6211\u662f\u653e\u5230\u6700\u540e\u624d\u7ec6\u8bfb\u3002C++\u5c42\u6211\u89c9\u5f97\u662f\u6700\u96be\u7684\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u53c8\u4e0d\u5f97\u4e0d\u5f00\u59cb\u8bfbV8\u7684\u6e90\u7801\u4e86\uff0c\u7406\u89e3V8\u975e\u5e38\u96be\uff0c\u6211\u9009\u53d6\u7684\u51e0\u4e4e\u662f\u6700\u65e9\u7684\u7248\u672c0.1.5\uff0c\u7136\u540e\u7ed3\u54088.x\u7248\u672c\u3002\u901a\u8fc7\u65e9\u671f\u7248\u672c\uff0c\u5148\u5b66\u4e60V8\u7684\u5927\u6982\u539f\u7406\u548c\u4e00\u4e9b\u65e9\u671f\u5b9e\u73b0\u4e0a\u7684\u7ec6\u8282\u3002\u56e0\u4e3a\u540e\u7eed\u7684\u7248\u672c\u867d\u7136\u53d8\u5316\u5f88\u5927\uff0c\u4f46\u662f\u66f4\u591a\u53ea\u662f\u529f\u80fd\u7684\u589e\u5f3a\u548c\u4f18\u5316\uff0c\u6709\u5f88\u591a\u6838\u5fc3\u7684\u6982\u5ff5\u8fd8\u662f\u6ca1\u6709\u53d8\u5316\u7684\uff0c\u8fd9\u662f\u6211\u9009\u53d6\u65e9\u671f\u7248\u672c\u7684\u539f\u56e0\uff0c\u907f\u514d\u4e00\u5f00\u59cb\u5c31\u9677\u5165\u65e0\u7a77\u65e0\u5c3d\u7684\u4ee3\u7801\u4e2d\uff0c\u8ff7\u5931\u4e86\u65b9\u5411\uff0c\u5931\u53bb\u4e86\u52a8\u529b\u3002\u4f46\u662f\u54ea\u6015\u662f\u65e9\u671f\u7684\u7248\u672c\uff0c\u6709\u5f88\u591a\u5185\u5bb9\u4f9d\u7136\u975e\u5e38\u590d\u6742\uff0c\u7ed3\u5408\u65b0\u7248\u672c\u662f\u56e0\u4e3a\u6709\u4e9b\u529f\u80fd\u5728\u65e9\u671f\u7248\u672c\u91cc\u6ca1\u6709\u5b9e\u73b0\uff0c\u8fd9\u65f6\u5019\u8981\u660e\u767d\u5b83\u7684\u539f\u7406\uff0c\u5c31\u53ea\u80fd\u770b\u65b0\u7248\u7684\u4ee3\u7801\uff0c\u6709\u4e86\u65e9\u671f\u7248\u672c\u7684\u7ecf\u9a8c\uff0c\u9605\u8bfb\u65b0\u7248\u7684\u4ee3\u7801\u4e5f\u6709\u4e00\u5b9a\u7684\u597d\u5904\uff0c\u591a\u5c11\u4e5f\u77e5\u9053\u4e86\u4e00\u4e9b\u9605\u8bfb\u6280\u5de7\u3002 Node.js\u7684\u5927\u90e8\u5206\u4ee3\u7801\u90fd\u5728C++\u548cJS\u5c42\uff0c\u6240\u4ee5\u76ee\u524d\u4ecd\u7136\u662f\u5728\u4e0d\u65ad\u5730\u9605\u8bfb\u8fd9\u4e24\u5c42\u7684\u4ee3\u7801\u3002\u8fd8\u662f\u6309\u7167\u6a21\u5757\u5782\u76f4\u5206\u6790\u3002\u9605\u8bfbNode.js\u4ee3\u7801\uff0c\u8ba9\u6211\u66f4\u4e86\u89e3Node.js\u7684\u539f\u7406\uff0c\u4e5f\u66f4\u4e86\u89e3JS\u3002\u4e0d\u8fc7\u4ee3\u7801\u91cf\u975e\u5e38\u5927\uff0c\u9700\u8981\u6e90\u6e90\u4e0d\u65ad\u7684\u65f6\u95f4\u548c\u7cbe\u529b\u6295\u5165\u3002\u4f46\u662f\u505a\u6280\u672f\uff0c\u77e5\u5176\u7136\u77e5\u5176\u6240\u4ee5\u7136\u7684\u611f\u89c9\u662f\u975e\u5e38\u7f8e\u5999\u7684\uff0c\u4f60\u9760\u7740\u4e00\u95e8\u6280\u672f\u8c0b\u751f\uff0c\u5374\u5bf9\u5b83\u77e5\u4e4b\u751a\u5c11\uff0c\u8fd9\u79cd\u611f\u89c9\u5e76\u4e0d\u597d\u3002\u9605\u8bfb\u6e90\u7801\uff0c\u867d\u7136\u4e0d\u4f1a\u4e3a\u4f60\u5e26\u6765\u76f4\u63a5\u7684\u3001\u8fc5\u901f\u7684\u6536\u76ca\uff0c\u4f46\u662f\u6709\u51e0\u4e2a\u597d\u5904\u662f\u5fc5\u7136\u7684\u3002\u7b2c\u4e00\u662f\u5b83\u4f1a\u51b3\u5b9a\u4f60\u7684\u9ad8\u5ea6\uff0c\u7b2c\u4e8c\u4f60\u5199\u4ee3\u7801\u7684\u65f6\u5019\uff0c\u4f60\u770b\u5230\u7684\u4e0d\u518d\u662f\u4e00\u4e9b\u51b0\u51b7\u51b7\u3001\u65e0\u751f\u547d\u7684\u5b57\u7b26\u3002\u8fd9\u53ef\u80fd\u6709\u70b9\u5938\u5f20\uff0c\u4f46\u662f\u4f60\u4e86\u89e3\u4e86\u6280\u672f\u7684\u539f\u7406\uff0c\u4f60\u5728\u4f7f\u7528\u6280\u672f\u7684\u65f6\u5019\uff0c\u7684\u786e\u4f1a\u6709\u4e0d\u540c\u7684\u4f53\u9a8c\uff0c\u4f60\u7684\u601d\u7ef4\u4e5f\u4f1a\u6709\u4e86\u66f4\u591a\u7684\u53d8\u5316\u3002\u7b2c\u4e09\u662f\u63d0\u9ad8\u4e86\u4f60\u7684\u5b66\u4e60\u80fd\u529b\uff0c\u5f53\u4f60\u5bf9\u5e95\u5c42\u539f\u7406\u6709\u4e86\u66f4\u591a\u7684\u4e86\u89e3\u548c\u7406\u89e3\uff0c\u4f60\u5728\u5b66\u4e60\u5176\u5b83\u6280\u672f\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u66f4\u5feb\u5730\u5b66\u4f1a\uff0c\u6bd4\u5982\u4f60\u4e86\u89e3\u4e86epoll\u7684\u539f\u7406\uff0c\u90a3\u4f60\u770bNginx\u3001Redis\u3001Libuv\u7b49\u6e90\u7801\u7684\u65f6\u5019\uff0c\u5173\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u903b\u8f91\uff0c\u57fa\u672c\u4e0a\u5f88\u5feb\u5c31\u80fd\u770b\u61c2\u3002\u5f88\u9ad8\u5174\u6709\u8fd9\u4e9b\u7ecf\u5386\uff0c\u4e5f\u6295\u5165\u4e86\u5f88\u591a\u65f6\u95f4\u548c\u7ecf\u7cbe\u529b\uff0c\u5e0c\u671b\u4ee5\u540e\u5bf9Node.js\u6709\u66f4\u591a\u7684\u7406\u89e3\u548c\u4e86\u89e3\uff0c\u4e5f\u5e0c\u671b\u5728Node.js\u65b9\u5411\u6709\u66f4\u591a\u7684\u5b9e\u8df5\u3002","title":"\u524d\u8a00"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_2","text":"\u9605\u8bfbNode.js\u6e90\u7801\u7684\u521d\u8877\u662f\u8ba9\u81ea\u5df1\u6df1\u5165\u7406\u89e3Node.js\u7684\u539f\u7406\uff0c\u4f46\u662f\u6211\u53d1\u73b0\u6709\u5f88\u591a\u540c\u5b66\u5bf9Node.js\u539f\u7406\u4e5f\u975e\u5e38\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u4e1a\u4f59\u65f6\u95f4\u91cc\u4e5f\u4e00\u76f4\u5728\u5199\u4e00\u4e9b\u5173\u4e8eNode.js\u6e90\u7801\u5206\u6790\u7684\u6587\u7ae0\uff08\u57fa\u4e8eNode.js V10\u548cV14\uff09\uff0c\u6240\u4ee5\u5c31\u6253\u7b97\u628a\u8fd9\u4e9b\u5185\u5bb9\u6574\u7406\u6210\u4e00\u672c\u6709\u4f53\u7cfb\u7684\u4e66\uff0c\u8ba9\u611f\u5174\u8da3\u7684\u540c\u5b66\u80fd\u7cfb\u7edf\u5730\u53bb\u4e86\u89e3\u548c\u7406\u89e3Node.js\u7684\u539f\u7406\u3002\u4e0d\u8fc7\u6211\u66f4\u5e0c\u671b\u7684\u662f\uff0c\u8bfb\u8005\u4ece\u4e66\u4e2d\u4e0d\u4ec5\u5b66\u5230Node.js\u7684\u77e5\u8bc6\uff0c\u800c\u4e14\u4e5f\u5b66\u5230\u5982\u4f55\u9605\u8bfbNode.js\u6e90\u7801\uff0c\u53ef\u4ee5\u81ea\u5df1\u72ec\u7acb\u5b8c\u6210\u6e90\u7801\u7684\u7814\u7a76\u3002\u4e5f\u5e0c\u671b\u66f4\u591a\u540c\u5b66\u5206\u4eab\u81ea\u5df1\u7684\u5fc3\u5f97\u3002\u672c\u4e66\u4e0d\u662fNode.js\u7684\u5168\u90e8\uff0c\u4f46\u662f\u5c3d\u91cf\u53bb\u8bb2\u5f97\u66f4\u591a\uff0c\u6e90\u7801\u975e\u5e38\u591a\uff0c\u9519\u7efc\u590d\u6742\uff0c\u7406\u89e3\u4e0a\u53ef\u80fd\u6709\u4e0d\u5bf9\u4e4b\u5904\uff0c\u6b22\u8fce\u4ea4\u6d41\u3002\u56e0\u4e3a\u770b\u8fc7Linux\u65e9\u671f\u5185\u6838\uff080.11\u548c1.2.13\uff09\u548c\u65e9\u671fV8\uff080.1.5\uff09\u7684\u4e00\u4e9b\u5b9e\u73b0\uff0c\u6587\u7ae0\u4f1a\u5f15\u7528\u5176\u4e2d\u7684\u4e00\u4e9b\u4ee3\u7801\uff0c\u76ee\u7684\u5728\u4e8e\u8ba9\u8bfb\u8005\u53ef\u4ee5\u66f4\u4e86\u89e3\u4e00\u4e2a\u77e5\u8bc6\u70b9\u7684\u5927\u81f4\u5b9e\u73b0\u539f\u7406\uff0c\u5982\u679c\u8bfb\u8005\u6709\u5174\u8da3\uff0c\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u76f8\u5173\u4ee3\u7801\u3002","title":"\u672c\u4e66\u7684\u76ee\u7684"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_3","text":"\u672c\u4e66\u5171\u5206\u4e3a\u4e8c\u5341\u4e8c\u7ae0\uff0c\u8bb2\u89e3\u7684\u4ee3\u7801\u90fd\u662f\u57fa\u4e8eLinux\u7cfb\u7edf\u7684\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u7684\u7ec4\u6210\u548c\u6574\u4f53\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u53e6\u5916\u5206\u6790\u4e86Node.js\u542f\u52a8\u7684\u8fc7\u7a0b\uff0c\u6700\u540e\u4ecb\u7ecd\u4e86\u670d\u52a1\u5668\u67b6\u6784\u7684\u6f14\u53d8\u548cNode.js\u7684\u6240\u9009\u53d6\u7684\u67b6\u6784\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7684\u57fa\u7840\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u7684\u903b\u8f91\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4f1a\u7528\u5230\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u8fd9\u662fNode.js\u7684\u6838\u5fc3\u6240\u5728,\u672c\u7ae0\u5177\u4f53\u4ecb\u7ecd\u4e86\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6bcf\u4e2a\u9636\u6bb5\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\uff0cLibuv\u7ebf\u7a0b\u6c60\u5bf9Node.js\u6765\u8bf4\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0cNode.js\u4e2d\u5f88\u591a\u6a21\u5757\u90fd\u9700\u8981\u4f7f\u7528\u7ebf\u7a0b\u6c60\uff0c\u5305\u62eccrypto\u3001fs\u3001dns\u7b49\u3002\u5982\u679c\u6ca1\u6709\u7ebf\u7a0b\u6c60\uff0cNode.js\u7684\u529f\u80fd\u5c06\u4f1a\u5927\u6253\u6298\u6263\u3002\u540c\u65f6\u5206\u6790\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u3002\u540c\u6837\u9002\u5408\u5176\u5b83\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u6d41\u7684\u5b9e\u73b0\uff0c\u6d41\u5728Node.js\u6e90\u7801\u4e2d\u5f88\u591a\u5730\u65b9\u90fd\u7528\u5230\uff0c\u53ef\u4ee5\u8bf4\u662f\u975e\u5e38\u6838\u5fc3\u7684\u6982\u5ff5\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dC++\u5c42\u7684\u4e00\u4e9b\u91cd\u8981\u6a21\u5757\u548c\u901a\u7528\u903b\u8f91\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684\u4fe1\u53f7\u5904\u7406\u673a\u5236\uff0c\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684dns\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u5305\u62eccares\u7684\u4f7f\u7528\u548c\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dpipe\u6a21\u5757\uff08Unix\u57df\uff09\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\uff0cUnix\u57df\u662f\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u5b83\u89e3\u51b3\u4e86\u6ca1\u6709\u7ee7\u627f\u7684\u8fdb\u7a0b\u65e0\u6cd5\u901a\u4fe1\u7684\u95ee\u9898\u3002\u800c\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u6781\u5927\u5730\u589e\u5f3a\u4e86Node.js\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u5b9e\u73b0\u3002\u5b9a\u65f6\u5668\u662f\u5b9a\u65f6\u5904\u7406\u4efb\u52a1\u7684\u5229\u5668\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js setImmediate\u548cnextTick\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6587\u4ef6\u64cd\u4f5c\u662f\u6211\u4eec\u7ecf\u5e38\u4f1a\u7528\u5230\u7684\u529f\u80fd\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u8fdb\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u4f7f\u5f97Node.js\u53ef\u4ee5\u5229\u7528\u591a\u6838\u80fd\u529b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7ebf\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u548c\u591a\u7ebf\u7a0b\u6709\u7c7b\u4f3c\u7684\u529f\u80fd\u4f46\u662f\u4e5f\u6709\u4e00\u4e9b\u5dee\u5f02\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2dcluster\u6a21\u5757\u7684\u4f7f\u7528\u548c\u5b9e\u73b0\u539f\u7406\uff0ccluster\u6a21\u5757\u5c01\u88c5\u4e86\u591a\u8fdb\u7a0b\u80fd\u529b\uff0c\u4f7f\u5f97Node.j\u662f\u53ef\u4ee5\u4f7f\u7528\u591a\u8fdb\u7a0b\u7684\u670d\u52a1\u5668\u67b6\u6784\uff0c\u5229\u7528\u4e86\u591a\u6838\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dUDP\u7684\u5b9e\u73b0\u548c\u76f8\u5173\u5185\u5bb9\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dTCP\u6a21\u5757\u7684\u5b9e\u73b0\uff0cTCP\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\uff0c\u6211\u4eec\u5e38\u7528\u7684HTTP\uff0cHTTPS\u90fd\u662f\u57fa\u4e8enet\u6a21\u5757\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86HTTP\u6a21\u5757\u7684\u5b9e\u73b0\u4ee5\u53caHTTP\u534f\u8bae\u7684\u4e00\u4e9b\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5404\u79cd\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\uff0c\u6df1\u5165\u7406\u89e3Node.js\u7684require\u51fd\u6570\u6240\u505a\u7684\u4e8b\u60c5\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86\u4e00\u4e9b\u62d3\u5c55Node.js\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528Node.js\uff0c\u62d3\u5c55Node.js\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86JS\u5c42Stream\u7684\u5b9e\u73b0\uff0cStream\u6a21\u5757\u7684\u903b\u8f91\u5f88\u7ed5\uff0c\u5927\u6982\u8bb2\u89e3\u4e86\u4e00\u4e0b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2devent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cevent\u6a21\u5757\u867d\u7136\u7b80\u5355\uff0c\u4f46\u662f\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\u3002","title":"\u672c\u4e66\u7ed3\u6784"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_4","text":"\u672c\u4e66\u9762\u5411\u6709\u4e00\u5b9aNode.js\u4f7f\u7528\u7ecf\u9a8c\u5e76\u5bf9Node.js\u539f\u7406\u611f\u5174\u8da3\u7684\u540c\u5b66\uff0c\u56e0\u4e3a\u672c\u4e66\u662fNode.js\u6e90\u7801\u7684\u89d2\u5ea6\u53bb\u5206\u6790Node.js\u7684\u539f\u7406\uff0c\u5176\u4e2d\u90e8\u5206\u662fC\u3001C++\uff0c\u6240\u4ee5\u9700\u8981\u8bfb\u8005\u6709\u4e00\u5b9a\u7684C\u3001C++\u57fa\u7840\uff0c\u53e6\u5916\uff0c\u6709\u4e00\u5b9a\u7684\u64cd\u4f5c\u7cfb\u7edf\u3001\u8ba1\u7b97\u673a\u7f51\u7edc\u3001V8\u57fa\u7840\u4f1a\u66f4\u597d\u3002","title":"\u9762\u5bf9\u7684\u8bfb\u8005"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_5","text":"\u5efa\u8bae\u9996\u5148\u9605\u8bfb\u524d\u9762\u51e0\u79cd\u57fa\u7840\u548c\u901a\u7528\u7684\u5185\u5bb9\uff0c\u7136\u540e\u518d\u9605\u8bfb\u5355\u4e2a\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6700\u540e\u6709\u5174\u8da3\u7684\u8bdd\uff0c\u518d\u9605\u8bfb\u5982\u4f55\u62d3\u5c55Node.js\u7ae0\u8282\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u6bd4\u8f83\u719f\u6089Node.js\uff0c\u53ea\u662f\u5bf9\u67d0\u4e2a\u6a21\u5757\u6216\u5185\u5bb9\u6bd4\u8f83\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u9605\u8bfb\u67d0\u4e2a\u7ae0\u8282\u3002\u521a\u5f00\u59cb\u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u9009\u53d6\u7684\u662fV10.x\u7684\u7248\u672c\uff0c\u540e\u6765Node.js\u5df2\u7ecf\u66f4\u65b0\u5230\u4e86V14\uff0c\u6240\u4ee5\u4e66\u4e2d\u7684\u4ee3\u7801\u6709\u7684\u662fV10\u6709\u7684\u662fV14\u7684\u3002Libuv\u662fV1.23\u3002\u53ef\u4ee5\u5230\u6211\u7684github\u4e0a\u83b7\u53d6\u3002","title":"\u9605\u8bfb\u5efa\u8bae"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_6","text":"Node.js\u7684\u6e90\u7801\u7531JS\u3001C++\u3001C\u7ec4\u6210\u3002 1 Libuv\u662fC\u8bed\u8a00\u7f16\u5199\u3002\u7406\u89e3Libuv\u9664\u4e86\u9700\u8981\u4e86\u89e3C\u8bed\u6cd5\u5916\uff0c\u66f4\u591a\u7684\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edf\u548c\u7f51\u7edc\u7684\u7406\u89e3\uff0c\u6709\u4e9b\u7ecf\u5178\u7684\u4e66\u7c4d\u53ef\u4ee5\u53c2\u8003\uff0c\u6bd4\u5982\u300aUnix\u7f51\u7edc\u7f16\u7a0b\u300b1,2\u4e24\u518c\uff0c\u300aLinux\u7cfb\u7edf\u7f16\u7a0b\u624b\u518c\u300b\u4e0a\u4e0b\u4e24\u518c\uff0c\u300aTCP/IP\u6743\u5a01\u6307\u5357\u300b\u7b49\u7b49\u3002\u8fd8\u6709Linux\u7684API\u6587\u6863\u4ee5\u53ca\u7f51\u4e0a\u4f18\u79c0\u7684\u6587\u7ae0\u90fd\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u3002 2 C++\u4e3b\u8981\u662f\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\u5bf9JS\u8fdb\u884c\u62d3\u5c55\uff0c\u4e5f\u6709\u4e00\u90e8\u5206\u529f\u80fd\u4f7f\u7528C++\u5b9e\u73b0\uff0c\u603b\u7684\u6765\u8bf4C++\u7684\u4f5c\u7528\u66f4\u591a\u662f\u80f6\u6c34\u5c42\uff0c\u5229\u7528V8\u4f5c\u4e3a\u6865\u6881\uff0c\u8fde\u63a5Libuv\u548cJS\u3002\u4e0d\u4f1aC++\uff0c\u4e5f\u4e0d\u5b8c\u5168\u5f71\u54cd\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u4f46\u662f\u4f1aC++\u4f1a\u66f4\u597d\u3002\u9605\u8bfbC++\u5c42\u4ee3\u7801\uff0c\u9664\u4e86\u8bed\u6cd5\u5916\uff0c\u8fd8\u9700\u8981\u5bf9V8\u7684\u6982\u5ff5\u548c\u4f7f\u7528\u6709\u4e00\u5b9a\u7684\u4e86\u89e3\u548c\u7406\u89e3\u3002 3 JS\u4ee3\u7801\u76f8\u4fe1\u5b66\u4e60Node.js\u7684\u540c\u5b66\u90fd\u6ca1\u4ec0\u4e48\u95ee\u9898\u3002","title":"\u6e90\u7801\u9605\u8bfb\u5efa\u8bae"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_7","text":"\u4e2a\u4eba\u535a\u5ba2 csdn https://blog.csdn.net/THEANARKH \u77e5\u4e4e https://www.zhihu.com/people/theanarkh github https://github.com/theanarkh \u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u6240\u7528\u5230\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u6240\u4f5c\u79ef\u7d2f\u548c\u8bb0\u5f55\u51e0\u4e4e\u90fd\u5728\u4e0a\u9762\u7684\u535a\u5ba2\u4e2d\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u95ee\u9898\u53ef\u4ee5\u5230 https://github.com/theanarkh/understand-nodejs \u63d0issue\u6216\u8005\u8054\u7cfb\u6211\u3002","title":"\u5176\u5b83\u8d44\u6e90"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/","text":"\u7b2c\u4e00\u7ae0 Node.js\u7ec4\u6210\u548c\u539f\u7406 \u00b6 1.1 Node.js\u7b80\u4ecb \u00b6 Node.js\u662f\u57fa\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u5355\u8fdb\u7a0b\u5355\u7ebf\u7a0b\u5e94\u7528\uff0c\u5355\u7ebf\u7a0b\u5177\u4f53\u4f53\u73b0\u5728Node.js\u5728\u5355\u4e2a\u7ebf\u7a0b\u4e2d\u7ef4\u62a4\u4e86\u4e00\u7cfb\u5217\u4efb\u52a1\uff0c\u7136\u540e\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u4e0d\u65ad\u6d88\u8d39\u4efb\u52a1\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u53c8\u4e0d\u65ad\u4ea7\u751f\u65b0\u7684\u4efb\u52a1\uff0c\u5728\u4efb\u52a1\u7684\u4ea7\u751f\u548c\u6d88\u8d39\u4e2d\u4e0d\u65ad\u9a71\u52a8\u7740Node.js\u7684\u6267\u884c\u3002\u4ece\u53e6\u5916\u4e00\u4e2a\u89d2\u5ea6\u6765\u8bf4\uff0cNode.js\u53c8\u53ef\u4ee5\u8bf4\u662f\u591a\u7ebf\u7a0b\u7684\uff0c\u56e0\u4e3aNode.js\u5e95\u5c42\u4e5f\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8be5\u7ebf\u7a0b\u6c60\u4e3b\u8981\u7528\u4e8e\u5904\u7406\u4e00\u4e9b\u6587\u4ef6IO\u3001DNS\u3001CPU\u8ba1\u7b97\u7b49\u4efb\u52a1\u3002 Node.js\u4e3b\u8981\u7531V8\u3001Libuv\uff0c\u8fd8\u6709\u4e00\u4e9b\u5176\u5b83\u7684\u7b2c\u4e09\u65b9\u6a21\u5757\u7ec4\u6210\uff08cares\u5f02\u6b65DNS\u89e3\u6790\u5e93\u3001HTTP\u89e3\u6790\u5668\u3001HTTP2\u89e3\u6790\u5668\uff0c\u538b\u7f29\u5e93\u3001\u52a0\u89e3\u5bc6\u5e93\u7b49\uff09\u3002Node.js\u6e90\u7801\u5206\u4e3a\u4e09\u5c42\uff0c\u5206\u522b\u662fJS\u3001C++\u3001C\uff0cLibuv\u662f\u4f7f\u7528C\u8bed\u8a00\u7f16\u5199\uff0cC++\u5c42\u4e3b\u8981\u662f\u901a\u8fc7V8\u4e3aJS\u5c42\u63d0\u4f9b\u548c\u5e95\u5c42\u4ea4\u4e92\u7684\u80fd\u529b\uff0cC++\u5c42\u4e5f\u5b9e\u73b0\u4e86\u90e8\u5206\u529f\u80fd\uff0cJS\u5c42\u662f\u9762\u5411\u7528\u6237\u7684\uff0c\u4e3a\u7528\u6237\u63d0\u4f9b\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u3002 1.1.1 JS\u5f15\u64ceV8 \u00b6 Node.js\u662f\u57fa\u4e8eV8\u7684JS\u8fd0\u884c\u65f6\uff0c\u5b83\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u4e86JS\u7684\u80fd\u529b\u3002\u8fd9\u79cd\u62d3\u5c55\u4e0d\u662f\u4e3aJS\u589e\u52a0\u4e86\u65b0\u7684\u8bed\u8a00\u7279\u6027\uff0c\u800c\u662f\u62d3\u5c55\u4e86\u529f\u80fd\u6a21\u5757\uff0c\u6bd4\u5982\u5728\u524d\u7aef\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528Date\u8fd9\u4e2a\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528TCP\u8fd9\u4e2a\u51fd\u6570\uff0c\u56e0\u4e3aJS\u4e2d\u5e76\u6ca1\u6709\u5185\u7f6e\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528TCP\uff0c\u8fd9\u5c31\u662fNode.js\u505a\u7684\u4e8b\u60c5\uff0c\u8ba9\u7528\u6237\u53ef\u4ee5\u4f7f\u7528JS\u4e2d\u672c\u6765\u4e0d\u5b58\u5728\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6587\u4ef6\u3001\u7f51\u7edc\u3002Node.js\u4e2d\u6700\u6838\u5fc3\u7684\u90e8\u5206\u662fLibuv\u548cV8\uff0cV8\u4e0d\u4ec5\u8d1f\u8d23\u6267\u884cJS\uff0c\u8fd8\u652f\u6301\u81ea\u5b9a\u4e49\u7684\u62d3\u5c55\uff0c\u5b9e\u73b0\u4e86JS\u8c03\u7528C++\u548cC++\u8c03\u7528JS\u7684\u80fd\u529b\u3002\u6bd4\u5982\u6211\u4eec\u53ef\u4ee5\u5199\u4e00\u4e2aC++\u6a21\u5757\uff0c\u7136\u540e\u5728JS\u8c03\u7528\uff0cNode.js\u6b63\u662f\u5229\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\uff0c\u5b8c\u6210\u4e86\u529f\u80fd\u7684\u62d3\u5c55\u3002JS\u5c42\u8c03\u7528\u7684\u6240\u6709C\u3001C++\u6a21\u5757\u90fd\u662f\u901a\u8fc7V8\u6765\u5b8c\u6210\u7684\u3002 1.1.2 Libuv \u00b6 Libuv\u662fNode.js\u5e95\u5c42\u7684\u5f02\u6b65IO\u5e93\uff0c\u4f46\u5b83\u63d0\u4f9b\u7684\u529f\u80fd\u4e0d\u4ec5\u4ec5\u662fIO\uff0c\u8fd8\u5305\u62ec\u8fdb\u7a0b\u3001\u7ebf\u7a0b\u3001\u4fe1\u53f7\u3001\u5b9a\u65f6\u5668\u3001\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7b49\uff0c\u800c\u4e14Libuv\u62b9\u5e73\u4e86\u5404\u4e2a\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u95f4\u7684\u5dee\u5f02\u3002Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u5927\u6982\u5982\u4e0b \u2022 Full-featured event loop backed by epoll, kqueue, IOCP, event ports. \u2022 Asynchronous TCP and UDP sockets \u2022 Asynchronous DNS resolution \u2022 Asynchronous file and file system operations \u2022 File system events \u2022 ANSI escape code controlled TTY \u2022 IPC with socket sharing, using Unix domain sockets or named pipes (Windows) \u2022 Child processes \u2022 Thread pool \u2022 Signal handling \u2022 High resolution clock \u2022 Threading and synchronization primitives Libuv\u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u7ecf\u5178\u7684\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\u3002Libuv\u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2d\uff0c\u6bcf\u4e00\u8f6e\u5faa\u73af\u90fd\u4f1a\u5904\u7406\u6bcf\u4e2a\u9636\u6bb5\uff08phase\uff09\u7ef4\u62a4\u7684\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u4efb\u52a1\u961f\u5217\u4e2d\u8282\u70b9\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u4e2d\uff0c\u4e0d\u65ad\u751f\u4ea7\u65b0\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u3002\u4e0b\u662fLibuv\u7684\u6574\u4f53\u6267\u884c\u6d41\u7a0b \u4ece\u4e0a\u56fe\u4e2d\u6211\u4eec\u5927\u81f4\u4e86\u89e3\u5230\uff0cLibuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u7136\u540e\u5728\u4e00\u4e2a\u5faa\u73af\u91cc\u4e0d\u65ad\u6267\u884c\u6bcf\u4e2a\u9636\u6bb5\u91cc\u7684\u4efb\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u770b\u4e00\u4e0b\u6bcf\u4e2a\u9636\u6bb5 \u66f4\u65b0\u5f53\u524d\u65f6\u95f4\uff0c\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u5230\u53d8\u91cf\u4e2d\uff0c\u8fd9\u4e00\u8f6e\u5faa\u73af\u7684\u5269\u4e0b\u64cd\u4f5c\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e2a\u53d8\u91cf\u83b7\u53d6\u5f53\u524d\u65f6\u95f4\uff0c\u907f\u514d\u8fc7\u591a\u7684\u7cfb\u7edf\u8c03\u7528\u5f71\u54cd\u6027\u80fd\uff0c\u989d\u5916\u7684\u5f71\u54cd\u5c31\u662f\u65f6\u95f4\u4e0d\u662f\u90a3\u4e48\u7cbe\u786e\u3002\u4f46\u662f\u5728\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0cLibuv\u5728\u5fc5\u8981\u7684\u65f6\u5019\uff0c\u4f1a\u4e3b\u52a8\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u6bd4\u5982\u5728epoll\u4e2d\u963b\u585e\u4e86timeout\u65f6\u95f4\u540e\u8fd4\u56de\u65f6\uff0c\u4f1a\u518d\u6b21\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u53d8\u91cf\u3002 \u5982\u679c\u4e8b\u4ef6\u5faa\u73af\u662f\u5904\u4e8ealive\u72b6\u6001\uff0c\u5219\u5f00\u59cb\u5904\u7406\u4e8b\u4ef6\u5faa\u73af\u7684\u6bcf\u4e2a\u9636\u6bb5\uff0c\u5426\u5219\u9000\u51fa\u8fd9\u4e2a\u4e8b\u4ef6\u5faa\u73af\u3002alive\u72b6\u6001\u662f\u4ec0\u4e48\u610f\u601d\u5462\uff1f\u5982\u679c\u6709active\u548cref\u72b6\u6001\u7684handle\uff0cactive\u72b6\u6001\u7684request\u6216\u8005closing\u72b6\u6001\u7684handle\u5219\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662falive\uff08\u5177\u4f53\u7684\u540e\u7eed\u4f1a\u8bb2\u5230\uff09\u3002 timer\u9636\u6bb5\uff1a\u5224\u65ad\u6700\u5c0f\u5806\u4e2d\u7684\u8282\u70b9\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 pending\u9636\u6bb5\uff1a\u6267\u884cpending\u56de\u8c03\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u6240\u6709\u7684IO\u56de\u8c03\uff08\u7f51\u7edc\uff0c\u6587\u4ef6\uff0cDNS\uff09\u90fd\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\uff0c\u4f46\u662f\u6709\u7684\u60c5\u51b5\u4e0b\uff0cPoll IO\u9636\u6bb5\u7684\u56de\u8c03\u4f1a\u5ef6\u8fdf\u5230\u4e0b\u4e00\u6b21\u5faa\u73af\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u79cd\u56de\u8c03\u5c31\u662f\u5728pending\u9636\u6bb5\u6267\u884c\u7684\uff0c\u6bd4\u5982IO\u56de\u8c03\u91cc\u51fa\u73b0\u4e86\u9519\u8bef\u6216\u5199\u6570\u636e\u6210\u529f\u7b49\u7b49\u90fd\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 idle\u9636\u6bb5\uff1a\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u90fd\u4f1a\u88ab\u6267\u884c\uff08idle\u4e0d\u662f\u8bf4\u4e8b\u4ef6\u5faa\u73af\u7a7a\u95f2\u7684\u65f6\u5019\u624d\u6267\u884c\uff09\u3002 prepare\u9636\u6bb5\uff1a\u548cidle\u9636\u6bb5\u7c7b\u4f3c\u3002 Poll IO\u9636\u6bb5\uff1a\u8c03\u7528\u5404\u5e73\u53f0\u63d0\u4f9b\u7684IO\u591a\u8def\u590d\u7528\u63a5\u53e3\uff08\u6bd4\u5982Linux\u4e0b\u5c31\u662fepoll\u6a21\u5f0f\uff09\uff0c\u6700\u591a\u7b49\u5f85timeout\u65f6\u95f4\uff0c\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002timeout\u7684\u8ba1\u7b97\u89c4\u5219\uff1a 1 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u662f\u4ee5UV_RUN_NOWAIT\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219timeout\u662f0\u3002 2 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u5373\u5c06\u9000\u51fa\uff08\u8c03\u7528\u4e86uv_stop\uff09\uff0c\u5219timeout\u662f0\u3002 3 \u5982\u679c\u6ca1\u6709active\u72b6\u6001\u7684handle\u6216\u8005request\uff0ctimeout\u662f0\u3002 4 \u5982\u679c\u6709idle\u9636\u6bb5\u7684\u961f\u5217\u91cc\u6709\u8282\u70b9\uff0c\u5219timeout\u662f0\u3002 5 \u5982\u679c\u6709handle\u7b49\u5f85\u88ab\u5173\u95ed\u7684\uff08\u5373\u8c03\u4e86uv_close\uff09\uff0ctimeout\u662f0\u3002 6 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\uff0c\u5219\u53d6timer\u9636\u6bb5\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u4f5c\u4e3atimeout\u3002 7 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\u5219timeout\u7b49\u4e8e-1\uff0c\u5373\u4e00\u76f4\u963b\u585e\uff0c\u76f4\u5230\u6ee1\u8db3\u6761\u4ef6\u3002 check\u9636\u6bb5\uff1a\u548cidle\u3001prepare\u4e00\u6837\u3002 closing\u9636\u6bb5\uff1a\u6267\u884c\u8c03\u7528uv_close\u51fd\u6570\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002 \u5982\u679cLibuv\u662f\u4ee5UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u90a3\u4e8b\u4ef6\u5faa\u73af\u5373\u5c06\u9000\u51fa\u3002\u4f46\u662f\u6709\u4e00\u79cd\u60c5\u51b5\u662f\uff0cPoll IO\u9636\u6bb5\u7684timeout\u7684\u503c\u662ftimer\u9636\u6bb5\u7684\u8282\u70b9\u7684\u503c\uff0c\u5e76\u4e14Poll IO\u9636\u6bb5\u662f\u56e0\u4e3a\u8d85\u65f6\u8fd4\u56de\u7684\uff0c\u5373\u6ca1\u6709\u4efb\u4f55\u4e8b\u4ef6\u53d1\u751f\uff0c\u4e5f\u6ca1\u6709\u6267\u884c\u4efb\u4f55IO\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u5728\u6267\u884c\u4e00\u6b21timer\u9636\u6bb5\u3002\u56e0\u4e3a\u6709\u8282\u70b9\u8d85\u65f6\u4e86\u3002 \u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\uff0c\u5982\u679cLibuv\u4ee5UV_RUN_NOWAIT \u6216 UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u679c\u662f\u4ee5UV_RUN_DEFAULT\u6a21\u5f0f\u8fd0\u884c\u7684\u5e76\u4e14\u72b6\u6001\u662falive\uff0c\u5219\u5f00\u59cb\u4e0b\u4e00\u8f6e\u5faa\u73af\u3002\u5426\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 \u4e0b\u9762\u6211\u80fd\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u6765\u4e86\u89e3libuv\u7684\u57fa\u672c\u539f\u7406\u3002 1. # include < stdio . h > 2. # include < uv . h > 3. 4. int64_t counter = 0 ; 5. 6. void wait_for_a_while ( uv_idle_t * handle ) { 7. counter ++ ; 8. if ( counter >= 10e6 ) 9. uv_idle_stop ( handle ); 10. } 11. 12. int main () { 13. uv_idle_t idler ; 14. // \u83b7\u53d6\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5e76\u521d\u59cb\u5316\u4e00\u4e2aidle 15. uv_idle_init ( uv_default_loop (), & idler ); 16. // \u5f80\u4e8b\u4ef6\u5faa\u73af\u7684idle\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1 17. uv_idle_start ( & idler , wait_for_a_while ); 18. // \u542f\u52a8\u4e8b\u4ef6\u5faa\u73af 19. uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); 20. // \u9500\u6bc1libuv\u7684\u76f8\u5173\u6570\u636e 21. uv_loop_close ( uv_default_loop ()); 22. return 0 ; 23. } \u4f7f\u7528Libuv\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u83b7\u53d6Libuv\u7684\u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_t\uff0cuv_loop_t\u662f\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u8bb0\u5f55\u4e86Libuv\u6574\u4e2a\u751f\u547d\u5468\u671f\u7684\u6570\u636e\u3002uv_default_loop\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u5df2\u7ecf\u521d\u59cb\u5316\u4e86\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5df1\u53bb\u5206\u914d\u4e00\u4e2a\uff0c\u81ea\u5df1\u521d\u59cb\u5316\u3002 1. uv_loop_t * uv_default_loop ( void ) { 2. // \u7f13\u5b58 3. if ( default_loop_ptr != NULL ) 4. return default_loop_ptr ; 5. 6. if ( uv_loop_init ( & default_loop_struct )) 7. return NULL ; 8. 9. default_loop_ptr = & default_loop_struct ; 10. return default_loop_ptr ; 11. } Libuv\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5168\u5c40\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528uv_loop_init\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u4e0d\u6253\u7b97\u5c55\u5f00\u8bb2\u89e3uv_loop_init\u51fd\u6570\uff0cw\u56e0\u4e3a\u5b83\u5927\u6982\u5c31\u662f\u5bf9uv_loop_t\u7ed3\u6784\u4f53\u5404\u4e2a\u5b57\u6bb5\u8fdb\u884c\u521d\u59cb\u5316\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0buv_idle_*\u7cfb\u5217\u7684\u51fd\u6570\u3002 1 uv_idle_init 1. int uv_idle_init ( uv_loop_t * loop , uv_idle_t * handle ) { 2. /* 3. \u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u6240\u5c5eloop\uff0c\u6253\u4e0aUV_HANDLE_REF\uff0c 4. \u5e76\u4e14\u628ahandle\u63d2\u5165loop->handle_queue\u961f\u5217\u7684\u961f\u5c3e 5. */ 6. uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_IDLE ); 7. handle -> idle_cb = NULL ; 8. return 0 ; 9. } \u6267\u884cuv_idle_init\u51fd\u6570\u540e\uff0cLibuv\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a 2 uv_idle_start 1. int uv_idle_start ( uv_idle_t * handle , uv_idle_cb cb ) { 2. // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de 3. if ( uv__is_active ( handle )) return 0 ; 4. // \u628ahandle\u63d2\u5165loop\u4e2didle\u7684\u961f\u5217 5. QUEUE_INSERT_HEAD ( & handle -> loop -> idle_handles , & handle -> queue ); 6. // \u6302\u8f7d\u56de\u8c03\uff0c\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684\u65f6\u5019\u88ab\u6267\u884c 7. handle -> idle_cb = cb ; 8. /* 9. \u8bbe\u7f6eUV_HANDLE_ACTIVE\u6807\u8bb0\u4f4d\uff0c\u5e76\u4e14loop\u4e2d\u7684handle\u6570\u52a0\u4e00\uff0c 10. init\u7684\u65f6\u5019\u53ea\u662f\u628ahandle\u6302\u8f7d\u5230loop\uff0cstart\u7684\u65f6\u5019handle\u624d 11. \u5904\u4e8e\u6fc0\u6d3b\u6001 12. */ 13. uv__handle_start ( handle ); 14. return 0 ; 15. } \u6267\u884c\u5b8cuv_idle_start\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u7136\u540e\u6267\u884cuv_run\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u3002 1. int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { 2. int timeout ; 3. int r ; 4. int ran_pending ; 5. // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop 6. r = uv__loop_alive ( loop ); 7. // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop 8. while ( r != 0 && loop -> stop_flag == 0 ) { 9. // \u5904\u7406idle\u961f\u5217 10. uv__run_idle ( loop ); 11. } 12. 13. // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag 14. if ( loop -> stop_flag != 0 ) 15. loop -> stop_flag = 0 ; 16. /* 17. \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c 18. \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run 19. */ 20. return r ; 21. } \u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2a\u51fd\u6570\u662fuv__run_idle\uff0c\u8fd9\u5c31\u662f\u5904\u7406idle\u9636\u6bb5\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1. // \u5728\u6bcf\u4e00\u8f6e\u5faa\u73af\u4e2d\u6267\u884c\u8be5\u51fd\u6570\uff0c\u6267\u884c\u65f6\u673a\u89c1uv_run 2. void uv__run_idle ( uv_loop_t * loop ) { 3. uv_idle_t * h ; 4. QUEUE queue ; 5. QUEUE * q ; 6. /* 7. \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c 8. \u53d8\u91cf\u56de\u8c03\u91cc\u4e0d\u65ad\u63d2\u5165\u65b0\u8282\u70b9\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af 9. */ 10. QUEUE_MOVE ( & loop -> idle_handles , & queue ); 11. // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 12. while ( ! QUEUE_EMPTY ( & queue )) { 13. // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9 14. q = QUEUE_HEAD ( & queue ); 15. // \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740 16. h = QUEUE_DATA ( q , uv_idle_t , queue ); 17. // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217\uff0c\u5426\u5219\u5faa\u73af\u4e0d\u4f1a\u7ed3\u675f 18. QUEUE_REMOVE ( q ); 19. // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 20. QUEUE_INSERT_TAIL ( & loop -> idle_handles , q ); 21. // \u6267\u884c\u56de\u8c03\u51fd\u6570 22. h -> idle_cb ( h ); 23. } 24. } \u6211\u4eec\u770b\u5230uv__run_idle\u7684\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5c31\u662f\u904d\u5386idle_handles\u961f\u5217\u7684\u8282\u70b9\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u63d2\u5165\u65b0\u7684\u8282\u70b9\uff08\u4ea7\u751f\u65b0\u4efb\u52a1\uff09\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u7684\u8fd0\u884c\u3002\u6211\u4eec\u770b\u5230uv_run\u9000\u51fa\u5faa\u73af\u7684\u6761\u4ef6\u4e0b\u9762\u7684\u4ee3\u7801\u4e3afalse\u3002 1. r != 0 && loop -> stop_flag == 0 stop_flag\u7531\u7528\u6237\u4e3b\u52a8\u5173\u95edLibuv\u4e8b\u4ef6\u5faa\u73af\u3002 1. void uv_stop ( uv_loop_t * loop ) { 2. loop -> stop_flag = 1 ; 3. } r\u662f\u4ee3\u8868\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u5b58\u6d3b\uff0c\u8fd9\u4e2a\u5224\u65ad\u7684\u6807\u51c6\u662f\u7531uv__loop_alive\u63d0\u4f9b 1. static int uv__loop_alive ( const uv_loop_t * loop ) { 2. return loop -> active_handles > 0 || 3. loop -> active_reqs . count > 0 || 4. loop -> closing_handles != NULL ; 5. } \u8fd9\u65f6\u5019\u6211\u4eec\u6709\u4e00\u4e2aactived handles\uff0c\u6240\u4ee5Libuv\u4e0d\u4f1a\u9000\u51fa\u3002\u5f53\u6211\u4eec\u8c03\u7528uv_idle_stop\u51fd\u6570\u628aidle\u8282\u70b9\u79fb\u51fahandle\u961f\u5217\u7684\u65f6\u5019\uff0cLibuv\u5c31\u4f1a\u9000\u51fa\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5177\u4f53\u5206\u6790Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u539f\u7406\u3002 1.1.3 \u5176\u5b83\u7b2c\u4e09\u65b9\u5e93 \u00b6 Node.js\u4e2d\u7b2c\u4e09\u65b9\u5e93\u5305\u62ec\u5f02\u6b65DNS\u89e3\u6790\uff08cares\uff09\u3001HTTP\u89e3\u6790\u5668\uff08\u65e7\u7248\u4f7f\u7528http_parser\uff0c\u65b0\u7248\u4f7f\u7528llhttp\uff09\u3001HTTP2\u89e3\u6790\u5668\uff08nghttp2\uff09\u3001\u89e3\u538b\u538b\u7f29\u5e93(zlib)\u3001\u52a0\u5bc6\u89e3\u5bc6\u5e93(openssl)\u7b49\u7b49\uff0c\u4e0d\u4e00\u4e00\u4ecb\u7ecd\u3002 1.2 Node.js\u5de5\u4f5c\u539f\u7406 \u00b6 1.2.1 Node.js\u662f\u5982\u4f55\u62d3\u5c55JS\u529f\u80fd\u7684\uff1f \u00b6 V8\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u8c03\u7528C++\u3001C\u8bed\u8a00\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\u3002Node.js\u6b63\u662f\u901a\u8fc7\u8fd9\u5957\u673a\u5236\uff0c\u5b9e\u73b0\u4e86\u5bf9JS\u80fd\u529b\u7684\u62d3\u5c55\u3002Node.js\u5728\u5e95\u5c42\u505a\u4e86\u5927\u91cf\u7684\u4e8b\u60c5\uff0c\u5b9e\u73b0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u7136\u540e\u5728JS\u5c42\u66b4\u9732\u63a5\u53e3\u7ed9\u7528\u6237\u4f7f\u7528\uff0c\u964d\u4f4e\u4e86\u7528\u6237\u6210\u672c\uff0c\u4e5f\u63d0\u9ad8\u4e86\u5f00\u53d1\u6548\u7387\u3002 1.2.2 \u5982\u4f55\u5728V8\u65b0\u589e\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u529f\u80fd\uff1f \u00b6 1. // C++\u91cc\u5b9a\u4e49 2. Handle < FunctionTemplate > Test = FunctionTemplate :: New ( cb ); 3. global -> Set ( String :: New ( \u201c Test \"), Test); 4. // JS\u91cc\u4f7f\u7528 5. const test = new Test (); \u6211\u4eec\u5148\u6709\u4e00\u4e2a\u611f\u6027\u7684\u8ba4\u8bc6\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u4f1a\u5177\u4f53\u8bb2\u89e3\u5982\u4f55\u4f7f\u7528V8\u62d3\u5c55JS\u7684\u529f\u80fd\u3002 1.2.3 Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u62d3\u5c55\u7684? \u00b6 Node.js\u5e76\u4e0d\u662f\u7ed9\u6bcf\u4e2a\u529f\u80fd\u90fd\u62d3\u5c55\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u6302\u8f7d\u5230\u5168\u5c40\u53d8\u91cf\u4e2d\uff0c\u800c\u662f\u62d3\u5c55\u4e00\u4e2aprocess\u5bf9\u8c61\uff0c\u518d\u901a\u8fc7process.binding\u62d3\u5c55js\u529f\u80fd\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5168\u5c40\u7684JS\u5bf9\u8c61process\uff0c\u6620\u5c04\u5230\u4e00\u4e2aC++\u5bf9\u8c61process\uff0c\u5e95\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2aC++\u6a21\u5757\u7684\u94fe\u8868\uff0cJS\u901a\u8fc7\u8c03\u7528JS\u5c42\u7684process.binding\uff0c\u8bbf\u95ee\u5230C++\u7684process\u5bf9\u8c61\uff0c\u4ece\u800c\u8bbf\u95eeC++\u6a21\u5757(\u7c7b\u4f3c\u8bbf\u95eeJS\u7684Object\u3001Date\u7b49)\u3002\u4e0d\u8fc7Node.js 14\u7248\u672c\u5df2\u7ecf\u6539\u6210internalBinding\u7684\u65b9\u5f0f\uff0c\u901a\u8fc7internalBinding\u5c31\u53ef\u4ee5\u8bbf\u95eeC++\u6a21\u5757\uff0c\u539f\u7406\u7c7b\u4f3c\u3002 1.3 Node.js\u542f\u52a8\u8fc7\u7a0b \u00b6 \u4e0b\u9762\u662fNode.js\u542f\u52a8\u7684\u4e3b\u6d41\u7a0b\u56fe\u5982\u56fe1-4\u6240\u793a\u3002 \u6211\u4eec\u4ece\u4e0a\u5f80\u4e0b\uff0c\u770b\u4e00\u4e0b\u6bcf\u4e2a\u8fc7\u7a0b\u90fd\u505a\u4e86\u4e9b\u4ec0\u4e48\u4e8b\u60c5\u3002 1.3.1 \u6ce8\u518cC++\u6a21\u5757 \u00b6 RegisterBuiltinModules\u51fd\u6570\uff08node_binding.cc\uff09\u7684\u4f5c\u7528\u662f\u6ce8\u518cC++\u6a21\u5757\u3002 1. void RegisterBuiltinModules () { 2. # define V ( modname ) _register_ ## modname (); 3. NODE_BUILTIN_MODULES ( V ) 4. # undef V 5. } NODE_BUILTIN_MODULES\u662f\u4e00\u4e2aC\u8bed\u8a00\u5b8f\uff0c\u5b8f\u5c55\u5f00\u540e\u5982\u4e0b\uff08\u7701\u7565\u7c7b\u4f3c\u903b\u8f91\uff09 1. void RegisterBuiltinModules () { 2. # define V ( modname ) _register_ ## modname (); 3. V ( tcp_wrap ) 4. V ( timers ) 5. ... \u5176\u5b83\u6a21\u5757 6. # undef V 7. } \u518d\u4e00\u6b65\u5c55\u5f00\u5982\u4e0b 1. void RegisterBuiltinModules () { 2. _register_tcp_wrap (); 3. _register_timers (); 4. } \u6267\u884c\u4e86\u4e00\u7cfb\u5217_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u5728Node.js\u6e90\u7801\u91cc\u627e\u4e0d\u5230\u8fd9\u4e9b\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u51fd\u6570\u662f\u5728\u6bcf\u4e2aC++\u6a21\u5757\u5b9a\u4e49\u7684\u6587\u4ef6\u91cc\uff08.cc\u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c\uff09\u901a\u8fc7\u5b8f\u5b9a\u4e49\u7684\u3002\u4ee5tcp_wrap\u6a21\u5757\u4e3a\u4f8b\uff0c\u770b\u770b\u5b83\u662f\u600e\u4e48\u505a\u7684\u3002\u6587\u4ef6tcp_wrap.cc\u7684\u6700\u540e\u4e00\u53e5\u4ee3\u7801 NODE_MODULE_CONTEXT_AWARE_INTERNAL(tcp_wrap, node::TCPWrap::Initialize) \u5b8f\u5c55\u5f00\u662f 1. # define NODE_MODULE_CONTEXT_AWARE_INTERNAL ( modname , regfunc ) \\ 2. NODE_MODULE_CONTEXT_AWARE_CPP ( modname , 3. regfunc , 4. nullptr , 5. NM_F_INTERNAL ) \u7ee7\u7eed\u5c55\u5f00 6. # define NODE_MODULE_CONTEXT_AWARE_CPP ( modname , regfunc , priv , flags \\ 7. static node :: node_module _module = { \\ 8. NODE_MODULE_VERSION , \\ 9. flags , \\ 10. nullptr , \\ 11. __FILE__ , \\ 12. nullptr , \\ 13. ( node :: addon_context_register_func )( regfunc ), \\ 14. NODE_STRINGIFY ( modname ), \\ 15. priv , \\ 16. nullptr }; \\ 17. void _register_tcp_wrap () { node_module_register ( & _module ); } \u6211\u4eec\u770b\u5230\u6bcf\u4e2aC++\u6a21\u5757\u5e95\u5c42\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u5728Node.js\u542f\u52a8\u65f6\uff0c\u5c31\u4f1a\u628a\u8fd9\u4e9b\u51fd\u6570\u9010\u4e2a\u6267\u884c\u4e00\u904d\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8fd9\u4e9b\u51fd\u6570\u90fd\u505a\u4e86\u4ec0\u4e48\uff0c\u5728\u8fd9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0bNode.js\u4e2d\u8868\u793aC++\u6a21\u5757\u7684\u6570\u636e\u7ed3\u6784\u3002 1. struct node_module { 2. int nm_version ; 3. unsigned int nm_flags ; 4. void * nm_dso_handle ; 5. const char * nm_filename ; 6. node :: addon_register_func nm_register_func ; 7. node :: addon_context_register_func nm_context_register_func ; 8. const char * nm_modname ; 9. void * nm_priv ; 10. struct node_module * nm_link ; 11. }; \u6211\u4eec\u770b\u5230_register\u5f00\u5934\u7684\u51fd\u6570\u8c03\u4e86node_module_register\uff0c\u5e76\u4f20\u5165\u4e00\u4e2anode_module\u6570\u636e\u7ed3\u6784\uff0c\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0bnode_module_register\u7684\u5b9e\u73b0 1. void node_module_register ( void * m ) { 2. struct node_module * mp = reinterpret_cast < struct node_module *> ( m ); 3. if ( mp -> nm_flags & NM_F_INTERNAL ) { 4. mp -> nm_link = modlist_internal ; 5. modlist_internal = mp ; 6. } else if ( ! node_is_initialized ) { 7. mp -> nm_flags = NM_F_LINKED ; 8. mp -> nm_link = modlist_linked ; 9. modlist_linked = mp ; 10. } else { 11. thread_local_modpending = mp ; 12. } 13. } C++\u5185\u7f6e\u6a21\u5757\u7684flag\u662fNM_F_INTERNAL\uff0c\u6240\u4ee5\u4f1a\u6267\u884c\u7b2c\u4e00\u4e2aif\u7684\u903b\u8f91\uff0cmodlist_internal\u7c7b\u4f3c\u4e00\u4e2a\u5934\u6307\u9488\u3002if\u91cc\u7684\u903b\u8f91\u5c31\u662f\u5934\u63d2\u6cd5\u5efa\u7acb\u4e00\u4e2a\u5355\u94fe\u8868\u3002C++\u5185\u7f6e\u6a21\u5757\u5728Node.js\u91cc\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u5f88\u591a\u529f\u80fd\u90fd\u4f1a\u8c03\u7528\uff0c\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002 1.3.2 \u521b\u5efaEnvironment\u5bf9\u8c61 \u00b6 1 CreateMainEnvironment Node.js\u4e2dEnvironment\u7c7b\uff08env.h\uff09\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7c7b\uff0cNode.js\u4e2d\uff0c\u5f88\u591a\u6570\u636e\u7531Environment\u5bf9\u8c61\u8fdb\u884c\u7ba1\u7406\u3002 1. context = NewContext ( isolate_ ); 2. std :: unique_ptr < Environment > env = std :: make_unique < Environment > ( 3. isolate_data_ . get (), 4. context , 5. args_ , 6. exec_args_ , 7. static_cast < Environment :: Flags > ( Environment :: kIsMainThread | 8. Environment :: kOwnsProcessState | Environment :: kOwnsInspector )); Isolate\uff0cContext\u662fV8\u4e2d\u7684\u6982\u5ff5\uff0cIsolate\u7528\u4e8e\u9694\u79bb\u5b9e\u4f8b\u95f4\u7684\u73af\u5883\uff0cContext\u7528\u4e8e\u63d0\u4f9bJS\u6267\u884c\u65f6\u7684\u4e0a\u4e0b\u6587\uff0ckIsMainThread\u8bf4\u660e\u5f53\u524d\u8fd0\u884c\u7684\u662f\u4e3b\u7ebf\u7a0b\uff0c\u7528\u4e8e\u533a\u5206Node.js\u4e2d\u7684worker_threads\u5b50\u7ebf\u7a0b\u3002Environment\u7c7b\u975e\u5e38\u5e9e\u5927\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u7684\u4ee3\u7801 1. Environment :: Environment ( IsolateData * isolate_data , 2. Local < Context > context , 3. const std :: vector < std :: string >& args , 4. const std :: vector < std :: string >& exec_args , 5. Flags flags , 6. uint64_t thread_id ) 7. : isolate_ ( context -> GetIsolate ()), 8. isolate_data_ ( isolate_data ), 9. immediate_info_ ( context -> GetIsolate ()), 10. tick_info_ ( context -> GetIsolate ()), 11. timer_base_ ( uv_now ( isolate_data -> event_loop ())), 12. exec_argv_ ( exec_args ), 13. argv_ ( args ), 14. exec_path_ ( GetExecPath ( args )), 15. should_abort_on_uncaught_toggle_ ( isolate_ , 1 ), 16. stream_base_state_ ( isolate_ , StreamBase :: kNumStreamBaseStateFields ), 17. flags_ ( flags ), 18. thread_id_ ( thread_id == kNoThreadId ? AllocateThreadId () : thread_id ), 19. fs_stats_field_array_ ( isolate_ , kFsStatsBufferLength ), 20. fs_stats_field_bigint_array_ ( isolate_ , kFsStatsBufferLength ), 21. context_ ( context -> GetIsolate (), context ) { 22. // \u8fdb\u5165\u5f53\u524d\u7684context 23. HandleScope handle_scope ( isolate ()); 24. Context :: Scope context_scope ( context ); 25. // \u4fdd\u5b58\u73af\u5883\u53d8\u91cf 26. set_env_vars ( per_process :: system_environment ); 27. // \u5173\u8054context\u548cenv 28. AssignToContext ( context , ContextInfo ( \"\" )); 29. // \u521b\u5efa\u5176\u5b83\u5bf9\u8c61 30. CreateProperties (); 31. } \u6211\u4eec\u53ea\u770b\u4e00\u4e0bAssignToContext\u548cCreateProperties\uff0cset_env_vars\u4f1a\u628a\u8fdb\u7a0b\u7ae0\u8282\u8bb2\u89e3\u3002 1.1 AssignToContext 1. inline void Environment :: AssignToContext ( v8 :: Local < v8 :: Context > context , 2. const ContextInfo & info ) { 3. // \u5728context\u4e2d\u4fdd\u5b58env\u5bf9\u8c61 4. context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kEnvironment , this ); 5. // Used by Environment::GetCurrent to know that we are on a node context. 6. context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kContextTag , Environment :: kNodeContextTagPtr ); 7. 8. } AssignToContext\u7528\u4e8e\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\u3002\u8fd9\u4e2a\u903b\u8f91\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u540e\u7eed\u6267\u884c\u4ee3\u7801\u65f6\uff0c\u6211\u4eec\u4f1a\u8fdb\u5165V8\u7684\u9886\u57df\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u77e5\u9053Isolate\u548ccontext\u3002\u5982\u679c\u4e0d\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\uff0c\u6211\u4eec\u5c31\u4e0d\u77e5\u9053\u5f53\u524d\u6240\u5c5e\u7684env\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u83b7\u53d6\u5bf9\u5e94\u7684env\u3002 1. inline Environment * Environment :: GetCurrent ( v8 :: Isolate * isolate ) { 2. v8 :: HandleScope handle_scope ( isolate ); 3. return GetCurrent ( isolate -> GetCurrentContext ()); 4. } 5. 6. inline Environment * Environment :: GetCurrent ( v8 :: Local < v8 :: Context > context ) { 7. return static_cast < Environment *> ( 8. context -> GetAlignedPointerFromEmbedderData ( ContextEmbedderIndex :: kEnvironment )); 9. } 1.2 CreateProperties \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bCreateProperties\u4e2d\u521b\u5efaprocess\u5bf9\u8c61\u7684\u903b\u8f91\u3002 1. Isolate * isolate = env -> isolate (); 2. EscapableHandleScope scope ( isolate ); 3. Local < Context > context = env -> context (); 4. // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 5. Local < FunctionTemplate > process_template = FunctionTemplate :: New ( isolate ); 6. process_template -> SetClassName ( env -> process_string ()); 7. // \u4fdd\u5b58\u51fd\u6570\u6a21\u677f\u751f\u6210\u7684\u51fd\u6570 8. Local < Function > process_ctor ; 9. // \u4fdd\u5b58\u51fd\u6570\u6a21\u5757\u751f\u6210\u7684\u51fd\u6570\u6240\u65b0\u5efa\u51fa\u6765\u7684\u5bf9\u8c61 10. Local < Object > process ; 11. if ( ! process_template -> GetFunction ( context ). ToLocal ( & process_ctor ) || ! process_ctor -> NewInstance ( context ). ToLocal ( & process )) { 12. return MaybeLocal < Object > (); 13. } process\u6240\u4fdd\u5b58\u7684\u5bf9\u8c61\u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u7528\u4f7f\u7528\u7684process\u5bf9\u8c61\u3002Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8fd8\u6302\u8f7d\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002 1. READONLY_PROPERTY ( process , 2. \"version\" , 3. FIXED_ONE_BYTE_STRING ( env -> isolate (), 4. NODE_VERSION )); 5. READONLY_STRING_PROPERTY ( process , \"arch\" , per_process :: metadata . arch );...... \u521b\u5efa\u5b8cprocess\u5bf9\u8c61\u540e\uff0cNode.js\u628aprocess\u4fdd\u5b58\u5230env\u4e2d\u3002 1. Local < Object > process_object = node :: CreateProcessObject ( this ). FromMaybe ( Local < Object > ()); 2. set_process_object ( process_object ) 1.3.3 \u521d\u59cb\u5316Libuv\u4efb\u52a1 \u00b6 InitializeLibuv\u51fd\u6570\u4e2d\u7684\u903b\u8f91\u662f\u5f80Libuv\u4e2d\u63d0\u4ea4\u4efb\u52a1 \u3002 1. void Environment :: InitializeLibuv ( bool start_profiler_idle_notifier ) { 2. HandleScope handle_scope ( isolate ()); 3. Context :: Scope context_scope ( context ()); 4. CHECK_EQ ( 0 , uv_timer_init ( event_loop (), timer_handle ())); 5. uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); 6. uv_check_init ( event_loop (), immediate_check_handle ()); 7. uv_unref ( reinterpret_cast < uv_handle_t *> ( immediate_check_handle ())); 8. uv_idle_init ( event_loop (), immediate_idle_handle ()); 9. uv_check_start ( immediate_check_handle (), CheckImmediate ); 10. uv_prepare_init ( event_loop (), & idle_prepare_handle_ ); 11. uv_check_init ( event_loop (), & idle_check_handle_ ); 12. uv_async_init ( 13. event_loop (), 14. & task_queues_async_ , 15. []( uv_async_t * async ) { 16. Environment * env = ContainerOf ( 17. & Environment :: task_queues_async_ , async ); 18. env -> CleanupFinalizationGroups (); 19. env -> RunAndClearNativeImmediates (); 20. }); 21. uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_prepare_handle_ )); 22. uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_check_handle_ )); 23. uv_unref ( reinterpret_cast < uv_handle_t *> ( & task_queues_async_ )); 24. // \u2026 25. } \u8fd9\u4e9b\u51fd\u6570\u90fd\u662fLibuv\u63d0\u4f9b\u7684\uff0c\u5206\u522b\u662f\u5f80Libuv\u4e0d\u540c\u9636\u6bb5\u63d2\u5165\u4efb\u52a1\u8282\u70b9\uff0cuv_unref\u662f\u4fee\u6539\u72b6\u6001\u3002 1 timer_handle\u662f\u5b9e\u73b0Node.js\u4e2d\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684time\u9636\u6bb5 2 immediate_check_handle\u662f\u5b9e\u73b0Node.js\u4e2dsetImmediate\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684check\u9636\u6bb5\u3002 3 task_queues_async_\u7528\u4e8e\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002 1.3.4 \u521d\u59cb\u5316Loader\u548c\u6267\u884c\u4e0a\u4e0b\u6587 \u00b6 RunBootstrapping\u91cc\u8c03\u7528\u4e86BootstrapInternalLoaders\u548cBootstrapNode\u51fd\u6570\uff0c\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002 1 \u521d\u59cb\u5316loader BootstrapInternalLoaders\u7528\u4e8e\u6267\u884cinternal/bootstrap/loaders.js\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u903b\u8f91\u3002\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u7528\u4e8e\u5b9a\u4e49\u51fd\u6570\u7684\u5f62\u53c2\u5217\u8868\uff0c\u4e00\u4f1a\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002 1. std :: vector < Local < String >> loaders_params = { 2. process_string (), 3. FIXED_ONE_BYTE_STRING ( isolate_ , \"getLinkedBinding\" ), 4. FIXED_ONE_BYTE_STRING ( isolate_ , \"getInternalBinding\" ), 5. primordials_string ()}; \u7136\u540e\u518d\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u7528\u4f5c\u6267\u884c\u51fd\u6570\u65f6\u7684\u5b9e\u53c2\u3002 1. std :: vector < Local < Value >> loaders_args = { 2. process_object (), 3. NewFunctionTemplate ( binding :: GetLinkedBinding ) 4. -> GetFunction ( context ()) 5. . ToLocalChecked (), 6. NewFunctionTemplate ( binding :: GetInternalBinding ) 7. -> GetFunction ( context ()) 8. . ToLocalChecked (), 9. primordials ()}; \u63a5\u7740Node.js\u7f16\u8bd1\u6267\u884cinternal/bootstrap/loaders.js\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u94fe\u8def\u975e\u5e38\u957f\uff0c\u6700\u540e\u5230V8\u5c42\uff0c\u5c31\u4e0d\u8d34\u51fa\u5177\u4f53\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u7684\u903b\u8f91\u8f6c\u6210JS\u5982\u4e0b\u3002 1. function demo ( process , 2. getLinkedBinding , 3. getInternalBinding , 4. primordials ) { 5. // internal/bootstrap/loaders.js \u7684\u4ee3\u7801 6. } 7. const process = {}; 8. function getLinkedBinding (){} 9. function getInternalBinding () {} 10. const primordials = {}; 11. const export = demo ( process , 12. getLinkedBinding , 13. getInternalBinding , 14. primordials ); V8\u628ainternal/bootstrap/loaders.js\u7528\u4e00\u4e2a\u51fd\u6570\u5305\u88f9\u8d77\u6765\uff0c\u5f62\u53c2\u5c31\u662floaders_params\u53d8\u91cf\u5bf9\u5e94\u7684\u56db\u4e2a\u5b57\u7b26\u4e32\u3002\u7136\u540e\u6267\u884c\u8fd9\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u4f20\u5165loaders_args\u91cc\u7684\u90a3\u56db\u4e2a\u5bf9\u8c61\u3002internal/bootstrap/loaders.js\u4f1a\u5bfc\u51fa\u4e00\u4e2a\u5bf9\u8c61\u3002\u5728\u770binternal/bootstrap/loaders.js\u4ee3\u7801\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0bgetLinkedBinding, getInternalBinding\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0cNode.js\u5728C++\u5c42\u5bf9\u5916\u66b4\u9732\u4e86AddLinkedBinding\u65b9\u6cd5\u6ce8\u518c\u6a21\u5757\uff0cNode.js\u9488\u5bf9\u8fd9\u79cd\u7c7b\u578b\u7684\u6a21\u5757\uff0c\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5355\u72ec\u7684\u94fe\u8868\u3002getLinkedBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\uff0c\u4f46\u662f\u6211\u4eec\u4e00\u822c\u7528\u4e0d\u5230\u8fd9\u4e2a\uff0c\u6240\u4ee5\u5c31\u4e0d\u6df1\u5165\u5206\u6790\u3002\u524d\u9762\u6211\u4eec\u770b\u5230\u5bf9\u4e8eC++\u5185\u7f6e\u6a21\u5757\uff0cNode.js\u540c\u6837\u7ef4\u62a4\u4e86\u4e00\u4e2a\u94fe\u8868\uff0cgetInternalBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5177\u4f53\u770b\u4e00\u4e0binternal/bootstrap/loaders.js\u7684\u4ee3\u7801\u4e86\u3002 1. let internalBinding ; 2. { 3. const bindingObj = ObjectCreate ( null ); 4. internalBinding = function internalBinding ( module ) { 5. let mod = bindingObj [ module ]; 6. if ( typeof mod !== ' object ' ) { 7. mod = bindingObj [ module ] = getInternalBinding ( module ); 8. moduleLoadList . push ( ` Internal Binding $ { module } ` ); 9. } 10. return mod ; 11. }; 12. } Node.js\u5728JS\u5bf9getInternalBinding\u8fdb\u884c\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u4e3b\u8981\u662f\u52a0\u4e86\u7f13\u5b58\u5904\u7406\u3002 1. const internalBindingWhitelist = new SafeSet ([, 2. ' tcp_wrap ' , 3. // \u4e00\u7cfb\u5217C++\u5185\u7f6e\u6a21\u5757\u540d 4. ]); 5. 6. { 7. const bindingObj = ObjectCreate ( null ); 8. process . binding = function binding ( module ) { 9. module = String ( module ); 10. if ( internalBindingWhitelist . has ( module )) { 11. return internalBinding ( module ); 12. } 13. throw new Error ( ` No such module : $ { module } ` ); 14. }; 15. } \u5728process\u5bf9\u8c61\uff08\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684process\u5bf9\u8c61\uff09\u4e2d\u6302\u8f7dbinding\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u4e3b\u8981\u7528\u4e8e\u5185\u7f6e\u7684JS\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u7ecf\u5e38\u770b\u5230\u3002binding\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684C++\u6a21\u5757\u3002\u4e0a\u9762\u7684\u5904\u7406\u662f\u4e3a\u4e86Node.js\u80fd\u5728JS\u5c42\u901a\u8fc7binding\u51fd\u6570\u52a0\u8f7dC++\u6a21\u5757\uff0c\u6211\u4eec\u77e5\u9053Node.js\u4e2d\u8fd8\u6709\u539f\u751f\u7684JS\u6a21\u5757\uff08lib\u6587\u4ef6\u5939\u4e0b\u7684JS\u6587\u4ef6\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\uff0c\u5bf9\u4e8e\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u5904\u7406\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2aNativeModule\u7c7b\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u3002\u8fd8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u53d8\u91cf\u4fdd\u5b58\u4e86\u539f\u751fJS\u6a21\u5757\u7684\u540d\u79f0\u5217\u8868\u3002 static map = new Map ( moduleIds . map (( id ) => [ id , new NativeModule ( id )])); NativeModule\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u539f\u751fJS\u6a21\u5757\u7684\u4ee3\u7801\u662f\u8f6c\u6210\u5b57\u7b26\u5b58\u5728node_javascript.cc\u6587\u4ef6\u7684\uff0cNativeModule\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\uff0c\u5373\u7f16\u8bd1\u548c\u6267\u884c\u3002 2 \u63d0\u4f9b\u4e00\u4e2arequire\u51fd\u6570\uff0c\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\uff0c\u5bf9\u4e8e\u6587\u4ef6\u8def\u5f84\u4ee5internal\u5f00\u5934\u7684\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u88ab\u7528\u6237require\u4f7f\u7528\u7684\u3002 \u8fd9\u662f\u539f\u751fJS\u6a21\u5757\u52a0\u8f7d\u7684\u5927\u6982\u903b\u8f91\uff0c\u5177\u4f53\u7684\u6211\u4eec\u5728Node.js\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u5177\u4f53\u5206\u6790\u3002\u6267\u884c\u5b8cinternal/bootstrap/loaders.js\uff0c\u6700\u540e\u8fd4\u56de\u4e09\u4e2a\u53d8\u91cf\u7ed9C++\u5c42\u3002 1. return { 2. internalBinding , 3. NativeModule , 4. require : nativeModuleRequire 5. }; C++\u5c42\u4fdd\u5b58\u5176\u4e2d\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u4e8e\u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757\u548c\u539f\u751fJS\u6a21\u5757\u7684\u51fd\u6570\u3002 1. set_internal_binding_loader ( internal_binding_loader . As < Function > ()); 2. set_native_module_require ( require . As < Function > ()); \u81f3\u6b64\uff0cinternal/bootstrap/loaders.js\u5206\u6790\u5b8c\u4e86\u3002 2 \u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587 BootstrapNode\u8d1f\u8d23\u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u4ee3\u7801\u5982\u4e0b 1. EscapableHandleScope scope ( isolate_ ); 2. // \u83b7\u53d6\u5168\u5c40\u53d8\u91cf\u5e76\u8bbe\u7f6eglobal\u5c5e\u6027 3. Local < Object > global = context () -> Global (); 4. global -> Set ( context (), FIXED_ONE_BYTE_STRING ( isolate_ , \"global\" ), global ). Check (); 5. /* 6. \u6267\u884cinternal/bootstrap/node.js\u65f6\u7684\u53c2\u6570 7. process, require, internalBinding, primordials 8. */ 9. std :: vector < Local < String >> node_params = { 10. process_string (), 11. require_string (), 12. internal_binding_string (), 13. primordials_string ()}; 14. std :: vector < Local < Value >> node_args = { 15. process_object (), 16. // \u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668 17. native_module_require (), 18. // C++\u6a21\u5757\u52a0\u8f7d\u5668 19. internal_binding_loader (), 20. primordials ()}; 21. 22. MaybeLocal < Value > result = ExecuteBootstrapper ( 23. this , \"internal/bootstrap/node\" , & node_params , & node_args ); \u5728\u5168\u5c40\u5bf9\u8c61\u4e0a\u8bbe\u7f6e\u4e00\u4e2aglobal\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5728Node.js\u4e2d\u4f7f\u7528\u7684global\u5bf9\u8c61\u3002\u63a5\u7740\u6267\u884cinternal/bootstrap/node.js\u8bbe\u7f6e\u4e00\u4e9b\u53d8\u91cf\uff08\u5177\u4f53\u53ef\u4ee5\u53c2\u8003nternal/bootstrap/node.js\uff09\u3002 1. process . cpuUsage = wrapped . cpuUsage ; 2. process . resourceUsage = wrapped . resourceUsage ; 3. process . memoryUsage = wrapped . memoryUsage ; 4. process . kill = wrapped . kill ; 5. process . exit = wrapped . exit ; \u8bbe\u7f6e\u5168\u5c40\u53d8\u91cf 1. defineOperation ( global , ' clearInterval ' , timers . clearInterval ); 2. defineOperation ( global , ' clearTimeout ' , timers . clearTimeout ); 3. defineOperation ( global , ' setInterval ' , timers . setInterval ); 4. defineOperation ( global , ' setTimeout ' , timers . setTimeout ); 5. ObjectDefineProperty ( global , ' process ' , { 6. value : process , 7. enumerable : false , 8. writable : true , 9. configurable : true 10. }); 1.3.5 \u6267\u884c\u7528\u6237JS\u6587\u4ef6 \u00b6 StartMainThreadExecution\u8fdb\u884c\u4e00\u4e9b\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u7136\u540e\u6267\u884c\u7528\u6237JS\u4ee3\u7801\u3002 1 \u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027 \u6267\u884cpatchProcessObject\u51fd\u6570\uff08\u5728node_process_methods.cc\u4e2d\u5bfc\u51fa\uff09\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e9b\u5217\u5c5e\u6027\uff0c\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1. // process.argv 2. process -> Set ( context , 3. FIXED_ONE_BYTE_STRING ( isolate , \"argv\" ), 4. ToV8Value ( context , env -> argv ()). ToLocalChecked ()). Check (); 5. 6. READONLY_PROPERTY ( process , 7. \"pid\" , 8. Integer :: New ( isolate , uv_os_getpid ())); \u56e0\u4e3aNode.js\u589e\u52a0\u4e86\u5bf9\u7ebf\u7a0b\u7684\u652f\u6301\uff0c\u6709\u4e9b\u5c5e\u6027\u9700\u8981hack\u4e00\u4e0b\uff0c\u6bd4\u5982\u5728\u7ebf\u7a0b\u91cc\u4f7f\u7528process.exit\u7684\u65f6\u5019\uff0c\u9000\u51fa\u7684\u662f\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\uff0cexit\u7b49\u51fd\u6570\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002\u540e\u9762\u7ae0\u8282\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002 2 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 1. function setupChildProcessIpcChannel () { 2. if ( process . env . NODE_CHANNEL_FD ) { 3. const fd = parseInt ( process . env . NODE_CHANNEL_FD , 10 ); 4. delete process . env . NODE_CHANNEL_FD ; 5. const serializationMode = 6. process . env . NODE_CHANNEL_SERIALIZATION_MODE || ' json ' ; 7. delete process . env . NODE_CHANNEL_SERIALIZATION_MODE ; 8. require ( ' child_process ' ). _forkChild ( fd , serializationMode ); 9. } 10. } \u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u662f\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8bf4\u660e\u5f53\u524d\u542f\u52a8\u7684\u8fdb\u7a0b\u662f\u5b50\u8fdb\u7a0b\uff0c\u5219\u9700\u8981\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 3 \u5904\u7406cluster\u6a21\u5757\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1 1. function initializeclusterIPC () { 2. if ( process . argv [ 1 ] && process . env . NODE_UNIQUE_ID ) { 3. const cluster = require ( ' cluster ' ); 4. cluster . _setupWorker (); 5. delete process . env . NODE_UNIQUE_ID ; 6. } 7. } 4 \u6267\u884c\u7528\u6237JS\u4ee3\u7801 require ( ' internal / modules / cjs / loader ' ). Module . runMain ( process . argv [ 1 ]); internal/modules/cjs/loader.js\u662f\u8d1f\u8d23\u52a0\u8f7d\u7528\u6237JS\u7684\u6a21\u5757\uff0crunMain\u51fd\u6570\u5728pre_execution.js\u88ab\u6302\u8f7d\uff0crunMain\u505a\u7684\u4e8b\u60c5\u662f\u52a0\u8f7d\u7528\u6237\u7684JS\uff0c\u7136\u540e\u6267\u884c\u3002\u5177\u4f53\u7684\u8fc7\u7a0b\u5728\u540e\u9762\u7ae0\u8282\u8be6\u7ec6\u5206\u6790\u3002 1.3.6 \u8fdb\u5165Libuv\u4e8b\u4ef6\u5faa\u73af \u00b6 \u6267\u884c\u5b8c\u6240\u6709\u7684\u521d\u59cb\u5316\u540e\uff0cNode.js\u6267\u884c\u4e86\u7528\u6237\u7684JS\u4ee3\u7801\uff0c\u7528\u6237\u7684JS\u4ee3\u7801\u4f1a\u5f80Libuv\u6ce8\u518c\u4e00\u4e9b\u4efb\u52a1\uff0c\u6bd4\u5982\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u6700\u540eNode.js\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u5f00\u59cb\u4e00\u8f6e\u53c8\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u5904\u7406\u3002\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\uff0cLibuv\u4f1a\u9000\u51fa\uff0c\u4ece\u800cNode.js\u9000\u51fa\u3002 1. do { 2. uv_run ( env -> event_loop (), UV_RUN_DEFAULT ); 3. per_process :: v8_platform . DrainVMTasks ( isolate_ ); 4. more = uv_loop_alive ( env -> event_loop ()); 5. if ( more && ! env -> is_stopping ()) continue ; 6. if ( ! uv_loop_alive ( env -> event_loop ())) { 7. EmitBeforeExit ( env . get ()); 8. } 9. more = uv_loop_alive ( env -> event_loop ()); 10. } while ( more == true && ! env -> is_stopping ()); 1.4 Node.js\u548c\u5176\u5b83\u670d\u52a1\u5668\u7684\u6bd4\u8f83 \u00b6 \u670d\u52a1\u5668\u662f\u73b0\u4ee3\u8f6f\u4ef6\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u7ec4\u6210\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u53d1\u5c55\u7684\u8fc7\u7a0b\u4e2d\uff0c\u90fd\u6709\u54ea\u4e9b\u8bbe\u8ba1\u67b6\u6784\u3002\u4e00\u4e2a\u57fa\u4e8eTCP\u534f\u8bae\u7684\u670d\u52a1\u5668\uff0c\u57fa\u672c\u7684\u6d41\u7a0b\u5982\u4e0b\uff08\u4f2a\u4ee3\u7801\uff09\u3002 1. // \u62ff\u5230\u4e00\u4e2asocket\u7528\u4e8e\u76d1\u542c 2. const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); 3. // \u76d1\u542c\u672c\u673a\u7684\u5730\u5740\uff08ip+\u7aef\u53e3\uff09 4. bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) 5. // \u6807\u8bb0\u8be5socket\u662f\u76d1\u542c\u578bsocket 6. listen ( socketfd ) \u6267\u884c\u5b8c\u4ee5\u4e0a\u6b65\u9aa4\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u6b63\u5f0f\u5f00\u59cb\u670d\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u4e0a\u9762\u7684\u6a21\u578b\uff0c\u5206\u6790\u5404\u79cd\u5404\u6837\u7684\u5904\u7406\u65b9\u6cd5\u3002 1.4.1 \u4e32\u884c\u5904\u7406\u8bf7\u6c42 \u00b6 1. while ( 1 ) { 2. const socketForCommunication = accept ( socket ); 3. const data = read ( socketForCommunication ); 4. handle ( data ); 5. write ( socketForCommunication , data ); 6. } \u6211\u4eec\u770b\u770b\u8fd9\u79cd\u6a21\u5f0f\u7684\u5904\u7406\u8fc7\u7a0b\uff0c\u5047\u8bbe\u6709n\u4e2a\u8bf7\u6c42\u5230\u6765\u3002\u90a3\u4e48socket\u7684\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u8fd9\u65f6\u5019\u8fdb\u7a0b\u4eceaccept\u4e2d\u88ab\u5524\u9192\u3002\u7136\u540e\u62ff\u5230\u4e00\u4e2a\u65b0\u7684socket\u7528\u4e8e\u901a\u4fe1\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 accept\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u961f\u5217\u91cc\uff0c\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u5f88\u591a\u540c\u5b66\u90fd\u4e86\u89e3\u4e09\u6b21\u63e1\u624b\u662f\u4ec0\u4e48\uff0c\u4f46\u662f\u53ef\u80fd\u5f88\u5c11\u540c\u5b66\u4f1a\u6df1\u5165\u601d\u8003\u6216\u8005\u770b\u5b83\u7684\u5b9e\u73b0\uff0c\u4f17\u6240\u5468\u77e5\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u76d1\u542c\u4e00\u4e2a\u7aef\u53e3\uff0c\u5176\u5b9e\u5c31\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u3002\u90a3\u4e48\u5982\u679c\u6709\u4e00\u4e2a\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u6211\u4eec\u901a\u8fc7accept\u5c31\u80fd\u62ff\u5230\u8fd9\u4e2a\u65b0\u8fde\u63a5\u5bf9\u5e94\u7684socket\uff0c\u90a3\u8fd9\u4e2asocket\u548c\u76d1\u542c\u7684socket\u662f\u4e0d\u662f\u540c\u4e00\u4e2a\u5462\uff1f\u5176\u5b9esocket\u5206\u4e3a\u76d1\u542c\u578b\u548c\u901a\u4fe1\u578b\u7684\uff0c\u8868\u9762\u4e0a\uff0c\u670d\u52a1\u5668\u7528\u4e00\u4e2a\u7aef\u53e3\u5b9e\u73b0\u4e86\u591a\u4e2a\u8fde\u63a5\uff0c\u4f46\u662f\u8fd9\u4e2a\u7aef\u53e3\u662f\u7528\u4e8e\u76d1\u542c\u7684\uff0c\u5e95\u5c42\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5176\u5b9e\u662f\u53e6\u4e00\u4e2asocket\u3002\u6240\u4ee5\u6bcf\u4e00\u4e2a\u8fde\u63a5\u8fc7\u6765\uff0c\u8d1f\u8d23\u76d1\u542c\u7684socket\u53d1\u73b0\u662f\u4e00\u4e2a\u5efa\u7acb\u8fde\u63a5\u7684\u5305\uff08syn\u5305\uff09\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a\u65b0\u7684socket\u4e0e\u4e4b\u901a\u4fe1\uff08accept\u7684\u65f6\u5019\u8fd4\u56de\u7684\u90a3\u4e2a\uff09\u3002\u76d1\u542csocket\u91cc\u53ea\u4fdd\u5b58\u4e86\u5b83\u76d1\u542c\u7684IP\u548c\u7aef\u53e3\uff0c\u901a\u4fe1socket\u9996\u5148\u4ece\u76d1\u542csocket\u4e2d\u590d\u5236IP\u548c\u7aef\u53e3\uff0c\u7136\u540e\u628a\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\u4e5f\u8bb0\u5f55\u4e0b\u6765\uff0c\u5f53\u4e0b\u6b21\u6536\u5230\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636e\u56db\u5143\u7ec4\u4ecesocket\u6c60\u5b50\u91cc\u627e\u5230\u8be5socket\uff0c\u4ece\u800c\u5b8c\u6210\u6570\u636e\u7684\u5904\u7406\u3002 \u4e32\u884c\u8fd9\u79cd\u6a21\u5f0f\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u961f\u5217\u91cc\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u5904\u7406\u3002\u518d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u518d\u5904\u7406\u3002\u5982\u679c\u5904\u7406\u7684\u8fc7\u7a0b\u4e2d\u6709\u963b\u585e\u5f0fIO\uff0c\u53ef\u60f3\u800c\u77e5\uff0c\u6548\u7387\u662f\u6709\u591a\u4f4e\u3002\u800c\u4e14\u5e76\u53d1\u91cf\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u76d1\u542csocket\u5bf9\u5e94\u7684\u961f\u5217\u5f88\u5feb\u5c31\u4f1a\u88ab\u5360\u6ee1\uff08\u5df2\u5b8c\u6210\u8fde\u63a5\u961f\u5217\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\uff09\u3002\u8fd9\u662f\u6700\u7b80\u5355\u7684\u6a21\u5f0f\uff0c\u867d\u7136\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u80af\u5b9a\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u79cd\u6a21\u5f0f\uff0c\u4f46\u662f\u5b83\u8ba9\u6211\u4eec\u4e86\u89e3\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u7684\u6574\u4f53\u8fc7\u7a0b\u3002 1.4.2 \u591a\u8fdb\u7a0b\u6a21\u5f0f \u00b6 \u4e32\u884c\u6a21\u5f0f\u4e2d\uff0c\u6240\u6709\u8bf7\u6c42\u90fd\u5728\u4e00\u4e2a\u8fdb\u7a0b\u4e2d\u6392\u961f\u88ab\u5904\u7406\uff0c\u8fd9\u662f\u6548\u7387\u4f4e\u4e0b\u7684\u539f\u56e0\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u628a\u8bf7\u6c42\u5206\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u5904\u7406\u6765\u63d0\u4f9b\u6548\u7387\uff0c\u56e0\u4e3a\u5728\u4e32\u884c\u5904\u7406\u7684\u6a21\u5f0f\u4e2d\uff0c\u5982\u679c\u6709\u963b\u585e\u5f0fIO\u64cd\u4f5c\uff0c\u5b83\u5c31\u4f1a\u963b\u585e\u4e3b\u8fdb\u7a0b\uff0c\u4ece\u800c\u963b\u585e\u540e\u7eed\u8bf7\u6c42\u7684\u5904\u7406\u3002\u5728\u591a\u8fdb\u7a0b\u7684\u6a21\u5f0f\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u5982\u679c\u963b\u585e\u4e86\u8fdb\u7a0b\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6302\u8d77\u8be5\u8fdb\u7a0b\uff0c\u63a5\u7740\u8c03\u5ea6\u5176\u5b83\u8fdb\u7a0b\u6267\u884c\uff0c\u90a3\u4e48\u5176\u5b83\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u6267\u884c\u65b0\u7684\u4efb\u52a1\u3002\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e0b\u5206\u4e3a\u51e0\u79cd\u3002 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u6458\u53d6\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u8282\u70b9\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u7684\u8bf7\u6c42\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\uff0c\u903b\u8f91\u5982\u4e0b\u3002 1. while ( 1 ) { 2. const socketForCommunication = accept ( socket ); 3. if ( fork () > 0 ) { 4. continue ; 5. // \u7236\u8fdb\u7a0b 6. } else { 7. // \u5b50\u8fdb\u7a0b 8. handle ( socketForCommunication ); 9. } 10. } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u6bcf\u6b21\u6765\u4e00\u4e2a\u8bf7\u6c42\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u53bb\u5904\u7406\u3002\u8fd9\u79cd\u6a21\u5f0f\u6bd4\u4e32\u884c\u7684\u7a0d\u5fae\u597d\u4e86\u4e00\u70b9\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u72ec\u7acb\u5904\u7406\uff0c\u5047\u8bbea\u8bf7\u6c42\u963b\u585e\u5728\u6587\u4ef6IO\uff0c\u90a3\u4e48\u4e0d\u4f1a\u5f71\u54cdb\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u5c3d\u53ef\u80fd\u5730\u505a\u5230\u4e86\u5e76\u53d1\u3002\u5b83\u7684\u74f6\u9888\u5c31\u662f\u7cfb\u7edf\u7684\u8fdb\u7a0b\u6570\u6709\u9650\uff0c\u5982\u679c\u6709\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u65e0\u6cd5\u625b\u5f97\u4f4f\uff0c\u518d\u8005\uff0c\u8fdb\u7a0b\u7684\u5f00\u9500\u5f88\u5927\uff0c\u5bf9\u4e8e\u7cfb\u7edf\u6765\u8bf4\u662f\u4e00\u4e2a\u6c89\u91cd\u7684\u8d1f\u62c5\u3002 2 \u8fdb\u7a0b\u6c60\u6a21\u5f0f \u5b9e\u65f6\u521b\u5efa\u548c\u9500\u6bc1\u8fdb\u7a0b\u5f00\u9500\u5927\uff0c\u6548\u7387\u4f4e\uff0c\u6240\u4ee5\u884d\u751f\u4e86\u8fdb\u7a0b\u6c60\u6a21\u5f0f\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u5c31\u662f\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u9884\u5148\u521b\u5efa\u4e00\u5b9a\u6570\u91cf\u7684\u8fdb\u7a0b\uff0c\u4f46\u662f\u8fd9\u4e9b\u8fdb\u7a0b\u662fworker\u8fdb\u7a0b\u3002\u5b83\u4e0d\u8d1f\u8d23accept\u8bf7\u6c42\u3002\u5b83\u53ea\u8d1f\u8d23\u5904\u7406\u8bf7\u6c42\u3002\u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\uff0c\u5b83\u628aaccept\u8fd4\u56de\u7684socket\u4ea4\u7ed9worker\u8fdb\u7a0b\u5904\u7406\uff0c\u6a21\u5f0f\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4f46\u662f\u548c1\u4e2d\u7684\u6a21\u5f0f\u76f8\u6bd4\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0c\u56e0\u4e3a\u5728\u6a21\u5f0f1\u4e2d\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b9e\u65f6fork\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u8fd9\u65f6\u5019\uff0c\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u4e2d\u65b0\u8bf7\u6c42\u5bf9\u5e94\u7684fd\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u76f4\u63a5\u5904\u7406\u8be5fd\u5bf9\u5e94\u7684\u8bf7\u6c42\uff0c\u5728\u8fdb\u7a0b\u6c60\u7684\u6a21\u5f0f\u4e2d\uff0c\u5b50\u8fdb\u7a0b\u662f\u9884\u5148\u521b\u5efa\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4e2d\u662f\u65e0\u6cd5\u62ff\u5f97\u5230\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u7684\u3002\u8fd9\u65f6\u5019\uff0c\u9700\u8981\u4e3b\u8fdb\u7a0b\u4f7f\u7528\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u6280\u672f\u628a\u8fd9\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4e00\u4e2a\u8fdb\u7a0b\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53task_struct\uff0c\u5728JS\u91cc\u6211\u4eec\u53ef\u4ee5\u8bf4\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5b83\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5f53\u6211\u4eec\u8bbf\u95ee\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636efd\u7684\u503c\uff0c\u4ecetask_struct\u4e2d\u627e\u5230fd\u5bf9\u5e94\u7684\u5e95\u5c42\u8d44\u6e90\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u4f20\u9012\u7684\u4e0d\u4ec5\u4ec5\u662f\u4e00\u4e2a\u6570\u5b57fd\uff0c\u56e0\u4e3a\u5982\u679c\u4ec5\u4ec5\u8fd9\u6837\u505a\uff0c\u5728\u5b50\u8fdb\u7a0b\u4e2d\u8be5fd\u53ef\u80fd\u6ca1\u6709\u5bf9\u5e94\u4efb\u4f55\u8d44\u6e90\uff0c\u6216\u8005\u5bf9\u5e94\u7684\u8d44\u6e90\u548c\u4e3b\u8fdb\u7a0b\u4e2d\u7684\u662f\u4e0d\u4e00\u81f4\u7684\u3002\u8fd9\u5176\u4e2d\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u6211\u4eec\u505a\u4e86\u5f88\u591a\u4e8b\u60c5\u3002\u8ba9\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u901a\u8fc7fd\u8bbf\u95ee\u5230\u6b63\u786e\u7684\u8d44\u6e90\uff0c\u5373\u4e3b\u8fdb\u7a0b\u4e2d\u6536\u5230\u7684\u8bf7\u6c42\u3002 3 \u5b50\u8fdb\u7a0baccept \u8fd9\u79cd\u6a21\u5f0f\u4e0d\u662f\u7b49\u5230\u8bf7\u6c42\u6765\u7684\u65f6\u5019\u518d\u521b\u5efa\u8fdb\u7a0b\u3002\u800c\u662f\u5728\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u521b\u5efa\u591a\u4e2a\u8fdb\u7a0b\u3002\u7136\u540e\u591a\u4e2a\u8fdb\u7a0b\u5206\u522b\u8c03\u7528accept\u3002\u8fd9\u79cd\u6a21\u5f0f\u7684\u67b6\u6784\u5982\u56fe1-8\u6240\u793a\u3002 1. const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); 2. bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) 3. 4. for ( let i = 0 ; i < \u8fdb\u7a0b\u4e2a\u6570 ; i ++ ) { 5. if ( fork () > 0 ) { 6. // \u7236\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u63a7\u5b50\u8fdb\u7a0b 7. } else { 8. // \u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 9. listen ( socketfd ); 10. while ( 1 ) { 11. const socketForCommunication = accept ( socketfd ); 12. handle ( socketForCommunication ); 13. } 14. } 15. } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\u591a\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u963b\u585e\u5728accept\u3002\u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\uff0c\u90a3\u4e48\u6240\u6709\u7684\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u88ab\u5524\u9192\uff0c\u4f46\u662f\u9996\u5148\u88ab\u8c03\u5ea6\u7684\u5b50\u8fdb\u7a0b\u4f1a\u9996\u5148\u6458\u4e0b\u8fd9\u4e2a\u8bf7\u6c42\u8282\u70b9\uff0c\u540e\u7eed\u7684\u8fdb\u7a0b\u88ab\u5524\u9192\u540e\u53ef\u80fd\u4f1a\u9047\u5230\u5df2\u7ecf\u6ca1\u6709\u8bf7\u6c42\u53ef\u4ee5\u5904\u7406\uff0c\u53c8\u8fdb\u5165\u7761\u7720\uff0c\u8fdb\u7a0b\u88ab\u65e0\u6548\u5524\u9192\uff0c\u8fd9\u662f\u8457\u540d\u7684\u60ca\u7fa4\u73b0\u8c61\u3002\u6539\u8fdb\u65b9\u5f0f\u5c31\u662f\u5728accpet\u4e4b\u524d\u52a0\u9501\uff0c\u62ff\u5230\u9501\u7684\u8fdb\u7a0b\u624d\u80fd\u8fdb\u884caccept\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u963b\u585e\u5728accept\uff0cNginx\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u662f\u65b0\u7248\u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u5728\u5185\u6838\u5c42\u9762\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002\u6bcf\u6b21\u53ea\u4f1a\u5524\u9192\u4e00\u4e2a\u8fdb\u7a0b\u3002\u901a\u5e38\u8fd9\u79cd\u6a21\u5f0f\u548c\u4e8b\u4ef6\u9a71\u52a8\u914d\u5408\u4f7f\u7528\u3002 1.4.3 \u591a\u7ebf\u7a0b\u6a21\u5f0f \u00b6 \u591a\u7ebf\u7a0b\u6a21\u5f0f\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u662f\u7c7b\u4f3c\u7684\uff0c\u4e5f\u662f\u5206\u4e3a\u4e0b\u9762\u51e0\u79cd 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u521b\u5efa\u5b50\u7ebf\u7a0b\u5904\u7406 2 \u5b50\u7ebf\u7a0baccept 3 \u7ebf\u7a0b\u6c60 \u524d\u9762\u4e24\u79cd\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e2d\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u79cd\u6bd4\u8f83\u7279\u522b\uff0c\u6211\u4eec\u4e3b\u8981\u4ecb\u7ecd\u7b2c\u4e09\u79cd\u3002\u5728\u5b50\u8fdb\u7a0b\u6a21\u5f0f\u65f6\uff0c\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u6709\u81ea\u5df1\u7684task_struct\uff0c\u8fd9\u5c31\u610f\u5473\u7740\u5728fork\u4e4b\u540e\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u8d1f\u8d23\u7ef4\u62a4\u81ea\u5df1\u7684\u6570\u636e\uff0c\u800c\u7ebf\u7a0b\u5219\u4e0d\u4e00\u6837\uff0c\u7ebf\u7a0b\u662f\u5171\u4eab\u4e3b\u7ebf\u7a0b\uff08\u4e3b\u8fdb\u7a0b\uff09\u7684\u6570\u636e\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u4eceaccept\u4e2d\u62ff\u5230\u4e00\u4e2afd\u7684\u65f6\u5019\uff0c\u4f20\u7ed9\u7ebf\u7a0b\u7684\u8bdd\uff0c\u7ebf\u7a0b\u662f\u53ef\u4ee5\u76f4\u63a5\u64cd\u4f5c\u7684\u3002\u6240\u4ee5\u5728\u7ebf\u7a0b\u6c60\u6a21\u5f0f\u65f6\uff0c\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1\u5230\u5171\u4eab\u961f\u5217\u4e2d\uff0c\u7ebf\u7a0b\u6c60\u4e2d\u7684\u5b50\u7ebf\u7a0b\u540c\u6837\u662f\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\uff0c\u4ece\u5171\u4eab\u961f\u5217\u4e2d\u6458\u53d6\u8282\u70b9\u8fdb\u884c\u5904\u7406\u3002 1.4.4 \u4e8b\u4ef6\u9a71\u52a8 \u00b6 \u73b0\u5728\u5f88\u591a\u670d\u52a1\u5668\uff08Nginx\uff0cNode.js\uff0cRedis\uff09\u90fd\u5f00\u59cb\u4f7f\u7528\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u53bb\u8bbe\u8ba1\u3002\u4ece\u4e4b\u524d\u7684\u8bbe\u8ba1\u6a21\u5f0f\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u4e3a\u4e86\u5e94\u5bf9\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u670d\u52a1\u5668\u9700\u8981\u5927\u91cf\u7684\u8fdb\u7a0b/\u7ebf\u7a0b\u3002\u8fd9\u4e2a\u662f\u4e2a\u975e\u5e38\u5927\u7684\u5f00\u9500\u3002\u800c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\uff0c\u4e00\u822c\u662f\u914d\u5408\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\uff0c\u518d\u591a\u7684\u8bf7\u6c42\uff0c\u4e5f\u662f\u5728\u4e00\u4e2a\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\u3002\u4f46\u662f\u56e0\u4e3a\u662f\u5355\u8fdb\u7a0b\uff0c\u6240\u4ee5\u4e0d\u9002\u5408CPU\u5bc6\u96c6\u578b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u4efb\u52a1\u4e00\u76f4\u5728\u5360\u636eCPU\u7684\u8bdd\uff0c\u540e\u7eed\u7684\u4efb\u52a1\u5c31\u65e0\u6cd5\u6267\u884c\u4e86\u3002\u5b83\u66f4\u9002\u5408IO\u5bc6\u96c6\u7684\uff08\u4e00\u822c\u90fd\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8d1f\u8d23\u5904\u7406CPU\u6216\u8005\u963b\u585e\u578b\u7684\u4efb\u52a1\uff09\u3002\u800c\u4f7f\u7528\u591a\u8fdb\u7a0b/\u7ebf\u7a0b\u6a21\u5f0f\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u8fdb\u7a0b/\u7ebf\u7a0b\u662f\u65e0\u6cd5\u4e00\u76f4\u5360\u636eCPU\u7684\uff0c\u6267\u884c\u4e00\u5b9a\u65f6\u95f4\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6267\u884c\u4efb\u52a1\u8c03\u5ea6\u3002\u8ba9\u5176\u5b83\u7ebf\u7a0b\u4e5f\u6709\u673a\u4f1a\u6267\u884c\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u524d\u9762\u7684\u4efb\u52a1\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\uff0c\u51fa\u73b0\u9965\u997f\u60c5\u51b5\u3002\u5927\u90e8\u5206\u64cd\u4f5c\u7cfb\u7edf\u90fd\u63d0\u4f9b\u4e86\u4e8b\u4ef6\u9a71\u52a8\u7684API\u3002\u4f46\u662f\u4e8b\u4ef6\u9a71\u52a8\u5728\u4e0d\u540c\u7cfb\u7edf\u4e2d\u5b9e\u73b0\u4e0d\u4e00\u6837\u3002\u6240\u4ee5\u4e00\u822c\u90fd\u4f1a\u6709\u4e00\u5c42\u62bd\u8c61\u5c42\u62b9\u5e73\u8fd9\u4e2a\u5dee\u5f02\u3002\u8fd9\u91cc\u4ee5Linux\u7684epoll\u4e3a\u4f8b\u5b50\u3002 1. // \u521b\u5efa\u4e00\u4e2aepoll 2. var epollFD = epoll_create (); 3. /* 4. \u5728epoll\u7ed9\u67d0\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u662f\u76d1\u542c\u7684socket\uff0c\u6ce8\u518c\u53ef 5. \u8bfb\u4e8b\u4ef6\uff0c\u5373\u8fde\u63a5\u5230\u6765 6. event = { 7. event: \u53ef\u8bfb 8. fd\uff1a \u76d1\u542csocket 9. // \u4e00\u4e9b\u4e0a\u4e0b\u6587 10. } 11. */ 12. epoll_ctl ( epollFD , EPOLL_CTL_ADD , socket , event ); 13. while ( 1 ) { 14. // \u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u5c31\u7eea\uff0cevents\u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u4fe1\u606f\uff0ctotal\u662f\u4e2a\u6570 15. var total = epoll_wait ( epollFD , \u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u7ed3\u6784 events , \u4e8b\u4ef6\u4e2a\u6570 , timeout ); 16. for ( let i = 0 ; i < total ; i ++ ) { 17. if ( events [ i ]. fd === \u76d1\u542c socket ) { 18. var newSocket = accpet ( socket ); 19. /* 20. \u628a\u65b0\u7684socket\u4e5f\u6ce8\u518c\u5230epoll\uff0c\u7b49\u5f85\u53ef\u8bfb\uff0c 21. \u5373\u53ef\u8bfb\u53d6\u5ba2\u6237\u7aef\u6570\u636e 22. */ 23. epoll_ctl ( epollFD , 24. EPOLL_CTL_ADD , 25. newSocket , 26. \u53ef\u8bfb\u4e8b\u4ef6 ); 27. } else { 28. // \u4eceevents[i]\u4e2d\u62ff\u5230\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03 29. } 30. } 31. } \u8fd9\u5c31\u662f\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u7684\u5927\u81f4\u8fc7\u7a0b\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u8ba2\u9605/\u53d1\u5e03\u6a21\u5f0f\u3002\u670d\u52a1\u5668\u901a\u8fc7\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u4e8b\u4ef6\u5230epoll\u4e2d\uff0cepoll\u5f00\u59cb\u963b\u585e\uff0c\u7b49\u5230epoll\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u544a\u8bc9\u670d\u52a1\u5668\u54ea\u4e9bfd\u7684\u54ea\u4e9b\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u904d\u5386\u5c31\u7eea\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u53ef\u4ee5\u518d\u6b21\u6ce8\u518c\u65b0\u7684\u4e8b\u4ef6\uff0c\u5c31\u662f\u8fd9\u6837\u4e0d\u65ad\u9a71\u52a8\u7740\u3002epoll\u7684\u539f\u7406\u5176\u5b9e\u4e5f\u7c7b\u4f3c\u4e8b\u4ef6\u9a71\u52a8\uff0cepoll\u5e95\u5c42\u7ef4\u62a4\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cepoll\u672c\u8eab\u4e5f\u4f1a\u5728\u6587\u4ef6\u63cf\u8ff0\u7b26\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u5904\u6ce8\u518c\u4e00\u4e2a\u56de\u8c03\uff0c\u7136\u540e\u81ea\u8eab\u8fdb\u5165\u963b\u585e\uff0c\u7b49\u5230\u522b\u4eba\u901a\u77e5epoll\u6709\u4e8b\u4ef6\u53d1\u751f\u7684\u65f6\u5019\uff0cepoll\u5c31\u4f1a\u628afd\u548c\u4e8b\u4ef6\u8fd4\u56de\u7ed9\u7528\u6237\u3002 1. function epoll_wait () { 2. for \u4e8b\u4ef6\u4e2a\u6570 3. // \u8c03\u7528\u6587\u4ef6\u7cfb\u7edf\u7684\u51fd\u6570\u5224\u65ad 4. if ( \u4e8b\u4ef6 [ i ] \u4e2d\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2d\u6709\u67d0\u4e2a\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u53d1\u751f ? ) { 5. \u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217 6. } else { 7. /* 8. \u5728\u4e8b\u4ef6[i]\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u6240\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u7b49indeo\u8282 9. \u70b9\u6ce8\u518c\u56de\u8c03\u3002\u5373\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u540e\u56de\u8c03epoll\uff0c\u56de\u8c03epoll\u540e\uff0c 10. epoll\u628a\u8be5event[i]\u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217\u8fd4\u56de\u7ed9\u7528\u6237 11. */ 12. } 13. } \u4ee5\u4e0a\u5c31\u662f\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\u4e00\u4e9b\u57fa\u672c\u4ecb\u7ecd\u3002\u73b0\u5728\u7684\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u8fd8\u4f1a\u6d89\u53ca\u5230\u534f\u7a0b\u3002\u4e0d\u8fc7\u76ee\u524d\u8fd8\u6ca1\u6709\u770b\u8fc7\u5177\u4f53\u7684\u5b9e\u73b0\uff0c\u6240\u4ee5\u6682\u4e0d\u5c55\u5f00\u4ecb\u7ecd\uff0c\u6709\u5174\u8da3\u7684\u901a\u4fe1\u53ef\u4ee5\u770b\u4e00\u4e0b\u534f\u7a0b\u5e93libtask\u4e86\u89e3\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528\u534f\u7a0b\u5b9e\u73b0\u4e00\u4e2a\u670d\u52a1\u5668\u3002 Node.js\u662f\u57fa\u4e8e\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48Node.js\u64c5\u957f\u5904\u7406\u9ad8\u5e76\u53d1IO\u578b\u4efb\u52a1\u800c\u4e0d\u64c5\u957f\u5904\u7406CPU\u578b\u4efb\u52a1\u7684\u539f\u56e0\uff0cNginx\u3001Redis\u4e5f\u662f\u8fd9\u79cd\u6a21\u5f0f\u3002\u53e6\u5916Node.js\u662f\u4e00\u4e2a\u53caweb\u670d\u52a1\u5668\u548c\u5e94\u7528\u670d\u52a1\u5668\u4e8e\u4e00\u8eab\u7684\u670d\u52a1\u5668\uff0c\u50cfNginx\u8fd9\u79cd\u5c5e\u4e8eweb\u670d\u52a1\u5668\uff0c\u5b83\u4eec\u53ea\u5904\u7406HTTP\u534f\u8bae\uff0c\u4e0d\u5177\u5907\u811a\u672c\u8bed\u8a00\u6765\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002\u5b83\u9700\u8981\u628a\u8bf7\u6c42\u8f6c\u53d1\u5230\u771f\u6b63\u7684web\u670d\u52a1\u5668\u4e2d\u53bb\u5904\u7406\uff0c\u6bd4\u5982PHP\u3002\u800cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u89e3\u6790HTTP\u534f\u8bae\uff0c\u8fd8\u53ef\u4ee5\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002","title":"01-Node.js\u7ec4\u6210\u548c\u539f\u7406"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#nodejs","text":"","title":"\u7b2c\u4e00\u7ae0 Node.js\u7ec4\u6210\u548c\u539f\u7406"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#11-nodejs","text":"Node.js\u662f\u57fa\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u5355\u8fdb\u7a0b\u5355\u7ebf\u7a0b\u5e94\u7528\uff0c\u5355\u7ebf\u7a0b\u5177\u4f53\u4f53\u73b0\u5728Node.js\u5728\u5355\u4e2a\u7ebf\u7a0b\u4e2d\u7ef4\u62a4\u4e86\u4e00\u7cfb\u5217\u4efb\u52a1\uff0c\u7136\u540e\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u4e0d\u65ad\u6d88\u8d39\u4efb\u52a1\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u53c8\u4e0d\u65ad\u4ea7\u751f\u65b0\u7684\u4efb\u52a1\uff0c\u5728\u4efb\u52a1\u7684\u4ea7\u751f\u548c\u6d88\u8d39\u4e2d\u4e0d\u65ad\u9a71\u52a8\u7740Node.js\u7684\u6267\u884c\u3002\u4ece\u53e6\u5916\u4e00\u4e2a\u89d2\u5ea6\u6765\u8bf4\uff0cNode.js\u53c8\u53ef\u4ee5\u8bf4\u662f\u591a\u7ebf\u7a0b\u7684\uff0c\u56e0\u4e3aNode.js\u5e95\u5c42\u4e5f\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8be5\u7ebf\u7a0b\u6c60\u4e3b\u8981\u7528\u4e8e\u5904\u7406\u4e00\u4e9b\u6587\u4ef6IO\u3001DNS\u3001CPU\u8ba1\u7b97\u7b49\u4efb\u52a1\u3002 Node.js\u4e3b\u8981\u7531V8\u3001Libuv\uff0c\u8fd8\u6709\u4e00\u4e9b\u5176\u5b83\u7684\u7b2c\u4e09\u65b9\u6a21\u5757\u7ec4\u6210\uff08cares\u5f02\u6b65DNS\u89e3\u6790\u5e93\u3001HTTP\u89e3\u6790\u5668\u3001HTTP2\u89e3\u6790\u5668\uff0c\u538b\u7f29\u5e93\u3001\u52a0\u89e3\u5bc6\u5e93\u7b49\uff09\u3002Node.js\u6e90\u7801\u5206\u4e3a\u4e09\u5c42\uff0c\u5206\u522b\u662fJS\u3001C++\u3001C\uff0cLibuv\u662f\u4f7f\u7528C\u8bed\u8a00\u7f16\u5199\uff0cC++\u5c42\u4e3b\u8981\u662f\u901a\u8fc7V8\u4e3aJS\u5c42\u63d0\u4f9b\u548c\u5e95\u5c42\u4ea4\u4e92\u7684\u80fd\u529b\uff0cC++\u5c42\u4e5f\u5b9e\u73b0\u4e86\u90e8\u5206\u529f\u80fd\uff0cJS\u5c42\u662f\u9762\u5411\u7528\u6237\u7684\uff0c\u4e3a\u7528\u6237\u63d0\u4f9b\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u3002","title":"1.1 Node.js\u7b80\u4ecb"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#111-jsv8","text":"Node.js\u662f\u57fa\u4e8eV8\u7684JS\u8fd0\u884c\u65f6\uff0c\u5b83\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u4e86JS\u7684\u80fd\u529b\u3002\u8fd9\u79cd\u62d3\u5c55\u4e0d\u662f\u4e3aJS\u589e\u52a0\u4e86\u65b0\u7684\u8bed\u8a00\u7279\u6027\uff0c\u800c\u662f\u62d3\u5c55\u4e86\u529f\u80fd\u6a21\u5757\uff0c\u6bd4\u5982\u5728\u524d\u7aef\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528Date\u8fd9\u4e2a\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528TCP\u8fd9\u4e2a\u51fd\u6570\uff0c\u56e0\u4e3aJS\u4e2d\u5e76\u6ca1\u6709\u5185\u7f6e\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528TCP\uff0c\u8fd9\u5c31\u662fNode.js\u505a\u7684\u4e8b\u60c5\uff0c\u8ba9\u7528\u6237\u53ef\u4ee5\u4f7f\u7528JS\u4e2d\u672c\u6765\u4e0d\u5b58\u5728\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6587\u4ef6\u3001\u7f51\u7edc\u3002Node.js\u4e2d\u6700\u6838\u5fc3\u7684\u90e8\u5206\u662fLibuv\u548cV8\uff0cV8\u4e0d\u4ec5\u8d1f\u8d23\u6267\u884cJS\uff0c\u8fd8\u652f\u6301\u81ea\u5b9a\u4e49\u7684\u62d3\u5c55\uff0c\u5b9e\u73b0\u4e86JS\u8c03\u7528C++\u548cC++\u8c03\u7528JS\u7684\u80fd\u529b\u3002\u6bd4\u5982\u6211\u4eec\u53ef\u4ee5\u5199\u4e00\u4e2aC++\u6a21\u5757\uff0c\u7136\u540e\u5728JS\u8c03\u7528\uff0cNode.js\u6b63\u662f\u5229\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\uff0c\u5b8c\u6210\u4e86\u529f\u80fd\u7684\u62d3\u5c55\u3002JS\u5c42\u8c03\u7528\u7684\u6240\u6709C\u3001C++\u6a21\u5757\u90fd\u662f\u901a\u8fc7V8\u6765\u5b8c\u6210\u7684\u3002","title":"1.1.1 JS\u5f15\u64ceV8"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#112-libuv","text":"Libuv\u662fNode.js\u5e95\u5c42\u7684\u5f02\u6b65IO\u5e93\uff0c\u4f46\u5b83\u63d0\u4f9b\u7684\u529f\u80fd\u4e0d\u4ec5\u4ec5\u662fIO\uff0c\u8fd8\u5305\u62ec\u8fdb\u7a0b\u3001\u7ebf\u7a0b\u3001\u4fe1\u53f7\u3001\u5b9a\u65f6\u5668\u3001\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7b49\uff0c\u800c\u4e14Libuv\u62b9\u5e73\u4e86\u5404\u4e2a\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u95f4\u7684\u5dee\u5f02\u3002Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u5927\u6982\u5982\u4e0b \u2022 Full-featured event loop backed by epoll, kqueue, IOCP, event ports. \u2022 Asynchronous TCP and UDP sockets \u2022 Asynchronous DNS resolution \u2022 Asynchronous file and file system operations \u2022 File system events \u2022 ANSI escape code controlled TTY \u2022 IPC with socket sharing, using Unix domain sockets or named pipes (Windows) \u2022 Child processes \u2022 Thread pool \u2022 Signal handling \u2022 High resolution clock \u2022 Threading and synchronization primitives Libuv\u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u7ecf\u5178\u7684\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\u3002Libuv\u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2d\uff0c\u6bcf\u4e00\u8f6e\u5faa\u73af\u90fd\u4f1a\u5904\u7406\u6bcf\u4e2a\u9636\u6bb5\uff08phase\uff09\u7ef4\u62a4\u7684\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u4efb\u52a1\u961f\u5217\u4e2d\u8282\u70b9\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u4e2d\uff0c\u4e0d\u65ad\u751f\u4ea7\u65b0\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u3002\u4e0b\u662fLibuv\u7684\u6574\u4f53\u6267\u884c\u6d41\u7a0b \u4ece\u4e0a\u56fe\u4e2d\u6211\u4eec\u5927\u81f4\u4e86\u89e3\u5230\uff0cLibuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u7136\u540e\u5728\u4e00\u4e2a\u5faa\u73af\u91cc\u4e0d\u65ad\u6267\u884c\u6bcf\u4e2a\u9636\u6bb5\u91cc\u7684\u4efb\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u770b\u4e00\u4e0b\u6bcf\u4e2a\u9636\u6bb5 \u66f4\u65b0\u5f53\u524d\u65f6\u95f4\uff0c\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u5230\u53d8\u91cf\u4e2d\uff0c\u8fd9\u4e00\u8f6e\u5faa\u73af\u7684\u5269\u4e0b\u64cd\u4f5c\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e2a\u53d8\u91cf\u83b7\u53d6\u5f53\u524d\u65f6\u95f4\uff0c\u907f\u514d\u8fc7\u591a\u7684\u7cfb\u7edf\u8c03\u7528\u5f71\u54cd\u6027\u80fd\uff0c\u989d\u5916\u7684\u5f71\u54cd\u5c31\u662f\u65f6\u95f4\u4e0d\u662f\u90a3\u4e48\u7cbe\u786e\u3002\u4f46\u662f\u5728\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0cLibuv\u5728\u5fc5\u8981\u7684\u65f6\u5019\uff0c\u4f1a\u4e3b\u52a8\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u6bd4\u5982\u5728epoll\u4e2d\u963b\u585e\u4e86timeout\u65f6\u95f4\u540e\u8fd4\u56de\u65f6\uff0c\u4f1a\u518d\u6b21\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u53d8\u91cf\u3002 \u5982\u679c\u4e8b\u4ef6\u5faa\u73af\u662f\u5904\u4e8ealive\u72b6\u6001\uff0c\u5219\u5f00\u59cb\u5904\u7406\u4e8b\u4ef6\u5faa\u73af\u7684\u6bcf\u4e2a\u9636\u6bb5\uff0c\u5426\u5219\u9000\u51fa\u8fd9\u4e2a\u4e8b\u4ef6\u5faa\u73af\u3002alive\u72b6\u6001\u662f\u4ec0\u4e48\u610f\u601d\u5462\uff1f\u5982\u679c\u6709active\u548cref\u72b6\u6001\u7684handle\uff0cactive\u72b6\u6001\u7684request\u6216\u8005closing\u72b6\u6001\u7684handle\u5219\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662falive\uff08\u5177\u4f53\u7684\u540e\u7eed\u4f1a\u8bb2\u5230\uff09\u3002 timer\u9636\u6bb5\uff1a\u5224\u65ad\u6700\u5c0f\u5806\u4e2d\u7684\u8282\u70b9\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 pending\u9636\u6bb5\uff1a\u6267\u884cpending\u56de\u8c03\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u6240\u6709\u7684IO\u56de\u8c03\uff08\u7f51\u7edc\uff0c\u6587\u4ef6\uff0cDNS\uff09\u90fd\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\uff0c\u4f46\u662f\u6709\u7684\u60c5\u51b5\u4e0b\uff0cPoll IO\u9636\u6bb5\u7684\u56de\u8c03\u4f1a\u5ef6\u8fdf\u5230\u4e0b\u4e00\u6b21\u5faa\u73af\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u79cd\u56de\u8c03\u5c31\u662f\u5728pending\u9636\u6bb5\u6267\u884c\u7684\uff0c\u6bd4\u5982IO\u56de\u8c03\u91cc\u51fa\u73b0\u4e86\u9519\u8bef\u6216\u5199\u6570\u636e\u6210\u529f\u7b49\u7b49\u90fd\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 idle\u9636\u6bb5\uff1a\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u90fd\u4f1a\u88ab\u6267\u884c\uff08idle\u4e0d\u662f\u8bf4\u4e8b\u4ef6\u5faa\u73af\u7a7a\u95f2\u7684\u65f6\u5019\u624d\u6267\u884c\uff09\u3002 prepare\u9636\u6bb5\uff1a\u548cidle\u9636\u6bb5\u7c7b\u4f3c\u3002 Poll IO\u9636\u6bb5\uff1a\u8c03\u7528\u5404\u5e73\u53f0\u63d0\u4f9b\u7684IO\u591a\u8def\u590d\u7528\u63a5\u53e3\uff08\u6bd4\u5982Linux\u4e0b\u5c31\u662fepoll\u6a21\u5f0f\uff09\uff0c\u6700\u591a\u7b49\u5f85timeout\u65f6\u95f4\uff0c\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002timeout\u7684\u8ba1\u7b97\u89c4\u5219\uff1a 1 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u662f\u4ee5UV_RUN_NOWAIT\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219timeout\u662f0\u3002 2 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u5373\u5c06\u9000\u51fa\uff08\u8c03\u7528\u4e86uv_stop\uff09\uff0c\u5219timeout\u662f0\u3002 3 \u5982\u679c\u6ca1\u6709active\u72b6\u6001\u7684handle\u6216\u8005request\uff0ctimeout\u662f0\u3002 4 \u5982\u679c\u6709idle\u9636\u6bb5\u7684\u961f\u5217\u91cc\u6709\u8282\u70b9\uff0c\u5219timeout\u662f0\u3002 5 \u5982\u679c\u6709handle\u7b49\u5f85\u88ab\u5173\u95ed\u7684\uff08\u5373\u8c03\u4e86uv_close\uff09\uff0ctimeout\u662f0\u3002 6 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\uff0c\u5219\u53d6timer\u9636\u6bb5\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u4f5c\u4e3atimeout\u3002 7 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\u5219timeout\u7b49\u4e8e-1\uff0c\u5373\u4e00\u76f4\u963b\u585e\uff0c\u76f4\u5230\u6ee1\u8db3\u6761\u4ef6\u3002 check\u9636\u6bb5\uff1a\u548cidle\u3001prepare\u4e00\u6837\u3002 closing\u9636\u6bb5\uff1a\u6267\u884c\u8c03\u7528uv_close\u51fd\u6570\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002 \u5982\u679cLibuv\u662f\u4ee5UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u90a3\u4e8b\u4ef6\u5faa\u73af\u5373\u5c06\u9000\u51fa\u3002\u4f46\u662f\u6709\u4e00\u79cd\u60c5\u51b5\u662f\uff0cPoll IO\u9636\u6bb5\u7684timeout\u7684\u503c\u662ftimer\u9636\u6bb5\u7684\u8282\u70b9\u7684\u503c\uff0c\u5e76\u4e14Poll IO\u9636\u6bb5\u662f\u56e0\u4e3a\u8d85\u65f6\u8fd4\u56de\u7684\uff0c\u5373\u6ca1\u6709\u4efb\u4f55\u4e8b\u4ef6\u53d1\u751f\uff0c\u4e5f\u6ca1\u6709\u6267\u884c\u4efb\u4f55IO\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u5728\u6267\u884c\u4e00\u6b21timer\u9636\u6bb5\u3002\u56e0\u4e3a\u6709\u8282\u70b9\u8d85\u65f6\u4e86\u3002 \u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\uff0c\u5982\u679cLibuv\u4ee5UV_RUN_NOWAIT \u6216 UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u679c\u662f\u4ee5UV_RUN_DEFAULT\u6a21\u5f0f\u8fd0\u884c\u7684\u5e76\u4e14\u72b6\u6001\u662falive\uff0c\u5219\u5f00\u59cb\u4e0b\u4e00\u8f6e\u5faa\u73af\u3002\u5426\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 \u4e0b\u9762\u6211\u80fd\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u6765\u4e86\u89e3libuv\u7684\u57fa\u672c\u539f\u7406\u3002 1. # include < stdio . h > 2. # include < uv . h > 3. 4. int64_t counter = 0 ; 5. 6. void wait_for_a_while ( uv_idle_t * handle ) { 7. counter ++ ; 8. if ( counter >= 10e6 ) 9. uv_idle_stop ( handle ); 10. } 11. 12. int main () { 13. uv_idle_t idler ; 14. // \u83b7\u53d6\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5e76\u521d\u59cb\u5316\u4e00\u4e2aidle 15. uv_idle_init ( uv_default_loop (), & idler ); 16. // \u5f80\u4e8b\u4ef6\u5faa\u73af\u7684idle\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1 17. uv_idle_start ( & idler , wait_for_a_while ); 18. // \u542f\u52a8\u4e8b\u4ef6\u5faa\u73af 19. uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); 20. // \u9500\u6bc1libuv\u7684\u76f8\u5173\u6570\u636e 21. uv_loop_close ( uv_default_loop ()); 22. return 0 ; 23. } \u4f7f\u7528Libuv\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u83b7\u53d6Libuv\u7684\u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_t\uff0cuv_loop_t\u662f\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u8bb0\u5f55\u4e86Libuv\u6574\u4e2a\u751f\u547d\u5468\u671f\u7684\u6570\u636e\u3002uv_default_loop\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u5df2\u7ecf\u521d\u59cb\u5316\u4e86\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5df1\u53bb\u5206\u914d\u4e00\u4e2a\uff0c\u81ea\u5df1\u521d\u59cb\u5316\u3002 1. uv_loop_t * uv_default_loop ( void ) { 2. // \u7f13\u5b58 3. if ( default_loop_ptr != NULL ) 4. return default_loop_ptr ; 5. 6. if ( uv_loop_init ( & default_loop_struct )) 7. return NULL ; 8. 9. default_loop_ptr = & default_loop_struct ; 10. return default_loop_ptr ; 11. } Libuv\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5168\u5c40\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528uv_loop_init\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u4e0d\u6253\u7b97\u5c55\u5f00\u8bb2\u89e3uv_loop_init\u51fd\u6570\uff0cw\u56e0\u4e3a\u5b83\u5927\u6982\u5c31\u662f\u5bf9uv_loop_t\u7ed3\u6784\u4f53\u5404\u4e2a\u5b57\u6bb5\u8fdb\u884c\u521d\u59cb\u5316\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0buv_idle_*\u7cfb\u5217\u7684\u51fd\u6570\u3002 1 uv_idle_init 1. int uv_idle_init ( uv_loop_t * loop , uv_idle_t * handle ) { 2. /* 3. \u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u6240\u5c5eloop\uff0c\u6253\u4e0aUV_HANDLE_REF\uff0c 4. \u5e76\u4e14\u628ahandle\u63d2\u5165loop->handle_queue\u961f\u5217\u7684\u961f\u5c3e 5. */ 6. uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_IDLE ); 7. handle -> idle_cb = NULL ; 8. return 0 ; 9. } \u6267\u884cuv_idle_init\u51fd\u6570\u540e\uff0cLibuv\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a 2 uv_idle_start 1. int uv_idle_start ( uv_idle_t * handle , uv_idle_cb cb ) { 2. // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de 3. if ( uv__is_active ( handle )) return 0 ; 4. // \u628ahandle\u63d2\u5165loop\u4e2didle\u7684\u961f\u5217 5. QUEUE_INSERT_HEAD ( & handle -> loop -> idle_handles , & handle -> queue ); 6. // \u6302\u8f7d\u56de\u8c03\uff0c\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684\u65f6\u5019\u88ab\u6267\u884c 7. handle -> idle_cb = cb ; 8. /* 9. \u8bbe\u7f6eUV_HANDLE_ACTIVE\u6807\u8bb0\u4f4d\uff0c\u5e76\u4e14loop\u4e2d\u7684handle\u6570\u52a0\u4e00\uff0c 10. init\u7684\u65f6\u5019\u53ea\u662f\u628ahandle\u6302\u8f7d\u5230loop\uff0cstart\u7684\u65f6\u5019handle\u624d 11. \u5904\u4e8e\u6fc0\u6d3b\u6001 12. */ 13. uv__handle_start ( handle ); 14. return 0 ; 15. } \u6267\u884c\u5b8cuv_idle_start\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u7136\u540e\u6267\u884cuv_run\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u3002 1. int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { 2. int timeout ; 3. int r ; 4. int ran_pending ; 5. // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop 6. r = uv__loop_alive ( loop ); 7. // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop 8. while ( r != 0 && loop -> stop_flag == 0 ) { 9. // \u5904\u7406idle\u961f\u5217 10. uv__run_idle ( loop ); 11. } 12. 13. // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag 14. if ( loop -> stop_flag != 0 ) 15. loop -> stop_flag = 0 ; 16. /* 17. \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c 18. \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run 19. */ 20. return r ; 21. } \u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2a\u51fd\u6570\u662fuv__run_idle\uff0c\u8fd9\u5c31\u662f\u5904\u7406idle\u9636\u6bb5\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1. // \u5728\u6bcf\u4e00\u8f6e\u5faa\u73af\u4e2d\u6267\u884c\u8be5\u51fd\u6570\uff0c\u6267\u884c\u65f6\u673a\u89c1uv_run 2. void uv__run_idle ( uv_loop_t * loop ) { 3. uv_idle_t * h ; 4. QUEUE queue ; 5. QUEUE * q ; 6. /* 7. \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c 8. \u53d8\u91cf\u56de\u8c03\u91cc\u4e0d\u65ad\u63d2\u5165\u65b0\u8282\u70b9\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af 9. */ 10. QUEUE_MOVE ( & loop -> idle_handles , & queue ); 11. // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 12. while ( ! QUEUE_EMPTY ( & queue )) { 13. // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9 14. q = QUEUE_HEAD ( & queue ); 15. // \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740 16. h = QUEUE_DATA ( q , uv_idle_t , queue ); 17. // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217\uff0c\u5426\u5219\u5faa\u73af\u4e0d\u4f1a\u7ed3\u675f 18. QUEUE_REMOVE ( q ); 19. // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 20. QUEUE_INSERT_TAIL ( & loop -> idle_handles , q ); 21. // \u6267\u884c\u56de\u8c03\u51fd\u6570 22. h -> idle_cb ( h ); 23. } 24. } \u6211\u4eec\u770b\u5230uv__run_idle\u7684\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5c31\u662f\u904d\u5386idle_handles\u961f\u5217\u7684\u8282\u70b9\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u63d2\u5165\u65b0\u7684\u8282\u70b9\uff08\u4ea7\u751f\u65b0\u4efb\u52a1\uff09\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u7684\u8fd0\u884c\u3002\u6211\u4eec\u770b\u5230uv_run\u9000\u51fa\u5faa\u73af\u7684\u6761\u4ef6\u4e0b\u9762\u7684\u4ee3\u7801\u4e3afalse\u3002 1. r != 0 && loop -> stop_flag == 0 stop_flag\u7531\u7528\u6237\u4e3b\u52a8\u5173\u95edLibuv\u4e8b\u4ef6\u5faa\u73af\u3002 1. void uv_stop ( uv_loop_t * loop ) { 2. loop -> stop_flag = 1 ; 3. } r\u662f\u4ee3\u8868\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u5b58\u6d3b\uff0c\u8fd9\u4e2a\u5224\u65ad\u7684\u6807\u51c6\u662f\u7531uv__loop_alive\u63d0\u4f9b 1. static int uv__loop_alive ( const uv_loop_t * loop ) { 2. return loop -> active_handles > 0 || 3. loop -> active_reqs . count > 0 || 4. loop -> closing_handles != NULL ; 5. } \u8fd9\u65f6\u5019\u6211\u4eec\u6709\u4e00\u4e2aactived handles\uff0c\u6240\u4ee5Libuv\u4e0d\u4f1a\u9000\u51fa\u3002\u5f53\u6211\u4eec\u8c03\u7528uv_idle_stop\u51fd\u6570\u628aidle\u8282\u70b9\u79fb\u51fahandle\u961f\u5217\u7684\u65f6\u5019\uff0cLibuv\u5c31\u4f1a\u9000\u51fa\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5177\u4f53\u5206\u6790Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u539f\u7406\u3002","title":"1.1.2 Libuv"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#113","text":"Node.js\u4e2d\u7b2c\u4e09\u65b9\u5e93\u5305\u62ec\u5f02\u6b65DNS\u89e3\u6790\uff08cares\uff09\u3001HTTP\u89e3\u6790\u5668\uff08\u65e7\u7248\u4f7f\u7528http_parser\uff0c\u65b0\u7248\u4f7f\u7528llhttp\uff09\u3001HTTP2\u89e3\u6790\u5668\uff08nghttp2\uff09\u3001\u89e3\u538b\u538b\u7f29\u5e93(zlib)\u3001\u52a0\u5bc6\u89e3\u5bc6\u5e93(openssl)\u7b49\u7b49\uff0c\u4e0d\u4e00\u4e00\u4ecb\u7ecd\u3002","title":"1.1.3 \u5176\u5b83\u7b2c\u4e09\u65b9\u5e93"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#12-nodejs","text":"","title":"1.2 Node.js\u5de5\u4f5c\u539f\u7406"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#121-nodejsjs","text":"V8\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u8c03\u7528C++\u3001C\u8bed\u8a00\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\u3002Node.js\u6b63\u662f\u901a\u8fc7\u8fd9\u5957\u673a\u5236\uff0c\u5b9e\u73b0\u4e86\u5bf9JS\u80fd\u529b\u7684\u62d3\u5c55\u3002Node.js\u5728\u5e95\u5c42\u505a\u4e86\u5927\u91cf\u7684\u4e8b\u60c5\uff0c\u5b9e\u73b0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u7136\u540e\u5728JS\u5c42\u66b4\u9732\u63a5\u53e3\u7ed9\u7528\u6237\u4f7f\u7528\uff0c\u964d\u4f4e\u4e86\u7528\u6237\u6210\u672c\uff0c\u4e5f\u63d0\u9ad8\u4e86\u5f00\u53d1\u6548\u7387\u3002","title":"1.2.1 Node.js\u662f\u5982\u4f55\u62d3\u5c55JS\u529f\u80fd\u7684\uff1f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#122-v8","text":"1. // C++\u91cc\u5b9a\u4e49 2. Handle < FunctionTemplate > Test = FunctionTemplate :: New ( cb ); 3. global -> Set ( String :: New ( \u201c Test \"), Test); 4. // JS\u91cc\u4f7f\u7528 5. const test = new Test (); \u6211\u4eec\u5148\u6709\u4e00\u4e2a\u611f\u6027\u7684\u8ba4\u8bc6\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u4f1a\u5177\u4f53\u8bb2\u89e3\u5982\u4f55\u4f7f\u7528V8\u62d3\u5c55JS\u7684\u529f\u80fd\u3002","title":"1.2.2 \u5982\u4f55\u5728V8\u65b0\u589e\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u529f\u80fd\uff1f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#123-nodejs","text":"Node.js\u5e76\u4e0d\u662f\u7ed9\u6bcf\u4e2a\u529f\u80fd\u90fd\u62d3\u5c55\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u6302\u8f7d\u5230\u5168\u5c40\u53d8\u91cf\u4e2d\uff0c\u800c\u662f\u62d3\u5c55\u4e00\u4e2aprocess\u5bf9\u8c61\uff0c\u518d\u901a\u8fc7process.binding\u62d3\u5c55js\u529f\u80fd\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5168\u5c40\u7684JS\u5bf9\u8c61process\uff0c\u6620\u5c04\u5230\u4e00\u4e2aC++\u5bf9\u8c61process\uff0c\u5e95\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2aC++\u6a21\u5757\u7684\u94fe\u8868\uff0cJS\u901a\u8fc7\u8c03\u7528JS\u5c42\u7684process.binding\uff0c\u8bbf\u95ee\u5230C++\u7684process\u5bf9\u8c61\uff0c\u4ece\u800c\u8bbf\u95eeC++\u6a21\u5757(\u7c7b\u4f3c\u8bbf\u95eeJS\u7684Object\u3001Date\u7b49)\u3002\u4e0d\u8fc7Node.js 14\u7248\u672c\u5df2\u7ecf\u6539\u6210internalBinding\u7684\u65b9\u5f0f\uff0c\u901a\u8fc7internalBinding\u5c31\u53ef\u4ee5\u8bbf\u95eeC++\u6a21\u5757\uff0c\u539f\u7406\u7c7b\u4f3c\u3002","title":"1.2.3 Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u62d3\u5c55\u7684?"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#13-nodejs","text":"\u4e0b\u9762\u662fNode.js\u542f\u52a8\u7684\u4e3b\u6d41\u7a0b\u56fe\u5982\u56fe1-4\u6240\u793a\u3002 \u6211\u4eec\u4ece\u4e0a\u5f80\u4e0b\uff0c\u770b\u4e00\u4e0b\u6bcf\u4e2a\u8fc7\u7a0b\u90fd\u505a\u4e86\u4e9b\u4ec0\u4e48\u4e8b\u60c5\u3002","title":"1.3 Node.js\u542f\u52a8\u8fc7\u7a0b"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#131-c","text":"RegisterBuiltinModules\u51fd\u6570\uff08node_binding.cc\uff09\u7684\u4f5c\u7528\u662f\u6ce8\u518cC++\u6a21\u5757\u3002 1. void RegisterBuiltinModules () { 2. # define V ( modname ) _register_ ## modname (); 3. NODE_BUILTIN_MODULES ( V ) 4. # undef V 5. } NODE_BUILTIN_MODULES\u662f\u4e00\u4e2aC\u8bed\u8a00\u5b8f\uff0c\u5b8f\u5c55\u5f00\u540e\u5982\u4e0b\uff08\u7701\u7565\u7c7b\u4f3c\u903b\u8f91\uff09 1. void RegisterBuiltinModules () { 2. # define V ( modname ) _register_ ## modname (); 3. V ( tcp_wrap ) 4. V ( timers ) 5. ... \u5176\u5b83\u6a21\u5757 6. # undef V 7. } \u518d\u4e00\u6b65\u5c55\u5f00\u5982\u4e0b 1. void RegisterBuiltinModules () { 2. _register_tcp_wrap (); 3. _register_timers (); 4. } \u6267\u884c\u4e86\u4e00\u7cfb\u5217_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u5728Node.js\u6e90\u7801\u91cc\u627e\u4e0d\u5230\u8fd9\u4e9b\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u51fd\u6570\u662f\u5728\u6bcf\u4e2aC++\u6a21\u5757\u5b9a\u4e49\u7684\u6587\u4ef6\u91cc\uff08.cc\u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c\uff09\u901a\u8fc7\u5b8f\u5b9a\u4e49\u7684\u3002\u4ee5tcp_wrap\u6a21\u5757\u4e3a\u4f8b\uff0c\u770b\u770b\u5b83\u662f\u600e\u4e48\u505a\u7684\u3002\u6587\u4ef6tcp_wrap.cc\u7684\u6700\u540e\u4e00\u53e5\u4ee3\u7801 NODE_MODULE_CONTEXT_AWARE_INTERNAL(tcp_wrap, node::TCPWrap::Initialize) \u5b8f\u5c55\u5f00\u662f 1. # define NODE_MODULE_CONTEXT_AWARE_INTERNAL ( modname , regfunc ) \\ 2. NODE_MODULE_CONTEXT_AWARE_CPP ( modname , 3. regfunc , 4. nullptr , 5. NM_F_INTERNAL ) \u7ee7\u7eed\u5c55\u5f00 6. # define NODE_MODULE_CONTEXT_AWARE_CPP ( modname , regfunc , priv , flags \\ 7. static node :: node_module _module = { \\ 8. NODE_MODULE_VERSION , \\ 9. flags , \\ 10. nullptr , \\ 11. __FILE__ , \\ 12. nullptr , \\ 13. ( node :: addon_context_register_func )( regfunc ), \\ 14. NODE_STRINGIFY ( modname ), \\ 15. priv , \\ 16. nullptr }; \\ 17. void _register_tcp_wrap () { node_module_register ( & _module ); } \u6211\u4eec\u770b\u5230\u6bcf\u4e2aC++\u6a21\u5757\u5e95\u5c42\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u5728Node.js\u542f\u52a8\u65f6\uff0c\u5c31\u4f1a\u628a\u8fd9\u4e9b\u51fd\u6570\u9010\u4e2a\u6267\u884c\u4e00\u904d\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8fd9\u4e9b\u51fd\u6570\u90fd\u505a\u4e86\u4ec0\u4e48\uff0c\u5728\u8fd9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0bNode.js\u4e2d\u8868\u793aC++\u6a21\u5757\u7684\u6570\u636e\u7ed3\u6784\u3002 1. struct node_module { 2. int nm_version ; 3. unsigned int nm_flags ; 4. void * nm_dso_handle ; 5. const char * nm_filename ; 6. node :: addon_register_func nm_register_func ; 7. node :: addon_context_register_func nm_context_register_func ; 8. const char * nm_modname ; 9. void * nm_priv ; 10. struct node_module * nm_link ; 11. }; \u6211\u4eec\u770b\u5230_register\u5f00\u5934\u7684\u51fd\u6570\u8c03\u4e86node_module_register\uff0c\u5e76\u4f20\u5165\u4e00\u4e2anode_module\u6570\u636e\u7ed3\u6784\uff0c\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0bnode_module_register\u7684\u5b9e\u73b0 1. void node_module_register ( void * m ) { 2. struct node_module * mp = reinterpret_cast < struct node_module *> ( m ); 3. if ( mp -> nm_flags & NM_F_INTERNAL ) { 4. mp -> nm_link = modlist_internal ; 5. modlist_internal = mp ; 6. } else if ( ! node_is_initialized ) { 7. mp -> nm_flags = NM_F_LINKED ; 8. mp -> nm_link = modlist_linked ; 9. modlist_linked = mp ; 10. } else { 11. thread_local_modpending = mp ; 12. } 13. } C++\u5185\u7f6e\u6a21\u5757\u7684flag\u662fNM_F_INTERNAL\uff0c\u6240\u4ee5\u4f1a\u6267\u884c\u7b2c\u4e00\u4e2aif\u7684\u903b\u8f91\uff0cmodlist_internal\u7c7b\u4f3c\u4e00\u4e2a\u5934\u6307\u9488\u3002if\u91cc\u7684\u903b\u8f91\u5c31\u662f\u5934\u63d2\u6cd5\u5efa\u7acb\u4e00\u4e2a\u5355\u94fe\u8868\u3002C++\u5185\u7f6e\u6a21\u5757\u5728Node.js\u91cc\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u5f88\u591a\u529f\u80fd\u90fd\u4f1a\u8c03\u7528\uff0c\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002","title":"1.3.1 \u6ce8\u518cC++\u6a21\u5757"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#132-environment","text":"1 CreateMainEnvironment Node.js\u4e2dEnvironment\u7c7b\uff08env.h\uff09\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7c7b\uff0cNode.js\u4e2d\uff0c\u5f88\u591a\u6570\u636e\u7531Environment\u5bf9\u8c61\u8fdb\u884c\u7ba1\u7406\u3002 1. context = NewContext ( isolate_ ); 2. std :: unique_ptr < Environment > env = std :: make_unique < Environment > ( 3. isolate_data_ . get (), 4. context , 5. args_ , 6. exec_args_ , 7. static_cast < Environment :: Flags > ( Environment :: kIsMainThread | 8. Environment :: kOwnsProcessState | Environment :: kOwnsInspector )); Isolate\uff0cContext\u662fV8\u4e2d\u7684\u6982\u5ff5\uff0cIsolate\u7528\u4e8e\u9694\u79bb\u5b9e\u4f8b\u95f4\u7684\u73af\u5883\uff0cContext\u7528\u4e8e\u63d0\u4f9bJS\u6267\u884c\u65f6\u7684\u4e0a\u4e0b\u6587\uff0ckIsMainThread\u8bf4\u660e\u5f53\u524d\u8fd0\u884c\u7684\u662f\u4e3b\u7ebf\u7a0b\uff0c\u7528\u4e8e\u533a\u5206Node.js\u4e2d\u7684worker_threads\u5b50\u7ebf\u7a0b\u3002Environment\u7c7b\u975e\u5e38\u5e9e\u5927\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u7684\u4ee3\u7801 1. Environment :: Environment ( IsolateData * isolate_data , 2. Local < Context > context , 3. const std :: vector < std :: string >& args , 4. const std :: vector < std :: string >& exec_args , 5. Flags flags , 6. uint64_t thread_id ) 7. : isolate_ ( context -> GetIsolate ()), 8. isolate_data_ ( isolate_data ), 9. immediate_info_ ( context -> GetIsolate ()), 10. tick_info_ ( context -> GetIsolate ()), 11. timer_base_ ( uv_now ( isolate_data -> event_loop ())), 12. exec_argv_ ( exec_args ), 13. argv_ ( args ), 14. exec_path_ ( GetExecPath ( args )), 15. should_abort_on_uncaught_toggle_ ( isolate_ , 1 ), 16. stream_base_state_ ( isolate_ , StreamBase :: kNumStreamBaseStateFields ), 17. flags_ ( flags ), 18. thread_id_ ( thread_id == kNoThreadId ? AllocateThreadId () : thread_id ), 19. fs_stats_field_array_ ( isolate_ , kFsStatsBufferLength ), 20. fs_stats_field_bigint_array_ ( isolate_ , kFsStatsBufferLength ), 21. context_ ( context -> GetIsolate (), context ) { 22. // \u8fdb\u5165\u5f53\u524d\u7684context 23. HandleScope handle_scope ( isolate ()); 24. Context :: Scope context_scope ( context ); 25. // \u4fdd\u5b58\u73af\u5883\u53d8\u91cf 26. set_env_vars ( per_process :: system_environment ); 27. // \u5173\u8054context\u548cenv 28. AssignToContext ( context , ContextInfo ( \"\" )); 29. // \u521b\u5efa\u5176\u5b83\u5bf9\u8c61 30. CreateProperties (); 31. } \u6211\u4eec\u53ea\u770b\u4e00\u4e0bAssignToContext\u548cCreateProperties\uff0cset_env_vars\u4f1a\u628a\u8fdb\u7a0b\u7ae0\u8282\u8bb2\u89e3\u3002 1.1 AssignToContext 1. inline void Environment :: AssignToContext ( v8 :: Local < v8 :: Context > context , 2. const ContextInfo & info ) { 3. // \u5728context\u4e2d\u4fdd\u5b58env\u5bf9\u8c61 4. context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kEnvironment , this ); 5. // Used by Environment::GetCurrent to know that we are on a node context. 6. context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kContextTag , Environment :: kNodeContextTagPtr ); 7. 8. } AssignToContext\u7528\u4e8e\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\u3002\u8fd9\u4e2a\u903b\u8f91\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u540e\u7eed\u6267\u884c\u4ee3\u7801\u65f6\uff0c\u6211\u4eec\u4f1a\u8fdb\u5165V8\u7684\u9886\u57df\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u77e5\u9053Isolate\u548ccontext\u3002\u5982\u679c\u4e0d\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\uff0c\u6211\u4eec\u5c31\u4e0d\u77e5\u9053\u5f53\u524d\u6240\u5c5e\u7684env\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u83b7\u53d6\u5bf9\u5e94\u7684env\u3002 1. inline Environment * Environment :: GetCurrent ( v8 :: Isolate * isolate ) { 2. v8 :: HandleScope handle_scope ( isolate ); 3. return GetCurrent ( isolate -> GetCurrentContext ()); 4. } 5. 6. inline Environment * Environment :: GetCurrent ( v8 :: Local < v8 :: Context > context ) { 7. return static_cast < Environment *> ( 8. context -> GetAlignedPointerFromEmbedderData ( ContextEmbedderIndex :: kEnvironment )); 9. } 1.2 CreateProperties \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bCreateProperties\u4e2d\u521b\u5efaprocess\u5bf9\u8c61\u7684\u903b\u8f91\u3002 1. Isolate * isolate = env -> isolate (); 2. EscapableHandleScope scope ( isolate ); 3. Local < Context > context = env -> context (); 4. // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 5. Local < FunctionTemplate > process_template = FunctionTemplate :: New ( isolate ); 6. process_template -> SetClassName ( env -> process_string ()); 7. // \u4fdd\u5b58\u51fd\u6570\u6a21\u677f\u751f\u6210\u7684\u51fd\u6570 8. Local < Function > process_ctor ; 9. // \u4fdd\u5b58\u51fd\u6570\u6a21\u5757\u751f\u6210\u7684\u51fd\u6570\u6240\u65b0\u5efa\u51fa\u6765\u7684\u5bf9\u8c61 10. Local < Object > process ; 11. if ( ! process_template -> GetFunction ( context ). ToLocal ( & process_ctor ) || ! process_ctor -> NewInstance ( context ). ToLocal ( & process )) { 12. return MaybeLocal < Object > (); 13. } process\u6240\u4fdd\u5b58\u7684\u5bf9\u8c61\u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u7528\u4f7f\u7528\u7684process\u5bf9\u8c61\u3002Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8fd8\u6302\u8f7d\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002 1. READONLY_PROPERTY ( process , 2. \"version\" , 3. FIXED_ONE_BYTE_STRING ( env -> isolate (), 4. NODE_VERSION )); 5. READONLY_STRING_PROPERTY ( process , \"arch\" , per_process :: metadata . arch );...... \u521b\u5efa\u5b8cprocess\u5bf9\u8c61\u540e\uff0cNode.js\u628aprocess\u4fdd\u5b58\u5230env\u4e2d\u3002 1. Local < Object > process_object = node :: CreateProcessObject ( this ). FromMaybe ( Local < Object > ()); 2. set_process_object ( process_object )","title":"1.3.2 \u521b\u5efaEnvironment\u5bf9\u8c61"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#133-libuv","text":"InitializeLibuv\u51fd\u6570\u4e2d\u7684\u903b\u8f91\u662f\u5f80Libuv\u4e2d\u63d0\u4ea4\u4efb\u52a1 \u3002 1. void Environment :: InitializeLibuv ( bool start_profiler_idle_notifier ) { 2. HandleScope handle_scope ( isolate ()); 3. Context :: Scope context_scope ( context ()); 4. CHECK_EQ ( 0 , uv_timer_init ( event_loop (), timer_handle ())); 5. uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); 6. uv_check_init ( event_loop (), immediate_check_handle ()); 7. uv_unref ( reinterpret_cast < uv_handle_t *> ( immediate_check_handle ())); 8. uv_idle_init ( event_loop (), immediate_idle_handle ()); 9. uv_check_start ( immediate_check_handle (), CheckImmediate ); 10. uv_prepare_init ( event_loop (), & idle_prepare_handle_ ); 11. uv_check_init ( event_loop (), & idle_check_handle_ ); 12. uv_async_init ( 13. event_loop (), 14. & task_queues_async_ , 15. []( uv_async_t * async ) { 16. Environment * env = ContainerOf ( 17. & Environment :: task_queues_async_ , async ); 18. env -> CleanupFinalizationGroups (); 19. env -> RunAndClearNativeImmediates (); 20. }); 21. uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_prepare_handle_ )); 22. uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_check_handle_ )); 23. uv_unref ( reinterpret_cast < uv_handle_t *> ( & task_queues_async_ )); 24. // \u2026 25. } \u8fd9\u4e9b\u51fd\u6570\u90fd\u662fLibuv\u63d0\u4f9b\u7684\uff0c\u5206\u522b\u662f\u5f80Libuv\u4e0d\u540c\u9636\u6bb5\u63d2\u5165\u4efb\u52a1\u8282\u70b9\uff0cuv_unref\u662f\u4fee\u6539\u72b6\u6001\u3002 1 timer_handle\u662f\u5b9e\u73b0Node.js\u4e2d\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684time\u9636\u6bb5 2 immediate_check_handle\u662f\u5b9e\u73b0Node.js\u4e2dsetImmediate\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684check\u9636\u6bb5\u3002 3 task_queues_async_\u7528\u4e8e\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002","title":"1.3.3 \u521d\u59cb\u5316Libuv\u4efb\u52a1"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#134-loader","text":"RunBootstrapping\u91cc\u8c03\u7528\u4e86BootstrapInternalLoaders\u548cBootstrapNode\u51fd\u6570\uff0c\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002 1 \u521d\u59cb\u5316loader BootstrapInternalLoaders\u7528\u4e8e\u6267\u884cinternal/bootstrap/loaders.js\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u903b\u8f91\u3002\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u7528\u4e8e\u5b9a\u4e49\u51fd\u6570\u7684\u5f62\u53c2\u5217\u8868\uff0c\u4e00\u4f1a\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002 1. std :: vector < Local < String >> loaders_params = { 2. process_string (), 3. FIXED_ONE_BYTE_STRING ( isolate_ , \"getLinkedBinding\" ), 4. FIXED_ONE_BYTE_STRING ( isolate_ , \"getInternalBinding\" ), 5. primordials_string ()}; \u7136\u540e\u518d\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u7528\u4f5c\u6267\u884c\u51fd\u6570\u65f6\u7684\u5b9e\u53c2\u3002 1. std :: vector < Local < Value >> loaders_args = { 2. process_object (), 3. NewFunctionTemplate ( binding :: GetLinkedBinding ) 4. -> GetFunction ( context ()) 5. . ToLocalChecked (), 6. NewFunctionTemplate ( binding :: GetInternalBinding ) 7. -> GetFunction ( context ()) 8. . ToLocalChecked (), 9. primordials ()}; \u63a5\u7740Node.js\u7f16\u8bd1\u6267\u884cinternal/bootstrap/loaders.js\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u94fe\u8def\u975e\u5e38\u957f\uff0c\u6700\u540e\u5230V8\u5c42\uff0c\u5c31\u4e0d\u8d34\u51fa\u5177\u4f53\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u7684\u903b\u8f91\u8f6c\u6210JS\u5982\u4e0b\u3002 1. function demo ( process , 2. getLinkedBinding , 3. getInternalBinding , 4. primordials ) { 5. // internal/bootstrap/loaders.js \u7684\u4ee3\u7801 6. } 7. const process = {}; 8. function getLinkedBinding (){} 9. function getInternalBinding () {} 10. const primordials = {}; 11. const export = demo ( process , 12. getLinkedBinding , 13. getInternalBinding , 14. primordials ); V8\u628ainternal/bootstrap/loaders.js\u7528\u4e00\u4e2a\u51fd\u6570\u5305\u88f9\u8d77\u6765\uff0c\u5f62\u53c2\u5c31\u662floaders_params\u53d8\u91cf\u5bf9\u5e94\u7684\u56db\u4e2a\u5b57\u7b26\u4e32\u3002\u7136\u540e\u6267\u884c\u8fd9\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u4f20\u5165loaders_args\u91cc\u7684\u90a3\u56db\u4e2a\u5bf9\u8c61\u3002internal/bootstrap/loaders.js\u4f1a\u5bfc\u51fa\u4e00\u4e2a\u5bf9\u8c61\u3002\u5728\u770binternal/bootstrap/loaders.js\u4ee3\u7801\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0bgetLinkedBinding, getInternalBinding\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0cNode.js\u5728C++\u5c42\u5bf9\u5916\u66b4\u9732\u4e86AddLinkedBinding\u65b9\u6cd5\u6ce8\u518c\u6a21\u5757\uff0cNode.js\u9488\u5bf9\u8fd9\u79cd\u7c7b\u578b\u7684\u6a21\u5757\uff0c\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5355\u72ec\u7684\u94fe\u8868\u3002getLinkedBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\uff0c\u4f46\u662f\u6211\u4eec\u4e00\u822c\u7528\u4e0d\u5230\u8fd9\u4e2a\uff0c\u6240\u4ee5\u5c31\u4e0d\u6df1\u5165\u5206\u6790\u3002\u524d\u9762\u6211\u4eec\u770b\u5230\u5bf9\u4e8eC++\u5185\u7f6e\u6a21\u5757\uff0cNode.js\u540c\u6837\u7ef4\u62a4\u4e86\u4e00\u4e2a\u94fe\u8868\uff0cgetInternalBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5177\u4f53\u770b\u4e00\u4e0binternal/bootstrap/loaders.js\u7684\u4ee3\u7801\u4e86\u3002 1. let internalBinding ; 2. { 3. const bindingObj = ObjectCreate ( null ); 4. internalBinding = function internalBinding ( module ) { 5. let mod = bindingObj [ module ]; 6. if ( typeof mod !== ' object ' ) { 7. mod = bindingObj [ module ] = getInternalBinding ( module ); 8. moduleLoadList . push ( ` Internal Binding $ { module } ` ); 9. } 10. return mod ; 11. }; 12. } Node.js\u5728JS\u5bf9getInternalBinding\u8fdb\u884c\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u4e3b\u8981\u662f\u52a0\u4e86\u7f13\u5b58\u5904\u7406\u3002 1. const internalBindingWhitelist = new SafeSet ([, 2. ' tcp_wrap ' , 3. // \u4e00\u7cfb\u5217C++\u5185\u7f6e\u6a21\u5757\u540d 4. ]); 5. 6. { 7. const bindingObj = ObjectCreate ( null ); 8. process . binding = function binding ( module ) { 9. module = String ( module ); 10. if ( internalBindingWhitelist . has ( module )) { 11. return internalBinding ( module ); 12. } 13. throw new Error ( ` No such module : $ { module } ` ); 14. }; 15. } \u5728process\u5bf9\u8c61\uff08\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684process\u5bf9\u8c61\uff09\u4e2d\u6302\u8f7dbinding\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u4e3b\u8981\u7528\u4e8e\u5185\u7f6e\u7684JS\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u7ecf\u5e38\u770b\u5230\u3002binding\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684C++\u6a21\u5757\u3002\u4e0a\u9762\u7684\u5904\u7406\u662f\u4e3a\u4e86Node.js\u80fd\u5728JS\u5c42\u901a\u8fc7binding\u51fd\u6570\u52a0\u8f7dC++\u6a21\u5757\uff0c\u6211\u4eec\u77e5\u9053Node.js\u4e2d\u8fd8\u6709\u539f\u751f\u7684JS\u6a21\u5757\uff08lib\u6587\u4ef6\u5939\u4e0b\u7684JS\u6587\u4ef6\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\uff0c\u5bf9\u4e8e\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u5904\u7406\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2aNativeModule\u7c7b\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u3002\u8fd8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u53d8\u91cf\u4fdd\u5b58\u4e86\u539f\u751fJS\u6a21\u5757\u7684\u540d\u79f0\u5217\u8868\u3002 static map = new Map ( moduleIds . map (( id ) => [ id , new NativeModule ( id )])); NativeModule\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u539f\u751fJS\u6a21\u5757\u7684\u4ee3\u7801\u662f\u8f6c\u6210\u5b57\u7b26\u5b58\u5728node_javascript.cc\u6587\u4ef6\u7684\uff0cNativeModule\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\uff0c\u5373\u7f16\u8bd1\u548c\u6267\u884c\u3002 2 \u63d0\u4f9b\u4e00\u4e2arequire\u51fd\u6570\uff0c\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\uff0c\u5bf9\u4e8e\u6587\u4ef6\u8def\u5f84\u4ee5internal\u5f00\u5934\u7684\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u88ab\u7528\u6237require\u4f7f\u7528\u7684\u3002 \u8fd9\u662f\u539f\u751fJS\u6a21\u5757\u52a0\u8f7d\u7684\u5927\u6982\u903b\u8f91\uff0c\u5177\u4f53\u7684\u6211\u4eec\u5728Node.js\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u5177\u4f53\u5206\u6790\u3002\u6267\u884c\u5b8cinternal/bootstrap/loaders.js\uff0c\u6700\u540e\u8fd4\u56de\u4e09\u4e2a\u53d8\u91cf\u7ed9C++\u5c42\u3002 1. return { 2. internalBinding , 3. NativeModule , 4. require : nativeModuleRequire 5. }; C++\u5c42\u4fdd\u5b58\u5176\u4e2d\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u4e8e\u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757\u548c\u539f\u751fJS\u6a21\u5757\u7684\u51fd\u6570\u3002 1. set_internal_binding_loader ( internal_binding_loader . As < Function > ()); 2. set_native_module_require ( require . As < Function > ()); \u81f3\u6b64\uff0cinternal/bootstrap/loaders.js\u5206\u6790\u5b8c\u4e86\u3002 2 \u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587 BootstrapNode\u8d1f\u8d23\u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u4ee3\u7801\u5982\u4e0b 1. EscapableHandleScope scope ( isolate_ ); 2. // \u83b7\u53d6\u5168\u5c40\u53d8\u91cf\u5e76\u8bbe\u7f6eglobal\u5c5e\u6027 3. Local < Object > global = context () -> Global (); 4. global -> Set ( context (), FIXED_ONE_BYTE_STRING ( isolate_ , \"global\" ), global ). Check (); 5. /* 6. \u6267\u884cinternal/bootstrap/node.js\u65f6\u7684\u53c2\u6570 7. process, require, internalBinding, primordials 8. */ 9. std :: vector < Local < String >> node_params = { 10. process_string (), 11. require_string (), 12. internal_binding_string (), 13. primordials_string ()}; 14. std :: vector < Local < Value >> node_args = { 15. process_object (), 16. // \u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668 17. native_module_require (), 18. // C++\u6a21\u5757\u52a0\u8f7d\u5668 19. internal_binding_loader (), 20. primordials ()}; 21. 22. MaybeLocal < Value > result = ExecuteBootstrapper ( 23. this , \"internal/bootstrap/node\" , & node_params , & node_args ); \u5728\u5168\u5c40\u5bf9\u8c61\u4e0a\u8bbe\u7f6e\u4e00\u4e2aglobal\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5728Node.js\u4e2d\u4f7f\u7528\u7684global\u5bf9\u8c61\u3002\u63a5\u7740\u6267\u884cinternal/bootstrap/node.js\u8bbe\u7f6e\u4e00\u4e9b\u53d8\u91cf\uff08\u5177\u4f53\u53ef\u4ee5\u53c2\u8003nternal/bootstrap/node.js\uff09\u3002 1. process . cpuUsage = wrapped . cpuUsage ; 2. process . resourceUsage = wrapped . resourceUsage ; 3. process . memoryUsage = wrapped . memoryUsage ; 4. process . kill = wrapped . kill ; 5. process . exit = wrapped . exit ; \u8bbe\u7f6e\u5168\u5c40\u53d8\u91cf 1. defineOperation ( global , ' clearInterval ' , timers . clearInterval ); 2. defineOperation ( global , ' clearTimeout ' , timers . clearTimeout ); 3. defineOperation ( global , ' setInterval ' , timers . setInterval ); 4. defineOperation ( global , ' setTimeout ' , timers . setTimeout ); 5. ObjectDefineProperty ( global , ' process ' , { 6. value : process , 7. enumerable : false , 8. writable : true , 9. configurable : true 10. });","title":"1.3.4 \u521d\u59cb\u5316Loader\u548c\u6267\u884c\u4e0a\u4e0b\u6587"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#135-js","text":"StartMainThreadExecution\u8fdb\u884c\u4e00\u4e9b\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u7136\u540e\u6267\u884c\u7528\u6237JS\u4ee3\u7801\u3002 1 \u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027 \u6267\u884cpatchProcessObject\u51fd\u6570\uff08\u5728node_process_methods.cc\u4e2d\u5bfc\u51fa\uff09\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e9b\u5217\u5c5e\u6027\uff0c\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1. // process.argv 2. process -> Set ( context , 3. FIXED_ONE_BYTE_STRING ( isolate , \"argv\" ), 4. ToV8Value ( context , env -> argv ()). ToLocalChecked ()). Check (); 5. 6. READONLY_PROPERTY ( process , 7. \"pid\" , 8. Integer :: New ( isolate , uv_os_getpid ())); \u56e0\u4e3aNode.js\u589e\u52a0\u4e86\u5bf9\u7ebf\u7a0b\u7684\u652f\u6301\uff0c\u6709\u4e9b\u5c5e\u6027\u9700\u8981hack\u4e00\u4e0b\uff0c\u6bd4\u5982\u5728\u7ebf\u7a0b\u91cc\u4f7f\u7528process.exit\u7684\u65f6\u5019\uff0c\u9000\u51fa\u7684\u662f\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\uff0cexit\u7b49\u51fd\u6570\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002\u540e\u9762\u7ae0\u8282\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002 2 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 1. function setupChildProcessIpcChannel () { 2. if ( process . env . NODE_CHANNEL_FD ) { 3. const fd = parseInt ( process . env . NODE_CHANNEL_FD , 10 ); 4. delete process . env . NODE_CHANNEL_FD ; 5. const serializationMode = 6. process . env . NODE_CHANNEL_SERIALIZATION_MODE || ' json ' ; 7. delete process . env . NODE_CHANNEL_SERIALIZATION_MODE ; 8. require ( ' child_process ' ). _forkChild ( fd , serializationMode ); 9. } 10. } \u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u662f\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8bf4\u660e\u5f53\u524d\u542f\u52a8\u7684\u8fdb\u7a0b\u662f\u5b50\u8fdb\u7a0b\uff0c\u5219\u9700\u8981\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 3 \u5904\u7406cluster\u6a21\u5757\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1 1. function initializeclusterIPC () { 2. if ( process . argv [ 1 ] && process . env . NODE_UNIQUE_ID ) { 3. const cluster = require ( ' cluster ' ); 4. cluster . _setupWorker (); 5. delete process . env . NODE_UNIQUE_ID ; 6. } 7. } 4 \u6267\u884c\u7528\u6237JS\u4ee3\u7801 require ( ' internal / modules / cjs / loader ' ). Module . runMain ( process . argv [ 1 ]); internal/modules/cjs/loader.js\u662f\u8d1f\u8d23\u52a0\u8f7d\u7528\u6237JS\u7684\u6a21\u5757\uff0crunMain\u51fd\u6570\u5728pre_execution.js\u88ab\u6302\u8f7d\uff0crunMain\u505a\u7684\u4e8b\u60c5\u662f\u52a0\u8f7d\u7528\u6237\u7684JS\uff0c\u7136\u540e\u6267\u884c\u3002\u5177\u4f53\u7684\u8fc7\u7a0b\u5728\u540e\u9762\u7ae0\u8282\u8be6\u7ec6\u5206\u6790\u3002","title":"1.3.5 \u6267\u884c\u7528\u6237JS\u6587\u4ef6"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#136-libuv","text":"\u6267\u884c\u5b8c\u6240\u6709\u7684\u521d\u59cb\u5316\u540e\uff0cNode.js\u6267\u884c\u4e86\u7528\u6237\u7684JS\u4ee3\u7801\uff0c\u7528\u6237\u7684JS\u4ee3\u7801\u4f1a\u5f80Libuv\u6ce8\u518c\u4e00\u4e9b\u4efb\u52a1\uff0c\u6bd4\u5982\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u6700\u540eNode.js\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u5f00\u59cb\u4e00\u8f6e\u53c8\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u5904\u7406\u3002\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\uff0cLibuv\u4f1a\u9000\u51fa\uff0c\u4ece\u800cNode.js\u9000\u51fa\u3002 1. do { 2. uv_run ( env -> event_loop (), UV_RUN_DEFAULT ); 3. per_process :: v8_platform . DrainVMTasks ( isolate_ ); 4. more = uv_loop_alive ( env -> event_loop ()); 5. if ( more && ! env -> is_stopping ()) continue ; 6. if ( ! uv_loop_alive ( env -> event_loop ())) { 7. EmitBeforeExit ( env . get ()); 8. } 9. more = uv_loop_alive ( env -> event_loop ()); 10. } while ( more == true && ! env -> is_stopping ());","title":"1.3.6 \u8fdb\u5165Libuv\u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#14-nodejs","text":"\u670d\u52a1\u5668\u662f\u73b0\u4ee3\u8f6f\u4ef6\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u7ec4\u6210\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u53d1\u5c55\u7684\u8fc7\u7a0b\u4e2d\uff0c\u90fd\u6709\u54ea\u4e9b\u8bbe\u8ba1\u67b6\u6784\u3002\u4e00\u4e2a\u57fa\u4e8eTCP\u534f\u8bae\u7684\u670d\u52a1\u5668\uff0c\u57fa\u672c\u7684\u6d41\u7a0b\u5982\u4e0b\uff08\u4f2a\u4ee3\u7801\uff09\u3002 1. // \u62ff\u5230\u4e00\u4e2asocket\u7528\u4e8e\u76d1\u542c 2. const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); 3. // \u76d1\u542c\u672c\u673a\u7684\u5730\u5740\uff08ip+\u7aef\u53e3\uff09 4. bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) 5. // \u6807\u8bb0\u8be5socket\u662f\u76d1\u542c\u578bsocket 6. listen ( socketfd ) \u6267\u884c\u5b8c\u4ee5\u4e0a\u6b65\u9aa4\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u6b63\u5f0f\u5f00\u59cb\u670d\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u4e0a\u9762\u7684\u6a21\u578b\uff0c\u5206\u6790\u5404\u79cd\u5404\u6837\u7684\u5904\u7406\u65b9\u6cd5\u3002","title":"1.4 Node.js\u548c\u5176\u5b83\u670d\u52a1\u5668\u7684\u6bd4\u8f83"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#141","text":"1. while ( 1 ) { 2. const socketForCommunication = accept ( socket ); 3. const data = read ( socketForCommunication ); 4. handle ( data ); 5. write ( socketForCommunication , data ); 6. } \u6211\u4eec\u770b\u770b\u8fd9\u79cd\u6a21\u5f0f\u7684\u5904\u7406\u8fc7\u7a0b\uff0c\u5047\u8bbe\u6709n\u4e2a\u8bf7\u6c42\u5230\u6765\u3002\u90a3\u4e48socket\u7684\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u8fd9\u65f6\u5019\u8fdb\u7a0b\u4eceaccept\u4e2d\u88ab\u5524\u9192\u3002\u7136\u540e\u62ff\u5230\u4e00\u4e2a\u65b0\u7684socket\u7528\u4e8e\u901a\u4fe1\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 accept\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u961f\u5217\u91cc\uff0c\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u5f88\u591a\u540c\u5b66\u90fd\u4e86\u89e3\u4e09\u6b21\u63e1\u624b\u662f\u4ec0\u4e48\uff0c\u4f46\u662f\u53ef\u80fd\u5f88\u5c11\u540c\u5b66\u4f1a\u6df1\u5165\u601d\u8003\u6216\u8005\u770b\u5b83\u7684\u5b9e\u73b0\uff0c\u4f17\u6240\u5468\u77e5\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u76d1\u542c\u4e00\u4e2a\u7aef\u53e3\uff0c\u5176\u5b9e\u5c31\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u3002\u90a3\u4e48\u5982\u679c\u6709\u4e00\u4e2a\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u6211\u4eec\u901a\u8fc7accept\u5c31\u80fd\u62ff\u5230\u8fd9\u4e2a\u65b0\u8fde\u63a5\u5bf9\u5e94\u7684socket\uff0c\u90a3\u8fd9\u4e2asocket\u548c\u76d1\u542c\u7684socket\u662f\u4e0d\u662f\u540c\u4e00\u4e2a\u5462\uff1f\u5176\u5b9esocket\u5206\u4e3a\u76d1\u542c\u578b\u548c\u901a\u4fe1\u578b\u7684\uff0c\u8868\u9762\u4e0a\uff0c\u670d\u52a1\u5668\u7528\u4e00\u4e2a\u7aef\u53e3\u5b9e\u73b0\u4e86\u591a\u4e2a\u8fde\u63a5\uff0c\u4f46\u662f\u8fd9\u4e2a\u7aef\u53e3\u662f\u7528\u4e8e\u76d1\u542c\u7684\uff0c\u5e95\u5c42\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5176\u5b9e\u662f\u53e6\u4e00\u4e2asocket\u3002\u6240\u4ee5\u6bcf\u4e00\u4e2a\u8fde\u63a5\u8fc7\u6765\uff0c\u8d1f\u8d23\u76d1\u542c\u7684socket\u53d1\u73b0\u662f\u4e00\u4e2a\u5efa\u7acb\u8fde\u63a5\u7684\u5305\uff08syn\u5305\uff09\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a\u65b0\u7684socket\u4e0e\u4e4b\u901a\u4fe1\uff08accept\u7684\u65f6\u5019\u8fd4\u56de\u7684\u90a3\u4e2a\uff09\u3002\u76d1\u542csocket\u91cc\u53ea\u4fdd\u5b58\u4e86\u5b83\u76d1\u542c\u7684IP\u548c\u7aef\u53e3\uff0c\u901a\u4fe1socket\u9996\u5148\u4ece\u76d1\u542csocket\u4e2d\u590d\u5236IP\u548c\u7aef\u53e3\uff0c\u7136\u540e\u628a\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\u4e5f\u8bb0\u5f55\u4e0b\u6765\uff0c\u5f53\u4e0b\u6b21\u6536\u5230\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636e\u56db\u5143\u7ec4\u4ecesocket\u6c60\u5b50\u91cc\u627e\u5230\u8be5socket\uff0c\u4ece\u800c\u5b8c\u6210\u6570\u636e\u7684\u5904\u7406\u3002 \u4e32\u884c\u8fd9\u79cd\u6a21\u5f0f\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u961f\u5217\u91cc\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u5904\u7406\u3002\u518d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u518d\u5904\u7406\u3002\u5982\u679c\u5904\u7406\u7684\u8fc7\u7a0b\u4e2d\u6709\u963b\u585e\u5f0fIO\uff0c\u53ef\u60f3\u800c\u77e5\uff0c\u6548\u7387\u662f\u6709\u591a\u4f4e\u3002\u800c\u4e14\u5e76\u53d1\u91cf\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u76d1\u542csocket\u5bf9\u5e94\u7684\u961f\u5217\u5f88\u5feb\u5c31\u4f1a\u88ab\u5360\u6ee1\uff08\u5df2\u5b8c\u6210\u8fde\u63a5\u961f\u5217\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\uff09\u3002\u8fd9\u662f\u6700\u7b80\u5355\u7684\u6a21\u5f0f\uff0c\u867d\u7136\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u80af\u5b9a\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u79cd\u6a21\u5f0f\uff0c\u4f46\u662f\u5b83\u8ba9\u6211\u4eec\u4e86\u89e3\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u7684\u6574\u4f53\u8fc7\u7a0b\u3002","title":"1.4.1 \u4e32\u884c\u5904\u7406\u8bf7\u6c42"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#142","text":"\u4e32\u884c\u6a21\u5f0f\u4e2d\uff0c\u6240\u6709\u8bf7\u6c42\u90fd\u5728\u4e00\u4e2a\u8fdb\u7a0b\u4e2d\u6392\u961f\u88ab\u5904\u7406\uff0c\u8fd9\u662f\u6548\u7387\u4f4e\u4e0b\u7684\u539f\u56e0\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u628a\u8bf7\u6c42\u5206\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u5904\u7406\u6765\u63d0\u4f9b\u6548\u7387\uff0c\u56e0\u4e3a\u5728\u4e32\u884c\u5904\u7406\u7684\u6a21\u5f0f\u4e2d\uff0c\u5982\u679c\u6709\u963b\u585e\u5f0fIO\u64cd\u4f5c\uff0c\u5b83\u5c31\u4f1a\u963b\u585e\u4e3b\u8fdb\u7a0b\uff0c\u4ece\u800c\u963b\u585e\u540e\u7eed\u8bf7\u6c42\u7684\u5904\u7406\u3002\u5728\u591a\u8fdb\u7a0b\u7684\u6a21\u5f0f\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u5982\u679c\u963b\u585e\u4e86\u8fdb\u7a0b\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6302\u8d77\u8be5\u8fdb\u7a0b\uff0c\u63a5\u7740\u8c03\u5ea6\u5176\u5b83\u8fdb\u7a0b\u6267\u884c\uff0c\u90a3\u4e48\u5176\u5b83\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u6267\u884c\u65b0\u7684\u4efb\u52a1\u3002\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e0b\u5206\u4e3a\u51e0\u79cd\u3002 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u6458\u53d6\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u8282\u70b9\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u7684\u8bf7\u6c42\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\uff0c\u903b\u8f91\u5982\u4e0b\u3002 1. while ( 1 ) { 2. const socketForCommunication = accept ( socket ); 3. if ( fork () > 0 ) { 4. continue ; 5. // \u7236\u8fdb\u7a0b 6. } else { 7. // \u5b50\u8fdb\u7a0b 8. handle ( socketForCommunication ); 9. } 10. } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u6bcf\u6b21\u6765\u4e00\u4e2a\u8bf7\u6c42\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u53bb\u5904\u7406\u3002\u8fd9\u79cd\u6a21\u5f0f\u6bd4\u4e32\u884c\u7684\u7a0d\u5fae\u597d\u4e86\u4e00\u70b9\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u72ec\u7acb\u5904\u7406\uff0c\u5047\u8bbea\u8bf7\u6c42\u963b\u585e\u5728\u6587\u4ef6IO\uff0c\u90a3\u4e48\u4e0d\u4f1a\u5f71\u54cdb\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u5c3d\u53ef\u80fd\u5730\u505a\u5230\u4e86\u5e76\u53d1\u3002\u5b83\u7684\u74f6\u9888\u5c31\u662f\u7cfb\u7edf\u7684\u8fdb\u7a0b\u6570\u6709\u9650\uff0c\u5982\u679c\u6709\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u65e0\u6cd5\u625b\u5f97\u4f4f\uff0c\u518d\u8005\uff0c\u8fdb\u7a0b\u7684\u5f00\u9500\u5f88\u5927\uff0c\u5bf9\u4e8e\u7cfb\u7edf\u6765\u8bf4\u662f\u4e00\u4e2a\u6c89\u91cd\u7684\u8d1f\u62c5\u3002 2 \u8fdb\u7a0b\u6c60\u6a21\u5f0f \u5b9e\u65f6\u521b\u5efa\u548c\u9500\u6bc1\u8fdb\u7a0b\u5f00\u9500\u5927\uff0c\u6548\u7387\u4f4e\uff0c\u6240\u4ee5\u884d\u751f\u4e86\u8fdb\u7a0b\u6c60\u6a21\u5f0f\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u5c31\u662f\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u9884\u5148\u521b\u5efa\u4e00\u5b9a\u6570\u91cf\u7684\u8fdb\u7a0b\uff0c\u4f46\u662f\u8fd9\u4e9b\u8fdb\u7a0b\u662fworker\u8fdb\u7a0b\u3002\u5b83\u4e0d\u8d1f\u8d23accept\u8bf7\u6c42\u3002\u5b83\u53ea\u8d1f\u8d23\u5904\u7406\u8bf7\u6c42\u3002\u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\uff0c\u5b83\u628aaccept\u8fd4\u56de\u7684socket\u4ea4\u7ed9worker\u8fdb\u7a0b\u5904\u7406\uff0c\u6a21\u5f0f\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4f46\u662f\u548c1\u4e2d\u7684\u6a21\u5f0f\u76f8\u6bd4\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0c\u56e0\u4e3a\u5728\u6a21\u5f0f1\u4e2d\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b9e\u65f6fork\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u8fd9\u65f6\u5019\uff0c\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u4e2d\u65b0\u8bf7\u6c42\u5bf9\u5e94\u7684fd\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u76f4\u63a5\u5904\u7406\u8be5fd\u5bf9\u5e94\u7684\u8bf7\u6c42\uff0c\u5728\u8fdb\u7a0b\u6c60\u7684\u6a21\u5f0f\u4e2d\uff0c\u5b50\u8fdb\u7a0b\u662f\u9884\u5148\u521b\u5efa\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4e2d\u662f\u65e0\u6cd5\u62ff\u5f97\u5230\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u7684\u3002\u8fd9\u65f6\u5019\uff0c\u9700\u8981\u4e3b\u8fdb\u7a0b\u4f7f\u7528\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u6280\u672f\u628a\u8fd9\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4e00\u4e2a\u8fdb\u7a0b\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53task_struct\uff0c\u5728JS\u91cc\u6211\u4eec\u53ef\u4ee5\u8bf4\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5b83\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5f53\u6211\u4eec\u8bbf\u95ee\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636efd\u7684\u503c\uff0c\u4ecetask_struct\u4e2d\u627e\u5230fd\u5bf9\u5e94\u7684\u5e95\u5c42\u8d44\u6e90\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u4f20\u9012\u7684\u4e0d\u4ec5\u4ec5\u662f\u4e00\u4e2a\u6570\u5b57fd\uff0c\u56e0\u4e3a\u5982\u679c\u4ec5\u4ec5\u8fd9\u6837\u505a\uff0c\u5728\u5b50\u8fdb\u7a0b\u4e2d\u8be5fd\u53ef\u80fd\u6ca1\u6709\u5bf9\u5e94\u4efb\u4f55\u8d44\u6e90\uff0c\u6216\u8005\u5bf9\u5e94\u7684\u8d44\u6e90\u548c\u4e3b\u8fdb\u7a0b\u4e2d\u7684\u662f\u4e0d\u4e00\u81f4\u7684\u3002\u8fd9\u5176\u4e2d\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u6211\u4eec\u505a\u4e86\u5f88\u591a\u4e8b\u60c5\u3002\u8ba9\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u901a\u8fc7fd\u8bbf\u95ee\u5230\u6b63\u786e\u7684\u8d44\u6e90\uff0c\u5373\u4e3b\u8fdb\u7a0b\u4e2d\u6536\u5230\u7684\u8bf7\u6c42\u3002 3 \u5b50\u8fdb\u7a0baccept \u8fd9\u79cd\u6a21\u5f0f\u4e0d\u662f\u7b49\u5230\u8bf7\u6c42\u6765\u7684\u65f6\u5019\u518d\u521b\u5efa\u8fdb\u7a0b\u3002\u800c\u662f\u5728\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u521b\u5efa\u591a\u4e2a\u8fdb\u7a0b\u3002\u7136\u540e\u591a\u4e2a\u8fdb\u7a0b\u5206\u522b\u8c03\u7528accept\u3002\u8fd9\u79cd\u6a21\u5f0f\u7684\u67b6\u6784\u5982\u56fe1-8\u6240\u793a\u3002 1. const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); 2. bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) 3. 4. for ( let i = 0 ; i < \u8fdb\u7a0b\u4e2a\u6570 ; i ++ ) { 5. if ( fork () > 0 ) { 6. // \u7236\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u63a7\u5b50\u8fdb\u7a0b 7. } else { 8. // \u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 9. listen ( socketfd ); 10. while ( 1 ) { 11. const socketForCommunication = accept ( socketfd ); 12. handle ( socketForCommunication ); 13. } 14. } 15. } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\u591a\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u963b\u585e\u5728accept\u3002\u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\uff0c\u90a3\u4e48\u6240\u6709\u7684\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u88ab\u5524\u9192\uff0c\u4f46\u662f\u9996\u5148\u88ab\u8c03\u5ea6\u7684\u5b50\u8fdb\u7a0b\u4f1a\u9996\u5148\u6458\u4e0b\u8fd9\u4e2a\u8bf7\u6c42\u8282\u70b9\uff0c\u540e\u7eed\u7684\u8fdb\u7a0b\u88ab\u5524\u9192\u540e\u53ef\u80fd\u4f1a\u9047\u5230\u5df2\u7ecf\u6ca1\u6709\u8bf7\u6c42\u53ef\u4ee5\u5904\u7406\uff0c\u53c8\u8fdb\u5165\u7761\u7720\uff0c\u8fdb\u7a0b\u88ab\u65e0\u6548\u5524\u9192\uff0c\u8fd9\u662f\u8457\u540d\u7684\u60ca\u7fa4\u73b0\u8c61\u3002\u6539\u8fdb\u65b9\u5f0f\u5c31\u662f\u5728accpet\u4e4b\u524d\u52a0\u9501\uff0c\u62ff\u5230\u9501\u7684\u8fdb\u7a0b\u624d\u80fd\u8fdb\u884caccept\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u963b\u585e\u5728accept\uff0cNginx\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u662f\u65b0\u7248\u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u5728\u5185\u6838\u5c42\u9762\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002\u6bcf\u6b21\u53ea\u4f1a\u5524\u9192\u4e00\u4e2a\u8fdb\u7a0b\u3002\u901a\u5e38\u8fd9\u79cd\u6a21\u5f0f\u548c\u4e8b\u4ef6\u9a71\u52a8\u914d\u5408\u4f7f\u7528\u3002","title":"1.4.2 \u591a\u8fdb\u7a0b\u6a21\u5f0f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#143","text":"\u591a\u7ebf\u7a0b\u6a21\u5f0f\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u662f\u7c7b\u4f3c\u7684\uff0c\u4e5f\u662f\u5206\u4e3a\u4e0b\u9762\u51e0\u79cd 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u521b\u5efa\u5b50\u7ebf\u7a0b\u5904\u7406 2 \u5b50\u7ebf\u7a0baccept 3 \u7ebf\u7a0b\u6c60 \u524d\u9762\u4e24\u79cd\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e2d\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u79cd\u6bd4\u8f83\u7279\u522b\uff0c\u6211\u4eec\u4e3b\u8981\u4ecb\u7ecd\u7b2c\u4e09\u79cd\u3002\u5728\u5b50\u8fdb\u7a0b\u6a21\u5f0f\u65f6\uff0c\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u6709\u81ea\u5df1\u7684task_struct\uff0c\u8fd9\u5c31\u610f\u5473\u7740\u5728fork\u4e4b\u540e\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u8d1f\u8d23\u7ef4\u62a4\u81ea\u5df1\u7684\u6570\u636e\uff0c\u800c\u7ebf\u7a0b\u5219\u4e0d\u4e00\u6837\uff0c\u7ebf\u7a0b\u662f\u5171\u4eab\u4e3b\u7ebf\u7a0b\uff08\u4e3b\u8fdb\u7a0b\uff09\u7684\u6570\u636e\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u4eceaccept\u4e2d\u62ff\u5230\u4e00\u4e2afd\u7684\u65f6\u5019\uff0c\u4f20\u7ed9\u7ebf\u7a0b\u7684\u8bdd\uff0c\u7ebf\u7a0b\u662f\u53ef\u4ee5\u76f4\u63a5\u64cd\u4f5c\u7684\u3002\u6240\u4ee5\u5728\u7ebf\u7a0b\u6c60\u6a21\u5f0f\u65f6\uff0c\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1\u5230\u5171\u4eab\u961f\u5217\u4e2d\uff0c\u7ebf\u7a0b\u6c60\u4e2d\u7684\u5b50\u7ebf\u7a0b\u540c\u6837\u662f\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\uff0c\u4ece\u5171\u4eab\u961f\u5217\u4e2d\u6458\u53d6\u8282\u70b9\u8fdb\u884c\u5904\u7406\u3002","title":"1.4.3 \u591a\u7ebf\u7a0b\u6a21\u5f0f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#144","text":"\u73b0\u5728\u5f88\u591a\u670d\u52a1\u5668\uff08Nginx\uff0cNode.js\uff0cRedis\uff09\u90fd\u5f00\u59cb\u4f7f\u7528\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u53bb\u8bbe\u8ba1\u3002\u4ece\u4e4b\u524d\u7684\u8bbe\u8ba1\u6a21\u5f0f\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u4e3a\u4e86\u5e94\u5bf9\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u670d\u52a1\u5668\u9700\u8981\u5927\u91cf\u7684\u8fdb\u7a0b/\u7ebf\u7a0b\u3002\u8fd9\u4e2a\u662f\u4e2a\u975e\u5e38\u5927\u7684\u5f00\u9500\u3002\u800c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\uff0c\u4e00\u822c\u662f\u914d\u5408\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\uff0c\u518d\u591a\u7684\u8bf7\u6c42\uff0c\u4e5f\u662f\u5728\u4e00\u4e2a\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\u3002\u4f46\u662f\u56e0\u4e3a\u662f\u5355\u8fdb\u7a0b\uff0c\u6240\u4ee5\u4e0d\u9002\u5408CPU\u5bc6\u96c6\u578b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u4efb\u52a1\u4e00\u76f4\u5728\u5360\u636eCPU\u7684\u8bdd\uff0c\u540e\u7eed\u7684\u4efb\u52a1\u5c31\u65e0\u6cd5\u6267\u884c\u4e86\u3002\u5b83\u66f4\u9002\u5408IO\u5bc6\u96c6\u7684\uff08\u4e00\u822c\u90fd\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8d1f\u8d23\u5904\u7406CPU\u6216\u8005\u963b\u585e\u578b\u7684\u4efb\u52a1\uff09\u3002\u800c\u4f7f\u7528\u591a\u8fdb\u7a0b/\u7ebf\u7a0b\u6a21\u5f0f\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u8fdb\u7a0b/\u7ebf\u7a0b\u662f\u65e0\u6cd5\u4e00\u76f4\u5360\u636eCPU\u7684\uff0c\u6267\u884c\u4e00\u5b9a\u65f6\u95f4\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6267\u884c\u4efb\u52a1\u8c03\u5ea6\u3002\u8ba9\u5176\u5b83\u7ebf\u7a0b\u4e5f\u6709\u673a\u4f1a\u6267\u884c\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u524d\u9762\u7684\u4efb\u52a1\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\uff0c\u51fa\u73b0\u9965\u997f\u60c5\u51b5\u3002\u5927\u90e8\u5206\u64cd\u4f5c\u7cfb\u7edf\u90fd\u63d0\u4f9b\u4e86\u4e8b\u4ef6\u9a71\u52a8\u7684API\u3002\u4f46\u662f\u4e8b\u4ef6\u9a71\u52a8\u5728\u4e0d\u540c\u7cfb\u7edf\u4e2d\u5b9e\u73b0\u4e0d\u4e00\u6837\u3002\u6240\u4ee5\u4e00\u822c\u90fd\u4f1a\u6709\u4e00\u5c42\u62bd\u8c61\u5c42\u62b9\u5e73\u8fd9\u4e2a\u5dee\u5f02\u3002\u8fd9\u91cc\u4ee5Linux\u7684epoll\u4e3a\u4f8b\u5b50\u3002 1. // \u521b\u5efa\u4e00\u4e2aepoll 2. var epollFD = epoll_create (); 3. /* 4. \u5728epoll\u7ed9\u67d0\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u662f\u76d1\u542c\u7684socket\uff0c\u6ce8\u518c\u53ef 5. \u8bfb\u4e8b\u4ef6\uff0c\u5373\u8fde\u63a5\u5230\u6765 6. event = { 7. event: \u53ef\u8bfb 8. fd\uff1a \u76d1\u542csocket 9. // \u4e00\u4e9b\u4e0a\u4e0b\u6587 10. } 11. */ 12. epoll_ctl ( epollFD , EPOLL_CTL_ADD , socket , event ); 13. while ( 1 ) { 14. // \u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u5c31\u7eea\uff0cevents\u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u4fe1\u606f\uff0ctotal\u662f\u4e2a\u6570 15. var total = epoll_wait ( epollFD , \u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u7ed3\u6784 events , \u4e8b\u4ef6\u4e2a\u6570 , timeout ); 16. for ( let i = 0 ; i < total ; i ++ ) { 17. if ( events [ i ]. fd === \u76d1\u542c socket ) { 18. var newSocket = accpet ( socket ); 19. /* 20. \u628a\u65b0\u7684socket\u4e5f\u6ce8\u518c\u5230epoll\uff0c\u7b49\u5f85\u53ef\u8bfb\uff0c 21. \u5373\u53ef\u8bfb\u53d6\u5ba2\u6237\u7aef\u6570\u636e 22. */ 23. epoll_ctl ( epollFD , 24. EPOLL_CTL_ADD , 25. newSocket , 26. \u53ef\u8bfb\u4e8b\u4ef6 ); 27. } else { 28. // \u4eceevents[i]\u4e2d\u62ff\u5230\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03 29. } 30. } 31. } \u8fd9\u5c31\u662f\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u7684\u5927\u81f4\u8fc7\u7a0b\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u8ba2\u9605/\u53d1\u5e03\u6a21\u5f0f\u3002\u670d\u52a1\u5668\u901a\u8fc7\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u4e8b\u4ef6\u5230epoll\u4e2d\uff0cepoll\u5f00\u59cb\u963b\u585e\uff0c\u7b49\u5230epoll\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u544a\u8bc9\u670d\u52a1\u5668\u54ea\u4e9bfd\u7684\u54ea\u4e9b\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u904d\u5386\u5c31\u7eea\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u53ef\u4ee5\u518d\u6b21\u6ce8\u518c\u65b0\u7684\u4e8b\u4ef6\uff0c\u5c31\u662f\u8fd9\u6837\u4e0d\u65ad\u9a71\u52a8\u7740\u3002epoll\u7684\u539f\u7406\u5176\u5b9e\u4e5f\u7c7b\u4f3c\u4e8b\u4ef6\u9a71\u52a8\uff0cepoll\u5e95\u5c42\u7ef4\u62a4\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cepoll\u672c\u8eab\u4e5f\u4f1a\u5728\u6587\u4ef6\u63cf\u8ff0\u7b26\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u5904\u6ce8\u518c\u4e00\u4e2a\u56de\u8c03\uff0c\u7136\u540e\u81ea\u8eab\u8fdb\u5165\u963b\u585e\uff0c\u7b49\u5230\u522b\u4eba\u901a\u77e5epoll\u6709\u4e8b\u4ef6\u53d1\u751f\u7684\u65f6\u5019\uff0cepoll\u5c31\u4f1a\u628afd\u548c\u4e8b\u4ef6\u8fd4\u56de\u7ed9\u7528\u6237\u3002 1. function epoll_wait () { 2. for \u4e8b\u4ef6\u4e2a\u6570 3. // \u8c03\u7528\u6587\u4ef6\u7cfb\u7edf\u7684\u51fd\u6570\u5224\u65ad 4. if ( \u4e8b\u4ef6 [ i ] \u4e2d\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2d\u6709\u67d0\u4e2a\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u53d1\u751f ? ) { 5. \u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217 6. } else { 7. /* 8. \u5728\u4e8b\u4ef6[i]\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u6240\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u7b49indeo\u8282 9. \u70b9\u6ce8\u518c\u56de\u8c03\u3002\u5373\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u540e\u56de\u8c03epoll\uff0c\u56de\u8c03epoll\u540e\uff0c 10. epoll\u628a\u8be5event[i]\u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217\u8fd4\u56de\u7ed9\u7528\u6237 11. */ 12. } 13. } \u4ee5\u4e0a\u5c31\u662f\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\u4e00\u4e9b\u57fa\u672c\u4ecb\u7ecd\u3002\u73b0\u5728\u7684\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u8fd8\u4f1a\u6d89\u53ca\u5230\u534f\u7a0b\u3002\u4e0d\u8fc7\u76ee\u524d\u8fd8\u6ca1\u6709\u770b\u8fc7\u5177\u4f53\u7684\u5b9e\u73b0\uff0c\u6240\u4ee5\u6682\u4e0d\u5c55\u5f00\u4ecb\u7ecd\uff0c\u6709\u5174\u8da3\u7684\u901a\u4fe1\u53ef\u4ee5\u770b\u4e00\u4e0b\u534f\u7a0b\u5e93libtask\u4e86\u89e3\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528\u534f\u7a0b\u5b9e\u73b0\u4e00\u4e2a\u670d\u52a1\u5668\u3002 Node.js\u662f\u57fa\u4e8e\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48Node.js\u64c5\u957f\u5904\u7406\u9ad8\u5e76\u53d1IO\u578b\u4efb\u52a1\u800c\u4e0d\u64c5\u957f\u5904\u7406CPU\u578b\u4efb\u52a1\u7684\u539f\u56e0\uff0cNginx\u3001Redis\u4e5f\u662f\u8fd9\u79cd\u6a21\u5f0f\u3002\u53e6\u5916Node.js\u662f\u4e00\u4e2a\u53caweb\u670d\u52a1\u5668\u548c\u5e94\u7528\u670d\u52a1\u5668\u4e8e\u4e00\u8eab\u7684\u670d\u52a1\u5668\uff0c\u50cfNginx\u8fd9\u79cd\u5c5e\u4e8eweb\u670d\u52a1\u5668\uff0c\u5b83\u4eec\u53ea\u5904\u7406HTTP\u534f\u8bae\uff0c\u4e0d\u5177\u5907\u811a\u672c\u8bed\u8a00\u6765\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002\u5b83\u9700\u8981\u628a\u8bf7\u6c42\u8f6c\u53d1\u5230\u771f\u6b63\u7684web\u670d\u52a1\u5668\u4e2d\u53bb\u5904\u7406\uff0c\u6bd4\u5982PHP\u3002\u800cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u89e3\u6790HTTP\u534f\u8bae\uff0c\u8fd8\u53ef\u4ee5\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002","title":"1.4.4 \u4e8b\u4ef6\u9a71\u52a8"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/","text":"\u7b2c\u4e8c\u7ae0Libuv\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u903b\u8f91 \u00b6 2.1 \u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_s \u00b6 uv_loop_s\u662fLibuv\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u5bf9\u5e94\u4e00\u4e2auv_loop_s\u7ed3\u6784\u4f53\u3002\u5b83\u8bb0\u5f55\u4e86\u6574\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684\u6838\u5fc3\u6570\u636e\u3002\u6211\u4eec\u6765\u5206\u6790\u6bcf\u4e00\u4e2a\u5b57\u6bb5\u7684\u610f\u4e49\u3002 1 \u7528\u6237\u81ea\u5b9a\u4e49\u6570\u636e\u7684\u5b57\u6bb5 void * data ; 2 \u6d3b\u8dc3\u7684 handle\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4f7f\u7528\u5faa\u73af\u7684\u9000\u51fa unsigned int active_handles ; 3 handle\u961f\u5217 \uff0c\u5305\u62ec\u6d3b\u8dc3\u548c\u975e\u6d3b\u8dc3\u7684 void * handle_queue [ 2 ]; 4 request\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa union { void * unused [ 2 ]; unsigned int count ; } active_reqs ; 5 \u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u7ed3\u675f\u7684\u6807\u8bb0 unsigned int stop_flag ; 6 Libuv\u8fd0\u884c\u7684\u4e00\u4e9b\u6807\u8bb0 \uff0c\u76ee\u524d\u53ea\u6709 UV_LOOP_BLOCK_SIGPROF \uff0c\u4e3b\u8981\u662f\u7528\u4e8e epoll_wait\u7684\u65f6\u5019\u5c4f\u853dSIGPROF\u4fe1\u53f7 \uff0c\u63d0\u9ad8\u6027\u80fd\uff0c SIGPROF\u662f\u8c03\u64cd\u4f5c\u7cfb\u7edfsettimer\u51fd\u6570\u8bbe\u7f6e\u4ece\u800c\u89e6\u53d1\u7684\u4fe1\u53f7 unsigned long flags ; 7 epoll\u7684fd int backend_fd ; 8 pending\u9636\u6bb5\u7684\u961f\u5217 void * pending_queue [ 2 ]; 9 \u6307\u5411\u9700\u8981\u5728 epoll\u4e2d\u6ce8\u518c\u4e8b\u4ef6\u7684uv__io_t\u7ed3\u6784\u4f53\u961f\u5217 void * watcher_queue [ 2 ]; 10 watcher_queue\u961f\u5217\u7684\u8282\u70b9\u4e2d\u6709\u4e00\u4e2afd\u5b57\u6bb5 \uff0c watchers\u4ee5fd\u4e3a\u7d22\u5f15 \uff0c\u8bb0\u5f55 fd\u6240\u5728\u7684uv__io_t\u7ed3\u6784\u4f53 uv__io_t ** watchers ; 11 watchers\u76f8\u5173\u7684\u6570\u91cf \uff0c\u5728 maybe_resize\u51fd\u6570\u91cc\u8bbe\u7f6e unsigned int nwatchers ; 12 watchers\u91ccfd\u4e2a\u6570 \uff0c\u4e00\u822c\u4e3a watcher_queue\u961f\u5217\u7684\u8282\u70b9\u6570 unsigned int nfds ; 13 \u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u5904\u7406\u5b8c\u4efb\u52a1\u540e\u628a\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u63d2\u5165\u5230 wq\u961f\u5217 void * wq [ 2 ]; 14 \u63a7\u5236 wq\u961f\u5217\u4e92\u65a5\u8bbf\u95ee \uff0c\u5426\u5219\u591a\u4e2a\u5b50\u7ebf\u7a0b\u540c\u65f6\u8bbf\u95ee\u4f1a\u6709\u95ee\u9898 uv_mutex_t wq_mutex ; 15 \u7528\u4e8e\u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 uv_async_t wq_async ; 16 \u7528\u4e8e\u8bfb\u5199\u9501\u7684\u4e92\u65a5\u53d8\u91cf uv_rwlock_t cloexec_lock ; 17 \u4e8b\u4ef6\u5faa\u73af close\u9636\u6bb5\u7684\u961f\u5217 \uff0c\u7531 uv_close\u4ea7\u751f uv_handle_t * closing_handles ; 18 fork\u51fa\u6765\u7684\u8fdb\u7a0b\u961f\u5217 void * process_handles [ 2 ]; 19 \u4e8b\u4ef6\u5faa\u73af\u7684 prepare\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * prepare_handles [ 2 ]; 20 \u4e8b\u4ef6\u5faa\u73af\u7684 check\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * check_handles [ 2 ]; 21 \u4e8b\u4ef6\u5faa\u73af\u7684 idle\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * idle_handles [ 2 ]; 21 async_handles\u961f\u5217 \uff0c Poll IO\u9636\u6bb5\u6267\u884cuv__async_io\u4e2d\u904d\u5386async_handles\u961f\u5217\u5904\u7406\u91cc\u9762pending\u4e3a1\u7684\u8282\u70b9 void * async_handles [ 2 ]; 22 \u7528\u4e8e\u76d1\u542c\u662f\u5426\u6709 async handle\u4efb\u52a1\u9700\u8981\u5904\u7406 uv__io_t async_io_watcher ; 23 \u7528\u4e8e\u4fdd\u5b58\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u5199\u7aef fd int async_wfd ; 24 \u4fdd\u5b58\u5b9a\u65f6\u5668\u4e8c\u53c9\u5806\u7ed3\u6784 struct { void * min ; unsigned int nelts ; } timer_heap ; 25 \u7ba1\u7406\u5b9a\u65f6\u5668\u8282\u70b9\u7684 id \uff0c\u4e0d\u65ad\u53e0\u52a0 uint64_t timer_counter ; 26 \u5f53\u524d\u65f6\u95f4\uff0c Libuv\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u7684\u5f00\u59cb\u548cPoll IO\u9636\u6bb5\u66f4\u65b0\u5f53\u524d\u65f6\u95f4 \uff0c\u7136\u540e\u5728\u540e\u7eed\u7684\u5404\u4e2a\u9636\u6bb5\u4f7f\u7528\uff0c\u51cf\u5c11\u5bf9\u7cfb\u7edf\u8c03\u7528 uint64_t time ; 27 \u7528\u4e8e fork\u51fa\u6765\u7684\u8fdb\u7a0b\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053 \uff0c\u7528\u4e8e\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u901a\u77e5\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u4e3b\u8fdb\u7a0b\u6267\u884c\u5b50\u8fdb\u7a0b\u8282\u70b9\u6ce8\u518c\u7684\u56de\u8c03 int signal_pipefd [ 2 ]; 28 \u7c7b\u4f3c async_io_watcher \uff0c signal_io_watcher\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aeffd\u548c\u56de\u8c03 \uff0c\u7136\u540e\u6ce8\u518c\u5230 epoll\u4e2d \uff0c\u5728\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u901a\u8fc7 write\u5199\u5230\u7ba1\u9053 \uff0c\u6700\u540e\u5728 Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03 uv__io_t signal_io_watcher ; 29 \u7528\u4e8e\u7ba1\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684 handle uv_signal_t child_watcher ; 30 \u5907\u7528\u7684 fd int emfile_fd ; 2.2 uv_handle_t \u00b6 \u5728Libuv\u4e2d\uff0cuv_handle_t\u7c7b\u4f3cC++\u4e2d\u7684\u57fa\u7c7b\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0cLibuv\u4e3b\u8981\u901a\u8fc7\u63a7\u5236\u5185\u5b58\u7684\u5e03\u5c40\u5f97\u5230\u7ee7\u627f\u7684\u6548\u679c\u3002handle\u4ee3\u8868\u751f\u547d\u5468\u671f\u6bd4\u8f83\u957f\u7684\u5bf9\u8c61\u3002\u4f8b\u5982 1 \u4e00\u4e2a\u5904\u4e8eactive\u72b6\u6001\u7684prepare handle\uff0c\u5b83\u7684\u56de\u8c03\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5316\u7684\u65f6\u5019\u88ab\u6267\u884c\u3002 2 \u4e00\u4e2aTCP handle\u5728\u6bcf\u6b21\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv_handle_t\u7684\u5b9a\u4e49 1 \u81ea\u5b9a\u4e49\u6570\u636e\uff0c\u7528\u4e8e\u5173\u8054\u4e00\u4e9b\u4e0a\u4e0b\u6587 , Node . js\u4e2d\u7528\u4e8e\u5173\u8054handle\u6240\u5c5e\u7684C ++ \u5bf9\u8c61 void * data ; 2 \u6240\u5c5e\u7684\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 handle\u7c7b\u578b uv_handle_type type ; 4 handle\u8c03\u7528uv_close\u540e \uff0c\u5728 closing\u9636\u6bb5\u88ab\u6267\u884c\u7684\u56de\u8c03 uv_close_cb close_cb ; 5 \u7528\u4e8e\u7ec4\u7ec7 handle\u961f\u5217\u7684\u524d\u7f6e\u540e\u7f6e\u6307\u9488 void * handle_queue [ 2 ]; 6 \u6587\u4ef6\u63cf\u8ff0\u7b26 union { int fd ; void * reserved [ 4 ]; } u ; 7 \u5f53 handle\u5728close\u961f\u5217\u65f6 \uff0c\u8be5\u5b57\u6bb5\u6307\u5411\u4e0b\u4e00\u4e2a close\u8282\u70b9 uv_handle_t * next_closing ; 8 handle\u7684\u72b6\u6001\u548c\u6807\u8bb0 unsigned int flags ; 2.2.1 uv_stream_s \u00b6 uv_stream_s\u662f\u8868\u793a\u6d41\u7684\u7ed3\u6784\u4f53\u3002\u9664\u4e86\u7ee7\u627fuv_handle_t\u7684\u5b57\u6bb5\u5916\uff0c\u5b83\u989d\u5916\u5b9a\u4e49\u4e0b\u9762\u5b57\u6bb5 1 \u7b49\u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570 size_t write_queue_size ; 2 \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570 uv_alloc_cb alloc_cb ; 3 \u8bfb\u53d6\u6570\u636e\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_read_cb read_cb ; 4 \u53d1\u8d77\u8fde\u63a5\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_connect_t * connect_req ; 5 \u5173\u95ed\u5199\u7aef\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_shutdown_t * shutdown_req ; 6 \u7528\u4e8e\u63d2\u5165 epoll \uff0c\u6ce8\u518c\u8bfb\u5199\u4e8b\u4ef6 uv__io_t io_watcher ; 7 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 8 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217 void * write_completed_queue [ 2 ]; 9 \u6536\u5230\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_connection_cb connection_cb ; 10 socket\u64cd\u4f5c\u5931\u8d25\u7684\u9519\u8bef\u7801 int delayed_error ; 11 accept\u8fd4\u56de\u7684fd int accepted_fd ; 12 \u5df2\u7ecf accept\u4e86\u4e00\u4e2afd \uff0c\u53c8\u6709\u65b0\u7684 fd \uff0c\u6682\u5b58\u8d77\u6765 void * queued_fds ; 2.2.2 uv_async_s \u00b6 uv_async_s\u662fLibuv\u4e2d\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1\u7684\u7ed3\u6784\u4f53\u3002\u7ee7\u627f\u4e8euv_handle_t\uff0c\u5e76\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5\u3002 1 \u5f02\u6b65\u4e8b\u4ef6\u89e6\u53d1\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_async_cb async_cb ; 2 \u7528\u4e8e\u63d2\u5165 async - handles\u961f\u5217 void * queue [ 2 ]; 3 async_handles\u961f\u5217\u4e2d\u7684\u8282\u70b9pending\u5b57\u6bb5\u4e3a1\u8bf4\u660e\u5bf9\u5e94\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86 int pending ; 2.2.3 uv_tcp_s \u00b6 uv_tcp_s\u7ee7\u627fuv_handle_s\u548cuv_stream_s\u3002 2.2.4 uv_udp_s \u00b6 1 \u53d1\u9001\u5b57\u8282\u6570 size_t send_queue_size ; 2 \u5199\u961f\u5217\u8282\u70b9\u7684\u4e2a\u6570 size_t send_queue_count ; 3 \u5206\u914d\u63a5\u6536\u6570\u636e\u7684\u5185\u5b58 uv_alloc_cb alloc_cb ; 4 \u63a5\u6536\u5b8c\u6570\u636e\u540e\u6267\u884c\u7684\u56de\u8c03 uv_udp_recv_cb recv_cb ; 5 \u63d2\u5165 epoll\u91cc\u7684IO\u89c2\u5bdf\u8005 \uff0c\u5b9e\u73b0\u6570\u636e\u8bfb\u5199 uv__io_t io_watcher ; 6 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 7 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09\uff0c\u548c\u5f85\u53d1\u9001\u961f\u5217\u76f8\u5173 void * write_completed_queue [ 2 ]; 2.2.5 uv_tty_s \u00b6 uv_tty_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 \u7ec8\u7aef\u7684\u53c2\u6570 struct termios orig_termios ; 2 \u7ec8\u7aef\u7684\u5de5\u4f5c\u6a21\u5f0f int mode ; 2.2.6 uv_pipe_s \u00b6 uv_pipe_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 \u6807\u8bb0\u7ba1\u9053\u662f\u5426\u53ef\u7528\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 int ipc ; 2 \u7528\u4e8e Unix\u57df\u901a\u4fe1\u7684\u6587\u4ef6\u8def\u5f84 const char * pipe_fname ; 2.2.7 uv_prepare_s\u3001uv_check_s\u3001uv_idle_s \u00b6 \u4e0a\u9762\u4e09\u4e2a\u7ed3\u6784\u4f53\u5b9a\u4e49\u662f\u7c7b\u4f3c\u7684\uff0c\u5b83\u4eec\u90fd\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e24\u4e2a\u5b57\u6bb5\u3002 1 prepare \u3001 check \u3001 idle\u9636\u6bb5\u56de\u8c03 uv_xxx_cb xxx_cb ; 2 \u7528\u4e8e\u63d2\u5165 prepare \u3001 check \u3001 idle\u961f\u5217 void * queue [ 2 ]; 2.2.8 uv_timer_s \u00b6 uv_timer_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u51e0\u4e2a\u5b57\u6bb5\u3002 1 \u8d85\u65f6\u56de\u8c03 uv_timer_cb timer_cb ; 2 \u63d2\u5165\u4e8c\u53c9\u5806\u7684\u5b57\u6bb5 void * heap_node [ 3 ]; 3 \u8d85\u65f6\u65f6\u95f4 uint64_t timeout ; 4 \u8d85\u65f6\u540e\u662f\u5426\u7ee7\u7eed\u5f00\u59cb\u91cd\u65b0\u8ba1\u65f6\uff0c\u662f\u7684\u8bdd\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806 uint64_t repeat ; 5 id\u6807\u8bb0 \uff0c\u7528\u4e8e\u63d2\u5165\u4e8c\u53c9\u5806\u7684\u65f6\u5019\u5bf9\u6bd4 uint64_t start_id 2.2.9 uv_process_s \u00b6 uv_process_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 \u8fdb\u7a0b\u9000\u51fa\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_exit_cb exit_cb ; 2 \u8fdb\u7a0b id int pid ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217\uff0c\u8fdb\u7a0b\u961f\u5217\u6216\u8005 pending\u961f\u5217 void * queue [ 2 ]; 4 \u9000\u51fa\u7801\uff0c\u8fdb\u7a0b\u9000\u51fa\u65f6\u8bbe\u7f6e int status ; 2.2.10 uv_fs_event_s \u00b6 uv_fs_event_s\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u6539\u52a8\u3002uv_fs_event_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 ( \u6587\u4ef6\u6216\u76ee\u5f55 ) char * path ; 2 \u6587\u4ef6\u6539\u53d8\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_fs_event_cb cb ; 2.2.11 uv_fs_poll_s \u00b6 uv_fs_poll_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 poll_ctx\u6307\u5411poll_ctx\u7ed3\u6784\u4f53 void * poll_ctx ; struct poll_ctx { // \u5bf9\u5e94\u7684handle uv_fs_poll_t * parent_handle ; // \u6807\u8bb0\u662f\u5426\u5f00\u59cb\u8f6e\u8be2\u548c\u8f6e\u8be2\u65f6\u7684\u5931\u8d25\u539f\u56e0 int busy_polling ; // \u591a\u4e45\u68c0\u6d4b\u4e00\u6b21\u6587\u4ef6\u5185\u5bb9\u662f\u5426\u6539\u53d8 unsigned int interval ; // \u6bcf\u4e00\u8f6e\u8f6e\u8be2\u65f6\u7684\u5f00\u59cb\u65f6\u95f4 uint64_t start_time ; // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; // \u6587\u4ef6\u6539\u53d8\u65f6\u56de\u8c03 uv_fs_poll_cb poll_cb ; // \u5b9a\u65f6\u5668\uff0c\u7528\u4e8e\u5b9a\u65f6\u8d85\u65f6\u540e\u8f6e\u8be2 uv_timer_t timer_handle ; // \u8bb0\u5f55\u8f6e\u8be2\u7684\u4e00\u4e0b\u4e0a\u4e0b\u6587\u4fe1\u606f\uff0c\u6587\u4ef6\u8def\u5f84\u3001\u56de\u8c03\u7b49 uv_fs_t fs_req ; // \u8f6e\u8be2\u65f6\u4fdd\u5b58\u64cd\u4f5c\u7cfb\u7edf\u8fd4\u56de\u7684\u6587\u4ef6\u4fe1\u606f uv_stat_t statbuf ; // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u5b57\u7b26\u4e32\u7684\u503c\u8ffd\u52a0\u5728\u7ed3\u6784\u4f53\u540e\u9762 char path [ 1 ]; /* variable length */ }; 2.2.12 uv_poll_s \u00b6 uv_poll_s\u7ee7\u627f\u4e8euv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 \u76d1\u542c\u7684 fd\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_poll_cb poll_cb ; 2 \u4fdd\u5b58\u4e86 fd\u548c\u56de\u8c03\u7684IO\u89c2\u5bdf\u8005 \uff0c\u6ce8\u518c\u5230 epoll\u4e2d uv__io_t io_watcher ; 2.1.13 uv_signal_s \u00b6 uv_signal_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5 1 \u6536\u5230\u4fe1\u53f7\u65f6\u7684\u56de\u8c03 uv_signal_cb signal_cb ; 2 \u6ce8\u518c\u7684\u4fe1\u53f7 int signum ; 3 \u7528\u4e8e\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u8fdb\u7a0b\u628a\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u5c01\u88c5\u6210 uv_signal_s \uff0c\u7136\u540e\u63d2\u5165\u5230\u7ea2\u9ed1\u6811\uff0c\u4fe1\u53f7\u5230\u6765\u65f6\uff0c\u8fdb\u7a0b\u5728\u4fe1\u53f7\u5904\u7406\u53f7\u4e2d\u628a\u901a\u77e5\u5199\u5165\u7ba1\u9053\uff0c\u901a\u77e5 Libuv \u3002 Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u6267\u884c\u8fdb\u7a0b\u5bf9\u5e94\u7684\u56de\u8c03 \u3002\u7ea2\u9ed1\u6811\u8282\u70b9\u7684\u5b9a\u4e49\u5982\u4e0b struct { struct uv_signal_s * rbe_left ; struct uv_signal_s * rbe_right ; struct uv_signal_s * rbe_parent ; int rbe_color ; } tree_entry ; 4 \u6536\u5230\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int caught_signals ; 5 \u5df2\u7ecf\u5904\u7406\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int dispatched_signals ; 2.3 uv_req_s \u00b6 \u5728Libuv\u4e2d\uff0cuv_req_s\u4e5f\u7c7b\u4f3cC++\u57fa\u7c7b\u7684\u4f5c\u7528\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0crequest\u4ee3\u8868\u4e00\u6b21\u8bf7\u6c42\uff0c\u6bd4\u5982\u8bfb\u5199\u4e00\u4e2a\u6587\u4ef6\uff0c\u8bfb\u5199socket\uff0c\u67e5\u8be2DNS\u3002\u4efb\u52a1\u5b8c\u6210\u540e\u8fd9\u4e2arequest\u5c31\u7ed3\u675f\u4e86\u3002request\u53ef\u4ee5\u548chandle\u7ed3\u5408\u4f7f\u7528\uff0c\u6bd4\u5982\u5728\u4e00\u4e2aTCP\u670d\u52a1\u5668\u4e0a\uff08handle\uff09\u5199\u4e00\u4e2a\u6570\u636e\uff08request\uff09\uff0c\u4e5f\u53ef\u4ee5\u5355\u72ec\u4f7f\u7528\u4e00\u4e2arequest\uff0c\u6bd4\u5982DNS\u67e5\u8be2\u6216\u8005\u6587\u4ef6\u8bfb\u5199\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_req_s\u7684\u5b9a\u4e49\u3002 1 \u81ea\u5b9a\u4e49\u6570\u636e void * data ; 2 request\u7c7b\u578b uv_req_type type ; 3 \u4fdd\u7559\u5b57\u6bb5 void * reserved [ 6 ]; 2.3.1 uv_shutdown_s \u00b6 uv_shutdown_s\u7528\u4e8e\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u8981\u5173\u95ed\u7684\u6d41\uff0c\u6bd4\u5982 TCP uv_stream_t * handle ; 2 \u5173\u95ed\u6d41\u7684\u5199\u7aef\u540e\u6267\u884c\u7684\u56de\u8c03 uv_shutdown_cb cb ; 2.3.2 uv_write_s \u00b6 uv_write_s\u8868\u793a\u4e00\u6b21\u5199\u8bf7\u6c42\uff0c\u6bd4\u5982\u5728TCP\u6d41\u4e0a\u53d1\u9001\u6570\u636e\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u5199\u5b8c\u540e\u7684\u56de\u8c03 uv_write_cb cb ; 2 \u9700\u8981\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5728 send_handle\u4e2d uv_stream_t * send_handle ; 3 \u5173\u8054\u7684 handle uv_stream_t * handle ; 4 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ]; 5 \u4fdd\u5b58\u9700\u8981\u5199\u7684\u6570\u636e\u76f8\u5173\u7684\u5b57\u6bb5\uff08\u5199\u5165\u7684 buffer\u4e2a\u6570 \uff0c\u5f53\u524d\u5199\u6210\u529f\u7684\u4f4d\u7f6e\u7b49\uff09 unsigned int write_index ; uv_buf_t * bufs ; unsigned int nbufs ; uv_buf_t bufsml [ 4 ]; 6 \u5199\u51fa\u9519\u7684\u9519\u8bef\u7801 int error ; 2.3.3 uv_connect_s \u00b6 uv_connect_s\u8868\u793a\u53d1\u8d77\u8fde\u63a5\u8bf7\u6c42\uff0c\u6bd4\u5982TCP\u8fde\u63a5\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u8fde\u63a5\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 uv_connect_cb cb ; 2 \u5bf9\u5e94\u7684\u6d41\uff0c\u6bd4\u5982 tcp uv_stream_t * handle ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ]; 2.3.4 uv_udp_send_s \u00b6 uv_udp_send_s\u8868\u793a\u4e00\u6b21\u53d1\u9001UDP\u6570\u636e\u7684\u8bf7\u6c42 1 \u6240\u5c5e udp\u7684handle \uff0c udp_send_s\u4ee3\u8868\u4e00\u6b21\u53d1\u9001 uv_udp_t * handle ; 2 \u56de\u8c03 uv_udp_send_cb cb ; 3 \u7528\u4e8e\u63d2\u5165\u5f85\u53d1\u9001\u961f\u5217 void * queue [ 2 ]; 4 \u53d1\u9001\u7684\u76ee\u7684\u5730\u5740 struct sockaddr_storage addr ; 5 \u4fdd\u5b58\u4e86\u53d1\u9001\u6570\u636e\u7684\u7f13\u51b2\u533a\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; uv_buf_t bufsml [ 4 ]; 6 \u53d1\u9001\u72b6\u6001\u6216\u6210\u529f\u53d1\u9001\u7684\u5b57\u8282\u6570 ssize_t status ; 7 \u53d1\u9001\u5b8c\u6267\u884c\u7684\u56de\u8c03\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09 uv_udp_send_cb send_cb ; 2.3.5 uv_getaddrinfo_s \u00b6 uv_getaddrinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7\u57df\u540d\u67e5\u8be2IP\u7684DNS\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 DNS\u89e3\u6790\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 uv_getaddrinfo_cb cb ; 4 DNS\u67e5\u8be2\u7684\u914d\u7f6e struct addrinfo * hints ; char * hostname ; char * service ; 5 DNS\u89e3\u6790\u7ed3\u679c struct addrinfo * addrinfo ; 6 DNS\u89e3\u6790\u7684\u8fd4\u56de\u7801 int retcode ; 2.3.6 uv_getnameinfo_s \u00b6 uv_getnameinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u7684DNS\u67e5\u8be2\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 socket\u8f6c\u57df\u540d\u5b8c\u6210\u7684\u56de\u8c03 uv_getnameinfo_cb getnameinfo_cb ; 4 \u9700\u8981\u8f6c\u57df\u540d\u7684 socket\u7ed3\u6784\u4f53 struct sockaddr_storage storage ; 5 \u6307\u793a\u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f int flags ; 6 \u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f char host [ NI_MAXHOST ]; char service [ NI_MAXSERV ]; 7 \u67e5\u8be2\u8fd4\u56de\u7801 int retcode ; 2.3.7 uv_work_s \u00b6 uv_work_s\u7528\u4e8e\u5f80\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u5904\u7406\u4efb\u52a1\u7684\u51fd\u6570 uv_work_cb work_cb ; 3 \u5904\u7406\u5b8c\u4efb\u52a1\u540e\u6267\u884c\u7684\u51fd\u6570 uv_after_work_cb after_work_cb ; 4 \u5c01\u88c5\u4e00\u4e2a work\u63d2\u5165\u5230\u7ebf\u7a0b\u6c60\u961f\u5217 \uff0c work_req\u7684work\u548cdone\u51fd\u6570\u662f\u5bf9\u4e0a\u9762work_cb\u548cafter_work_cb\u7684\u5c01\u88c5 struct uv__work work_req ; uv_fs_s \u00b6 uv_fs_s\u8868\u793a\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6587\u4ef6\u64cd\u4f5c\u7c7b\u578b uv_fs_type fs_type ; 2 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 \u6587\u4ef6\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03 uv_fs_cb cb ; 4 \u6587\u4ef6\u64cd\u4f5c\u7684\u8fd4\u56de\u7801 ssize_t result ; 5 \u6587\u4ef6\u64cd\u4f5c\u8fd4\u56de\u7684\u6570\u636e void * ptr ; 6 \u6587\u4ef6\u64cd\u4f5c\u8def\u5f84 const char * path ; 7 \u6587\u4ef6\u7684 stat\u4fe1\u606f uv_stat_t statbuf ; 8 \u6587\u4ef6\u64cd\u4f5c\u6d89\u53ca\u5230\u4e24\u4e2a\u8def\u5f84\u65f6\uff0c\u4fdd\u5b58\u76ee\u7684\u8def\u5f84 const char * new_path ; 9 \u6587\u4ef6\u63cf\u8ff0\u7b26 uv_file file ; 10 \u6587\u4ef6\u6807\u8bb0 int flags ; 11 \u64cd\u4f5c\u6a21\u5f0f mode_t mode ; 12 \u5199\u6587\u4ef6\u65f6\u4f20\u5165\u7684\u6570\u636e\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; 13 \u6587\u4ef6\u504f\u79fb off_t off ; 14 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684 uid\u548cgid \uff0c\u4f8b\u5982 chmod\u7684\u65f6\u5019 uv_uid_t uid ; uv_gid_t gid ; 15 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684\u6587\u4ef6\u4fee\u6539\u3001\u8bbf\u95ee\u65f6\u95f4\uff0c\u4f8b\u5982 fs . utimes\u7684\u65f6\u5019 double atime ; double mtime ; 16 \u5f02\u6b65\u7684\u65f6\u5019\u7528\u4e8e\u63d2\u5165\u4efb\u52a1\u961f\u5217\uff0c\u4fdd\u5b58\u5de5\u4f5c\u51fd\u6570\uff0c\u56de\u8c03\u51fd\u6570 struct uv__work work_req ; 17 \u4fdd\u5b58\u8bfb\u53d6\u6570\u636e\u6216\u8005\u957f\u5ea6\u3002\u4f8b\u5982 read\u548csendfile uv_buf_t bufsml [ 4 ]; 2.4 IO\u89c2\u5bdf\u8005 \u00b6 IO\u89c2\u5bdf\u8005\u662fLibuv\u4e2d\u7684\u6838\u5fc3\u6982\u5ff5\u548c\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9a\u4e49 1. struct uv__io_s { 2. // \u4e8b\u4ef6\u89e6\u53d1\u540e\u7684\u56de\u8c03 3. uv__io_cb cb ; 4. // \u7528\u4e8e\u63d2\u5165\u961f\u5217 5. void * pending_queue [ 2 ]; 6. void * watcher_queue [ 2 ]; 7. // \u4fdd\u5b58\u672c\u6b21\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\u65f6\u8bbe\u7f6e 8. unsigned int pevents ; 9. // \u4fdd\u5b58\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. unsigned int events ; 11. int fd ; 12. }; IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4e8b\u4ef6\u548c\u56de\u8c03\uff0c\u7136\u540e\u63d2\u5165\u5230loop\u7ef4\u62a4\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6839\u636eIO\u89c2\u5bdf\u8005\u63cf\u8ff0\u7684\u4fe1\u606f\uff0c\u5f80\u5e95\u5c42\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u5f53\u6ce8\u518c\u7684\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u6211\u4eec\u770b\u5982\u4f55\u521dIO\u89c2\u5bdf\u8005\u7684\u4e00\u4e9b\u903b\u8f91\u3002 2.4.1 \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005 \u00b6 1. void uv__io_init ( uv__io_t * w , uv__io_cb cb , int fd ) { 2. // \u521d\u59cb\u5316\u961f\u5217\uff0c\u56de\u8c03\uff0c\u9700\u8981\u76d1\u542c\u7684fd 3. QUEUE_INIT ( & w -> pending_queue ); 4. QUEUE_INIT ( & w -> watcher_queue ); 5. w -> cb = cb ; 6. w -> fd = fd ; 7. // \u4e0a\u6b21\u52a0\u5165epoll\u65f6\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u6267\u884c\u5b8cepoll\u64cd\u4f5c\u51fd\u6570\u540e\u8bbe\u7f6e 8. w -> events = 0 ; 9. // \u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u518d\u6b21\u6267\u884cepoll\u51fd\u6570\u4e4b\u524d\u8bbe\u7f6e 10. w -> pevents = 0 ; 11. } 2.4.2\u6ce8\u518c\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u5230Libuv\u3002 \u00b6 1. void uv__io_start ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { 2. // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 3. w -> pevents |= events ; 4. // \u53ef\u80fd\u9700\u8981\u6269\u5bb9 5. maybe_resize ( loop , w -> fd + 1 ); 6. // \u4e8b\u4ef6\u6ca1\u6709\u53d8\u5316\u5219\u76f4\u63a5\u8fd4\u56de 7. if ( w -> events == w -> pevents ) 8. return ; 9. // IO\u89c2\u5bdf\u8005\u6ca1\u6709\u6302\u8f7d\u5728\u5176\u5b83\u5730\u65b9\u5219\u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217 10. if ( QUEUE_EMPTY ( & w -> watcher_queue )) 11. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 12. // \u4fdd\u5b58\u6620\u5c04\u5173\u7cfb 13. if ( loop -> watchers [ w -> fd ] == NULL ) { 14. loop -> watchers [ w -> fd ] = w ; 15. loop -> nfds ++ ; 16. } 17. } uv__io_start\u51fd\u6570\u5c31\u662f\u628a\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u63d2\u5165\u5230Libuv\u7684\u89c2\u5bdf\u8005\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u5728watchers\u6570\u7ec4\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\u3002Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u961f\u5217\u3002 2.4.3 \u64a4\u9500IO\u89c2\u5bdf\u8005\u6216\u8005\u4e8b\u4ef6 \u00b6 uv__io_stop\u4fee\u6539IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u8fd8\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7684\u8bdd\uff0cIO\u89c2\u5bdf\u8005\u8fd8\u4f1a\u5728\u961f\u5217\u91cc\uff0c\u5426\u5219\u79fb\u51fa 1. void uv__io_stop ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. if ( w -> fd == -1 ) 5. return ; 6. assert ( w -> fd >= 0 ); 7. if (( unsigned ) w -> fd >= loop -> nwatchers ) 8. return ; 9. // \u6e05\u9664\u4e4b\u524d\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4fdd\u5b58\u5728pevents\u91cc\uff0c\u8868\u793a\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. w -> pevents &= ~ events ; 11. // \u5bf9\u6240\u6709\u4e8b\u4ef6\u90fd\u4e0d\u611f\u5174\u8da3\u4e86 12. if ( w -> pevents == 0 ) { 13. // \u79fb\u51faIO\u89c2\u5bdf\u8005\u961f\u5217 14. QUEUE_REMOVE ( & w -> watcher_queue ); 15. // \u91cd\u7f6e 16. QUEUE_INIT ( & w -> watcher_queue ); 17. // \u91cd\u7f6e 18. if ( loop -> watchers [ w -> fd ] != NULL ) { 19. assert ( loop -> watchers [ w -> fd ] == w ); 20. assert ( loop -> nfds > 0 ); 21. loop -> watchers [ w -> fd ] = NULL ; 22. loop -> nfds -- ; 23. w -> events = 0 ; 24. } 25. } 26. /* 27. \u4e4b\u524d\u8fd8\u6ca1\u6709\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5219\u63d2\u5165\uff0c 28. \u7b49\u5230Poll IO\u65f6\u5904\u7406\uff0c\u5426\u5219\u4e0d\u9700\u8981\u5904\u7406 29. */ 30. else if ( QUEUE_EMPTY ( & w -> watcher_queue )) 31. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 32. } 2.5 Libuv\u901a\u7528\u903b\u8f91 \u00b6 2.5.1 uv__handle_init \u00b6 uv__handle_init\u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u8bbe\u7f6eREF\u6807\u8bb0\uff0c\u63d2\u5165handle\u961f\u5217\u3002 1. # define uv__handle_init ( loop_ , h , type_ ) 2. do { 3. ( h ) -> loop = ( loop_ ); 4. ( h ) -> type = ( type_ ); 5. ( h ) -> flags = UV_HANDLE_REF ; 6. QUEUE_INSERT_TAIL ( & ( loop_ ) -> handle_queue , & ( h ) -> handle_queue ); 7. ( h ) -> next_closing = NULL 8. } 9. while ( 0 ) 2.5.2. uv__handle_start \u00b6 uv__handle_start\u8bbe\u7f6e\u6807\u8bb0handle\u4e3aACTIVE\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86REF\u6807\u8bb0\uff0c\u5219active handle\u7684\u4e2a\u6570\u52a0\u4e00\uff0cactive handle\u6570\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1. # define uv__handle_start ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) 6. ( h ) -> loop -> active_handles ++ ; 7. } 8. while ( 0 ) 2.5.3. uv__handle_stop \u00b6 uv__handle_stop\u548cuv__handle_start\u76f8\u53cd\u3002 1. # define uv__handle_stop ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) uv__active_handle_rm ( h ); 6. } 7. while ( 0 ) Libuv\u4e2dhandle\u6709REF\u548cACTIVE\u4e24\u4e2a\u72b6\u6001\u3002\u5f53\u4e00\u4e2ahandle\u8c03\u7528xxx_init\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u9996\u5148\u88ab\u6253\u4e0aREF\u6807\u8bb0\uff0c\u5e76\u4e14\u63d2\u5165loop->handle\u961f\u5217\u3002\u5f53handle\u8c03\u7528xxx_start\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u88ab\u6253\u4e0aACTIVE\u6807\u8bb0\uff0c\u5e76\u4e14\u8bb0\u5f55active handle\u7684\u4e2a\u6570\u52a0\u4e00\u3002\u53ea\u6709REF\u5e76\u4e14ACTIVE\u72b6\u6001\u7684handle\u624d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 2.5.4. uv__req_init \u00b6 uv__req_init\u521d\u59cb\u5316\u8bf7\u6c42\u7684\u7c7b\u578b\uff0c\u8bb0\u5f55\u8bf7\u6c42\u7684\u4e2a\u6570\uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1. # define uv__req_init ( loop , req , typ ) 2. do { 3. ( req ) -> type = ( typ ); 4. ( loop ) -> active_reqs . count ++ ; 5. } 6. while ( 0 ) 2.5.5. uv__req_register \u00b6 \u8bf7\u6c42\u7684\u4e2a\u6570\u52a0\u4e00 1. # define uv__req_register ( loop , req ) 2. do { 3. ( loop ) -> active_reqs . count ++ ; 4. } 5. while ( 0 ) 2.5.6. uv__req_unregister \u00b6 \u8bf7\u6c42\u4e2a\u6570\u51cf\u4e00 1. # define uv__req_unregister ( loop , req ) 2. do { 3. assert ( uv__has_active_reqs ( loop )); 4. ( loop ) -> active_reqs . count -- ; 5. } 6. while ( 0 ) 2.5.7. uv__handle_ref \u00b6 uv__handle_ref\u6807\u8bb0handle\u4e3aREF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u52a0\u4e00 1. # define uv__handle_ref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_add ( h ); 7. } 8. while ( 0 ) 9. uv__handle_unref uv__handle_unref\u53bb\u6389handle\u7684REF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u51cf\u4e00 1. # define uv__handle_unref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_rm ( h ); 7. } 8. while ( 0 )","title":"02-Libuv\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u903b\u8f91"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#libuv","text":"","title":"\u7b2c\u4e8c\u7ae0Libuv\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u903b\u8f91"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#21-uv_loop_s","text":"uv_loop_s\u662fLibuv\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u5bf9\u5e94\u4e00\u4e2auv_loop_s\u7ed3\u6784\u4f53\u3002\u5b83\u8bb0\u5f55\u4e86\u6574\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684\u6838\u5fc3\u6570\u636e\u3002\u6211\u4eec\u6765\u5206\u6790\u6bcf\u4e00\u4e2a\u5b57\u6bb5\u7684\u610f\u4e49\u3002 1 \u7528\u6237\u81ea\u5b9a\u4e49\u6570\u636e\u7684\u5b57\u6bb5 void * data ; 2 \u6d3b\u8dc3\u7684 handle\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4f7f\u7528\u5faa\u73af\u7684\u9000\u51fa unsigned int active_handles ; 3 handle\u961f\u5217 \uff0c\u5305\u62ec\u6d3b\u8dc3\u548c\u975e\u6d3b\u8dc3\u7684 void * handle_queue [ 2 ]; 4 request\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa union { void * unused [ 2 ]; unsigned int count ; } active_reqs ; 5 \u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u7ed3\u675f\u7684\u6807\u8bb0 unsigned int stop_flag ; 6 Libuv\u8fd0\u884c\u7684\u4e00\u4e9b\u6807\u8bb0 \uff0c\u76ee\u524d\u53ea\u6709 UV_LOOP_BLOCK_SIGPROF \uff0c\u4e3b\u8981\u662f\u7528\u4e8e epoll_wait\u7684\u65f6\u5019\u5c4f\u853dSIGPROF\u4fe1\u53f7 \uff0c\u63d0\u9ad8\u6027\u80fd\uff0c SIGPROF\u662f\u8c03\u64cd\u4f5c\u7cfb\u7edfsettimer\u51fd\u6570\u8bbe\u7f6e\u4ece\u800c\u89e6\u53d1\u7684\u4fe1\u53f7 unsigned long flags ; 7 epoll\u7684fd int backend_fd ; 8 pending\u9636\u6bb5\u7684\u961f\u5217 void * pending_queue [ 2 ]; 9 \u6307\u5411\u9700\u8981\u5728 epoll\u4e2d\u6ce8\u518c\u4e8b\u4ef6\u7684uv__io_t\u7ed3\u6784\u4f53\u961f\u5217 void * watcher_queue [ 2 ]; 10 watcher_queue\u961f\u5217\u7684\u8282\u70b9\u4e2d\u6709\u4e00\u4e2afd\u5b57\u6bb5 \uff0c watchers\u4ee5fd\u4e3a\u7d22\u5f15 \uff0c\u8bb0\u5f55 fd\u6240\u5728\u7684uv__io_t\u7ed3\u6784\u4f53 uv__io_t ** watchers ; 11 watchers\u76f8\u5173\u7684\u6570\u91cf \uff0c\u5728 maybe_resize\u51fd\u6570\u91cc\u8bbe\u7f6e unsigned int nwatchers ; 12 watchers\u91ccfd\u4e2a\u6570 \uff0c\u4e00\u822c\u4e3a watcher_queue\u961f\u5217\u7684\u8282\u70b9\u6570 unsigned int nfds ; 13 \u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u5904\u7406\u5b8c\u4efb\u52a1\u540e\u628a\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u63d2\u5165\u5230 wq\u961f\u5217 void * wq [ 2 ]; 14 \u63a7\u5236 wq\u961f\u5217\u4e92\u65a5\u8bbf\u95ee \uff0c\u5426\u5219\u591a\u4e2a\u5b50\u7ebf\u7a0b\u540c\u65f6\u8bbf\u95ee\u4f1a\u6709\u95ee\u9898 uv_mutex_t wq_mutex ; 15 \u7528\u4e8e\u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 uv_async_t wq_async ; 16 \u7528\u4e8e\u8bfb\u5199\u9501\u7684\u4e92\u65a5\u53d8\u91cf uv_rwlock_t cloexec_lock ; 17 \u4e8b\u4ef6\u5faa\u73af close\u9636\u6bb5\u7684\u961f\u5217 \uff0c\u7531 uv_close\u4ea7\u751f uv_handle_t * closing_handles ; 18 fork\u51fa\u6765\u7684\u8fdb\u7a0b\u961f\u5217 void * process_handles [ 2 ]; 19 \u4e8b\u4ef6\u5faa\u73af\u7684 prepare\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * prepare_handles [ 2 ]; 20 \u4e8b\u4ef6\u5faa\u73af\u7684 check\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * check_handles [ 2 ]; 21 \u4e8b\u4ef6\u5faa\u73af\u7684 idle\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * idle_handles [ 2 ]; 21 async_handles\u961f\u5217 \uff0c Poll IO\u9636\u6bb5\u6267\u884cuv__async_io\u4e2d\u904d\u5386async_handles\u961f\u5217\u5904\u7406\u91cc\u9762pending\u4e3a1\u7684\u8282\u70b9 void * async_handles [ 2 ]; 22 \u7528\u4e8e\u76d1\u542c\u662f\u5426\u6709 async handle\u4efb\u52a1\u9700\u8981\u5904\u7406 uv__io_t async_io_watcher ; 23 \u7528\u4e8e\u4fdd\u5b58\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u5199\u7aef fd int async_wfd ; 24 \u4fdd\u5b58\u5b9a\u65f6\u5668\u4e8c\u53c9\u5806\u7ed3\u6784 struct { void * min ; unsigned int nelts ; } timer_heap ; 25 \u7ba1\u7406\u5b9a\u65f6\u5668\u8282\u70b9\u7684 id \uff0c\u4e0d\u65ad\u53e0\u52a0 uint64_t timer_counter ; 26 \u5f53\u524d\u65f6\u95f4\uff0c Libuv\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u7684\u5f00\u59cb\u548cPoll IO\u9636\u6bb5\u66f4\u65b0\u5f53\u524d\u65f6\u95f4 \uff0c\u7136\u540e\u5728\u540e\u7eed\u7684\u5404\u4e2a\u9636\u6bb5\u4f7f\u7528\uff0c\u51cf\u5c11\u5bf9\u7cfb\u7edf\u8c03\u7528 uint64_t time ; 27 \u7528\u4e8e fork\u51fa\u6765\u7684\u8fdb\u7a0b\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053 \uff0c\u7528\u4e8e\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u901a\u77e5\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u4e3b\u8fdb\u7a0b\u6267\u884c\u5b50\u8fdb\u7a0b\u8282\u70b9\u6ce8\u518c\u7684\u56de\u8c03 int signal_pipefd [ 2 ]; 28 \u7c7b\u4f3c async_io_watcher \uff0c signal_io_watcher\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aeffd\u548c\u56de\u8c03 \uff0c\u7136\u540e\u6ce8\u518c\u5230 epoll\u4e2d \uff0c\u5728\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u901a\u8fc7 write\u5199\u5230\u7ba1\u9053 \uff0c\u6700\u540e\u5728 Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03 uv__io_t signal_io_watcher ; 29 \u7528\u4e8e\u7ba1\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684 handle uv_signal_t child_watcher ; 30 \u5907\u7528\u7684 fd int emfile_fd ;","title":"2.1 \u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#22-uv_handle_t","text":"\u5728Libuv\u4e2d\uff0cuv_handle_t\u7c7b\u4f3cC++\u4e2d\u7684\u57fa\u7c7b\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0cLibuv\u4e3b\u8981\u901a\u8fc7\u63a7\u5236\u5185\u5b58\u7684\u5e03\u5c40\u5f97\u5230\u7ee7\u627f\u7684\u6548\u679c\u3002handle\u4ee3\u8868\u751f\u547d\u5468\u671f\u6bd4\u8f83\u957f\u7684\u5bf9\u8c61\u3002\u4f8b\u5982 1 \u4e00\u4e2a\u5904\u4e8eactive\u72b6\u6001\u7684prepare handle\uff0c\u5b83\u7684\u56de\u8c03\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5316\u7684\u65f6\u5019\u88ab\u6267\u884c\u3002 2 \u4e00\u4e2aTCP handle\u5728\u6bcf\u6b21\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv_handle_t\u7684\u5b9a\u4e49 1 \u81ea\u5b9a\u4e49\u6570\u636e\uff0c\u7528\u4e8e\u5173\u8054\u4e00\u4e9b\u4e0a\u4e0b\u6587 , Node . js\u4e2d\u7528\u4e8e\u5173\u8054handle\u6240\u5c5e\u7684C ++ \u5bf9\u8c61 void * data ; 2 \u6240\u5c5e\u7684\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 handle\u7c7b\u578b uv_handle_type type ; 4 handle\u8c03\u7528uv_close\u540e \uff0c\u5728 closing\u9636\u6bb5\u88ab\u6267\u884c\u7684\u56de\u8c03 uv_close_cb close_cb ; 5 \u7528\u4e8e\u7ec4\u7ec7 handle\u961f\u5217\u7684\u524d\u7f6e\u540e\u7f6e\u6307\u9488 void * handle_queue [ 2 ]; 6 \u6587\u4ef6\u63cf\u8ff0\u7b26 union { int fd ; void * reserved [ 4 ]; } u ; 7 \u5f53 handle\u5728close\u961f\u5217\u65f6 \uff0c\u8be5\u5b57\u6bb5\u6307\u5411\u4e0b\u4e00\u4e2a close\u8282\u70b9 uv_handle_t * next_closing ; 8 handle\u7684\u72b6\u6001\u548c\u6807\u8bb0 unsigned int flags ;","title":"2.2 uv_handle_t"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#221-uv_stream_s","text":"uv_stream_s\u662f\u8868\u793a\u6d41\u7684\u7ed3\u6784\u4f53\u3002\u9664\u4e86\u7ee7\u627fuv_handle_t\u7684\u5b57\u6bb5\u5916\uff0c\u5b83\u989d\u5916\u5b9a\u4e49\u4e0b\u9762\u5b57\u6bb5 1 \u7b49\u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570 size_t write_queue_size ; 2 \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570 uv_alloc_cb alloc_cb ; 3 \u8bfb\u53d6\u6570\u636e\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_read_cb read_cb ; 4 \u53d1\u8d77\u8fde\u63a5\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_connect_t * connect_req ; 5 \u5173\u95ed\u5199\u7aef\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_shutdown_t * shutdown_req ; 6 \u7528\u4e8e\u63d2\u5165 epoll \uff0c\u6ce8\u518c\u8bfb\u5199\u4e8b\u4ef6 uv__io_t io_watcher ; 7 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 8 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217 void * write_completed_queue [ 2 ]; 9 \u6536\u5230\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_connection_cb connection_cb ; 10 socket\u64cd\u4f5c\u5931\u8d25\u7684\u9519\u8bef\u7801 int delayed_error ; 11 accept\u8fd4\u56de\u7684fd int accepted_fd ; 12 \u5df2\u7ecf accept\u4e86\u4e00\u4e2afd \uff0c\u53c8\u6709\u65b0\u7684 fd \uff0c\u6682\u5b58\u8d77\u6765 void * queued_fds ;","title":"2.2.1 uv_stream_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#222-uv_async_s","text":"uv_async_s\u662fLibuv\u4e2d\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1\u7684\u7ed3\u6784\u4f53\u3002\u7ee7\u627f\u4e8euv_handle_t\uff0c\u5e76\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5\u3002 1 \u5f02\u6b65\u4e8b\u4ef6\u89e6\u53d1\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_async_cb async_cb ; 2 \u7528\u4e8e\u63d2\u5165 async - handles\u961f\u5217 void * queue [ 2 ]; 3 async_handles\u961f\u5217\u4e2d\u7684\u8282\u70b9pending\u5b57\u6bb5\u4e3a1\u8bf4\u660e\u5bf9\u5e94\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86 int pending ;","title":"2.2.2 uv_async_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#223-uv_tcp_s","text":"uv_tcp_s\u7ee7\u627fuv_handle_s\u548cuv_stream_s\u3002","title":"2.2.3 uv_tcp_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#224-uv_udp_s","text":"1 \u53d1\u9001\u5b57\u8282\u6570 size_t send_queue_size ; 2 \u5199\u961f\u5217\u8282\u70b9\u7684\u4e2a\u6570 size_t send_queue_count ; 3 \u5206\u914d\u63a5\u6536\u6570\u636e\u7684\u5185\u5b58 uv_alloc_cb alloc_cb ; 4 \u63a5\u6536\u5b8c\u6570\u636e\u540e\u6267\u884c\u7684\u56de\u8c03 uv_udp_recv_cb recv_cb ; 5 \u63d2\u5165 epoll\u91cc\u7684IO\u89c2\u5bdf\u8005 \uff0c\u5b9e\u73b0\u6570\u636e\u8bfb\u5199 uv__io_t io_watcher ; 6 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 7 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09\uff0c\u548c\u5f85\u53d1\u9001\u961f\u5217\u76f8\u5173 void * write_completed_queue [ 2 ];","title":"2.2.4 uv_udp_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#225-uv_tty_s","text":"uv_tty_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 \u7ec8\u7aef\u7684\u53c2\u6570 struct termios orig_termios ; 2 \u7ec8\u7aef\u7684\u5de5\u4f5c\u6a21\u5f0f int mode ;","title":"2.2.5 uv_tty_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#226-uv_pipe_s","text":"uv_pipe_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 \u6807\u8bb0\u7ba1\u9053\u662f\u5426\u53ef\u7528\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 int ipc ; 2 \u7528\u4e8e Unix\u57df\u901a\u4fe1\u7684\u6587\u4ef6\u8def\u5f84 const char * pipe_fname ;","title":"2.2.6 uv_pipe_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#227-uv_prepare_suv_check_suv_idle_s","text":"\u4e0a\u9762\u4e09\u4e2a\u7ed3\u6784\u4f53\u5b9a\u4e49\u662f\u7c7b\u4f3c\u7684\uff0c\u5b83\u4eec\u90fd\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e24\u4e2a\u5b57\u6bb5\u3002 1 prepare \u3001 check \u3001 idle\u9636\u6bb5\u56de\u8c03 uv_xxx_cb xxx_cb ; 2 \u7528\u4e8e\u63d2\u5165 prepare \u3001 check \u3001 idle\u961f\u5217 void * queue [ 2 ];","title":"2.2.7 uv_prepare_s\u3001uv_check_s\u3001uv_idle_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#228-uv_timer_s","text":"uv_timer_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u51e0\u4e2a\u5b57\u6bb5\u3002 1 \u8d85\u65f6\u56de\u8c03 uv_timer_cb timer_cb ; 2 \u63d2\u5165\u4e8c\u53c9\u5806\u7684\u5b57\u6bb5 void * heap_node [ 3 ]; 3 \u8d85\u65f6\u65f6\u95f4 uint64_t timeout ; 4 \u8d85\u65f6\u540e\u662f\u5426\u7ee7\u7eed\u5f00\u59cb\u91cd\u65b0\u8ba1\u65f6\uff0c\u662f\u7684\u8bdd\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806 uint64_t repeat ; 5 id\u6807\u8bb0 \uff0c\u7528\u4e8e\u63d2\u5165\u4e8c\u53c9\u5806\u7684\u65f6\u5019\u5bf9\u6bd4 uint64_t start_id","title":"2.2.8 uv_timer_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#229-uv_process_s","text":"uv_process_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 \u8fdb\u7a0b\u9000\u51fa\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_exit_cb exit_cb ; 2 \u8fdb\u7a0b id int pid ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217\uff0c\u8fdb\u7a0b\u961f\u5217\u6216\u8005 pending\u961f\u5217 void * queue [ 2 ]; 4 \u9000\u51fa\u7801\uff0c\u8fdb\u7a0b\u9000\u51fa\u65f6\u8bbe\u7f6e int status ;","title":"2.2.9 uv_process_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2210-uv_fs_event_s","text":"uv_fs_event_s\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u6539\u52a8\u3002uv_fs_event_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 ( \u6587\u4ef6\u6216\u76ee\u5f55 ) char * path ; 2 \u6587\u4ef6\u6539\u53d8\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_fs_event_cb cb ;","title":"2.2.10 uv_fs_event_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2211-uv_fs_poll_s","text":"uv_fs_poll_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 poll_ctx\u6307\u5411poll_ctx\u7ed3\u6784\u4f53 void * poll_ctx ; struct poll_ctx { // \u5bf9\u5e94\u7684handle uv_fs_poll_t * parent_handle ; // \u6807\u8bb0\u662f\u5426\u5f00\u59cb\u8f6e\u8be2\u548c\u8f6e\u8be2\u65f6\u7684\u5931\u8d25\u539f\u56e0 int busy_polling ; // \u591a\u4e45\u68c0\u6d4b\u4e00\u6b21\u6587\u4ef6\u5185\u5bb9\u662f\u5426\u6539\u53d8 unsigned int interval ; // \u6bcf\u4e00\u8f6e\u8f6e\u8be2\u65f6\u7684\u5f00\u59cb\u65f6\u95f4 uint64_t start_time ; // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; // \u6587\u4ef6\u6539\u53d8\u65f6\u56de\u8c03 uv_fs_poll_cb poll_cb ; // \u5b9a\u65f6\u5668\uff0c\u7528\u4e8e\u5b9a\u65f6\u8d85\u65f6\u540e\u8f6e\u8be2 uv_timer_t timer_handle ; // \u8bb0\u5f55\u8f6e\u8be2\u7684\u4e00\u4e0b\u4e0a\u4e0b\u6587\u4fe1\u606f\uff0c\u6587\u4ef6\u8def\u5f84\u3001\u56de\u8c03\u7b49 uv_fs_t fs_req ; // \u8f6e\u8be2\u65f6\u4fdd\u5b58\u64cd\u4f5c\u7cfb\u7edf\u8fd4\u56de\u7684\u6587\u4ef6\u4fe1\u606f uv_stat_t statbuf ; // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u5b57\u7b26\u4e32\u7684\u503c\u8ffd\u52a0\u5728\u7ed3\u6784\u4f53\u540e\u9762 char path [ 1 ]; /* variable length */ };","title":"2.2.11 uv_fs_poll_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2212-uv_poll_s","text":"uv_poll_s\u7ee7\u627f\u4e8euv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 \u76d1\u542c\u7684 fd\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_poll_cb poll_cb ; 2 \u4fdd\u5b58\u4e86 fd\u548c\u56de\u8c03\u7684IO\u89c2\u5bdf\u8005 \uff0c\u6ce8\u518c\u5230 epoll\u4e2d uv__io_t io_watcher ;","title":"2.2.12 uv_poll_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2113-uv_signal_s","text":"uv_signal_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5 1 \u6536\u5230\u4fe1\u53f7\u65f6\u7684\u56de\u8c03 uv_signal_cb signal_cb ; 2 \u6ce8\u518c\u7684\u4fe1\u53f7 int signum ; 3 \u7528\u4e8e\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u8fdb\u7a0b\u628a\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u5c01\u88c5\u6210 uv_signal_s \uff0c\u7136\u540e\u63d2\u5165\u5230\u7ea2\u9ed1\u6811\uff0c\u4fe1\u53f7\u5230\u6765\u65f6\uff0c\u8fdb\u7a0b\u5728\u4fe1\u53f7\u5904\u7406\u53f7\u4e2d\u628a\u901a\u77e5\u5199\u5165\u7ba1\u9053\uff0c\u901a\u77e5 Libuv \u3002 Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u6267\u884c\u8fdb\u7a0b\u5bf9\u5e94\u7684\u56de\u8c03 \u3002\u7ea2\u9ed1\u6811\u8282\u70b9\u7684\u5b9a\u4e49\u5982\u4e0b struct { struct uv_signal_s * rbe_left ; struct uv_signal_s * rbe_right ; struct uv_signal_s * rbe_parent ; int rbe_color ; } tree_entry ; 4 \u6536\u5230\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int caught_signals ; 5 \u5df2\u7ecf\u5904\u7406\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int dispatched_signals ;","title":"2.1.13 uv_signal_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#23-uv_req_s","text":"\u5728Libuv\u4e2d\uff0cuv_req_s\u4e5f\u7c7b\u4f3cC++\u57fa\u7c7b\u7684\u4f5c\u7528\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0crequest\u4ee3\u8868\u4e00\u6b21\u8bf7\u6c42\uff0c\u6bd4\u5982\u8bfb\u5199\u4e00\u4e2a\u6587\u4ef6\uff0c\u8bfb\u5199socket\uff0c\u67e5\u8be2DNS\u3002\u4efb\u52a1\u5b8c\u6210\u540e\u8fd9\u4e2arequest\u5c31\u7ed3\u675f\u4e86\u3002request\u53ef\u4ee5\u548chandle\u7ed3\u5408\u4f7f\u7528\uff0c\u6bd4\u5982\u5728\u4e00\u4e2aTCP\u670d\u52a1\u5668\u4e0a\uff08handle\uff09\u5199\u4e00\u4e2a\u6570\u636e\uff08request\uff09\uff0c\u4e5f\u53ef\u4ee5\u5355\u72ec\u4f7f\u7528\u4e00\u4e2arequest\uff0c\u6bd4\u5982DNS\u67e5\u8be2\u6216\u8005\u6587\u4ef6\u8bfb\u5199\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_req_s\u7684\u5b9a\u4e49\u3002 1 \u81ea\u5b9a\u4e49\u6570\u636e void * data ; 2 request\u7c7b\u578b uv_req_type type ; 3 \u4fdd\u7559\u5b57\u6bb5 void * reserved [ 6 ];","title":"2.3 uv_req_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#231-uv_shutdown_s","text":"uv_shutdown_s\u7528\u4e8e\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u8981\u5173\u95ed\u7684\u6d41\uff0c\u6bd4\u5982 TCP uv_stream_t * handle ; 2 \u5173\u95ed\u6d41\u7684\u5199\u7aef\u540e\u6267\u884c\u7684\u56de\u8c03 uv_shutdown_cb cb ;","title":"2.3.1 uv_shutdown_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#232-uv_write_s","text":"uv_write_s\u8868\u793a\u4e00\u6b21\u5199\u8bf7\u6c42\uff0c\u6bd4\u5982\u5728TCP\u6d41\u4e0a\u53d1\u9001\u6570\u636e\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u5199\u5b8c\u540e\u7684\u56de\u8c03 uv_write_cb cb ; 2 \u9700\u8981\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5728 send_handle\u4e2d uv_stream_t * send_handle ; 3 \u5173\u8054\u7684 handle uv_stream_t * handle ; 4 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ]; 5 \u4fdd\u5b58\u9700\u8981\u5199\u7684\u6570\u636e\u76f8\u5173\u7684\u5b57\u6bb5\uff08\u5199\u5165\u7684 buffer\u4e2a\u6570 \uff0c\u5f53\u524d\u5199\u6210\u529f\u7684\u4f4d\u7f6e\u7b49\uff09 unsigned int write_index ; uv_buf_t * bufs ; unsigned int nbufs ; uv_buf_t bufsml [ 4 ]; 6 \u5199\u51fa\u9519\u7684\u9519\u8bef\u7801 int error ;","title":"2.3.2 uv_write_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#233-uv_connect_s","text":"uv_connect_s\u8868\u793a\u53d1\u8d77\u8fde\u63a5\u8bf7\u6c42\uff0c\u6bd4\u5982TCP\u8fde\u63a5\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u8fde\u63a5\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 uv_connect_cb cb ; 2 \u5bf9\u5e94\u7684\u6d41\uff0c\u6bd4\u5982 tcp uv_stream_t * handle ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ];","title":"2.3.3 uv_connect_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#234-uv_udp_send_s","text":"uv_udp_send_s\u8868\u793a\u4e00\u6b21\u53d1\u9001UDP\u6570\u636e\u7684\u8bf7\u6c42 1 \u6240\u5c5e udp\u7684handle \uff0c udp_send_s\u4ee3\u8868\u4e00\u6b21\u53d1\u9001 uv_udp_t * handle ; 2 \u56de\u8c03 uv_udp_send_cb cb ; 3 \u7528\u4e8e\u63d2\u5165\u5f85\u53d1\u9001\u961f\u5217 void * queue [ 2 ]; 4 \u53d1\u9001\u7684\u76ee\u7684\u5730\u5740 struct sockaddr_storage addr ; 5 \u4fdd\u5b58\u4e86\u53d1\u9001\u6570\u636e\u7684\u7f13\u51b2\u533a\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; uv_buf_t bufsml [ 4 ]; 6 \u53d1\u9001\u72b6\u6001\u6216\u6210\u529f\u53d1\u9001\u7684\u5b57\u8282\u6570 ssize_t status ; 7 \u53d1\u9001\u5b8c\u6267\u884c\u7684\u56de\u8c03\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09 uv_udp_send_cb send_cb ;","title":"2.3.4 uv_udp_send_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#235-uv_getaddrinfo_s","text":"uv_getaddrinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7\u57df\u540d\u67e5\u8be2IP\u7684DNS\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 DNS\u89e3\u6790\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 uv_getaddrinfo_cb cb ; 4 DNS\u67e5\u8be2\u7684\u914d\u7f6e struct addrinfo * hints ; char * hostname ; char * service ; 5 DNS\u89e3\u6790\u7ed3\u679c struct addrinfo * addrinfo ; 6 DNS\u89e3\u6790\u7684\u8fd4\u56de\u7801 int retcode ;","title":"2.3.5 uv_getaddrinfo_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#236-uv_getnameinfo_s","text":"uv_getnameinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u7684DNS\u67e5\u8be2\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 socket\u8f6c\u57df\u540d\u5b8c\u6210\u7684\u56de\u8c03 uv_getnameinfo_cb getnameinfo_cb ; 4 \u9700\u8981\u8f6c\u57df\u540d\u7684 socket\u7ed3\u6784\u4f53 struct sockaddr_storage storage ; 5 \u6307\u793a\u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f int flags ; 6 \u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f char host [ NI_MAXHOST ]; char service [ NI_MAXSERV ]; 7 \u67e5\u8be2\u8fd4\u56de\u7801 int retcode ;","title":"2.3.6 uv_getnameinfo_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#237-uv_work_s","text":"uv_work_s\u7528\u4e8e\u5f80\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u5904\u7406\u4efb\u52a1\u7684\u51fd\u6570 uv_work_cb work_cb ; 3 \u5904\u7406\u5b8c\u4efb\u52a1\u540e\u6267\u884c\u7684\u51fd\u6570 uv_after_work_cb after_work_cb ; 4 \u5c01\u88c5\u4e00\u4e2a work\u63d2\u5165\u5230\u7ebf\u7a0b\u6c60\u961f\u5217 \uff0c work_req\u7684work\u548cdone\u51fd\u6570\u662f\u5bf9\u4e0a\u9762work_cb\u548cafter_work_cb\u7684\u5c01\u88c5 struct uv__work work_req ;","title":"2.3.7 uv_work_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#uv_fs_s","text":"uv_fs_s\u8868\u793a\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 \u6587\u4ef6\u64cd\u4f5c\u7c7b\u578b uv_fs_type fs_type ; 2 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 \u6587\u4ef6\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03 uv_fs_cb cb ; 4 \u6587\u4ef6\u64cd\u4f5c\u7684\u8fd4\u56de\u7801 ssize_t result ; 5 \u6587\u4ef6\u64cd\u4f5c\u8fd4\u56de\u7684\u6570\u636e void * ptr ; 6 \u6587\u4ef6\u64cd\u4f5c\u8def\u5f84 const char * path ; 7 \u6587\u4ef6\u7684 stat\u4fe1\u606f uv_stat_t statbuf ; 8 \u6587\u4ef6\u64cd\u4f5c\u6d89\u53ca\u5230\u4e24\u4e2a\u8def\u5f84\u65f6\uff0c\u4fdd\u5b58\u76ee\u7684\u8def\u5f84 const char * new_path ; 9 \u6587\u4ef6\u63cf\u8ff0\u7b26 uv_file file ; 10 \u6587\u4ef6\u6807\u8bb0 int flags ; 11 \u64cd\u4f5c\u6a21\u5f0f mode_t mode ; 12 \u5199\u6587\u4ef6\u65f6\u4f20\u5165\u7684\u6570\u636e\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; 13 \u6587\u4ef6\u504f\u79fb off_t off ; 14 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684 uid\u548cgid \uff0c\u4f8b\u5982 chmod\u7684\u65f6\u5019 uv_uid_t uid ; uv_gid_t gid ; 15 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684\u6587\u4ef6\u4fee\u6539\u3001\u8bbf\u95ee\u65f6\u95f4\uff0c\u4f8b\u5982 fs . utimes\u7684\u65f6\u5019 double atime ; double mtime ; 16 \u5f02\u6b65\u7684\u65f6\u5019\u7528\u4e8e\u63d2\u5165\u4efb\u52a1\u961f\u5217\uff0c\u4fdd\u5b58\u5de5\u4f5c\u51fd\u6570\uff0c\u56de\u8c03\u51fd\u6570 struct uv__work work_req ; 17 \u4fdd\u5b58\u8bfb\u53d6\u6570\u636e\u6216\u8005\u957f\u5ea6\u3002\u4f8b\u5982 read\u548csendfile uv_buf_t bufsml [ 4 ];","title":"uv_fs_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#24-io","text":"IO\u89c2\u5bdf\u8005\u662fLibuv\u4e2d\u7684\u6838\u5fc3\u6982\u5ff5\u548c\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9a\u4e49 1. struct uv__io_s { 2. // \u4e8b\u4ef6\u89e6\u53d1\u540e\u7684\u56de\u8c03 3. uv__io_cb cb ; 4. // \u7528\u4e8e\u63d2\u5165\u961f\u5217 5. void * pending_queue [ 2 ]; 6. void * watcher_queue [ 2 ]; 7. // \u4fdd\u5b58\u672c\u6b21\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\u65f6\u8bbe\u7f6e 8. unsigned int pevents ; 9. // \u4fdd\u5b58\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. unsigned int events ; 11. int fd ; 12. }; IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4e8b\u4ef6\u548c\u56de\u8c03\uff0c\u7136\u540e\u63d2\u5165\u5230loop\u7ef4\u62a4\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6839\u636eIO\u89c2\u5bdf\u8005\u63cf\u8ff0\u7684\u4fe1\u606f\uff0c\u5f80\u5e95\u5c42\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u5f53\u6ce8\u518c\u7684\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u6211\u4eec\u770b\u5982\u4f55\u521dIO\u89c2\u5bdf\u8005\u7684\u4e00\u4e9b\u903b\u8f91\u3002","title":"2.4 IO\u89c2\u5bdf\u8005"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#241-io","text":"1. void uv__io_init ( uv__io_t * w , uv__io_cb cb , int fd ) { 2. // \u521d\u59cb\u5316\u961f\u5217\uff0c\u56de\u8c03\uff0c\u9700\u8981\u76d1\u542c\u7684fd 3. QUEUE_INIT ( & w -> pending_queue ); 4. QUEUE_INIT ( & w -> watcher_queue ); 5. w -> cb = cb ; 6. w -> fd = fd ; 7. // \u4e0a\u6b21\u52a0\u5165epoll\u65f6\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u6267\u884c\u5b8cepoll\u64cd\u4f5c\u51fd\u6570\u540e\u8bbe\u7f6e 8. w -> events = 0 ; 9. // \u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u518d\u6b21\u6267\u884cepoll\u51fd\u6570\u4e4b\u524d\u8bbe\u7f6e 10. w -> pevents = 0 ; 11. }","title":"2.4.1 \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#242iolibuv","text":"1. void uv__io_start ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { 2. // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 3. w -> pevents |= events ; 4. // \u53ef\u80fd\u9700\u8981\u6269\u5bb9 5. maybe_resize ( loop , w -> fd + 1 ); 6. // \u4e8b\u4ef6\u6ca1\u6709\u53d8\u5316\u5219\u76f4\u63a5\u8fd4\u56de 7. if ( w -> events == w -> pevents ) 8. return ; 9. // IO\u89c2\u5bdf\u8005\u6ca1\u6709\u6302\u8f7d\u5728\u5176\u5b83\u5730\u65b9\u5219\u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217 10. if ( QUEUE_EMPTY ( & w -> watcher_queue )) 11. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 12. // \u4fdd\u5b58\u6620\u5c04\u5173\u7cfb 13. if ( loop -> watchers [ w -> fd ] == NULL ) { 14. loop -> watchers [ w -> fd ] = w ; 15. loop -> nfds ++ ; 16. } 17. } uv__io_start\u51fd\u6570\u5c31\u662f\u628a\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u63d2\u5165\u5230Libuv\u7684\u89c2\u5bdf\u8005\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u5728watchers\u6570\u7ec4\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\u3002Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u961f\u5217\u3002","title":"2.4.2\u6ce8\u518c\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u5230Libuv\u3002"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#243-io","text":"uv__io_stop\u4fee\u6539IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u8fd8\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7684\u8bdd\uff0cIO\u89c2\u5bdf\u8005\u8fd8\u4f1a\u5728\u961f\u5217\u91cc\uff0c\u5426\u5219\u79fb\u51fa 1. void uv__io_stop ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. if ( w -> fd == -1 ) 5. return ; 6. assert ( w -> fd >= 0 ); 7. if (( unsigned ) w -> fd >= loop -> nwatchers ) 8. return ; 9. // \u6e05\u9664\u4e4b\u524d\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4fdd\u5b58\u5728pevents\u91cc\uff0c\u8868\u793a\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. w -> pevents &= ~ events ; 11. // \u5bf9\u6240\u6709\u4e8b\u4ef6\u90fd\u4e0d\u611f\u5174\u8da3\u4e86 12. if ( w -> pevents == 0 ) { 13. // \u79fb\u51faIO\u89c2\u5bdf\u8005\u961f\u5217 14. QUEUE_REMOVE ( & w -> watcher_queue ); 15. // \u91cd\u7f6e 16. QUEUE_INIT ( & w -> watcher_queue ); 17. // \u91cd\u7f6e 18. if ( loop -> watchers [ w -> fd ] != NULL ) { 19. assert ( loop -> watchers [ w -> fd ] == w ); 20. assert ( loop -> nfds > 0 ); 21. loop -> watchers [ w -> fd ] = NULL ; 22. loop -> nfds -- ; 23. w -> events = 0 ; 24. } 25. } 26. /* 27. \u4e4b\u524d\u8fd8\u6ca1\u6709\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5219\u63d2\u5165\uff0c 28. \u7b49\u5230Poll IO\u65f6\u5904\u7406\uff0c\u5426\u5219\u4e0d\u9700\u8981\u5904\u7406 29. */ 30. else if ( QUEUE_EMPTY ( & w -> watcher_queue )) 31. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 32. }","title":"2.4.3 \u64a4\u9500IO\u89c2\u5bdf\u8005\u6216\u8005\u4e8b\u4ef6"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#25-libuv","text":"","title":"2.5 Libuv\u901a\u7528\u903b\u8f91"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#251-uv__handle_init","text":"uv__handle_init\u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u8bbe\u7f6eREF\u6807\u8bb0\uff0c\u63d2\u5165handle\u961f\u5217\u3002 1. # define uv__handle_init ( loop_ , h , type_ ) 2. do { 3. ( h ) -> loop = ( loop_ ); 4. ( h ) -> type = ( type_ ); 5. ( h ) -> flags = UV_HANDLE_REF ; 6. QUEUE_INSERT_TAIL ( & ( loop_ ) -> handle_queue , & ( h ) -> handle_queue ); 7. ( h ) -> next_closing = NULL 8. } 9. while ( 0 )","title":"2.5.1   uv__handle_init"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#252-uv__handle_start","text":"uv__handle_start\u8bbe\u7f6e\u6807\u8bb0handle\u4e3aACTIVE\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86REF\u6807\u8bb0\uff0c\u5219active handle\u7684\u4e2a\u6570\u52a0\u4e00\uff0cactive handle\u6570\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1. # define uv__handle_start ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) 6. ( h ) -> loop -> active_handles ++ ; 7. } 8. while ( 0 )","title":"2.5.2.  uv__handle_start"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#253-uv__handle_stop","text":"uv__handle_stop\u548cuv__handle_start\u76f8\u53cd\u3002 1. # define uv__handle_stop ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) uv__active_handle_rm ( h ); 6. } 7. while ( 0 ) Libuv\u4e2dhandle\u6709REF\u548cACTIVE\u4e24\u4e2a\u72b6\u6001\u3002\u5f53\u4e00\u4e2ahandle\u8c03\u7528xxx_init\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u9996\u5148\u88ab\u6253\u4e0aREF\u6807\u8bb0\uff0c\u5e76\u4e14\u63d2\u5165loop->handle\u961f\u5217\u3002\u5f53handle\u8c03\u7528xxx_start\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u88ab\u6253\u4e0aACTIVE\u6807\u8bb0\uff0c\u5e76\u4e14\u8bb0\u5f55active handle\u7684\u4e2a\u6570\u52a0\u4e00\u3002\u53ea\u6709REF\u5e76\u4e14ACTIVE\u72b6\u6001\u7684handle\u624d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002","title":"2.5.3.  uv__handle_stop"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#254-uv__req_init","text":"uv__req_init\u521d\u59cb\u5316\u8bf7\u6c42\u7684\u7c7b\u578b\uff0c\u8bb0\u5f55\u8bf7\u6c42\u7684\u4e2a\u6570\uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1. # define uv__req_init ( loop , req , typ ) 2. do { 3. ( req ) -> type = ( typ ); 4. ( loop ) -> active_reqs . count ++ ; 5. } 6. while ( 0 )","title":"2.5.4.  uv__req_init"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#255-uv__req_register","text":"\u8bf7\u6c42\u7684\u4e2a\u6570\u52a0\u4e00 1. # define uv__req_register ( loop , req ) 2. do { 3. ( loop ) -> active_reqs . count ++ ; 4. } 5. while ( 0 )","title":"2.5.5.  uv__req_register"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#256-uv__req_unregister","text":"\u8bf7\u6c42\u4e2a\u6570\u51cf\u4e00 1. # define uv__req_unregister ( loop , req ) 2. do { 3. assert ( uv__has_active_reqs ( loop )); 4. ( loop ) -> active_reqs . count -- ; 5. } 6. while ( 0 )","title":"2.5.6.  uv__req_unregister"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#257-uv__handle_ref","text":"uv__handle_ref\u6807\u8bb0handle\u4e3aREF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u52a0\u4e00 1. # define uv__handle_ref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_add ( h ); 7. } 8. while ( 0 ) 9. uv__handle_unref uv__handle_unref\u53bb\u6389handle\u7684REF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u51cf\u4e00 1. # define uv__handle_unref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_rm ( h ); 7. } 8. while ( 0 )","title":"2.5.7.  uv__handle_ref"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","text":"\u7b2c\u4e09\u7ae0 \u4e8b\u4ef6\u5faa\u73af \u00b6 Node.js\u5c5e\u4e8e\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u67b6\u6784\uff0c\u8be5\u4e8b\u4ef6\u5faa\u73af\u7531Libuv\u7684uv_run\u51fd\u6570\u5b9e\u73b0\uff0c\u5728\u8be5\u51fd\u6570\u4e2d\u6267\u884cwhile\u5faa\u73af\uff0c\u7136\u540e\u4e0d\u65ad\u5730\u5904\u7406\u5404\u4e2a\u9636\u6bb5\uff08phase\uff09\u7684\u4e8b\u4ef6\u56de\u8c03\u3002\u4e8b\u4ef6\u5faa\u73af\u7684\u5904\u7406\u76f8\u5f53\u4e8e\u4e00\u4e2a\u6d88\u8d39\u8005\uff0c\u6d88\u8d39\u7531\u5404\u79cd\u4ee3\u7801\u4ea7\u751f\u7684\u4efb\u52a1\u3002Node.js\u521d\u59cb\u5316\u5b8c\u6210\u540e\u5c31\u5f00\u59cb\u9677\u5165\u8be5\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\u4e5f\u5c31\u610f\u5473\u7740Node.js\u7684\u7ed3\u675f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u4ee3\u7801\u3002 1. int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { 2. int timeout ; 3. int r ; 4. int ran_pending ; 5. // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop 6. r = uv__loop_alive ( loop ); 7. // \u4e8b\u4ef6\u5faa\u73af\u6ca1\u6709\u4efb\u52a1\u6267\u884c\uff0c\u5373\u5c06\u9000\u51fa\uff0c\u8bbe\u7f6e\u4e00\u4e0b\u5f53\u524d\u5faa\u73af\u7684\u65f6\u95f4 8. if ( ! r ) 9. uv__update_time ( loop ); 10. // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af 11. while ( r != 0 && loop -> stop_flag == 0 ) { 12. // \u66f4\u65b0loop\u7684time\u5b57\u6bb5 13. uv__update_time ( loop ); 14. // \u6267\u884c\u8d85\u65f6\u56de\u8c03 15. uv__run_timers ( loop ); 16. /* 17. \u6267\u884cpending\u56de\u8c03\uff0cran_pending\u4ee3\u8868pending\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c 18. \u5373\u6ca1\u6709\u8282\u70b9\u53ef\u4ee5\u6267\u884c 19. */ 20. ran_pending = uv__run_pending ( loop ); 21. // \u7ee7\u7eed\u6267\u884c\u5404\u79cd\u961f\u5217 22. uv__run_idle ( loop ); 23. uv__run_prepare ( loop ); 24. 25. timeout = 0 ; 26. /* 27. \u6267\u884c\u6a21\u5f0f\u662fUV_RUN_ONCE\u65f6\uff0c\u5982\u679c\u6ca1\u6709pending\u8282\u70b9\uff0c 28. \u624d\u4f1a\u963b\u585e\u5f0fPoll IO\uff0c\u9ed8\u8ba4\u6a21\u5f0f\u4e5f\u662f 29. */ 30. if (( mode == UV_RUN_ONCE && ! ran_pending ) || 31. mode == UV_RUN_DEFAULT ) 32. timeout = uv_backend_timeout ( loop ); 33. // Poll IO timeout\u662fepoll_wait\u7684\u8d85\u65f6\u65f6\u95f4 34. uv__io_poll ( loop , timeout ); 35. // \u5904\u7406check\u9636\u6bb5 36. uv__run_check ( loop ); 37. // \u5904\u7406close\u9636\u6bb5 38. uv__run_closing_handles ( loop ); 39. /* 40. \u8fd8\u6709\u4e00\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u673a\u4f1a\uff0c\u56e0\u4e3auv__io_poll\u53ef\u80fd\u662f\u56e0\u4e3a 41. \u5b9a\u65f6\u5668\u8d85\u65f6\u8fd4\u56de\u7684\u3002 42. */ 43. if ( mode == UV_RUN_ONCE ) { 44. uv__update_time ( loop ); 45. uv__run_timers ( loop ); 46. } 47. 48. r = uv__loop_alive ( loop ); 49. /* 50. \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u9000\u51fa\u5faa\u73af,UV_RUN_NOWAIT\u8868\u793a\u5728Poll IO\u9636\u6bb5 51. \u4e0d\u4f1a\u963b\u585e\u5e76\u4e14\u5faa\u73af\u53ea\u6267\u884c\u4e00\u6b21 52. */ 53. if ( mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT ) 54. break ; 55. } 56. // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag 57. if ( loop -> stop_flag != 0 ) 58. loop -> stop_flag = 0 ; 59. /* 60. \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c 61. \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run 62. */ 63. return r ; 64. } Libuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u4e0b\u9762\u4ece\u5148\u5230\u540e\uff0c\u5206\u522b\u5206\u6790\u5404\u4e2a\u9636\u6bb5\u7684\u76f8\u5173\u4ee3\u7801\u3002 3.1 \u4e8b\u4ef6\u5faa\u73af\u4e4b\u5b9a\u65f6\u5668 \u00b6 Libuv\u4e2d\uff0c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u7b2c\u4e00\u4e2a\u88ab\u5904\u7406\u7684\u9636\u6bb5\u3002\u5b9a\u65f6\u5668\u662f\u4ee5\u6700\u5c0f\u5806\u5b9e\u73b0\u7684\uff0c\u6700\u5feb\u8fc7\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002Libuv\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u90fd\u4f1a\u7f13\u5b58\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5728\u6bcf\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4f7f\u7528\u7684\u90fd\u662f\u8fd9\u4e2a\u7f13\u5b58\u7684\u65f6\u95f4\uff0c\u5fc5\u8981\u7684\u65f6\u5019Libuv\u4f1a\u663e\u5f0f\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u56e0\u4e3a\u83b7\u53d6\u65f6\u95f4\u9700\u8981\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c\u800c\u9891\u7e41\u8c03\u7528\u7cfb\u7edf\u8c03\u7528\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u8017\u65f6\uff0c\u7f13\u5b58\u65f6\u95f4\u53ef\u4ee5\u51cf\u5c11\u64cd\u4f5c\u7cfb\u7edf\u7684\u8c03\u7528\uff0c\u63d0\u9ad8\u6027\u80fd\u3002Libuv\u7f13\u5b58\u4e86\u5f53\u524d\u6700\u65b0\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u6267\u884cuv__run_timers\uff0c\u8be5\u51fd\u6570\u5c31\u662f\u904d\u5386\u6700\u5c0f\u5806\uff0c\u627e\u51fa\u5f53\u524d\u8d85\u65f6\u7684\u8282\u70b9\u3002\u56e0\u4e3a\u5806\u7684\u6027\u8d28\u662f\u7236\u8282\u70b9\u80af\u5b9a\u6bd4\u5b69\u5b50\u5c0f\u3002\u5e76\u4e14\u6839\u8282\u70b9\u662f\u6700\u5c0f\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4e00\u4e2a\u6839\u8282\u70b9\uff0c\u5b83\u6ca1\u6709\u8d85\u65f6\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u3002\u5bf9\u4e8e\u8d85\u65f6\u7684\u8282\u70b9\u5c31\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1. void uv__run_timers ( uv_loop_t * loop ) { 2. struct heap_node * heap_node ; 3. uv_timer_t * handle ; 4. // \u904d\u5386\u4e8c\u53c9\u5806 5. for (;;) { 6. // \u627e\u51fa\u6700\u5c0f\u7684\u8282\u70b9 7. heap_node = heap_min ( timer_heap ( loop )); 8. // \u6ca1\u6709\u5219\u9000\u51fa 9. if ( heap_node == NULL ) 10. break ; 11. // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 12. handle = container_of ( heap_node , uv_timer_t , heap_node ); 13. // \u6700\u5c0f\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u5e02\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6 14. if ( handle -> timeout > loop -> time ) 15. break ; 16. // \u5220\u9664\u8be5\u8282\u70b9 17. uv_timer_stop ( handle ); 18. /* 19. \u91cd\u8bd5\u63d2\u5165\u4e8c\u53c9\u5806\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd\uff08\u8bbe\u7f6e\u4e86repeat\uff0c\u6bd4\u5982 20. setInterval\uff09 21. */ 22. uv_timer_again ( handle ); 23. // \u6267\u884c\u56de\u8c03 24. handle -> timer_cb ( handle ); 25. } 26. } \u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0c\u8fd8\u6709\u4e24\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\uff0c\u7b2c\u4e00\u5c31\u662fstop\uff0c\u7b2c\u4e8c\u5c31\u662fagain\u3002stop\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u628ahandle\u4ece\u4e8c\u53c9\u5806\u4e2d\u5220\u9664\uff0c\u5e76\u4e14\u4fee\u6539handle\u7684\u72b6\u6001\u3002\u90a3\u4e48again\u53c8\u662f\u4ec0\u4e48\u5462\uff1fagain\u662f\u4e3a\u4e86\u652f\u6301setInterval\u8fd9\u79cd\u573a\u666f\uff0c\u5982\u679chandle\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\uff0c\u5219\u8be5handle\u5728\u8d85\u65f6\u540e\uff0c\u6bcfrepeat\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u4f1a\u7ee7\u7eed\u6267\u884c\u8d85\u65f6\u56de\u8c03\u3002\u5bf9\u4e8esetInterval\uff0c\u5c31\u662f\u8d85\u65f6\u65f6\u95f4\u662fx\uff0c\u6bcfx\u7684\u65f6\u95f4\u540e\uff0c\u6267\u884c\u56de\u8c03\u3002\u8fd9\u5c31\u662fNode.js\u91cc\u5b9a\u65f6\u5668\u7684\u5e95\u5c42\u539f\u7406\u3002\u4f46Node.js\u4e0d\u662f\u6bcf\u6b21\u8c03setTimeout/setInterval\u7684\u65f6\u5019\u90fd\u5f80\u6700\u5c0f\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0cNode.js\u91cc\uff0c\u53ea\u6709\u4e00\u4e2a\u5173\u4e8euv_timer_s\u7684handle\uff0c\u5b83\u5728JS\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u6b21\u8ba1\u7b97\u51fa\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9\uff0c\u7136\u540e\u4fee\u6539handle\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5177\u4f53\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u8bb2\u89e3\u3002 \u53e6\u5916timer\u9636\u6bb5\u548cPoll IO\u9636\u6bb5\u4e5f\u6709\u4e00\u4e9b\u8054\u7cfb\uff0c\u56e0\u4e3aPoll IO\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u4e3b\u7ebf\u7a0b\u53ef\u4ee5\u5c3d\u5feb\u6267\u884c\u5b9a\u65f6\u5668\u7684\u56de\u8c03\uff0cPoll IO\u4e0d\u80fd\u4e00\u76f4\u963b\u585e\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u963b\u585e\u7684\u65f6\u957f\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u65f6\u957f\uff08\u5177\u4f53\u53ef\u53c2\u8003libuv core.c\u4e2d\u7684uv_backend_timeout\u51fd\u6570\uff09\u3002 3.2 pending\u9636\u6bb5 \u00b6 \u5b98\u7f51\u5bf9pending\u9636\u6bb5\u7684\u89e3\u91ca\u662f\u5728\u4e0a\u4e00\u8f6e\u7684Poll IO\u9636\u6bb5\u6ca1\u6709\u6267\u884c\u7684IO\u56de\u8c03\uff0c\u4f1a\u5728\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684pending\u9636\u6bb5\u88ab\u6267\u884c\u3002\u4ece\u6e90\u7801\u6765\u770b\uff0cPoll IO\u9636\u6bb5\u5904\u7406\u4efb\u52a1\u65f6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u5f53\u524d\u6267\u884c\u7684\u64cd\u4f5c\u5931\u8d25\u9700\u8981\u6267\u884c\u56de\u8c03\u901a\u77e5\u8c03\u7528\u65b9\u4e00\u4e9b\u4fe1\u606f\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u4e0d\u4f1a\u7acb\u523b\u6267\u884c\uff0c\u800c\u662f\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\uff08\u6bd4\u5982\u5199\u5165\u6570\u636e\u6210\u529f\uff0c\u6216\u8005TCP\u8fde\u63a5\u5931\u8d25\u65f6\u56de\u8c03C++\u5c42\uff09\uff0c\u6211\u4eec\u5148\u770bpending\u9636\u6bb5\u7684\u5904\u7406\u3002 1. static int uv__run_pending ( uv_loop_t * loop ) { 2. QUEUE * q ; 3. QUEUE pq ; 4. uv__io_t * w ; 5. 6. if ( QUEUE_EMPTY ( & loop -> pending_queue )) 7. return 0 ; 8. // \u628apending_queue\u961f\u5217\u7684\u8282\u70b9\u79fb\u5230pq\uff0c\u5373\u6e05\u7a7a\u4e86pending_queue 9. QUEUE_MOVE ( & loop -> pending_queue , & pq ); 10. 11. // \u904d\u5386pq\u961f\u5217 12. while ( ! QUEUE_EMPTY ( & pq )) { 13. // \u53d6\u51fa\u5f53\u524d\u7b2c\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373pq.next 14. q = QUEUE_HEAD ( & pq ); 15. // \u628a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u79fb\u51fa\u961f\u5217 16. QUEUE_REMOVE ( q ); 17. /* 18. \u91cd\u7f6e\u4e00\u4e0bprev\u548cnext\u6307\u9488\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u8fd9\u4e24\u4e2a\u6307\u9488\u662f 19. \u6307\u5411\u961f\u5217\u4e2d\u7684\u4e24\u4e2a\u8282\u70b9 20. */ 21. QUEUE_INIT ( q ); 22. w = QUEUE_DATA ( q , uv__io_t , pending_queue ); 23. w -> cb ( loop , w , POLLOUT ); 24. } 25. 26. return 1 ; 27. } pending\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91\u5c31\u662f\u628apending\u961f\u5217\u91cc\u7684\u8282\u70b9\u9010\u4e2a\u6267\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0bpending\u961f\u5217\u7684\u8282\u70b9\u662f\u5982\u4f55\u751f\u4ea7\u51fa\u6765\u7684\u3002 1. void uv__io_feed ( uv_loop_t * loop , uv__io_t * w ) { 2. if ( QUEUE_EMPTY ( & w -> pending_queue )) 3. QUEUE_INSERT_TAIL ( & loop -> pending_queue , & w -> pending_queue ); 4. } Libuv\u901a\u8fc7uv__io_feed\u51fd\u6570\u751f\u4ea7pending\u4efb\u52a1\uff0c\u4eceLibuv\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230IO\u9519\u8bef\u7684\u65f6\u5019\u4f1a\u8c03\u8fd9\u4e2a\u51fd\u6570\uff08\u5982tcp.c\u7684uv__tcp_connect\u51fd\u6570\uff09\u3002 1. if ( handle -> delayed_error ) 2. uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u5728\u5199\u5165\u6570\u636e\u6210\u529f\u540e\uff08\u6bd4\u5982TCP\u3001UDP\uff09\uff0c\u4e5f\u4f1a\u5f80pending\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7b49\u5f85\u56de\u8c03\u3002\u6bd4\u5982\u53d1\u9001\u6570\u636e\u6210\u529f\u540e\u6267\u884c\u7684\u4ee3\u7801\uff08udp.c\u7684uv__udp_sendmsg\u51fd\u6570\uff09 1. // \u53d1\u9001\u5b8c\u79fb\u51fa\u5199\u961f\u5217 2. QUEUE_REMOVE ( & req -> queue ); 3. // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 4. QUEUE_INSERT_TAIL ( & handle -> write_completed_queue , & req -> queue ); 5. /* 6. \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c 7. pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 8. */ 9. uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u6700\u540e\u5173\u95edIO\u7684\u65f6\u5019\uff08\u5982\u5173\u95ed\u4e00\u4e2aTCP\u8fde\u63a5\uff09\u4f1a\u4ecepending\u961f\u5217\u79fb\u9664\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5173\u95ed\u4e86\uff0c\u81ea\u7136\u5c31\u4e0d\u9700\u8981\u6267\u884c\u56de\u8c03\u3002 1. void uv__io_close ( uv_loop_t * loop , uv__io_t * w ) { 2. uv__io_stop ( loop , 3. w , 4. POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI ); 5. QUEUE_REMOVE ( & w -> pending_queue ); 6. } 3.3 \u4e8b\u4ef6\u5faa\u73af\u4e4bprepare,check,idle \u00b6 prepare,check,idle\u662fLibuv\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5c5e\u4e8e\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u5b83\u4eec\u7684\u5b9e\u73b0\u662f\u4e00\u6837\u7684\uff08\u89c1loop-watcher.c\uff09\u3002\u672c\u8282\u53ea\u8bb2\u89e3prepare\u9636\u6bb5\uff0c\u6211\u4eec\u77e5\u9053Libuv\u4e2d\u5206\u4e3ahandle\u548crequest\uff0c\u800cprepare\u9636\u6bb5\u7684\u4efb\u52a1\u662f\u5c5e\u4e8ehandle\u7c7b\u578b\u3002\u8fd9\u610f\u5473\u7740\u9664\u975e\u6211\u4eec\u663e\u5f0f\u79fb\u9664\uff0c\u5426\u5219prepare\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u4e0b\u9762\u6211\u4eec\u5148\u770b\u770b\u600e\u4e48\u4f7f\u7528\u5b83\u3002 1. void prep_cb ( uv_prepare_t * handle ) { 2. printf ( \"Prep callback \\n \" ); 3. } 4. 5. int main () { 6. uv_prepare_t prep ; 7. // \u521d\u59cb\u5316\u4e00\u4e2ahandle\uff0cuv_default_loop\u662f\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 8. uv_prepare_init ( uv_default_loop (), & prep ); 9. // \u6ce8\u518chandle\u7684\u56de\u8c03 10. uv_prepare_start ( & prep , prep_cb ); 11. // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af 12. uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); 13. return 0 ; 14. } \u6267\u884cmain\u51fd\u6570\uff0cLibuv\u5c31\u4f1a\u5728prepare\u9636\u6bb5\u6267\u884c\u56de\u8c03prep_cb\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1. int uv_prepare_init ( uv_loop_t * loop , uv_prepare_t * handle ) { 2. uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_PREPARE ); 3. handle -> prepare_cb = NULL ; 4. return 0 ; 5. } init\u51fd\u6570\u4e3b\u8981\u662f\u505a\u4e00\u4e9b\u521d\u59cb\u5316\u64cd\u4f5c\u3002\u6211\u4eec\u7ee7\u7eed\u8981\u770bstart\u51fd\u6570\u3002 1. int uv_prepare_start ( uv_prepare_t * handle , uv_prepare_cb cb ) { 2. // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de 3. if ( uv__is_active ( handle )) return 0 ; 4. if ( cb == NULL ) return UV_EINVAL ; 5. QUEUE_INSERT_HEAD ( & handle -> loop -> prepare_handles , 6. & handle -> queue ); 7. handle -> prepare_cb = cb ; 8. uv__handle_start ( handle ); 9. return 0 ; 10. } uv_prepare_start\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u4e3b\u8981\u662f\u8bbe\u7f6e\u56de\u8c03\uff0c\u628ahandle\u63d2\u5165loop\u7684prepare_handles\u961f\u5217\uff0cprepare_handles\u961f\u5217\u4fdd\u5b58\u4e86prepare\u9636\u6bb5\u7684\u4efb\u52a1\u3002\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u4f1a\u9010\u4e2a\u6267\u884c\u91cc\u9762\u7684\u8282\u70b9\u7684\u56de\u8c03\u3002\u7136\u540e\u6211\u4eec\u770b\u770bLibuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u662f\u5982\u4f55\u5904\u7406\u7684\u3002 1. void uv__run_prepare ( uv_loop_t * loop ) { 2. uv_prepare_t * h ; 3. QUEUE queue ; 4. QUEUE * q ; 5. /* 6. \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c 7. \u76f8\u5f53\u4e8e\u6e05\u7a7aprepare_handles\u961f\u5217\uff0c\u56e0\u4e3a\u5982\u679c\u76f4\u63a5\u904d\u5386 8. prepare_handles\u961f\u5217\uff0c\u5728\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4e00\u76f4\u5f80prepare_handles 9. \u961f\u5217\u52a0\u8282\u70b9\uff0c\u4f1a\u5bfc\u81f4\u4e0b\u9762\u7684while\u5faa\u73af\u65e0\u6cd5\u9000\u51fa\u3002 10. \u5148\u79fb\u9664\u7684\u8bdd\uff0c\u65b0\u63d2\u5165\u7684\u8282\u70b9\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u624d\u4f1a\u88ab\u5904\u7406\u3002 11. */ 12. QUEUE_MOVE ( & loop -> prepare_handles , & queue ); 13. // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 14. while ( ! QUEUE_EMPTY ( & queue )) { 15. // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373\u961f\u5217\u7684\u5934 16. q = QUEUE_HEAD ( & queue ); 17. /* 18. \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740\uff0c 19. \u5373\u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u53d6\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 20. */ 21. h = QUEUE_DATA ( q , uv_prepare_t , queue ); 22. // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217 23. QUEUE_REMOVE ( q ); 24. // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 25. QUEUE_INSERT_TAIL ( & loop -> prepare_handles , q ); 26. // \u6267\u884c\u56de\u8c03\u51fd\u6570 27. h -> prepare_cb ( h ); 28. } 29. } uv__run_prepare\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u91cd\u70b9\u7684\u5730\u65b9\u5c31\u662f\u6267\u884c\u5b8c\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0cLibuv\u4f1a\u628a\u8be5\u8282\u70b9\u91cd\u65b0\u63d2\u5165\u961f\u5217\u4e2d\uff0c\u6240\u4ee5prepare\uff08\u5305\u62ecidle\u3001check\uff09\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u800c\u50cf\u5b9a\u65f6\u5668\u3001pending\u3001closing\u9636\u6bb5\u7684\u8282\u70b9\u662f\u4e00\u6b21\u6027\u7684\uff0c\u88ab\u6267\u884c\u540e\u5c31\u4f1a\u4ece\u961f\u5217\u91cc\u5220\u9664\u3002 \u6211\u4eec\u56de\u987e\u4e00\u5f00\u59cb\u7684\u6d4b\u8bd5\u4ee3\u7801\u3002\u56e0\u4e3a\u5b83\u8bbe\u7f6e\u4e86Libuv\u7684\u8fd0\u884c\u6a21\u5f0f\u662f\u9ed8\u8ba4\u6a21\u5f0f\u3002\u800cprepare\u961f\u5217\u53c8\u4e00\u76f4\u6709\u4e00\u4e2ahandle\u8282\u70b9\uff0c\u6240\u4ee5\u5b83\u662f\u4e0d\u4f1a\u9000\u51fa\u7684\u3002\u5b83\u4f1a\u4e00\u76f4\u6267\u884c\u56de\u8c03\u3002\u90a3\u5982\u679c\u6211\u4eec\u8981\u9000\u51fa\u600e\u4e48\u529e\u5462\uff1f\u6216\u8005\u8bf4\u4e0d\u8981\u6267\u884cprepare\u961f\u5217\u7684\u67d0\u4e2a\u8282\u70b9\u4e86\u3002\u6211\u4eec\u53ea\u9700\u8981stop\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002 1. int uv_prepare_stop ( uv_prepare_t * handle ) { 2. if ( ! uv__is_active ( handle )) return 0 ; 3. // \u628ahandle\u4eceprepare\u961f\u5217\u4e2d\u79fb\u9664\uff0c\u4f46\u8fd8\u6302\u8f7d\u5230handle_queue\u4e2d 4. QUEUE_REMOVE ( & handle -> queue ); 5. // \u6e05\u9664active\u6807\u8bb0\u4f4d\u5e76\u4e14\u51cf\u53bbloop\u4e2dhandle\u7684active\u6570 6. uv__handle_stop ( handle ); 7. return 0 ; 8. } stop\u51fd\u6570\u548cstart\u51fd\u6570\u662f\u76f8\u53cd\u7684\u4f5c\u7528\uff0c\u8fd9\u5c31\u662fNode.js\u4e2dprepare\u3001check\u3001idle\u9636\u6bb5\u7684\u539f\u7406\u3002 3.4 \u4e8b\u4ef6\u5faa\u73af\u4e4bPoll IO \u00b6 Poll IO\u662fLibuv\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u6587\u4ef6IO\u3001\u7f51\u7edcIO\u3001\u4fe1\u53f7\u5904\u7406\u7b49\u90fd\u5728\u8fd9\u4e2a\u9636\u6bb5\u5904\u7406\uff0c\u8fd9\u4e5f\u662f\u6700\u590d\u6742\u7684\u4e00\u4e2a\u9636\u6bb5\u3002\u5904\u7406\u903b\u8f91\u5728core.c\u7684uv__io_poll\u8fd9\u4e2a\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002\u5728\u5f00\u59cb\u5206\u6790Poll IO\u4e4b\u524d\uff0c\u5148\u4e86\u89e3\u4e00\u4e0b\u5b83\u76f8\u5173\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002 1 IO\u89c2\u5bdf\u8005uv__io_t\u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u662fPoll IO\u9636\u6bb5\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5b83\u4e3b\u8981\u662f\u4fdd\u5b58\u4e86IO\u76f8\u5173\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de \u8c03\u3001\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7b49\u4fe1\u606f\u3002 2 watcher_queue\u89c2\u5bdf\u8005\u961f\u5217\u3002\u6240\u6709\u9700\u8981Libuv\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u90fd\u6302\u8f7d\u5728\u8fd9\u4e2a\u961f\u5217\u91cc\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u9010\u4e2a\u5904\u7406\u3002 \u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790Poll IO\u9636\u6bb5\u3002\u5148\u770b\u7b2c\u4e00\u6bb5\u903b\u8f91\u3002 1. // \u6ca1\u6709IO\u89c2\u5bdf\u8005\uff0c\u5219\u76f4\u63a5\u8fd4\u56de 2. if ( loop -> nfds == 0 ) { 3. assert ( QUEUE_EMPTY ( & loop -> watcher_queue )); 4. return ; 5. } 6. // \u904d\u5386IO\u89c2\u5bdf\u8005\u961f\u5217 7. while ( ! QUEUE_EMPTY ( & loop -> watcher_queue )) { 8. // \u53d6\u51fa\u5f53\u524d\u5934\u8282\u70b9 9. q = QUEUE_HEAD ( & loop -> watcher_queue ); 10. // \u8131\u79bb\u961f\u5217 11. QUEUE_REMOVE ( q ); 12. // \u521d\u59cb\u5316\uff08\u91cd\u7f6e\uff09\u8282\u70b9\u7684\u524d\u540e\u6307\u9488 13. QUEUE_INIT ( q ); 14. // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u529f\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 15. w = QUEUE_DATA ( q , uv__io_t , watcher_queue ); 16. // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 17. e . events = w -> pevents ; 18. /* 19. \u8fd9\u91cc\u4f7f\u7528\u4e86fd\u5b57\u6bb5\uff0c\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u901a\u8fc7fd\u4ecewatchs 20. \u5b57\u6bb5\u91cc\u627e\u5230\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005\uff0c\u6ca1\u6709\u4f7f\u7528ptr\u6307\u5411IO\u89c2\u5bdf\u8005\u7684\u65b9\u6848 21. */ 22. e . data . fd = w -> fd ; 23. // \u5982\u679cw->events\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u5219\u65b0\u589e\uff0c\u5426\u5219\u4fee\u6539 24. if ( w -> events == 0 ) 25. op = EPOLL_CTL_ADD ; 26. else 27. op = EPOLL_CTL_MOD ; 28. // \u4fee\u6539epoll\u7684\u6570\u636e 29. epoll_ctl ( loop -> backend_fd , op , w -> fd , & e ) 30. // \u8bb0\u5f55\u5f53\u524d\u52a0\u5230epoll\u65f6\u7684\u72b6\u6001 31. w -> events = w -> pevents ; 32. } \u7b2c\u4e00\u6b65\u9996\u5148\u904d\u5386IO\u89c2\u5bdf\u8005\uff0c\u4fee\u6539epoll\u7684\u6570\u636e\u3002\u7136\u540e\u51c6\u5907\u8fdb\u5165\u7b49\u5f85\u3002 1. psigset = NULL ; 2. if ( loop -> flags & UV_LOOP_BLOCK_SIGPROF ) { 3. sigemptyset ( & sigset ); 4. sigaddset ( & sigset , SIGPROF ); 5. psigset = & sigset ; 6. } 7. /* 8. http://man7.org/Linux/man-pages/man2/epoll_wait.2.html 9. pthread_sigmask(SIG_SETMASK, &sigmask, &origmask); 10. ready = epoll_wait(epfd, &events, maxevents, timeout); 11. pthread_sigmask(SIG_SETMASK, &origmask, NULL); 12. \u5373\u5c4f\u853dSIGPROF\u4fe1\u53f7\uff0c\u907f\u514dSIGPROF\u4fe1\u53f7\u5524\u9192epoll_wait\uff0c\u4f46\u662f\u5374\u6ca1 13. \u6709\u5c31\u7eea\u7684\u4e8b\u4ef6 14. */ 15. nfds = epoll_pwait ( loop -> backend_fd , 16. events , 17. ARRAY_SIZE ( events ), 18. timeout , 19. psigset ); 20. // epoll\u53ef\u80fd\u963b\u585e\uff0c\u8fd9\u91cc\u9700\u8981\u66f4\u65b0\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u95f4 21. uv__update_time ( loop ) ``` epoll_wait\u53ef\u80fd\u4f1a\u5f15\u8d77\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u6240\u4ee5wait\u8fd4\u56de\u540e\u9700\u8981\u66f4\u65b0\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5426\u5219\u5728\u4f7f\u7528\u7684\u65f6\u5019\u65f6\u95f4\u5dee\u4f1a\u6bd4\u8f83\u5927\uff0c\u56e0\u4e3aLibuv\u4f1a\u5728\u6bcf\u8f6e\u65f6\u95f4\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u7f13\u5b58\u5f53\u524d\u65f6\u95f4\u8fd9\u4e2a\u503c\u3002\u5176\u5b83\u5730\u65b9\u76f4\u63a5\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u6bcf\u6b21\u90fd\u53bb\u83b7\u53d6\u3002\u4e0b\u9762\u6211\u4eec\u63a5\u7740\u770bepoll\u8fd4\u56de\u540e\u7684\u5904\u7406\uff08\u5047\u8bbe\u6709\u4e8b\u4ef6\u89e6\u53d1\uff09\u3002 1. // \u4fdd\u5b58epoll_wait\u8fd4\u56de\u7684\u4e00\u4e9b\u6570\u636e\uff0cmaybe_resize\u7533\u8bf7\u7a7a\u95f4\u7684\u65f6\u5019+2\u4e86 2. loop -> watchers [ loop -> nwatchers ] = ( void * ) events ; 3. loop -> watchers [ loop -> nwatchers + 1 ] = ( void * ) ( uintptr_t ) nfds ; 4. for ( i = 0 ; i < nfds ; i ++ ) { 5. // \u89e6\u53d1\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26 6. pe = events + i ; 7. fd = pe -> data . fd ; 8. // \u6839\u636efd\u83b7\u53d6IO\u89c2\u5bdf\u8005\uff0c\u89c1\u4e0a\u9762\u7684\u56fe 9. w = loop -> watchers [ fd ]; 10. // \u4f1a\u5176\u5b83\u56de\u8c03\u91cc\u88ab\u5220\u9664\u4e86\uff0c\u5219\u4eceepoll\u4e2d\u5220\u9664 11. if ( w == NULL ) { 12. epoll_ctl ( loop -> backend_fd , EPOLL_CTL_DEL , fd , pe ); 13. continue ; 14. } 15. if ( pe -> events != 0 ) { 16. /* 17. \u7528\u4e8e\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c 18. \u5373\u6709\u4fe1\u53f7\u53d1\u751f\u3002 19. */ 20. if ( w == & loop -> signal_io_watcher ) 21. have_signals = 1 ; 22. else 23. // \u4e00\u822c\u7684IO\u89c2\u5bdf\u8005\u5219\u6267\u884c\u56de\u8c03 24. w -> cb ( loop , w , pe -> events ); 25. nevents ++ ; 26. } 27. } 28. // \u6709\u4fe1\u53f7\u53d1\u751f\uff0c\u89e6\u53d1\u56de\u8c03 29. if ( have_signals != 0 ) 30. loop -> signal_io_watcher . cb ( loop , 31. & loop -> signal_io_watcher , 32. POLLIN ); \u4e0a\u9762\u7684\u4ee3\u7801\u5904\u7406IO\u4e8b\u4ef6\u5e76\u6267\u884cIO\u89c2\u5bdf\u8005\u91cc\u7684\u56de\u8c03\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u7279\u6b8a\u7684\u5730\u65b9\u5c31\u662f\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u9700\u8981\u5355\u72ec\u5224\u65ad\uff0c\u5b83\u662f\u4e00\u4e2a\u5168\u5c40\u7684IO\u89c2\u5bdf\u8005\uff0c\u548c\u4e00\u822c\u52a8\u6001\u7533\u8bf7\u548c\u9500\u6bc1\u7684IO\u89c2\u5bdf\u8005\u4e0d\u4e00\u6837\uff0c\u5b83\u662f\u5b58\u5728\u4e8eLibuv\u8fd0\u884c\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u3002\u8fd9\u5c31\u662fPoll IO\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002 3.5 \u4e8b\u4ef6\u5faa\u73af\u4e4bclose \u00b6 close\u662fLibuv\u6bcf\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6700\u540e\u7684\u4e00\u4e2a\u9636\u6bb5\u3002uv_close\u7528\u4e8e\u5173\u95ed\u4e00\u4e2ahandle\uff0c\u5e76\u4e14\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u3002uv_close\u4ea7\u751f\u7684\u4efb\u52a1\u4f1a\u63d2\u5165\u5230close\u9636\u6bb5\u7684\u961f\u5217\uff0c\u7136\u540e\u5728close\u9636\u6bb5\u88ab\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_close\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. void uv_close ( uv_handle_t * handle , uv_close_cb close_cb ) { 2. // \u6b63\u5728\u5173\u95ed\uff0c\u4f46\u662f\u8fd8\u6ca1\u6267\u884c\u56de\u8c03\u7b49\u540e\u7f6e\u64cd\u4f5c 3. handle -> flags |= UV_HANDLE_CLOSING ; 4. handle -> close_cb = close_cb ; 5. 6. switch ( handle -> type ) { 7. case UV_PREPARE : 8. uv__prepare_close (( uv_prepare_t * ) handle ); 9. break ; 10. case UV_CHECK : 11. uv__check_close (( uv_check_t * ) handle ); 12. break ; 13. ... 14. default : 15. assert ( 0 ); 16. } 17. uv__make_close_pending ( handle ); 18. } uv_close\u8bbe\u7f6e\u56de\u8c03\u548c\u72b6\u6001\uff0c\u7136\u540e\u6839\u636ehandle\u7c7b\u578b\u8c03\u5bf9\u5e94\u7684close\u51fd\u6570\uff0c\u4e00\u822c\u5c31\u662fstop\u8fd9\u4e2ahandle\uff0c\u89e3\u9664IO\u89c2\u5bdf\u8005\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4ece\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217\u79fb\u9664\u8be5handle\u7b49\u7b49\uff0c\u6bd4\u5982prepare\u7684close\u51fd\u6570\u53ea\u662f\u628ahandle\u4ece\u961f\u5217\u4e2d\u79fb\u9664\u3002 1. void uv__prepare_close ( uv_prepare_t * handle ) { 2. uv_prepare_stop ( handle ); 3. } 4. int uv_prepare_stop ( uv_prepare__t * handle ) { 5. QUEUE_REMOVE ( & handle -> queue ); 6. uv__handle_stop ( handle ); 7. return 0 ; 8. } \u6839\u636e\u4e0d\u540c\u7684handle\u505a\u4e0d\u540c\u7684\u5904\u7406\u540e\uff0c\u63a5\u7740\u6267\u884cuv__make_close_pending\u5f80close\u961f\u5217\u8ffd\u52a0\u8282\u70b9\u3002 1. // \u5934\u63d2\u6cd5\u63d2\u5165closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u88ab\u6267\u884c 2. void uv__make_close_pending ( uv_handle_t * handle ) { 3. handle -> next_closing = handle -> loop -> closing_handles ; 4. handle -> loop -> closing_handles = handle ; 5. } \u7136\u540e\u5728close\u9636\u6bb5\u9010\u4e2a\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0bclose\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91 1. // \u6267\u884cclosing\u9636\u6bb5\u7684\u7684\u56de\u8c03 2. static void uv__run_closing_handles ( uv_loop_t * loop ) { 3. uv_handle_t * p ; 4. uv_handle_t * q ; 5. 6. p = loop -> closing_handles ; 7. loop -> closing_handles = NULL ; 8. 9. while ( p ) { 10. q = p -> next_closing ; 11. uv__finish_close ( p ); 12. p = q ; 13. } 14. } 15. 16. // \u6267\u884cclosing\u9636\u6bb5\u7684\u56de\u8c03 17. static void uv__finish_close ( uv_handle_t * handle ) { 18. handle -> flags |= UV_HANDLE_CLOSED ; 19. ... 20. uv__handle_unref ( handle ); 21. // \u4ecehandle\u961f\u5217\u91cc\u79fb\u9664 22. QUEUE_REMOVE ( & handle -> handle_queue ); 23. if ( handle -> close_cb ) { 24. handle -> close_cb ( handle ); 25. } 26. } uv__run_closing_handles\u4f1a\u9010\u4e2a\u6267\u884c\u6bcf\u4e2a\u4efb\u52a1\u8282\u70b9\u7684\u56de\u8c03\u3002 3.6 \u63a7\u5236\u4e8b\u4ef6\u5faa\u73af \u00b6 Libuv\u901a\u8fc7uv__loop_alive\u51fd\u6570\u5224\u65ad\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u9700\u8981\u7ee7\u7eed\u6267\u884c\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1. static int uv__loop_alive ( const uv_loop_t * loop ) { 2. return uv__has_active_handles ( loop ) || 3. uv__has_active_reqs ( loop ) || 4. loop -> closing_handles != NULL ; 5. } \u4e3a\u4ec0\u4e48\u4f1a\u6709\u4e00\u4e2aclosing_handle\u7684\u5224\u65ad\u5462\uff1f\u4eceuv_run\u7684\u4ee3\u7801\u6765\u770b\uff0c\u6267\u884c\u5b8cclose\u9636\u6bb5\u540e\uff0c\u4f1a\u7acb\u523b\u6267\u884cuv__loop_alive\uff0c\u6b63\u5e38\u6765\u8bf4\uff0cclose\u9636\u6bb5\u7684\u961f\u5217\u662f\u7a7a\u7684\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728close\u56de\u8c03\u91cc\u53c8\u5f80close\u961f\u5217\u65b0\u589e\u4e86\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u8be5\u8282\u70b9\u4e0d\u4f1a\u5728\u672c\u8f6e\u7684close\u9636\u6bb5\u88ab\u6267\u884c\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u6267\u884c\u5b8cclose\u9636\u6bb5\uff0c\u4f46\u662fclose\u961f\u5217\u4f9d\u7136\u6709\u8282\u70b9\uff0c\u5982\u679c\u76f4\u63a5\u9000\u51fa\uff0c\u5219\u65e0\u6cd5\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0cLibuv\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662f\u5b58\u6d3b\u7684\u3002\u5982\u679c\u6211\u4eec\u63a7\u5236\u8fd9\u4e09\u79cd\u6761\u4ef6\u5c31\u53ef\u4ee5\u63a7\u5236\u4e8b\u4ef6\u5faa\u73af\u7684\u7684\u9000\u51fa\u3002\u6211\u4eec\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u7406\u89e3\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1. const timeout = setTimeout (() => { 2. console . log ( ' never console ' ) 3. }, 5000 ); 4. timeout . unref (); \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0csetTimeout\u7684\u56de\u8c03\u662f\u4e0d\u4f1a\u6267\u884c\u7684\u3002\u9664\u975e\u8d85\u65f6\u65f6\u95f4\u975e\u5e38\u77ed\uff0c\u77ed\u5230\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u5019\u5c31\u5230\u671f\u4e86\uff0c\u5426\u5219\u5728\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e4b\u540e\uff0c\u7531\u4e8eunref\u7684\u5f71\u54cd\uff0c\u4e8b\u4ef6\u5faa\u73af\u76f4\u63a5\u9000\u51fa\u4e86\u3002unref\u5f71\u54cd\u7684\u5c31\u662fhandle\u8fd9\u4e2a\u6761\u4ef6\u3002\u8fd9\u65f6\u5019\u4e8b\u4ef6\u5faa\u73af\u4ee3\u7801\u5982\u4e0b\u3002 1. while ( r != 0 && loop -> stop_flag == 0 ) { 2. uv__update_time ( loop ); 3. uv__run_timers ( loop ); 4. // ... 5. // uv__loop_alive\u8fd4\u56defalse\uff0c\u76f4\u63a5\u8df3\u51fawhile\uff0c\u4ece\u800c\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af 6. r = uv__loop_alive ( loop ); 7. }","title":"03-\u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#_1","text":"Node.js\u5c5e\u4e8e\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u67b6\u6784\uff0c\u8be5\u4e8b\u4ef6\u5faa\u73af\u7531Libuv\u7684uv_run\u51fd\u6570\u5b9e\u73b0\uff0c\u5728\u8be5\u51fd\u6570\u4e2d\u6267\u884cwhile\u5faa\u73af\uff0c\u7136\u540e\u4e0d\u65ad\u5730\u5904\u7406\u5404\u4e2a\u9636\u6bb5\uff08phase\uff09\u7684\u4e8b\u4ef6\u56de\u8c03\u3002\u4e8b\u4ef6\u5faa\u73af\u7684\u5904\u7406\u76f8\u5f53\u4e8e\u4e00\u4e2a\u6d88\u8d39\u8005\uff0c\u6d88\u8d39\u7531\u5404\u79cd\u4ee3\u7801\u4ea7\u751f\u7684\u4efb\u52a1\u3002Node.js\u521d\u59cb\u5316\u5b8c\u6210\u540e\u5c31\u5f00\u59cb\u9677\u5165\u8be5\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\u4e5f\u5c31\u610f\u5473\u7740Node.js\u7684\u7ed3\u675f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u4ee3\u7801\u3002 1. int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { 2. int timeout ; 3. int r ; 4. int ran_pending ; 5. // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop 6. r = uv__loop_alive ( loop ); 7. // \u4e8b\u4ef6\u5faa\u73af\u6ca1\u6709\u4efb\u52a1\u6267\u884c\uff0c\u5373\u5c06\u9000\u51fa\uff0c\u8bbe\u7f6e\u4e00\u4e0b\u5f53\u524d\u5faa\u73af\u7684\u65f6\u95f4 8. if ( ! r ) 9. uv__update_time ( loop ); 10. // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af 11. while ( r != 0 && loop -> stop_flag == 0 ) { 12. // \u66f4\u65b0loop\u7684time\u5b57\u6bb5 13. uv__update_time ( loop ); 14. // \u6267\u884c\u8d85\u65f6\u56de\u8c03 15. uv__run_timers ( loop ); 16. /* 17. \u6267\u884cpending\u56de\u8c03\uff0cran_pending\u4ee3\u8868pending\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c 18. \u5373\u6ca1\u6709\u8282\u70b9\u53ef\u4ee5\u6267\u884c 19. */ 20. ran_pending = uv__run_pending ( loop ); 21. // \u7ee7\u7eed\u6267\u884c\u5404\u79cd\u961f\u5217 22. uv__run_idle ( loop ); 23. uv__run_prepare ( loop ); 24. 25. timeout = 0 ; 26. /* 27. \u6267\u884c\u6a21\u5f0f\u662fUV_RUN_ONCE\u65f6\uff0c\u5982\u679c\u6ca1\u6709pending\u8282\u70b9\uff0c 28. \u624d\u4f1a\u963b\u585e\u5f0fPoll IO\uff0c\u9ed8\u8ba4\u6a21\u5f0f\u4e5f\u662f 29. */ 30. if (( mode == UV_RUN_ONCE && ! ran_pending ) || 31. mode == UV_RUN_DEFAULT ) 32. timeout = uv_backend_timeout ( loop ); 33. // Poll IO timeout\u662fepoll_wait\u7684\u8d85\u65f6\u65f6\u95f4 34. uv__io_poll ( loop , timeout ); 35. // \u5904\u7406check\u9636\u6bb5 36. uv__run_check ( loop ); 37. // \u5904\u7406close\u9636\u6bb5 38. uv__run_closing_handles ( loop ); 39. /* 40. \u8fd8\u6709\u4e00\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u673a\u4f1a\uff0c\u56e0\u4e3auv__io_poll\u53ef\u80fd\u662f\u56e0\u4e3a 41. \u5b9a\u65f6\u5668\u8d85\u65f6\u8fd4\u56de\u7684\u3002 42. */ 43. if ( mode == UV_RUN_ONCE ) { 44. uv__update_time ( loop ); 45. uv__run_timers ( loop ); 46. } 47. 48. r = uv__loop_alive ( loop ); 49. /* 50. \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u9000\u51fa\u5faa\u73af,UV_RUN_NOWAIT\u8868\u793a\u5728Poll IO\u9636\u6bb5 51. \u4e0d\u4f1a\u963b\u585e\u5e76\u4e14\u5faa\u73af\u53ea\u6267\u884c\u4e00\u6b21 52. */ 53. if ( mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT ) 54. break ; 55. } 56. // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag 57. if ( loop -> stop_flag != 0 ) 58. loop -> stop_flag = 0 ; 59. /* 60. \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c 61. \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run 62. */ 63. return r ; 64. } Libuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u4e0b\u9762\u4ece\u5148\u5230\u540e\uff0c\u5206\u522b\u5206\u6790\u5404\u4e2a\u9636\u6bb5\u7684\u76f8\u5173\u4ee3\u7801\u3002","title":"\u7b2c\u4e09\u7ae0 \u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#31","text":"Libuv\u4e2d\uff0c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u7b2c\u4e00\u4e2a\u88ab\u5904\u7406\u7684\u9636\u6bb5\u3002\u5b9a\u65f6\u5668\u662f\u4ee5\u6700\u5c0f\u5806\u5b9e\u73b0\u7684\uff0c\u6700\u5feb\u8fc7\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002Libuv\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u90fd\u4f1a\u7f13\u5b58\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5728\u6bcf\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4f7f\u7528\u7684\u90fd\u662f\u8fd9\u4e2a\u7f13\u5b58\u7684\u65f6\u95f4\uff0c\u5fc5\u8981\u7684\u65f6\u5019Libuv\u4f1a\u663e\u5f0f\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u56e0\u4e3a\u83b7\u53d6\u65f6\u95f4\u9700\u8981\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c\u800c\u9891\u7e41\u8c03\u7528\u7cfb\u7edf\u8c03\u7528\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u8017\u65f6\uff0c\u7f13\u5b58\u65f6\u95f4\u53ef\u4ee5\u51cf\u5c11\u64cd\u4f5c\u7cfb\u7edf\u7684\u8c03\u7528\uff0c\u63d0\u9ad8\u6027\u80fd\u3002Libuv\u7f13\u5b58\u4e86\u5f53\u524d\u6700\u65b0\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u6267\u884cuv__run_timers\uff0c\u8be5\u51fd\u6570\u5c31\u662f\u904d\u5386\u6700\u5c0f\u5806\uff0c\u627e\u51fa\u5f53\u524d\u8d85\u65f6\u7684\u8282\u70b9\u3002\u56e0\u4e3a\u5806\u7684\u6027\u8d28\u662f\u7236\u8282\u70b9\u80af\u5b9a\u6bd4\u5b69\u5b50\u5c0f\u3002\u5e76\u4e14\u6839\u8282\u70b9\u662f\u6700\u5c0f\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4e00\u4e2a\u6839\u8282\u70b9\uff0c\u5b83\u6ca1\u6709\u8d85\u65f6\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u3002\u5bf9\u4e8e\u8d85\u65f6\u7684\u8282\u70b9\u5c31\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1. void uv__run_timers ( uv_loop_t * loop ) { 2. struct heap_node * heap_node ; 3. uv_timer_t * handle ; 4. // \u904d\u5386\u4e8c\u53c9\u5806 5. for (;;) { 6. // \u627e\u51fa\u6700\u5c0f\u7684\u8282\u70b9 7. heap_node = heap_min ( timer_heap ( loop )); 8. // \u6ca1\u6709\u5219\u9000\u51fa 9. if ( heap_node == NULL ) 10. break ; 11. // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 12. handle = container_of ( heap_node , uv_timer_t , heap_node ); 13. // \u6700\u5c0f\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u5e02\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6 14. if ( handle -> timeout > loop -> time ) 15. break ; 16. // \u5220\u9664\u8be5\u8282\u70b9 17. uv_timer_stop ( handle ); 18. /* 19. \u91cd\u8bd5\u63d2\u5165\u4e8c\u53c9\u5806\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd\uff08\u8bbe\u7f6e\u4e86repeat\uff0c\u6bd4\u5982 20. setInterval\uff09 21. */ 22. uv_timer_again ( handle ); 23. // \u6267\u884c\u56de\u8c03 24. handle -> timer_cb ( handle ); 25. } 26. } \u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0c\u8fd8\u6709\u4e24\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\uff0c\u7b2c\u4e00\u5c31\u662fstop\uff0c\u7b2c\u4e8c\u5c31\u662fagain\u3002stop\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u628ahandle\u4ece\u4e8c\u53c9\u5806\u4e2d\u5220\u9664\uff0c\u5e76\u4e14\u4fee\u6539handle\u7684\u72b6\u6001\u3002\u90a3\u4e48again\u53c8\u662f\u4ec0\u4e48\u5462\uff1fagain\u662f\u4e3a\u4e86\u652f\u6301setInterval\u8fd9\u79cd\u573a\u666f\uff0c\u5982\u679chandle\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\uff0c\u5219\u8be5handle\u5728\u8d85\u65f6\u540e\uff0c\u6bcfrepeat\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u4f1a\u7ee7\u7eed\u6267\u884c\u8d85\u65f6\u56de\u8c03\u3002\u5bf9\u4e8esetInterval\uff0c\u5c31\u662f\u8d85\u65f6\u65f6\u95f4\u662fx\uff0c\u6bcfx\u7684\u65f6\u95f4\u540e\uff0c\u6267\u884c\u56de\u8c03\u3002\u8fd9\u5c31\u662fNode.js\u91cc\u5b9a\u65f6\u5668\u7684\u5e95\u5c42\u539f\u7406\u3002\u4f46Node.js\u4e0d\u662f\u6bcf\u6b21\u8c03setTimeout/setInterval\u7684\u65f6\u5019\u90fd\u5f80\u6700\u5c0f\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0cNode.js\u91cc\uff0c\u53ea\u6709\u4e00\u4e2a\u5173\u4e8euv_timer_s\u7684handle\uff0c\u5b83\u5728JS\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u6b21\u8ba1\u7b97\u51fa\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9\uff0c\u7136\u540e\u4fee\u6539handle\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5177\u4f53\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u8bb2\u89e3\u3002 \u53e6\u5916timer\u9636\u6bb5\u548cPoll IO\u9636\u6bb5\u4e5f\u6709\u4e00\u4e9b\u8054\u7cfb\uff0c\u56e0\u4e3aPoll IO\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u4e3b\u7ebf\u7a0b\u53ef\u4ee5\u5c3d\u5feb\u6267\u884c\u5b9a\u65f6\u5668\u7684\u56de\u8c03\uff0cPoll IO\u4e0d\u80fd\u4e00\u76f4\u963b\u585e\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u963b\u585e\u7684\u65f6\u957f\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u65f6\u957f\uff08\u5177\u4f53\u53ef\u53c2\u8003libuv core.c\u4e2d\u7684uv_backend_timeout\u51fd\u6570\uff09\u3002","title":"3.1 \u4e8b\u4ef6\u5faa\u73af\u4e4b\u5b9a\u65f6\u5668"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#32-pending","text":"\u5b98\u7f51\u5bf9pending\u9636\u6bb5\u7684\u89e3\u91ca\u662f\u5728\u4e0a\u4e00\u8f6e\u7684Poll IO\u9636\u6bb5\u6ca1\u6709\u6267\u884c\u7684IO\u56de\u8c03\uff0c\u4f1a\u5728\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684pending\u9636\u6bb5\u88ab\u6267\u884c\u3002\u4ece\u6e90\u7801\u6765\u770b\uff0cPoll IO\u9636\u6bb5\u5904\u7406\u4efb\u52a1\u65f6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u5f53\u524d\u6267\u884c\u7684\u64cd\u4f5c\u5931\u8d25\u9700\u8981\u6267\u884c\u56de\u8c03\u901a\u77e5\u8c03\u7528\u65b9\u4e00\u4e9b\u4fe1\u606f\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u4e0d\u4f1a\u7acb\u523b\u6267\u884c\uff0c\u800c\u662f\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\uff08\u6bd4\u5982\u5199\u5165\u6570\u636e\u6210\u529f\uff0c\u6216\u8005TCP\u8fde\u63a5\u5931\u8d25\u65f6\u56de\u8c03C++\u5c42\uff09\uff0c\u6211\u4eec\u5148\u770bpending\u9636\u6bb5\u7684\u5904\u7406\u3002 1. static int uv__run_pending ( uv_loop_t * loop ) { 2. QUEUE * q ; 3. QUEUE pq ; 4. uv__io_t * w ; 5. 6. if ( QUEUE_EMPTY ( & loop -> pending_queue )) 7. return 0 ; 8. // \u628apending_queue\u961f\u5217\u7684\u8282\u70b9\u79fb\u5230pq\uff0c\u5373\u6e05\u7a7a\u4e86pending_queue 9. QUEUE_MOVE ( & loop -> pending_queue , & pq ); 10. 11. // \u904d\u5386pq\u961f\u5217 12. while ( ! QUEUE_EMPTY ( & pq )) { 13. // \u53d6\u51fa\u5f53\u524d\u7b2c\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373pq.next 14. q = QUEUE_HEAD ( & pq ); 15. // \u628a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u79fb\u51fa\u961f\u5217 16. QUEUE_REMOVE ( q ); 17. /* 18. \u91cd\u7f6e\u4e00\u4e0bprev\u548cnext\u6307\u9488\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u8fd9\u4e24\u4e2a\u6307\u9488\u662f 19. \u6307\u5411\u961f\u5217\u4e2d\u7684\u4e24\u4e2a\u8282\u70b9 20. */ 21. QUEUE_INIT ( q ); 22. w = QUEUE_DATA ( q , uv__io_t , pending_queue ); 23. w -> cb ( loop , w , POLLOUT ); 24. } 25. 26. return 1 ; 27. } pending\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91\u5c31\u662f\u628apending\u961f\u5217\u91cc\u7684\u8282\u70b9\u9010\u4e2a\u6267\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0bpending\u961f\u5217\u7684\u8282\u70b9\u662f\u5982\u4f55\u751f\u4ea7\u51fa\u6765\u7684\u3002 1. void uv__io_feed ( uv_loop_t * loop , uv__io_t * w ) { 2. if ( QUEUE_EMPTY ( & w -> pending_queue )) 3. QUEUE_INSERT_TAIL ( & loop -> pending_queue , & w -> pending_queue ); 4. } Libuv\u901a\u8fc7uv__io_feed\u51fd\u6570\u751f\u4ea7pending\u4efb\u52a1\uff0c\u4eceLibuv\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230IO\u9519\u8bef\u7684\u65f6\u5019\u4f1a\u8c03\u8fd9\u4e2a\u51fd\u6570\uff08\u5982tcp.c\u7684uv__tcp_connect\u51fd\u6570\uff09\u3002 1. if ( handle -> delayed_error ) 2. uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u5728\u5199\u5165\u6570\u636e\u6210\u529f\u540e\uff08\u6bd4\u5982TCP\u3001UDP\uff09\uff0c\u4e5f\u4f1a\u5f80pending\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7b49\u5f85\u56de\u8c03\u3002\u6bd4\u5982\u53d1\u9001\u6570\u636e\u6210\u529f\u540e\u6267\u884c\u7684\u4ee3\u7801\uff08udp.c\u7684uv__udp_sendmsg\u51fd\u6570\uff09 1. // \u53d1\u9001\u5b8c\u79fb\u51fa\u5199\u961f\u5217 2. QUEUE_REMOVE ( & req -> queue ); 3. // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 4. QUEUE_INSERT_TAIL ( & handle -> write_completed_queue , & req -> queue ); 5. /* 6. \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c 7. pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 8. */ 9. uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u6700\u540e\u5173\u95edIO\u7684\u65f6\u5019\uff08\u5982\u5173\u95ed\u4e00\u4e2aTCP\u8fde\u63a5\uff09\u4f1a\u4ecepending\u961f\u5217\u79fb\u9664\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5173\u95ed\u4e86\uff0c\u81ea\u7136\u5c31\u4e0d\u9700\u8981\u6267\u884c\u56de\u8c03\u3002 1. void uv__io_close ( uv_loop_t * loop , uv__io_t * w ) { 2. uv__io_stop ( loop , 3. w , 4. POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI ); 5. QUEUE_REMOVE ( & w -> pending_queue ); 6. }","title":"3.2 pending\u9636\u6bb5"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#33-preparecheckidle","text":"prepare,check,idle\u662fLibuv\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5c5e\u4e8e\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u5b83\u4eec\u7684\u5b9e\u73b0\u662f\u4e00\u6837\u7684\uff08\u89c1loop-watcher.c\uff09\u3002\u672c\u8282\u53ea\u8bb2\u89e3prepare\u9636\u6bb5\uff0c\u6211\u4eec\u77e5\u9053Libuv\u4e2d\u5206\u4e3ahandle\u548crequest\uff0c\u800cprepare\u9636\u6bb5\u7684\u4efb\u52a1\u662f\u5c5e\u4e8ehandle\u7c7b\u578b\u3002\u8fd9\u610f\u5473\u7740\u9664\u975e\u6211\u4eec\u663e\u5f0f\u79fb\u9664\uff0c\u5426\u5219prepare\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u4e0b\u9762\u6211\u4eec\u5148\u770b\u770b\u600e\u4e48\u4f7f\u7528\u5b83\u3002 1. void prep_cb ( uv_prepare_t * handle ) { 2. printf ( \"Prep callback \\n \" ); 3. } 4. 5. int main () { 6. uv_prepare_t prep ; 7. // \u521d\u59cb\u5316\u4e00\u4e2ahandle\uff0cuv_default_loop\u662f\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 8. uv_prepare_init ( uv_default_loop (), & prep ); 9. // \u6ce8\u518chandle\u7684\u56de\u8c03 10. uv_prepare_start ( & prep , prep_cb ); 11. // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af 12. uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); 13. return 0 ; 14. } \u6267\u884cmain\u51fd\u6570\uff0cLibuv\u5c31\u4f1a\u5728prepare\u9636\u6bb5\u6267\u884c\u56de\u8c03prep_cb\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1. int uv_prepare_init ( uv_loop_t * loop , uv_prepare_t * handle ) { 2. uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_PREPARE ); 3. handle -> prepare_cb = NULL ; 4. return 0 ; 5. } init\u51fd\u6570\u4e3b\u8981\u662f\u505a\u4e00\u4e9b\u521d\u59cb\u5316\u64cd\u4f5c\u3002\u6211\u4eec\u7ee7\u7eed\u8981\u770bstart\u51fd\u6570\u3002 1. int uv_prepare_start ( uv_prepare_t * handle , uv_prepare_cb cb ) { 2. // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de 3. if ( uv__is_active ( handle )) return 0 ; 4. if ( cb == NULL ) return UV_EINVAL ; 5. QUEUE_INSERT_HEAD ( & handle -> loop -> prepare_handles , 6. & handle -> queue ); 7. handle -> prepare_cb = cb ; 8. uv__handle_start ( handle ); 9. return 0 ; 10. } uv_prepare_start\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u4e3b\u8981\u662f\u8bbe\u7f6e\u56de\u8c03\uff0c\u628ahandle\u63d2\u5165loop\u7684prepare_handles\u961f\u5217\uff0cprepare_handles\u961f\u5217\u4fdd\u5b58\u4e86prepare\u9636\u6bb5\u7684\u4efb\u52a1\u3002\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u4f1a\u9010\u4e2a\u6267\u884c\u91cc\u9762\u7684\u8282\u70b9\u7684\u56de\u8c03\u3002\u7136\u540e\u6211\u4eec\u770b\u770bLibuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u662f\u5982\u4f55\u5904\u7406\u7684\u3002 1. void uv__run_prepare ( uv_loop_t * loop ) { 2. uv_prepare_t * h ; 3. QUEUE queue ; 4. QUEUE * q ; 5. /* 6. \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c 7. \u76f8\u5f53\u4e8e\u6e05\u7a7aprepare_handles\u961f\u5217\uff0c\u56e0\u4e3a\u5982\u679c\u76f4\u63a5\u904d\u5386 8. prepare_handles\u961f\u5217\uff0c\u5728\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4e00\u76f4\u5f80prepare_handles 9. \u961f\u5217\u52a0\u8282\u70b9\uff0c\u4f1a\u5bfc\u81f4\u4e0b\u9762\u7684while\u5faa\u73af\u65e0\u6cd5\u9000\u51fa\u3002 10. \u5148\u79fb\u9664\u7684\u8bdd\uff0c\u65b0\u63d2\u5165\u7684\u8282\u70b9\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u624d\u4f1a\u88ab\u5904\u7406\u3002 11. */ 12. QUEUE_MOVE ( & loop -> prepare_handles , & queue ); 13. // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 14. while ( ! QUEUE_EMPTY ( & queue )) { 15. // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373\u961f\u5217\u7684\u5934 16. q = QUEUE_HEAD ( & queue ); 17. /* 18. \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740\uff0c 19. \u5373\u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u53d6\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 20. */ 21. h = QUEUE_DATA ( q , uv_prepare_t , queue ); 22. // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217 23. QUEUE_REMOVE ( q ); 24. // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 25. QUEUE_INSERT_TAIL ( & loop -> prepare_handles , q ); 26. // \u6267\u884c\u56de\u8c03\u51fd\u6570 27. h -> prepare_cb ( h ); 28. } 29. } uv__run_prepare\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u91cd\u70b9\u7684\u5730\u65b9\u5c31\u662f\u6267\u884c\u5b8c\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0cLibuv\u4f1a\u628a\u8be5\u8282\u70b9\u91cd\u65b0\u63d2\u5165\u961f\u5217\u4e2d\uff0c\u6240\u4ee5prepare\uff08\u5305\u62ecidle\u3001check\uff09\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u800c\u50cf\u5b9a\u65f6\u5668\u3001pending\u3001closing\u9636\u6bb5\u7684\u8282\u70b9\u662f\u4e00\u6b21\u6027\u7684\uff0c\u88ab\u6267\u884c\u540e\u5c31\u4f1a\u4ece\u961f\u5217\u91cc\u5220\u9664\u3002 \u6211\u4eec\u56de\u987e\u4e00\u5f00\u59cb\u7684\u6d4b\u8bd5\u4ee3\u7801\u3002\u56e0\u4e3a\u5b83\u8bbe\u7f6e\u4e86Libuv\u7684\u8fd0\u884c\u6a21\u5f0f\u662f\u9ed8\u8ba4\u6a21\u5f0f\u3002\u800cprepare\u961f\u5217\u53c8\u4e00\u76f4\u6709\u4e00\u4e2ahandle\u8282\u70b9\uff0c\u6240\u4ee5\u5b83\u662f\u4e0d\u4f1a\u9000\u51fa\u7684\u3002\u5b83\u4f1a\u4e00\u76f4\u6267\u884c\u56de\u8c03\u3002\u90a3\u5982\u679c\u6211\u4eec\u8981\u9000\u51fa\u600e\u4e48\u529e\u5462\uff1f\u6216\u8005\u8bf4\u4e0d\u8981\u6267\u884cprepare\u961f\u5217\u7684\u67d0\u4e2a\u8282\u70b9\u4e86\u3002\u6211\u4eec\u53ea\u9700\u8981stop\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002 1. int uv_prepare_stop ( uv_prepare_t * handle ) { 2. if ( ! uv__is_active ( handle )) return 0 ; 3. // \u628ahandle\u4eceprepare\u961f\u5217\u4e2d\u79fb\u9664\uff0c\u4f46\u8fd8\u6302\u8f7d\u5230handle_queue\u4e2d 4. QUEUE_REMOVE ( & handle -> queue ); 5. // \u6e05\u9664active\u6807\u8bb0\u4f4d\u5e76\u4e14\u51cf\u53bbloop\u4e2dhandle\u7684active\u6570 6. uv__handle_stop ( handle ); 7. return 0 ; 8. } stop\u51fd\u6570\u548cstart\u51fd\u6570\u662f\u76f8\u53cd\u7684\u4f5c\u7528\uff0c\u8fd9\u5c31\u662fNode.js\u4e2dprepare\u3001check\u3001idle\u9636\u6bb5\u7684\u539f\u7406\u3002","title":"3.3 \u4e8b\u4ef6\u5faa\u73af\u4e4bprepare,check,idle"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#34-poll-io","text":"Poll IO\u662fLibuv\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u6587\u4ef6IO\u3001\u7f51\u7edcIO\u3001\u4fe1\u53f7\u5904\u7406\u7b49\u90fd\u5728\u8fd9\u4e2a\u9636\u6bb5\u5904\u7406\uff0c\u8fd9\u4e5f\u662f\u6700\u590d\u6742\u7684\u4e00\u4e2a\u9636\u6bb5\u3002\u5904\u7406\u903b\u8f91\u5728core.c\u7684uv__io_poll\u8fd9\u4e2a\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002\u5728\u5f00\u59cb\u5206\u6790Poll IO\u4e4b\u524d\uff0c\u5148\u4e86\u89e3\u4e00\u4e0b\u5b83\u76f8\u5173\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002 1 IO\u89c2\u5bdf\u8005uv__io_t\u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u662fPoll IO\u9636\u6bb5\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5b83\u4e3b\u8981\u662f\u4fdd\u5b58\u4e86IO\u76f8\u5173\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de \u8c03\u3001\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7b49\u4fe1\u606f\u3002 2 watcher_queue\u89c2\u5bdf\u8005\u961f\u5217\u3002\u6240\u6709\u9700\u8981Libuv\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u90fd\u6302\u8f7d\u5728\u8fd9\u4e2a\u961f\u5217\u91cc\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u9010\u4e2a\u5904\u7406\u3002 \u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790Poll IO\u9636\u6bb5\u3002\u5148\u770b\u7b2c\u4e00\u6bb5\u903b\u8f91\u3002 1. // \u6ca1\u6709IO\u89c2\u5bdf\u8005\uff0c\u5219\u76f4\u63a5\u8fd4\u56de 2. if ( loop -> nfds == 0 ) { 3. assert ( QUEUE_EMPTY ( & loop -> watcher_queue )); 4. return ; 5. } 6. // \u904d\u5386IO\u89c2\u5bdf\u8005\u961f\u5217 7. while ( ! QUEUE_EMPTY ( & loop -> watcher_queue )) { 8. // \u53d6\u51fa\u5f53\u524d\u5934\u8282\u70b9 9. q = QUEUE_HEAD ( & loop -> watcher_queue ); 10. // \u8131\u79bb\u961f\u5217 11. QUEUE_REMOVE ( q ); 12. // \u521d\u59cb\u5316\uff08\u91cd\u7f6e\uff09\u8282\u70b9\u7684\u524d\u540e\u6307\u9488 13. QUEUE_INIT ( q ); 14. // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u529f\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 15. w = QUEUE_DATA ( q , uv__io_t , watcher_queue ); 16. // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 17. e . events = w -> pevents ; 18. /* 19. \u8fd9\u91cc\u4f7f\u7528\u4e86fd\u5b57\u6bb5\uff0c\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u901a\u8fc7fd\u4ecewatchs 20. \u5b57\u6bb5\u91cc\u627e\u5230\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005\uff0c\u6ca1\u6709\u4f7f\u7528ptr\u6307\u5411IO\u89c2\u5bdf\u8005\u7684\u65b9\u6848 21. */ 22. e . data . fd = w -> fd ; 23. // \u5982\u679cw->events\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u5219\u65b0\u589e\uff0c\u5426\u5219\u4fee\u6539 24. if ( w -> events == 0 ) 25. op = EPOLL_CTL_ADD ; 26. else 27. op = EPOLL_CTL_MOD ; 28. // \u4fee\u6539epoll\u7684\u6570\u636e 29. epoll_ctl ( loop -> backend_fd , op , w -> fd , & e ) 30. // \u8bb0\u5f55\u5f53\u524d\u52a0\u5230epoll\u65f6\u7684\u72b6\u6001 31. w -> events = w -> pevents ; 32. } \u7b2c\u4e00\u6b65\u9996\u5148\u904d\u5386IO\u89c2\u5bdf\u8005\uff0c\u4fee\u6539epoll\u7684\u6570\u636e\u3002\u7136\u540e\u51c6\u5907\u8fdb\u5165\u7b49\u5f85\u3002 1. psigset = NULL ; 2. if ( loop -> flags & UV_LOOP_BLOCK_SIGPROF ) { 3. sigemptyset ( & sigset ); 4. sigaddset ( & sigset , SIGPROF ); 5. psigset = & sigset ; 6. } 7. /* 8. http://man7.org/Linux/man-pages/man2/epoll_wait.2.html 9. pthread_sigmask(SIG_SETMASK, &sigmask, &origmask); 10. ready = epoll_wait(epfd, &events, maxevents, timeout); 11. pthread_sigmask(SIG_SETMASK, &origmask, NULL); 12. \u5373\u5c4f\u853dSIGPROF\u4fe1\u53f7\uff0c\u907f\u514dSIGPROF\u4fe1\u53f7\u5524\u9192epoll_wait\uff0c\u4f46\u662f\u5374\u6ca1 13. \u6709\u5c31\u7eea\u7684\u4e8b\u4ef6 14. */ 15. nfds = epoll_pwait ( loop -> backend_fd , 16. events , 17. ARRAY_SIZE ( events ), 18. timeout , 19. psigset ); 20. // epoll\u53ef\u80fd\u963b\u585e\uff0c\u8fd9\u91cc\u9700\u8981\u66f4\u65b0\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u95f4 21. uv__update_time ( loop ) ``` epoll_wait\u53ef\u80fd\u4f1a\u5f15\u8d77\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u6240\u4ee5wait\u8fd4\u56de\u540e\u9700\u8981\u66f4\u65b0\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5426\u5219\u5728\u4f7f\u7528\u7684\u65f6\u5019\u65f6\u95f4\u5dee\u4f1a\u6bd4\u8f83\u5927\uff0c\u56e0\u4e3aLibuv\u4f1a\u5728\u6bcf\u8f6e\u65f6\u95f4\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u7f13\u5b58\u5f53\u524d\u65f6\u95f4\u8fd9\u4e2a\u503c\u3002\u5176\u5b83\u5730\u65b9\u76f4\u63a5\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u6bcf\u6b21\u90fd\u53bb\u83b7\u53d6\u3002\u4e0b\u9762\u6211\u4eec\u63a5\u7740\u770bepoll\u8fd4\u56de\u540e\u7684\u5904\u7406\uff08\u5047\u8bbe\u6709\u4e8b\u4ef6\u89e6\u53d1\uff09\u3002 1. // \u4fdd\u5b58epoll_wait\u8fd4\u56de\u7684\u4e00\u4e9b\u6570\u636e\uff0cmaybe_resize\u7533\u8bf7\u7a7a\u95f4\u7684\u65f6\u5019+2\u4e86 2. loop -> watchers [ loop -> nwatchers ] = ( void * ) events ; 3. loop -> watchers [ loop -> nwatchers + 1 ] = ( void * ) ( uintptr_t ) nfds ; 4. for ( i = 0 ; i < nfds ; i ++ ) { 5. // \u89e6\u53d1\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26 6. pe = events + i ; 7. fd = pe -> data . fd ; 8. // \u6839\u636efd\u83b7\u53d6IO\u89c2\u5bdf\u8005\uff0c\u89c1\u4e0a\u9762\u7684\u56fe 9. w = loop -> watchers [ fd ]; 10. // \u4f1a\u5176\u5b83\u56de\u8c03\u91cc\u88ab\u5220\u9664\u4e86\uff0c\u5219\u4eceepoll\u4e2d\u5220\u9664 11. if ( w == NULL ) { 12. epoll_ctl ( loop -> backend_fd , EPOLL_CTL_DEL , fd , pe ); 13. continue ; 14. } 15. if ( pe -> events != 0 ) { 16. /* 17. \u7528\u4e8e\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c 18. \u5373\u6709\u4fe1\u53f7\u53d1\u751f\u3002 19. */ 20. if ( w == & loop -> signal_io_watcher ) 21. have_signals = 1 ; 22. else 23. // \u4e00\u822c\u7684IO\u89c2\u5bdf\u8005\u5219\u6267\u884c\u56de\u8c03 24. w -> cb ( loop , w , pe -> events ); 25. nevents ++ ; 26. } 27. } 28. // \u6709\u4fe1\u53f7\u53d1\u751f\uff0c\u89e6\u53d1\u56de\u8c03 29. if ( have_signals != 0 ) 30. loop -> signal_io_watcher . cb ( loop , 31. & loop -> signal_io_watcher , 32. POLLIN ); \u4e0a\u9762\u7684\u4ee3\u7801\u5904\u7406IO\u4e8b\u4ef6\u5e76\u6267\u884cIO\u89c2\u5bdf\u8005\u91cc\u7684\u56de\u8c03\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u7279\u6b8a\u7684\u5730\u65b9\u5c31\u662f\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u9700\u8981\u5355\u72ec\u5224\u65ad\uff0c\u5b83\u662f\u4e00\u4e2a\u5168\u5c40\u7684IO\u89c2\u5bdf\u8005\uff0c\u548c\u4e00\u822c\u52a8\u6001\u7533\u8bf7\u548c\u9500\u6bc1\u7684IO\u89c2\u5bdf\u8005\u4e0d\u4e00\u6837\uff0c\u5b83\u662f\u5b58\u5728\u4e8eLibuv\u8fd0\u884c\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u3002\u8fd9\u5c31\u662fPoll IO\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002","title":"3.4 \u4e8b\u4ef6\u5faa\u73af\u4e4bPoll IO"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#35-close","text":"close\u662fLibuv\u6bcf\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6700\u540e\u7684\u4e00\u4e2a\u9636\u6bb5\u3002uv_close\u7528\u4e8e\u5173\u95ed\u4e00\u4e2ahandle\uff0c\u5e76\u4e14\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u3002uv_close\u4ea7\u751f\u7684\u4efb\u52a1\u4f1a\u63d2\u5165\u5230close\u9636\u6bb5\u7684\u961f\u5217\uff0c\u7136\u540e\u5728close\u9636\u6bb5\u88ab\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_close\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. void uv_close ( uv_handle_t * handle , uv_close_cb close_cb ) { 2. // \u6b63\u5728\u5173\u95ed\uff0c\u4f46\u662f\u8fd8\u6ca1\u6267\u884c\u56de\u8c03\u7b49\u540e\u7f6e\u64cd\u4f5c 3. handle -> flags |= UV_HANDLE_CLOSING ; 4. handle -> close_cb = close_cb ; 5. 6. switch ( handle -> type ) { 7. case UV_PREPARE : 8. uv__prepare_close (( uv_prepare_t * ) handle ); 9. break ; 10. case UV_CHECK : 11. uv__check_close (( uv_check_t * ) handle ); 12. break ; 13. ... 14. default : 15. assert ( 0 ); 16. } 17. uv__make_close_pending ( handle ); 18. } uv_close\u8bbe\u7f6e\u56de\u8c03\u548c\u72b6\u6001\uff0c\u7136\u540e\u6839\u636ehandle\u7c7b\u578b\u8c03\u5bf9\u5e94\u7684close\u51fd\u6570\uff0c\u4e00\u822c\u5c31\u662fstop\u8fd9\u4e2ahandle\uff0c\u89e3\u9664IO\u89c2\u5bdf\u8005\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4ece\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217\u79fb\u9664\u8be5handle\u7b49\u7b49\uff0c\u6bd4\u5982prepare\u7684close\u51fd\u6570\u53ea\u662f\u628ahandle\u4ece\u961f\u5217\u4e2d\u79fb\u9664\u3002 1. void uv__prepare_close ( uv_prepare_t * handle ) { 2. uv_prepare_stop ( handle ); 3. } 4. int uv_prepare_stop ( uv_prepare__t * handle ) { 5. QUEUE_REMOVE ( & handle -> queue ); 6. uv__handle_stop ( handle ); 7. return 0 ; 8. } \u6839\u636e\u4e0d\u540c\u7684handle\u505a\u4e0d\u540c\u7684\u5904\u7406\u540e\uff0c\u63a5\u7740\u6267\u884cuv__make_close_pending\u5f80close\u961f\u5217\u8ffd\u52a0\u8282\u70b9\u3002 1. // \u5934\u63d2\u6cd5\u63d2\u5165closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u88ab\u6267\u884c 2. void uv__make_close_pending ( uv_handle_t * handle ) { 3. handle -> next_closing = handle -> loop -> closing_handles ; 4. handle -> loop -> closing_handles = handle ; 5. } \u7136\u540e\u5728close\u9636\u6bb5\u9010\u4e2a\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0bclose\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91 1. // \u6267\u884cclosing\u9636\u6bb5\u7684\u7684\u56de\u8c03 2. static void uv__run_closing_handles ( uv_loop_t * loop ) { 3. uv_handle_t * p ; 4. uv_handle_t * q ; 5. 6. p = loop -> closing_handles ; 7. loop -> closing_handles = NULL ; 8. 9. while ( p ) { 10. q = p -> next_closing ; 11. uv__finish_close ( p ); 12. p = q ; 13. } 14. } 15. 16. // \u6267\u884cclosing\u9636\u6bb5\u7684\u56de\u8c03 17. static void uv__finish_close ( uv_handle_t * handle ) { 18. handle -> flags |= UV_HANDLE_CLOSED ; 19. ... 20. uv__handle_unref ( handle ); 21. // \u4ecehandle\u961f\u5217\u91cc\u79fb\u9664 22. QUEUE_REMOVE ( & handle -> handle_queue ); 23. if ( handle -> close_cb ) { 24. handle -> close_cb ( handle ); 25. } 26. } uv__run_closing_handles\u4f1a\u9010\u4e2a\u6267\u884c\u6bcf\u4e2a\u4efb\u52a1\u8282\u70b9\u7684\u56de\u8c03\u3002","title":"3.5 \u4e8b\u4ef6\u5faa\u73af\u4e4bclose"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#36","text":"Libuv\u901a\u8fc7uv__loop_alive\u51fd\u6570\u5224\u65ad\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u9700\u8981\u7ee7\u7eed\u6267\u884c\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1. static int uv__loop_alive ( const uv_loop_t * loop ) { 2. return uv__has_active_handles ( loop ) || 3. uv__has_active_reqs ( loop ) || 4. loop -> closing_handles != NULL ; 5. } \u4e3a\u4ec0\u4e48\u4f1a\u6709\u4e00\u4e2aclosing_handle\u7684\u5224\u65ad\u5462\uff1f\u4eceuv_run\u7684\u4ee3\u7801\u6765\u770b\uff0c\u6267\u884c\u5b8cclose\u9636\u6bb5\u540e\uff0c\u4f1a\u7acb\u523b\u6267\u884cuv__loop_alive\uff0c\u6b63\u5e38\u6765\u8bf4\uff0cclose\u9636\u6bb5\u7684\u961f\u5217\u662f\u7a7a\u7684\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728close\u56de\u8c03\u91cc\u53c8\u5f80close\u961f\u5217\u65b0\u589e\u4e86\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u8be5\u8282\u70b9\u4e0d\u4f1a\u5728\u672c\u8f6e\u7684close\u9636\u6bb5\u88ab\u6267\u884c\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u6267\u884c\u5b8cclose\u9636\u6bb5\uff0c\u4f46\u662fclose\u961f\u5217\u4f9d\u7136\u6709\u8282\u70b9\uff0c\u5982\u679c\u76f4\u63a5\u9000\u51fa\uff0c\u5219\u65e0\u6cd5\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0cLibuv\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662f\u5b58\u6d3b\u7684\u3002\u5982\u679c\u6211\u4eec\u63a7\u5236\u8fd9\u4e09\u79cd\u6761\u4ef6\u5c31\u53ef\u4ee5\u63a7\u5236\u4e8b\u4ef6\u5faa\u73af\u7684\u7684\u9000\u51fa\u3002\u6211\u4eec\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u7406\u89e3\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1. const timeout = setTimeout (() => { 2. console . log ( ' never console ' ) 3. }, 5000 ); 4. timeout . unref (); \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0csetTimeout\u7684\u56de\u8c03\u662f\u4e0d\u4f1a\u6267\u884c\u7684\u3002\u9664\u975e\u8d85\u65f6\u65f6\u95f4\u975e\u5e38\u77ed\uff0c\u77ed\u5230\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u5019\u5c31\u5230\u671f\u4e86\uff0c\u5426\u5219\u5728\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e4b\u540e\uff0c\u7531\u4e8eunref\u7684\u5f71\u54cd\uff0c\u4e8b\u4ef6\u5faa\u73af\u76f4\u63a5\u9000\u51fa\u4e86\u3002unref\u5f71\u54cd\u7684\u5c31\u662fhandle\u8fd9\u4e2a\u6761\u4ef6\u3002\u8fd9\u65f6\u5019\u4e8b\u4ef6\u5faa\u73af\u4ee3\u7801\u5982\u4e0b\u3002 1. while ( r != 0 && loop -> stop_flag == 0 ) { 2. uv__update_time ( loop ); 3. uv__run_timers ( loop ); 4. // ... 5. // uv__loop_alive\u8fd4\u56defalse\uff0c\u76f4\u63a5\u8df3\u51fawhile\uff0c\u4ece\u800c\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af 6. r = uv__loop_alive ( loop ); 7. }","title":"3.6 \u63a7\u5236\u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","text":"\u7b2c\u56db\u7ae0 \u7ebf\u7a0b\u6c60 \u00b6 Libuv\u662f\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u9a71\u52a8\u7684\u5f02\u6b65IO\u5e93\uff0c\u5bf9\u4e8e\u963b\u585e\u5f0f\u6216\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u5728Libuv\u7684\u4e3b\u5faa\u73af\u91cc\u6267\u884c\u7684\u8bdd\uff0c\u5c31\u4f1a\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\u6267\u884c\uff0c\u6240\u4ee5Libuv\u91cc\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u5b83\u8d1f\u8d23\u5904\u7406Libuv\u4e2d\u8017\u65f6\u6216\u8005\u5bfc\u81f4\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u6587\u4ef6IO\u3001DNS\u3001\u81ea\u5b9a\u4e49\u7684\u8017\u65f6\u4efb\u52a1\u3002\u7ebf\u7a0b\u6c60\u5728Libuv\u67b6\u6784\u4e2d\u7684\u4f4d\u7f6e\u5982\u56fe4-1\u6240\u793a\u3002 Libuv\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u7ebf\u7a0b\u6c60\u63d0\u4f9b\u7684\u63a5\u53e3\u628a\u4efb\u52a1\u63d0\u4ea4\u7ed9\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u7acb\u523b\u8fd4\u56de\u5230\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7ee7\u7eed\u6267\u884c\uff0c\u7ebf\u7a0b\u6c60\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4efb\u52a1\u961f\u5217\uff0c\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4f1a\u4e92\u65a5\u5730\u4ece\u4e2d\u6458\u4e0b\u4efb\u52a1\u8282\u70b9\u6267\u884c\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u4efb\u52a1\u5b8c\u6bd5\u540e\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u4e3b\u7ebf\u7a0b\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002 4.1\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1 \u00b6 Libuv\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u662f\u4f7f\u7528uv_async_t\u7ed3\u6784\u4f53\u5b9e\u73b0\u7684\u3002Libuv\u4f7f\u7528loop->async_handles\u961f\u5217\u8bb0\u5f55\u6240\u6709\u7684uv_async_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528loop->async_io_watcher\u4f5c\u4e3a\u6240\u6709uv_async_t\u7ed3\u6784\u4f53\u7684IO\u89c2\u5bdf\u8005\uff0c\u5373loop-> async_handles\u961f\u5217\u4e0a\u6240\u6709\u7684handle\u90fd\u662f\u5171\u4eabasync_io_watcher\u8fd9\u4e2aIO\u89c2\u5bdf\u8005\u7684\u3002\u7b2c\u4e00\u6b21\u63d2\u5165\u4e00\u4e2auv_async_t\u7ed3\u6784\u4f53\u5230async_handle\u961f\u5217\u65f6\uff0c\u4f1a\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u5982\u679c\u518d\u6b21\u6ce8\u518c\u4e00\u4e2aasync_handle\uff0c\u53ea\u4f1a\u5728loop->async_handle\u961f\u5217\u548chandle\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u4e0d\u4f1a\u65b0\u589e\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u3002\u5f53uv_async_t\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u5b50\u7ebf\u7a0b\u4f1a\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u4e3a\u53ef\u8bfb\u3002Libuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0buv_async_t\u5728Libuv\u4e2d\u7684\u4f7f\u7528\u3002 4.1.1 \u521d\u59cb\u5316 \u00b6 \u4f7f\u7528uv_async_t\u4e4b\u524d\u9996\u5148\u9700\u8981\u6267\u884cuv_async_init\u8fdb\u884c\u521d\u59cb\u5316\u3002 1. int uv_async_init ( uv_loop_t * loop , 2. uv_async_t * handle , 3. uv_async_cb async_cb ) { 4. int err ; 5. // \u7ed9Libuv\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005io 6. err = uv__async_start ( loop ); 7. if ( err ) 8. return err ; 9. // \u8bbe\u7f6e\u76f8\u5173\u5b57\u6bb5\uff0c\u7ed9Libuv\u63d2\u5165\u4e00\u4e2ahandle 10. uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_ASYNC ); 11. // \u8bbe\u7f6e\u56de\u8c03 12. handle -> async_cb = async_cb ; 13. // \u521d\u59cb\u5316\u6807\u8bb0\u5b57\u6bb5\uff0c0\u8868\u793a\u6ca1\u6709\u4efb\u52a1\u5b8c\u6210 14. handle -> pending = 0 ; 15. // \u628auv_async_t\u63d2\u5165async_handle\u961f\u5217 16. QUEUE_INSERT_TAIL ( & loop -> async_handles , & handle -> queue ); 17. uv__handle_start ( handle ); 18. return 0 ; 19. } uv_async_init\u51fd\u6570\u4e3b\u8981\u521d\u59cb\u5316\u7ed3\u6784\u4f53uv_async_t\u7684\u4e00\u4e9b\u5b57\u6bb5\uff0c\u7136\u540e\u6267\u884cQUEUE_INSERT_TAIL\u7ed9Libuv\u7684async_handles\u961f\u5217\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002\u6211\u4eec\u770b\u5230\u8fd8\u6709\u4e00\u4e2auv__async_start\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__async_start\u7684\u5b9e\u73b0\u3002 1. static int uv__async_start ( uv_loop_t * loop ) { 2. int pipefd [ 2 ]; 3. int err ; 4. // uv__async_start\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6709fd\u5219\u4e0d\u9700\u8981\u6267\u884c\u4e86 5. if ( loop -> async_io_watcher . fd != -1 ) 6. return 0 ; 7. // \u83b7\u53d6\u4e00\u4e2a\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684fd\uff08Linux\u7684eventfd\u673a\u5236\uff09 8. err = uv__async_eventfd (); 9. /* 10. \u6210\u529f\u5219\u4fdd\u5b58fd\uff0c\u5931\u8d25\u8bf4\u660e\u4e0d\u652f\u6301eventfd\uff0c 11. \u5219\u4f7f\u7528\u7ba1\u9053\u901a\u4fe1\u4f5c\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1 12. */ 13. if ( err >= 0 ) { 14. pipefd [ 0 ] = err ; 15. pipefd [ 1 ] = -1 ; 16. } 17. else if ( err == UV_ENOSYS ) { 18. // \u4e0d\u652f\u6301eventfd\u5219\u4f7f\u7528\u533f\u540d\u7ba1\u9053 19. err = uv__make_pipe ( pipefd , UV__F_NONBLOCK ); 20. # if defined ( __Linux__ ) 21. if ( err == 0 ) { 22. char buf [ 32 ]; 23. int fd ; 24. snprintf ( buf , sizeof ( buf ), \"/proc/self/fd/%d\" , pipefd [ 0 ]); // \u901a\u8fc7\u4e00\u4e2afd\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u7ba1\u9053\u7684\u8bfb\u5199\uff0c\u9ad8\u7ea7\u7528\u6cd5 25. fd = uv__open_cloexec ( buf , O_RDWR ); 26. if ( fd >= 0 ) { 27. // \u5173\u6389\u65e7\u7684 28. uv__close ( pipefd [ 0 ]); 29. uv__close ( pipefd [ 1 ]); 30. // \u8d4b\u503c\u65b0\u7684 31. pipefd [ 0 ] = fd ; 32. pipefd [ 1 ] = fd ; 33. } 34. } 35. # endif 36. } 37. // err\u5927\u4e8e\u7b49\u4e8e0\u8bf4\u660e\u62ff\u5230\u4e86\u901a\u4fe1\u7684\u8bfb\u5199\u4e24\u7aef 38. if ( err < 0 ) 39. return err ; 40. /* 41. \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005async_io_watcher\uff0c 42. \u628a\u8bfb\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230IO\u89c2\u5bdf\u8005 43. */ 44. uv__io_init ( & loop -> async_io_watcher , uv__async_io , pipefd [ 0 ]); 45. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\u91cc\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6POLLIN\uff0c\u7b49\u5f85\u53ef\u8bfb 46. uv__io_start ( loop , & loop -> async_io_watcher , POLLIN ); 47. // \u4fdd\u5b58\u5199\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26 48. loop -> async_wfd = pipefd [ 1 ]; 49. return 0 ; 50. } uv__async_start\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u65f6\u673a\u5728\u7b2c\u4e00\u6b21\u6267\u884cuv_async_init\u7684\u65f6\u5019\u3002uv__async_start\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u83b7\u53d6\u901a\u4fe1\u63cf\u8ff0\u7b26\uff08\u901a\u8fc7eventfd\u751f\u6210\u4e00\u4e2a\u901a\u4fe1\u7684fd\uff08\u5145\u5f53\u8bfb\u5199\u4e24\u7aef\uff09\u6216\u8005\u7ba1\u9053\u751f\u6210\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2afd\u8868\u793a\u8bfb\u7aef\u548c\u5199\u7aef\uff09\u3002 2 \u5c01\u88c5\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u548c\u56de\u8c03\u5230IO\u89c2\u5bdf\u8005\u7136\u540e\u8ffd\u52a0\u5230watcher_queue\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6ce8\u518c\u5230epoll\u91cc\u9762\uff0c\u5982\u679c\u6709\u4efb\u52a1\u5b8c\u6210\uff0c\u4e5f\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 3 \u4fdd\u5b58\u5199\u7aef\u63cf\u8ff0\u7b26\u3002\u4efb\u52a1\u5b8c\u6210\u65f6\u901a\u8fc7\u5199\u7aeffd\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u5230uv__async_start\u51fd\u6570\u91cc\u6709\u5f88\u591a\u83b7\u53d6\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u903b\u8f91\uff0c\u603b\u7684\u6765\u8bf4\uff0c\u662f\u4e3a\u4e86\u5b8c\u6210\u4e24\u7aef\u901a\u4fe1\u7684\u529f\u80fd\u3002\u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0cLibuv\u7ed3\u6784\u5982\u56fe4-2\u6240\u793a\u3002 4.1.2 \u901a\u77e5\u4e3b\u7ebf\u7a0b \u00b6 \u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0c\u5982\u679casync\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u901a\u8fc7\u8bbe\u7f6e\u8fd9\u4e2ahandle\u7684pending\u4e3a1\u6807\u8bb0\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u518d\u5f80\u7ba1\u9053\u5199\u7aef\u5199\u5165\u6807\u8bb0\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210\u4e86\u3002 1. int uv_async_send ( uv_async_t * handle ) { 2. /* Do a cheap read first. */ 3. if ( ACCESS_ONCE ( int , handle -> pending ) != 0 ) 4. return 0 ; 5. /* 6. \u5982pending\u662f0\uff0c\u5219\u8bbe\u7f6e\u4e3a1\uff0c\u8fd4\u56de0\uff0c\u5982\u679c\u662f1\u5219\u8fd4\u56de1\uff0c 7. \u6240\u4ee5\u5982\u679c\u591a\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u662f\u4f1a\u88ab\u5408\u5e76\u7684 8. */ 9. if ( cmpxchgi ( & handle -> pending , 0 , 1 ) == 0 ) 10. uv__async_send ( handle -> loop ); 11. return 0 ; 12. } 13. 14. static void uv__async_send ( uv_loop_t * loop ) { 15. const void * buf ; 16. ssize_t len ; 17. int fd ; 18. int r ; 19. 20. buf = \"\" ; 21. len = 1 ; 22. fd = loop -> async_wfd ; 23. 24. # if defined ( __Linux__ ) 25. // \u8bf4\u660e\u7528\u7684\u662feventfd\u800c\u4e0d\u662f\u7ba1\u9053,eventfd\u65f6\u8bfb\u5199\u4e24\u7aef\u5bf9\u5e94\u540c\u4e00\u4e2afd 26. if ( fd == -1 ) { 27. static const uint64_t val = 1 ; 28. buf = & val ; 29. len = sizeof ( val ); 30. // \u89c1uv__async_start 31. fd = loop -> async_io_watcher . fd ; /* eventfd */ 32. } 33. # endif 34. // \u901a\u77e5\u8bfb\u7aef 35. do 36. r = write ( fd , buf , len ); 37. while ( r == -1 && errno == EINTR ); 38. 39. if ( r == len ) 40. return ; 41. 42. if ( r == -1 ) 43. if ( errno == EAGAIN || errno == EWOULDBLOCK ) 44. return ; 45. 46. abort (); 47. } uv_async_send\u9996\u5148\u62ff\u5230\u5199\u7aef\u5bf9\u5e94\u7684fd\uff0c\u7136\u540e\u8c03\u7528write\u51fd\u6570\uff0c\u6b64\u65f6\uff0c\u5f80\u7ba1\u9053\u7684\u5199\u7aef\u5199\u5165\u6570\u636e\uff0c\u6807\u8bb0\u6709\u4efb\u52a1\u5b8c\u6210\u3002\u6709\u5199\u5219\u5fc5\u7136\u6709\u8bfb\u3002\u8bfb\u7684\u903b\u8f91\u662f\u5728uv__io_poll\u4e2d\u5b9e\u73b0\u7684\u3002uv__io_poll\u51fd\u6570\u5373Libuv\u4e2dPoll IO\u9636\u6bb5\u6267\u884c\u7684\u51fd\u6570\u3002\u5728uv__io_poll\u4e2d\u4f1a\u53d1\u73b0\u7ba1\u9053\u53ef\u8bfb\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03uv__async_io\u3002 4.1.3 \u4e3b\u7ebf\u7a0b\u5904\u7406\u56de\u8c03 \u00b6 1. static void uv__async_io ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. char buf [ 1024 ]; 5. ssize_t r ; 6. QUEUE queue ; 7. QUEUE * q ; 8. uv_async_t * h ; 9. 10. for (;;) { 11. // \u6d88\u8d39\u6240\u6709\u7684\u6570\u636e 12. r = read ( w -> fd , buf , sizeof ( buf )); 13. // \u6570\u636e\u5927\u5c0f\u5927\u4e8ebuf\u957f\u5ea6\uff081024\uff09\uff0c\u5219\u7ee7\u7eed\u6d88\u8d39 14. if ( r == sizeof ( buf )) 15. continue ; 16. // \u6210\u529f\u6d88\u8d39\u5b8c\u6bd5\uff0c\u8df3\u51fa\u6d88\u8d39\u7684\u903b\u8f91 17. if ( r != -1 ) 18. break ; 19. // \u8bfb\u7e41\u5fd9 20. if ( errno == EAGAIN || errno == EWOULDBLOCK ) 21. break ; 22. // \u8bfb\u88ab\u4e2d\u65ad\uff0c\u7ee7\u7eed\u8bfb 23. if ( errno == EINTR ) 24. continue ; 25. abort (); 26. } 27. // \u628aasync_handles\u961f\u5217\u91cc\u7684\u6240\u6709\u8282\u70b9\u90fd\u79fb\u5230queue\u53d8\u91cf\u4e2d 28. QUEUE_MOVE ( & loop -> async_handles , & queue ); 29. while ( ! QUEUE_EMPTY ( & queue )) { 30. // \u9010\u4e2a\u53d6\u51fa\u8282\u70b9 31. q = QUEUE_HEAD ( & queue ); 32. // \u6839\u636e\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 33. h = QUEUE_DATA ( q , uv_async_t , queue ); 34. // \u4ece\u961f\u5217\u4e2d\u79fb\u9664\u8be5\u8282\u70b9 35. QUEUE_REMOVE ( q ); 36. // \u91cd\u65b0\u63d2\u5165async_handles\u961f\u5217\uff0c\u7b49\u5f85\u4e0b\u6b21\u4e8b\u4ef6 37. QUEUE_INSERT_TAIL ( & loop -> async_handles , q ); 38. /* 39. \u5c06\u7b2c\u4e00\u4e2a\u53c2\u6570\u548c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u7b49\uff0c 40. \u5219\u5c06\u7b2c\u4e09\u53c2\u6570\u5199\u5165\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\uff0c 41. \u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\u3002 42. */ 43. /* 44. \u5224\u65ad\u89e6\u53d1\u4e86\u54ea\u4e9basync\u3002pending\u5728uv_async_send\u91cc\u8bbe\u7f6e\u62101\uff0c 45. \u5982\u679cpending\u7b49\u4e8e1\uff0c\u5219\u6e050\uff0c\u8fd4\u56de1.\u5982\u679cpending\u7b49\u4e8e0\uff0c\u5219\u8fd4\u56de0 46. */ 47. if ( cmpxchgi ( & h -> pending , 1 , 0 ) == 0 ) 48. continue ; 49. 50. if ( h -> async_cb == NULL ) 51. continue ; 52. // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 53. h -> async_cb ( h ); 54. } 55. } uv__async_io\u4f1a\u904d\u5386async_handles\u961f\u5217\uff0cpending\u7b49\u4e8e1\u7684\u8bdd\u8bf4\u660e\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u5e76\u6e05\u9664\u6807\u8bb0\u4f4d\u3002 4.2 \u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0 \u00b6 \u4e86\u89e3\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u540e\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\u3002 4.2.1 \u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316 \u00b6 \u7ebf\u7a0b\u6c60\u662f\u61d2\u521d\u59cb\u5316\u7684\uff0cNode.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709\u521b\u5efa\u5b50\u7ebf\u7a0b\uff0c\u800c\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7ed9\u7ebf\u7a0b\u6c60\u65f6\uff0c\u7ebf\u7a0b\u6c60\u624d\u5f00\u59cb\u521d\u59cb\u5316\u3002\u6211\u4eec\u5148\u770b\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u903b\u8f91\uff0c\u7136\u540e\u518d\u770b\u5b83\u7684\u4f7f\u7528\u3002 1. static void init_threads ( void ) { 2. unsigned int i ; 3. const char * val ; 4. // \u9ed8\u8ba4\u7ebf\u7a0b\u65704\u4e2a\uff0cstatic uv_thread_t default_threads[4]; 5. nthreads = ARRAY_SIZE ( default_threads ); 6. // \u5224\u65ad\u7528\u6237\u662f\u5426\u5728\u73af\u5883\u53d8\u91cf\u4e2d\u8bbe\u7f6e\u4e86\u7ebf\u7a0b\u6570\uff0c\u662f\u7684\u8bdd\u53d6\u7528\u6237\u5b9a\u4e49\u7684 7. val = getenv ( \"UV_THREADPOOL_SIZE\" ); 8. if ( val != NULL ) 9. nthreads = atoi ( val ); 10. if ( nthreads == 0 ) 11. nthreads = 1 ; 12. // #define MAX_THREADPOOL_SIZE 128\u6700\u591a128\u4e2a\u7ebf\u7a0b 13. if ( nthreads > MAX_THREADPOOL_SIZE ) 14. nthreads = MAX_THREADPOOL_SIZE ; 15. 16. threads = default_threads ; 17. // \u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\uff0c\u91cd\u65b0\u5206\u914d\u5185\u5b58 18. if ( nthreads > ARRAY_SIZE ( default_threads )) { 19. threads = uv__malloc ( nthreads * sizeof ( threads [ 0 ])); 20. } 21. // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\uff0c\u7528\u4e8e\u6709\u4efb\u52a1\u65f6\u5524\u9192\u5b50\u7ebf\u7a0b\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u6302\u8d77\u5b50\u7ebf\u7a0b 22. if ( uv_cond_init ( & cond )) 23. abort (); 24. // \u521d\u59cb\u5316\u4e92\u65a5\u53d8\u91cf\uff0c\u7528\u4e8e\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 25. if ( uv_mutex_init ( & mutex )) 26. abort (); 27. 28. // \u521d\u59cb\u5316\u4e09\u4e2a\u961f\u5217 29. QUEUE_INIT ( & wq ); 30. QUEUE_INIT ( & slow_io_pending_wq ); 31. QUEUE_INIT ( & run_slow_work_message ); 32. 33. // \u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u5de5\u4f5c\u51fd\u6570\u4e3aworker\uff0csem\u4e3aworker\u5165\u53c2 34. for ( i = 0 ; i < nthreads ; i ++ ) 35. if ( uv_thread_create ( threads + i , worker , & sem )) 36. abort (); 37. } \u7ebf\u7a0b\u6c60\u521d\u59cb\u5316\u65f6\uff0c\u4f1a\u6839\u636e\u914d\u7f6e\u7684\u5b50\u7ebf\u7a0b\u6570\u521b\u5efa\u5bf9\u5e94\u6570\u91cf\u7684\u7ebf\u7a0b\u3002\u9ed8\u8ba4\u662f4\u4e2a\uff0c\u6700\u5927128\u4e2a\u5b50\u7ebf\u7a0b\uff08\u4e0d\u540c\u7248\u672c\u7684Libuv\u53ef\u80fd\u4f1a\u4e0d\u4e00\u6837\uff09\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u7684\u5927\u5c0f\u3002\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u63a5\u7740\u5728\u6bcf\u4e2a\u7ebf\u7a0b\u91cc\u6267\u884cworker\u51fd\u6570\u5904\u7406\u4efb\u52a1\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790worker\u7684\u903b\u8f91\u3002 4.2.2 \u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60 \u00b6 \u4e86\u89e3\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e4b\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1 1. // \u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1 2. void uv__work_submit ( uv_loop_t * loop , 3. struct uv__work * w , 4. enum uv__work_kind kind , 5. void ( * work )( struct uv__work * w ), 6. void ( * done )( struct uv__work * w , int status )){ 7. /* 8. \u4fdd\u8bc1\u5df2\u7ecf\u521d\u59cb\u5316\u7ebf\u7a0b\uff0c\u5e76\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u7ebf\u7a0b\u6c60\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a 9. \u4efb\u52a1\u7684\u65f6\u5019\u624d\u88ab\u521d\u59cb\u5316\uff0cinit_once -> init_threads 10. */ 11. uv_once ( & once , init_once ); 12. w -> loop = loop ; 13. w -> work = work ; 14. w -> done = done ; 15. post ( & w -> wq , kind ); 16. } \u8fd9\u91cc\u628a\u4e1a\u52a1\u76f8\u5173\u7684\u51fd\u6570\u548c\u4efb\u52a1\u5b8c\u6210\u540e\u7684\u56de\u8c03\u51fd\u6570\u5c01\u88c5\u5230uv__work\u7ed3\u6784\u4f53\u4e2d\u3002uv__work\u7ed3\u6784\u5b9a\u4e49\u5982\u4e0b\u3002 1. struct uv__work { 2. void ( * work )( struct uv__work * w ); 3. void ( * done )( struct uv__work * w , int status ); 4. struct uv_loop_s * loop ; 5. void * wq [ 2 ]; 6. }; \u7136\u540e\u8c03\u8c03\u7528post\u51fd\u6570\u5f80\u7ebf\u7a0b\u6c60\u7684\u961f\u5217\u4e2d\u52a0\u5165\u4e00\u4e2a\u65b0\u7684\u4efb\u52a1\u3002Libuv\u628a\u4efb\u52a1\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff0c\u6162IO\uff08DNS\u89e3\u6790\uff09\u3001\u5febIO\uff08\u6587\u4ef6\u64cd\u4f5c\uff09\u3001CPU\u5bc6\u96c6\u578b\u7b49\uff0ckind\u5c31\u662f\u8bf4\u660e\u4efb\u52a1\u7684\u7c7b\u578b\u7684\u3002\u6211\u4eec\u63a5\u7740\u770bpost\u51fd\u6570\u3002 1. static void post ( QUEUE * q , enum uv__work_kind kind ) { 2. // \u52a0\u9501\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u961f\u5217\u662f\u7ebf\u7a0b\u6c60\u5171\u4eab\u7684 3. uv_mutex_lock ( & mutex ); 4. // \u7c7b\u578b\u662f\u6162IO 5. if ( kind == UV__WORK_SLOW_IO ) { 6. /* 7. \u63d2\u5165\u6162IO\u5bf9\u5e94\u7684\u961f\u5217\uff0cLibuv\u8fd9\u4e2a\u7248\u672c\u628a\u4efb\u52a1\u5206\u4e3a\u51e0\u79cd\u7c7b\u578b\uff0c 8. \u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u662f\u5f80\u4efb\u52a1\u961f\u5217\u91cc\u9762\u63d2\u5165\u4e00\u4e2a\u7279\u6b8a\u7684\u8282\u70b9 9. run_slow_work_message\uff0c\u7136\u540e\u7528slow_io_pending_wq\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6162IO 10. \u4efb\u52a1\u7684\u961f\u5217\uff0c\u5f53\u5904\u7406\u5230run_slow_work_message\u8fd9\u4e2a\u8282\u70b9\u7684\u65f6\u5019\uff0c 11. Libuv\u4f1a\u4eceslow_io_pending_wq\u961f\u5217\u91cc\u9010\u4e2a\u53d6\u51fa\u4efb\u52a1\u8282\u70b9\u6765\u6267\u884c\u3002 12. */ 13. QUEUE_INSERT_TAIL ( & slow_io_pending_wq , q ); 14. /* 15. \u6709\u6162IO\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u9700\u8981\u7ed9\u4e3b\u961f\u5217wq\u63d2\u5165\u4e00\u4e2a\u6d88\u606f\u8282\u70b9 16. run_slow_work_message,\u8bf4\u660e\u6709\u6162IO\u4efb\u52a1\uff0c\u6240\u4ee5\u5982\u679c 17. run_slow_work_message\u662f\u7a7a\uff0c\u8bf4\u660e\u8fd8\u6ca1\u6709\u63d2\u5165\u4e3b\u961f\u5217\u3002\u9700\u8981\u8fdb\u884c 18. q = &run_slow_work_message;\u8d4b\u503c\uff0c\u7136\u540e\u628a 19. run_slow_work_message\u63d2\u5165\u4e3b\u961f\u5217\u3002\u5982\u679crun_slow_work_message 20. \u975e\u7a7a\uff0c\u8bf4\u660e\u5df2\u7ecf\u63d2\u5165\u7ebf\u7a0b\u6c60\u7684\u4efb\u52a1\u961f\u5217\u4e86\u3002\u89e3\u9501\u7136\u540e\u76f4\u63a5\u8fd4\u56de\u3002 21. */ 22. if ( ! QUEUE_EMPTY ( & run_slow_work_message )) { 23. uv_mutex_unlock ( & mutex ); 24. return ; 25. } 26. // \u8bf4\u660erun_slow_work_message\u8fd8\u6ca1\u6709\u63d2\u5165\u961f\u5217\uff0c\u51c6\u5907\u63d2\u5165\u961f\u5217 27. q = & run_slow_work_message ; 28. } 29. // \u628a\u8282\u70b9\u63d2\u5165\u4e3b\u961f\u5217\uff0c\u53ef\u80fd\u662f\u6162IO\u6d88\u606f\u8282\u70b9\u6216\u8005\u4e00\u822c\u4efb\u52a1 30. QUEUE_INSERT_TAIL ( & wq , q ); 31. /* 32. \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u5982\u679c\u5927\u5bb6\u90fd\u5728\u5fd9\uff0c 33. \u5219\u7b49\u5230\u5b83\u5fd9\u5b8c\u540e\u5c31\u4f1a\u91cd\u65b0\u5224\u65ad\u662f\u5426\u8fd8\u6709\u65b0\u4efb\u52a1 34. */ 35. if ( idle_threads > 0 ) 36. uv_cond_signal ( & cond ); 37. // \u64cd\u4f5c\u5b8c\u961f\u5217\uff0c\u89e3\u9501 38. uv_mutex_unlock ( & mutex ); 39. } \u8fd9\u5c31\u662fLibuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u751f\u4ea7\u8005\u903b\u8f91\u3002\u4efb\u52a1\u961f\u5217\u7684\u67b6\u6784\u5982\u56fe4-3\u6240\u793a\u3002 \u9664\u4e86\u4e0a\u9762\u63d0\u5230\u7684\uff0cLibuv\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u79cd\u751f\u4ea7\u4efb\u52a1\u7684\u65b9\u5f0f\uff0c\u5373uv_queue_work\u51fd\u6570\uff0c\u5b83\u53ea\u63d0\u4ea4CPU\u5bc6\u96c6\u578b\u7684\u4efb\u52a1\uff08\u5728Node.js\u7684crypto\u6a21\u5757\u4e2d\u4f7f\u7528\uff09\u3002\u4e0b\u9762\u6211\u4eec\u770buv_queue_work\u7684\u5b9e\u73b0\u3002 1. int uv_queue_work ( uv_loop_t * loop , 2. uv_work_t * req , 3. uv_work_cb work_cb , 4. uv_after_work_cb after_work_cb ) { 5. if ( work_cb == NULL ) 6. return UV_EINVAL ; 7. 8. uv__req_init ( loop , req , UV_WORK ); 9. req -> loop = loop ; 10. req -> work_cb = work_cb ; 11. req -> after_work_cb = after_work_cb ; 12. uv__work_submit ( loop , 13. & req -> work_req , 14. UV__WORK_CPU , 15. uv__queue_work , 16. uv__queue_done ); 17. return 0 ; 18. } uv_queue_work\u51fd\u6570\u5176\u5b9e\u4e5f\u6ca1\u6709\u592a\u591a\u7684\u903b\u8f91\uff0c\u5b83\u4fdd\u5b58\u7528\u6237\u7684\u5de5\u4f5c\u51fd\u6570\u548c\u56de\u8c03\u5230request\u4e2d\u3002\u7136\u540e\u628auv__queue_work\u548cuv__queue_done\u5c01\u88c5\u5230uv__work\u4e2d\uff0c\u63a5\u7740\u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60\u4e2d\u3002\u6240\u4ee5\u5f53\u8fd9\u4e2a\u4efb\u52a1\u88ab\u6267\u884c\u7684\u65f6\u5019\u3002\u5b83\u4f1a\u6267\u884c\u5de5\u4f5c\u51fd\u6570uv__queue_work\u3002 1. static void uv__queue_work ( struct uv__work * w ) { 2. // \u901a\u8fc7\u7ed3\u6784\u4f53\u67d0\u5b57\u6bb5\u62ff\u5230\u7ed3\u6784\u4f53\u5730\u5740 3. uv_work_t * req = container_of ( w , uv_work_t , work_req ); 4. req -> work_cb ( req ); 5. } \u6211\u4eec\u770b\u5230uv__queue_work\u5176\u5b9e\u5c31\u662f\u5bf9\u7528\u6237\u5b9a\u4e49\u7684\u4efb\u52a1\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u731c\u5230\uff0cuv__queue_done\u4e5f\u53ea\u662f\u5bf9\u7528\u6237\u56de\u8c03\u7684\u7b80\u5355\u5c01\u88c5\uff0c\u5373\u5b83\u4f1a\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 4.2.3 \u5904\u7406\u4efb\u52a1 \u00b6 \u6211\u4eec\u63d0\u4ea4\u4e86\u4efb\u52a1\u540e\uff0c\u7ebf\u7a0b\u81ea\u7136\u8981\u5904\u7406\uff0c\u521d\u59cb\u5316\u7ebf\u7a0b\u6c60\u7684\u65f6\u5019\u6211\u4eec\u5206\u6790\u8fc7\uff0cworker\u51fd\u6570\u662f\u8d1f\u8d23\u5904\u7406\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0bworker\u51fd\u6570\u7684\u903b\u8f91\u3002 1. static void worker ( void * arg ) { 2. struct uv__work * w ; 3. QUEUE * q ; 4. int is_slow_work ; 5. // \u7ebf\u7a0b\u542f\u52a8\u6210\u529f 6. uv_sem_post (( uv_sem_t * ) arg ); 7. arg = NULL ; 8. // \u52a0\u9501\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 9. uv_mutex_lock ( & mutex ); 10. for (;;) { 11. /* 12. 1 \u961f\u5217\u4e3a\u7a7a 13. 2 \u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u4f46\u662f\u961f\u5217\u4e2d\u53ea\u6709\u6162IO\u4efb\u52a1\u4e14\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4efb\u52a1 14. \u4e2a\u6570\u8fbe\u5230\u9608\u503c\u5219\u7a7a\u95f2\u7ebf\u7a0b\u52a0\u4e00\uff0c\u9632\u6b62\u6162IO\u5360\u7528\u8fc7\u591a\u7ebf\u7a0b\uff0c\u5bfc\u81f4 15. \u5176\u5b83\u5feb\u7684\u4efb\u52a1\u65e0\u6cd5\u5f97\u5230\u6267\u884c 16. */ 17. while ( QUEUE_EMPTY ( & wq ) || 18. ( QUEUE_HEAD ( & wq ) == & run_slow_work_message && 19. QUEUE_NEXT ( & run_slow_work_message ) == & wq && 20. slow_io_work_running >= slow_work_thread_threshold ())) { 21. idle_threads += 1 ; 22. // \u963b\u585e\uff0c\u7b49\u5f85\u5524\u9192 23. uv_cond_wait ( & cond , & mutex ); 24. // \u88ab\u5524\u9192\uff0c\u5f00\u59cb\u5e72\u6d3b\uff0c\u7a7a\u95f2\u7ebf\u7a0b\u6570\u51cf\u4e00 25. idle_threads -= 1 ; 26. } 27. // \u53d6\u51fa\u5934\u7ed3\u70b9\uff0c\u5934\u6307\u70b9\u53ef\u80fd\u662f\u9000\u51fa\u6d88\u606f\u3001\u6162IO\uff0c\u4e00\u822c\u8bf7\u6c42 28. q = QUEUE_HEAD ( & wq ); 29. // \u5982\u679c\u5934\u7ed3\u70b9\u662f\u9000\u51fa\u6d88\u606f\uff0c\u5219\u7ed3\u675f\u7ebf\u7a0b 30. if ( q == & exit_message ) { 31. /* 32. \u5524\u9192\u5176\u5b83\u56e0\u4e3a\u6ca1\u6709\u4efb\u52a1\u6b63\u963b\u585e\u7b49\u5f85\u4efb\u52a1\u7684\u7ebf\u7a0b\uff0c 33. \u544a\u8bc9\u5b83\u4eec\u51c6\u5907\u9000\u51fa 34. */ 35. uv_cond_signal ( & cond ); 36. uv_mutex_unlock ( & mutex ); 37. break ; 38. } 39. // \u79fb\u9664\u8282\u70b9 40. QUEUE_REMOVE ( q ); 41. // \u91cd\u7f6e\u524d\u540e\u6307\u9488 42. QUEUE_INIT ( q ); 43. is_slow_work = 0 ; 44. /* 45. \u5982\u679c\u5f53\u524d\u8282\u70b9\u7b49\u4e8e\u6162IO\u8282\u70b9\uff0c\u4e0a\u9762\u7684while\u53ea\u5224\u65ad\u4e86\u662f\u4e0d\u662f\u53ea\u6709\u6162 46. IO\u4efb\u52a1\u4e14\u8fbe\u5230\u9608\u503c\uff0c\u8fd9\u91cc\u662f\u4efb\u52a1\u961f\u5217\u91cc\u80af\u5b9a\u6709\u975e\u6162IO\u4efb\u52a1\uff0c\u53ef\u80fd\u6709 47. \u6162IO\uff0c\u5982\u679c\u6709\u6162IO\u5e76\u4e14\u6b63\u5728\u6267\u884c\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5219\u5148\u4e0d\u5904\u7406\u8be5\u6162 48. IO\u4efb\u52a1\uff0c\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u8fd8\u6709\u975e\u6162IO\u4efb\u52a1\u53ef\u6267\u884c\u3002 49. */ 50. if ( q == & run_slow_work_message ) { 51. // \u8fbe\u5230\u9608\u503c\uff0c\u8be5\u8282\u70b9\u91cd\u65b0\u5165\u961f\uff0c\u56e0\u4e3a\u521a\u624d\u88ab\u5220\u9664\u4e86 52. if ( slow_io_work_running >= slow_work_thread_threshold ()) { 53. QUEUE_INSERT_TAIL ( & wq , q ); 54. continue ; 55. } 56. /* 57. \u6ca1\u6709\u6162IO\u4efb\u52a1\u5219\u7ee7\u7eed\uff0c\u8fd9\u65f6\u5019run_slow_work_message 58. \u5df2\u7ecf\u4ece\u961f\u5217\u4e2d\u88ab\u5220\u9664\uff0c\u4e0b\u6b21\u6709\u6162IO\u7684\u65f6\u5019\u91cd\u65b0\u5165\u961f 59. */ 60. if ( QUEUE_EMPTY ( & slow_io_pending_wq )) 61. continue ; 62. // \u6709\u6162IO\uff0c\u5f00\u59cb\u5904\u7406\u6162IO\u4efb\u52a1 63. is_slow_work = 1 ; 64. /* 65. \u6b63\u5728\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u4e2a\u6570\u7d2f\u52a0\uff0c\u7528\u4e8e\u5176\u5b83\u7ebf\u7a0b\u5224\u65ad\u6162IO\u4efb\u52a1\u4e2a 66. \u6570\u662f\u5426\u8fbe\u5230\u9608\u503c, slow_io_work_running\u662f\u591a\u4e2a\u7ebf\u7a0b\u5171\u4eab\u7684\u53d8\u91cf 67. */ 68. slow_io_work_running ++ ; 69. // \u6458\u4e0b\u4e00\u4e2a\u6162IO\u4efb\u52a1 70. q = QUEUE_HEAD ( & slow_io_pending_wq ); 71. // \u4ece\u6162IO\u961f\u5217\u79fb\u9664 72. QUEUE_REMOVE ( q ); 73. QUEUE_INIT ( q ); 74. /* 75. \u53d6\u51fa\u4e00\u4e2a\u4efb\u52a1\u540e\uff0c\u5982\u679c\u8fd8\u6709\u6162IO\u4efb\u52a1\u5219\u628a\u6162IO\u6807\u8bb0\u8282\u70b9\u91cd\u65b0\u5165 76. \u961f\uff0c\u8868\u793a\u8fd8\u6709\u6162IO\u4efb\u52a1\uff0c\u56e0\u4e3a\u4e0a\u9762\u628a\u8be5\u6807\u8bb0\u8282\u70b9\u51fa\u961f\u4e86 77. */ 78. if ( ! QUEUE_EMPTY ( & slow_io_pending_wq )) { 79. QUEUE_INSERT_TAIL ( & wq , & run_slow_work_message ); 80. // \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u56e0\u4e3a\u8fd8\u6709\u4efb\u52a1\u5904\u7406 81. if ( idle_threads > 0 ) 82. uv_cond_signal ( & cond ); 83. } 84. } 85. // \u4e0d\u9700\u8981\u64cd\u4f5c\u961f\u5217\u4e86\uff0c\u5c3d\u5feb\u91ca\u653e\u9501 86. uv_mutex_unlock ( & mutex ); 87. // q\u662f\u6162IO\u6216\u8005\u4e00\u822c\u4efb\u52a1 88. w = QUEUE_DATA ( q , struct uv__work , wq ); 89. // \u6267\u884c\u4e1a\u52a1\u7684\u4efb\u52a1\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u4e00\u822c\u4f1a\u963b\u585e 90. w -> work ( w ); 91. // \u51c6\u5907\u64cd\u4f5cloop\u7684\u4efb\u52a1\u5b8c\u6210\u961f\u5217\uff0c\u52a0\u9501 92. uv_mutex_lock ( & w -> loop -> wq_mutex ); 93. // \u7f6e\u7a7a\u8bf4\u660e\u6267\u884c\u5b8c\u4e86\uff0c\u89c1cancel\u903b\u8f91 94. w -> work = NULL ; 95. /* 96. \u6267\u884c\u5b8c\u4efb\u52a1,\u63d2\u5165\u5230loop\u7684wq\u961f\u5217,\u5728uv__work_done\u7684\u65f6\u5019\u4f1a 97. \u6267\u884c\u8be5\u961f\u5217\u7684\u8282\u70b9 98. */ 99. QUEUE_INSERT_TAIL ( & w -> loop -> wq , & w -> wq ); 100. // \u901a\u77e5loop\u7684wq_async\u8282\u70b9 101. uv_async_send ( & w -> loop -> wq_async ); 102. uv_mutex_unlock ( & w -> loop -> wq_mutex ); 103. // \u4e3a\u4e0b\u4e00\u8f6e\u64cd\u4f5c\u4efb\u52a1\u961f\u5217\u52a0\u9501 104. uv_mutex_lock ( & mutex ); 105. /* 106. \u6267\u884c\u5b8c\u6162IO\u4efb\u52a1\uff0c\u8bb0\u5f55\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4e2a\u6570\u53d8\u91cf\u51cf1\uff0c 107. \u4e0a\u9762\u52a0\u9501\u4fdd\u8bc1\u4e86\u4e92\u65a5\u8bbf\u95ee\u8fd9\u4e2a\u53d8\u91cf 108. */ 109. if ( is_slow_work ) { 110. slow_io_work_running -- ; 111. } 112. } 113. } \u6211\u4eec\u770b\u5230\u6d88\u8d39\u8005\u7684\u903b\u8f91\u4f3c\u4e4e\u6bd4\u8f83\u590d\u6742\uff0c\u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u9650\u5236\u4e86\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u7ebf\u7a0b\u6570\uff0c\u907f\u514d\u8017\u65f6\u6bd4\u8f83\u5c11\u7684\u4efb\u52a1\u5f97\u4e0d\u5230\u5904\u7406\u3002\u5176\u4f59\u7684\u903b\u8f91\u548c\u4e00\u822c\u7684\u7ebf\u7a0b\u6c60\u7c7b\u4f3c\uff0c\u5c31\u662f\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u53d6\u51fa\u8282\u70b9\u6267\u884c\uff0c\u6267\u884c\u5b8c\u540e\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002\u7ed3\u6784\u5982\u56fe4-4\u6240\u793a\u3002 4.2.4 \u901a\u77e5\u4e3b\u7ebf\u7a0b \u00b6 \u7ebf\u7a0b\u6267\u884c\u5b8c\u4efb\u52a1\u540e\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u800c\u662f\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u7531\u4e3b\u7ebf\u7a0b\u7edf\u4e00\u5904\u7406\uff0c\u8fd9\u662fNode.js\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684\u8981\u6c42\uff0c\u4e5f\u907f\u514d\u4e86\u591a\u7ebf\u7a0b\u5e26\u6765\u7684\u590d\u6742\u95ee\u9898\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u5757\u7684\u903b\u8f91\u3002\u4e00\u5207\u8981\u4eceLibuv\u7684\u521d\u59cb\u5316\u5f00\u59cb uv_default_loop (); -> uv_loop_init (); -> uv_async_init ( loop , & loop -> wq_async , uv__work_done ); \u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\uff0cwq_async\u662f\u7528\u4e8e\u7ebf\u7a0b\u6c60\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684async handle\uff0c\u5b83\u5bf9\u5e94\u7684\u56de\u8c03\u662fuv__work_done\u3002\u6240\u4ee5\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u6c60\u7684\u7ebf\u7a0b\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u901a\u8fc7uv_async_send(&w->loop->wq_async)\u8bbe\u7f6eloop->wq_async.pending = 1\uff0c\u7136\u540e\u901a\u77e5IO\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u8be5handle\u5bf9\u5e94\u7684\u56de\u8c03uv__work_done\u51fd\u6570\u3002\u90a3\u4e48\u6211\u4eec\u5c31\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u3002 1. void uv__work_done ( uv_async_t * handle ) { 2. struct uv__work * w ; 3. uv_loop_t * loop ; 4. QUEUE * q ; 5. QUEUE wq ; 6. int err ; 7. // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 8. loop = container_of ( handle , uv_loop_t , wq_async ); 9. // \u51c6\u5907\u5904\u7406\u961f\u5217\uff0c\u52a0\u9501 10. uv_mutex_lock ( & loop -> wq_mutex ); 11. /* 12. loop->wq\u662f\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u961f\u5217\u3002\u628aloop->wq\u961f\u5217\u7684\u8282\u70b9\u5168\u90e8\u79fb\u5230 13. wp\u53d8\u91cf\u4e2d\uff0c\u8fd9\u6837\u4e00\u6765\u53ef\u4ee5\u5c3d\u5feb\u91ca\u653e\u9501 14. */ 15. QUEUE_MOVE ( & loop -> wq , & wq ); 16. // \u4e0d\u9700\u8981\u4f7f\u7528\u4e86\uff0c\u89e3\u9501 17. uv_mutex_unlock ( & loop -> wq_mutex ); 18. // wq\u961f\u5217\u7684\u8282\u70b9\u6765\u81ea\u5b50\u7ebf\u7a0b\u63d2\u5165 19. while ( ! QUEUE_EMPTY ( & wq )) { 20. q = QUEUE_HEAD ( & wq ); 21. QUEUE_REMOVE ( q ); 22. w = container_of ( q , struct uv__work , wq ); 23. // \u7b49\u4e8euv__canceled\u8bf4\u660e\u8fd9\u4e2a\u4efb\u52a1\u88ab\u53d6\u6d88\u4e86 24. err = ( w -> work == uv__cancelled ) ? UV_ECANCELED : 0 ; 25. // \u6267\u884c\u56de\u8c03 26. w -> done ( w , err ); 27. } 28. } \u8be5\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9010\u4e2a\u5904\u7406\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u8282\u70b9\uff0c\u6267\u884c\u56de\u8c03\uff0c\u5728Node.js\u4e2d\uff0c\u8fd9\u91cc\u7684\u56de\u8c03\u662fC++\u5c42\uff0c\u7136\u540e\u518d\u5230JS\u5c42\u3002\u7ed3\u6784\u56fe\u5982\u56fe4-5\u6240\u793a\u3002 4.2.5 \u53d6\u6d88\u4efb\u52a1 \u00b6 \u7ebf\u7a0b\u6c60\u7684\u8bbe\u8ba1\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u662f\u4e00\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u80fd\u529b\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u91cc\u6267\u884c\u7684\u90fd\u662f\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u5f15\u8d77\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u80fd\u53ca\u65f6\u53d6\u6d88\u4e00\u4e2a\u4efb\u52a1\uff0c\u5c06\u4f1a\u51cf\u8f7b\u5f88\u591a\u6ca1\u5fc5\u8981\u7684\u5904\u7406\u3002\u4e0d\u8fc7Libuv\u5b9e\u73b0\u4e2d\uff0c\u53ea\u6709\u5f53\u4efb\u52a1\u8fd8\u5728\u7b49\u5f85\u961f\u5217\u4e2d\u624d\u80fd\u88ab\u53d6\u6d88\uff0c\u5982\u679c\u4e00\u4e2a\u4efb\u52a1\u6b63\u5728\u88ab\u7ebf\u7a0b\u5904\u7406\uff0c\u5219\u65e0\u6cd5\u53d6\u6d88\u4e86\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bLibuv\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u53d6\u6d88\u4efb\u52a1\u7684\u3002Libuv\u63d0\u4f9b\u4e86uv__work_cancel\u51fd\u6570\u652f\u6301\u7528\u6237\u53d6\u6d88\u63d0\u4ea4\u7684\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u903b\u8f91\u3002 1. static int uv__work_cancel ( uv_loop_t * loop , uv_req_t * req , struct uv__work * w ) { 2. int cancelled ; 3. // \u52a0\u9501\uff0c\u4e3a\u4e86\u628a\u8282\u70b9\u79fb\u51fa\u961f\u5217 4. uv_mutex_lock ( & mutex ); 5. // \u52a0\u9501\uff0c\u4e3a\u4e86\u5224\u65adw->wq\u662f\u5426\u4e3a\u7a7a 6. uv_mutex_lock ( & w -> loop -> wq_mutex ); 7. /* 8. cancelled\u4e3atrue\u8bf4\u660e\u4efb\u52a1\u8fd8\u5728\u7ebf\u7a0b\u6c60\u961f\u5217\u7b49\u5f85\u5904\u7406 9. 1 \u5904\u7406\u5b8c\uff0cw->work == NULL 10. 2 \u5904\u7406\u4e2d\uff0cQUEUE_EMPTY(&w->wq)\u4e3atrue\uff0c\u56e0 11. \u4e3aworker\u5728\u6458\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u91cd\u7f6eprev\u548cnext\u6307\u9488 12. 3 \u672a\u5904\u7406\uff0c!QUEUE_EMPTY(&w->wq)\u662ftrue \u4e14w->work != NULL 13. */ 14. cancelled = ! QUEUE_EMPTY ( & w -> wq ) && w -> work != NULL ; 15. // \u4ece\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9 16. if ( cancelled ) 17. QUEUE_REMOVE ( & w -> wq ); 18. 19. uv_mutex_unlock ( & w -> loop -> wq_mutex ); 20. uv_mutex_unlock ( & mutex ); 21. // \u6b63\u5728\u6267\u884c\u6216\u8005\u5df2\u7ecf\u6267\u884c\u5b8c\u4e86\uff0c\u5219\u4e0d\u80fd\u53d6\u6d88 22. if ( ! cancelled ) 23. return UV_EBUSY ; 24. // \u6253\u53d6\u6d88\u6807\u8bb0\uff0cLibuv\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u7528\u5230 25. w -> work = uv__cancelled ; 26. 27. uv_mutex_lock ( & loop -> wq_mutex ); 28. /* 29. \u63d2\u5165loop\u7684wq\u961f\u5217\uff0c\u5bf9\u4e8e\u53d6\u6d88\u7684\u52a8\u4f5c\uff0cLibuv\u8ba4\u4e3a\u662f\u4efb\u52a1\u6267\u884c\u5b8c\u4e86\u3002 30. \u6240\u4ee5\u63d2\u5165\u5df2\u5b8c\u6210\u7684\u961f\u5217\uff0c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4f1a\u901a\u77e5\u7528\u6237\u8be5\u4efb\u52a1\u7684\u6267\u884c\u7ed3\u679c 31. \u662f\u53d6\u6d88\uff0c\u9519\u8bef\u7801\u662fUV_ECANCELED 32. */ 33. QUEUE_INSERT_TAIL ( & loop -> wq , & w -> wq ); 34. // \u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210 35. uv_async_send ( & loop -> wq_async ); 36. uv_mutex_unlock ( & loop -> wq_mutex ); 37. 38. return 0 ; 39. } \u5728Libuv\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u7684\u65b9\u5f0f\u5c31\u662f\u628a\u8282\u70b9\u4ece\u7ebf\u7a0b\u6c60\u5f85\u5904\u7406\u961f\u5217\u4e2d\u5220\u9664\uff0c\u7136\u540e\u6253\u4e0a\u53d6\u6d88\u7684\u6807\u8bb0\uff08w->work = uv__cancelled\uff09\uff0c\u63a5\u7740\u628a\u8be5\u8282\u70b9\u63d2\u5165\u5df2\u5b8c\u6210\u961f\u5217\uff0cLibuv\u5728\u5904\u7406\u5df2\u5b8c\u6210\u961f\u5217\u7684\u8282\u70b9\u65f6\uff0c\u5224\u65ad\u5982\u679cw->work == uv__cancelled\u5219\u5728\u6267\u884c\u7528\u6237\u56de\u8c03\u65f6\uff0c\u4f20\u5165\u9519\u8bef\u7801UV_ECANCELED\uff0c\u6211\u4eec\u770b\u5230uv__work_cancel\u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u524d\u9762\u52a0\u4e86\u4e00\u4e2astatic\uff0c\u8bf4\u660e\u8fd9\u4e2a\u51fd\u6570\u662f\u53ea\u5728\u672c\u6587\u4ef6\u5185\u4f7f\u7528\u7684\uff0cLibuv\u5bf9\u5916\u63d0\u4f9b\u7684\u53d6\u6d88\u4efb\u52a1\u7684\u63a5\u53e3\u662fuv_cancel\u3002","title":"04-\u7ebf\u7a0b\u6c60"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#_1","text":"Libuv\u662f\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u9a71\u52a8\u7684\u5f02\u6b65IO\u5e93\uff0c\u5bf9\u4e8e\u963b\u585e\u5f0f\u6216\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u5728Libuv\u7684\u4e3b\u5faa\u73af\u91cc\u6267\u884c\u7684\u8bdd\uff0c\u5c31\u4f1a\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\u6267\u884c\uff0c\u6240\u4ee5Libuv\u91cc\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u5b83\u8d1f\u8d23\u5904\u7406Libuv\u4e2d\u8017\u65f6\u6216\u8005\u5bfc\u81f4\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u6587\u4ef6IO\u3001DNS\u3001\u81ea\u5b9a\u4e49\u7684\u8017\u65f6\u4efb\u52a1\u3002\u7ebf\u7a0b\u6c60\u5728Libuv\u67b6\u6784\u4e2d\u7684\u4f4d\u7f6e\u5982\u56fe4-1\u6240\u793a\u3002 Libuv\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u7ebf\u7a0b\u6c60\u63d0\u4f9b\u7684\u63a5\u53e3\u628a\u4efb\u52a1\u63d0\u4ea4\u7ed9\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u7acb\u523b\u8fd4\u56de\u5230\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7ee7\u7eed\u6267\u884c\uff0c\u7ebf\u7a0b\u6c60\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4efb\u52a1\u961f\u5217\uff0c\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4f1a\u4e92\u65a5\u5730\u4ece\u4e2d\u6458\u4e0b\u4efb\u52a1\u8282\u70b9\u6267\u884c\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u4efb\u52a1\u5b8c\u6bd5\u540e\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u4e3b\u7ebf\u7a0b\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002","title":"\u7b2c\u56db\u7ae0 \u7ebf\u7a0b\u6c60"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#41","text":"Libuv\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u662f\u4f7f\u7528uv_async_t\u7ed3\u6784\u4f53\u5b9e\u73b0\u7684\u3002Libuv\u4f7f\u7528loop->async_handles\u961f\u5217\u8bb0\u5f55\u6240\u6709\u7684uv_async_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528loop->async_io_watcher\u4f5c\u4e3a\u6240\u6709uv_async_t\u7ed3\u6784\u4f53\u7684IO\u89c2\u5bdf\u8005\uff0c\u5373loop-> async_handles\u961f\u5217\u4e0a\u6240\u6709\u7684handle\u90fd\u662f\u5171\u4eabasync_io_watcher\u8fd9\u4e2aIO\u89c2\u5bdf\u8005\u7684\u3002\u7b2c\u4e00\u6b21\u63d2\u5165\u4e00\u4e2auv_async_t\u7ed3\u6784\u4f53\u5230async_handle\u961f\u5217\u65f6\uff0c\u4f1a\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u5982\u679c\u518d\u6b21\u6ce8\u518c\u4e00\u4e2aasync_handle\uff0c\u53ea\u4f1a\u5728loop->async_handle\u961f\u5217\u548chandle\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u4e0d\u4f1a\u65b0\u589e\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u3002\u5f53uv_async_t\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u5b50\u7ebf\u7a0b\u4f1a\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u4e3a\u53ef\u8bfb\u3002Libuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0buv_async_t\u5728Libuv\u4e2d\u7684\u4f7f\u7528\u3002","title":"4.1\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#411","text":"\u4f7f\u7528uv_async_t\u4e4b\u524d\u9996\u5148\u9700\u8981\u6267\u884cuv_async_init\u8fdb\u884c\u521d\u59cb\u5316\u3002 1. int uv_async_init ( uv_loop_t * loop , 2. uv_async_t * handle , 3. uv_async_cb async_cb ) { 4. int err ; 5. // \u7ed9Libuv\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005io 6. err = uv__async_start ( loop ); 7. if ( err ) 8. return err ; 9. // \u8bbe\u7f6e\u76f8\u5173\u5b57\u6bb5\uff0c\u7ed9Libuv\u63d2\u5165\u4e00\u4e2ahandle 10. uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_ASYNC ); 11. // \u8bbe\u7f6e\u56de\u8c03 12. handle -> async_cb = async_cb ; 13. // \u521d\u59cb\u5316\u6807\u8bb0\u5b57\u6bb5\uff0c0\u8868\u793a\u6ca1\u6709\u4efb\u52a1\u5b8c\u6210 14. handle -> pending = 0 ; 15. // \u628auv_async_t\u63d2\u5165async_handle\u961f\u5217 16. QUEUE_INSERT_TAIL ( & loop -> async_handles , & handle -> queue ); 17. uv__handle_start ( handle ); 18. return 0 ; 19. } uv_async_init\u51fd\u6570\u4e3b\u8981\u521d\u59cb\u5316\u7ed3\u6784\u4f53uv_async_t\u7684\u4e00\u4e9b\u5b57\u6bb5\uff0c\u7136\u540e\u6267\u884cQUEUE_INSERT_TAIL\u7ed9Libuv\u7684async_handles\u961f\u5217\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002\u6211\u4eec\u770b\u5230\u8fd8\u6709\u4e00\u4e2auv__async_start\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__async_start\u7684\u5b9e\u73b0\u3002 1. static int uv__async_start ( uv_loop_t * loop ) { 2. int pipefd [ 2 ]; 3. int err ; 4. // uv__async_start\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6709fd\u5219\u4e0d\u9700\u8981\u6267\u884c\u4e86 5. if ( loop -> async_io_watcher . fd != -1 ) 6. return 0 ; 7. // \u83b7\u53d6\u4e00\u4e2a\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684fd\uff08Linux\u7684eventfd\u673a\u5236\uff09 8. err = uv__async_eventfd (); 9. /* 10. \u6210\u529f\u5219\u4fdd\u5b58fd\uff0c\u5931\u8d25\u8bf4\u660e\u4e0d\u652f\u6301eventfd\uff0c 11. \u5219\u4f7f\u7528\u7ba1\u9053\u901a\u4fe1\u4f5c\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1 12. */ 13. if ( err >= 0 ) { 14. pipefd [ 0 ] = err ; 15. pipefd [ 1 ] = -1 ; 16. } 17. else if ( err == UV_ENOSYS ) { 18. // \u4e0d\u652f\u6301eventfd\u5219\u4f7f\u7528\u533f\u540d\u7ba1\u9053 19. err = uv__make_pipe ( pipefd , UV__F_NONBLOCK ); 20. # if defined ( __Linux__ ) 21. if ( err == 0 ) { 22. char buf [ 32 ]; 23. int fd ; 24. snprintf ( buf , sizeof ( buf ), \"/proc/self/fd/%d\" , pipefd [ 0 ]); // \u901a\u8fc7\u4e00\u4e2afd\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u7ba1\u9053\u7684\u8bfb\u5199\uff0c\u9ad8\u7ea7\u7528\u6cd5 25. fd = uv__open_cloexec ( buf , O_RDWR ); 26. if ( fd >= 0 ) { 27. // \u5173\u6389\u65e7\u7684 28. uv__close ( pipefd [ 0 ]); 29. uv__close ( pipefd [ 1 ]); 30. // \u8d4b\u503c\u65b0\u7684 31. pipefd [ 0 ] = fd ; 32. pipefd [ 1 ] = fd ; 33. } 34. } 35. # endif 36. } 37. // err\u5927\u4e8e\u7b49\u4e8e0\u8bf4\u660e\u62ff\u5230\u4e86\u901a\u4fe1\u7684\u8bfb\u5199\u4e24\u7aef 38. if ( err < 0 ) 39. return err ; 40. /* 41. \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005async_io_watcher\uff0c 42. \u628a\u8bfb\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230IO\u89c2\u5bdf\u8005 43. */ 44. uv__io_init ( & loop -> async_io_watcher , uv__async_io , pipefd [ 0 ]); 45. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\u91cc\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6POLLIN\uff0c\u7b49\u5f85\u53ef\u8bfb 46. uv__io_start ( loop , & loop -> async_io_watcher , POLLIN ); 47. // \u4fdd\u5b58\u5199\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26 48. loop -> async_wfd = pipefd [ 1 ]; 49. return 0 ; 50. } uv__async_start\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u65f6\u673a\u5728\u7b2c\u4e00\u6b21\u6267\u884cuv_async_init\u7684\u65f6\u5019\u3002uv__async_start\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u83b7\u53d6\u901a\u4fe1\u63cf\u8ff0\u7b26\uff08\u901a\u8fc7eventfd\u751f\u6210\u4e00\u4e2a\u901a\u4fe1\u7684fd\uff08\u5145\u5f53\u8bfb\u5199\u4e24\u7aef\uff09\u6216\u8005\u7ba1\u9053\u751f\u6210\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2afd\u8868\u793a\u8bfb\u7aef\u548c\u5199\u7aef\uff09\u3002 2 \u5c01\u88c5\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u548c\u56de\u8c03\u5230IO\u89c2\u5bdf\u8005\u7136\u540e\u8ffd\u52a0\u5230watcher_queue\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6ce8\u518c\u5230epoll\u91cc\u9762\uff0c\u5982\u679c\u6709\u4efb\u52a1\u5b8c\u6210\uff0c\u4e5f\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 3 \u4fdd\u5b58\u5199\u7aef\u63cf\u8ff0\u7b26\u3002\u4efb\u52a1\u5b8c\u6210\u65f6\u901a\u8fc7\u5199\u7aeffd\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u5230uv__async_start\u51fd\u6570\u91cc\u6709\u5f88\u591a\u83b7\u53d6\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u903b\u8f91\uff0c\u603b\u7684\u6765\u8bf4\uff0c\u662f\u4e3a\u4e86\u5b8c\u6210\u4e24\u7aef\u901a\u4fe1\u7684\u529f\u80fd\u3002\u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0cLibuv\u7ed3\u6784\u5982\u56fe4-2\u6240\u793a\u3002","title":"4.1.1 \u521d\u59cb\u5316"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#412","text":"\u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0c\u5982\u679casync\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u901a\u8fc7\u8bbe\u7f6e\u8fd9\u4e2ahandle\u7684pending\u4e3a1\u6807\u8bb0\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u518d\u5f80\u7ba1\u9053\u5199\u7aef\u5199\u5165\u6807\u8bb0\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210\u4e86\u3002 1. int uv_async_send ( uv_async_t * handle ) { 2. /* Do a cheap read first. */ 3. if ( ACCESS_ONCE ( int , handle -> pending ) != 0 ) 4. return 0 ; 5. /* 6. \u5982pending\u662f0\uff0c\u5219\u8bbe\u7f6e\u4e3a1\uff0c\u8fd4\u56de0\uff0c\u5982\u679c\u662f1\u5219\u8fd4\u56de1\uff0c 7. \u6240\u4ee5\u5982\u679c\u591a\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u662f\u4f1a\u88ab\u5408\u5e76\u7684 8. */ 9. if ( cmpxchgi ( & handle -> pending , 0 , 1 ) == 0 ) 10. uv__async_send ( handle -> loop ); 11. return 0 ; 12. } 13. 14. static void uv__async_send ( uv_loop_t * loop ) { 15. const void * buf ; 16. ssize_t len ; 17. int fd ; 18. int r ; 19. 20. buf = \"\" ; 21. len = 1 ; 22. fd = loop -> async_wfd ; 23. 24. # if defined ( __Linux__ ) 25. // \u8bf4\u660e\u7528\u7684\u662feventfd\u800c\u4e0d\u662f\u7ba1\u9053,eventfd\u65f6\u8bfb\u5199\u4e24\u7aef\u5bf9\u5e94\u540c\u4e00\u4e2afd 26. if ( fd == -1 ) { 27. static const uint64_t val = 1 ; 28. buf = & val ; 29. len = sizeof ( val ); 30. // \u89c1uv__async_start 31. fd = loop -> async_io_watcher . fd ; /* eventfd */ 32. } 33. # endif 34. // \u901a\u77e5\u8bfb\u7aef 35. do 36. r = write ( fd , buf , len ); 37. while ( r == -1 && errno == EINTR ); 38. 39. if ( r == len ) 40. return ; 41. 42. if ( r == -1 ) 43. if ( errno == EAGAIN || errno == EWOULDBLOCK ) 44. return ; 45. 46. abort (); 47. } uv_async_send\u9996\u5148\u62ff\u5230\u5199\u7aef\u5bf9\u5e94\u7684fd\uff0c\u7136\u540e\u8c03\u7528write\u51fd\u6570\uff0c\u6b64\u65f6\uff0c\u5f80\u7ba1\u9053\u7684\u5199\u7aef\u5199\u5165\u6570\u636e\uff0c\u6807\u8bb0\u6709\u4efb\u52a1\u5b8c\u6210\u3002\u6709\u5199\u5219\u5fc5\u7136\u6709\u8bfb\u3002\u8bfb\u7684\u903b\u8f91\u662f\u5728uv__io_poll\u4e2d\u5b9e\u73b0\u7684\u3002uv__io_poll\u51fd\u6570\u5373Libuv\u4e2dPoll IO\u9636\u6bb5\u6267\u884c\u7684\u51fd\u6570\u3002\u5728uv__io_poll\u4e2d\u4f1a\u53d1\u73b0\u7ba1\u9053\u53ef\u8bfb\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03uv__async_io\u3002","title":"4.1.2 \u901a\u77e5\u4e3b\u7ebf\u7a0b"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#413","text":"1. static void uv__async_io ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. char buf [ 1024 ]; 5. ssize_t r ; 6. QUEUE queue ; 7. QUEUE * q ; 8. uv_async_t * h ; 9. 10. for (;;) { 11. // \u6d88\u8d39\u6240\u6709\u7684\u6570\u636e 12. r = read ( w -> fd , buf , sizeof ( buf )); 13. // \u6570\u636e\u5927\u5c0f\u5927\u4e8ebuf\u957f\u5ea6\uff081024\uff09\uff0c\u5219\u7ee7\u7eed\u6d88\u8d39 14. if ( r == sizeof ( buf )) 15. continue ; 16. // \u6210\u529f\u6d88\u8d39\u5b8c\u6bd5\uff0c\u8df3\u51fa\u6d88\u8d39\u7684\u903b\u8f91 17. if ( r != -1 ) 18. break ; 19. // \u8bfb\u7e41\u5fd9 20. if ( errno == EAGAIN || errno == EWOULDBLOCK ) 21. break ; 22. // \u8bfb\u88ab\u4e2d\u65ad\uff0c\u7ee7\u7eed\u8bfb 23. if ( errno == EINTR ) 24. continue ; 25. abort (); 26. } 27. // \u628aasync_handles\u961f\u5217\u91cc\u7684\u6240\u6709\u8282\u70b9\u90fd\u79fb\u5230queue\u53d8\u91cf\u4e2d 28. QUEUE_MOVE ( & loop -> async_handles , & queue ); 29. while ( ! QUEUE_EMPTY ( & queue )) { 30. // \u9010\u4e2a\u53d6\u51fa\u8282\u70b9 31. q = QUEUE_HEAD ( & queue ); 32. // \u6839\u636e\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 33. h = QUEUE_DATA ( q , uv_async_t , queue ); 34. // \u4ece\u961f\u5217\u4e2d\u79fb\u9664\u8be5\u8282\u70b9 35. QUEUE_REMOVE ( q ); 36. // \u91cd\u65b0\u63d2\u5165async_handles\u961f\u5217\uff0c\u7b49\u5f85\u4e0b\u6b21\u4e8b\u4ef6 37. QUEUE_INSERT_TAIL ( & loop -> async_handles , q ); 38. /* 39. \u5c06\u7b2c\u4e00\u4e2a\u53c2\u6570\u548c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u7b49\uff0c 40. \u5219\u5c06\u7b2c\u4e09\u53c2\u6570\u5199\u5165\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\uff0c 41. \u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\u3002 42. */ 43. /* 44. \u5224\u65ad\u89e6\u53d1\u4e86\u54ea\u4e9basync\u3002pending\u5728uv_async_send\u91cc\u8bbe\u7f6e\u62101\uff0c 45. \u5982\u679cpending\u7b49\u4e8e1\uff0c\u5219\u6e050\uff0c\u8fd4\u56de1.\u5982\u679cpending\u7b49\u4e8e0\uff0c\u5219\u8fd4\u56de0 46. */ 47. if ( cmpxchgi ( & h -> pending , 1 , 0 ) == 0 ) 48. continue ; 49. 50. if ( h -> async_cb == NULL ) 51. continue ; 52. // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 53. h -> async_cb ( h ); 54. } 55. } uv__async_io\u4f1a\u904d\u5386async_handles\u961f\u5217\uff0cpending\u7b49\u4e8e1\u7684\u8bdd\u8bf4\u660e\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u5e76\u6e05\u9664\u6807\u8bb0\u4f4d\u3002","title":"4.1.3 \u4e3b\u7ebf\u7a0b\u5904\u7406\u56de\u8c03"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#42","text":"\u4e86\u89e3\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u540e\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\u3002","title":"4.2 \u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#421","text":"\u7ebf\u7a0b\u6c60\u662f\u61d2\u521d\u59cb\u5316\u7684\uff0cNode.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709\u521b\u5efa\u5b50\u7ebf\u7a0b\uff0c\u800c\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7ed9\u7ebf\u7a0b\u6c60\u65f6\uff0c\u7ebf\u7a0b\u6c60\u624d\u5f00\u59cb\u521d\u59cb\u5316\u3002\u6211\u4eec\u5148\u770b\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u903b\u8f91\uff0c\u7136\u540e\u518d\u770b\u5b83\u7684\u4f7f\u7528\u3002 1. static void init_threads ( void ) { 2. unsigned int i ; 3. const char * val ; 4. // \u9ed8\u8ba4\u7ebf\u7a0b\u65704\u4e2a\uff0cstatic uv_thread_t default_threads[4]; 5. nthreads = ARRAY_SIZE ( default_threads ); 6. // \u5224\u65ad\u7528\u6237\u662f\u5426\u5728\u73af\u5883\u53d8\u91cf\u4e2d\u8bbe\u7f6e\u4e86\u7ebf\u7a0b\u6570\uff0c\u662f\u7684\u8bdd\u53d6\u7528\u6237\u5b9a\u4e49\u7684 7. val = getenv ( \"UV_THREADPOOL_SIZE\" ); 8. if ( val != NULL ) 9. nthreads = atoi ( val ); 10. if ( nthreads == 0 ) 11. nthreads = 1 ; 12. // #define MAX_THREADPOOL_SIZE 128\u6700\u591a128\u4e2a\u7ebf\u7a0b 13. if ( nthreads > MAX_THREADPOOL_SIZE ) 14. nthreads = MAX_THREADPOOL_SIZE ; 15. 16. threads = default_threads ; 17. // \u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\uff0c\u91cd\u65b0\u5206\u914d\u5185\u5b58 18. if ( nthreads > ARRAY_SIZE ( default_threads )) { 19. threads = uv__malloc ( nthreads * sizeof ( threads [ 0 ])); 20. } 21. // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\uff0c\u7528\u4e8e\u6709\u4efb\u52a1\u65f6\u5524\u9192\u5b50\u7ebf\u7a0b\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u6302\u8d77\u5b50\u7ebf\u7a0b 22. if ( uv_cond_init ( & cond )) 23. abort (); 24. // \u521d\u59cb\u5316\u4e92\u65a5\u53d8\u91cf\uff0c\u7528\u4e8e\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 25. if ( uv_mutex_init ( & mutex )) 26. abort (); 27. 28. // \u521d\u59cb\u5316\u4e09\u4e2a\u961f\u5217 29. QUEUE_INIT ( & wq ); 30. QUEUE_INIT ( & slow_io_pending_wq ); 31. QUEUE_INIT ( & run_slow_work_message ); 32. 33. // \u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u5de5\u4f5c\u51fd\u6570\u4e3aworker\uff0csem\u4e3aworker\u5165\u53c2 34. for ( i = 0 ; i < nthreads ; i ++ ) 35. if ( uv_thread_create ( threads + i , worker , & sem )) 36. abort (); 37. } \u7ebf\u7a0b\u6c60\u521d\u59cb\u5316\u65f6\uff0c\u4f1a\u6839\u636e\u914d\u7f6e\u7684\u5b50\u7ebf\u7a0b\u6570\u521b\u5efa\u5bf9\u5e94\u6570\u91cf\u7684\u7ebf\u7a0b\u3002\u9ed8\u8ba4\u662f4\u4e2a\uff0c\u6700\u5927128\u4e2a\u5b50\u7ebf\u7a0b\uff08\u4e0d\u540c\u7248\u672c\u7684Libuv\u53ef\u80fd\u4f1a\u4e0d\u4e00\u6837\uff09\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u7684\u5927\u5c0f\u3002\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u63a5\u7740\u5728\u6bcf\u4e2a\u7ebf\u7a0b\u91cc\u6267\u884cworker\u51fd\u6570\u5904\u7406\u4efb\u52a1\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790worker\u7684\u903b\u8f91\u3002","title":"4.2.1 \u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#422","text":"\u4e86\u89e3\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e4b\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1 1. // \u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1 2. void uv__work_submit ( uv_loop_t * loop , 3. struct uv__work * w , 4. enum uv__work_kind kind , 5. void ( * work )( struct uv__work * w ), 6. void ( * done )( struct uv__work * w , int status )){ 7. /* 8. \u4fdd\u8bc1\u5df2\u7ecf\u521d\u59cb\u5316\u7ebf\u7a0b\uff0c\u5e76\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u7ebf\u7a0b\u6c60\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a 9. \u4efb\u52a1\u7684\u65f6\u5019\u624d\u88ab\u521d\u59cb\u5316\uff0cinit_once -> init_threads 10. */ 11. uv_once ( & once , init_once ); 12. w -> loop = loop ; 13. w -> work = work ; 14. w -> done = done ; 15. post ( & w -> wq , kind ); 16. } \u8fd9\u91cc\u628a\u4e1a\u52a1\u76f8\u5173\u7684\u51fd\u6570\u548c\u4efb\u52a1\u5b8c\u6210\u540e\u7684\u56de\u8c03\u51fd\u6570\u5c01\u88c5\u5230uv__work\u7ed3\u6784\u4f53\u4e2d\u3002uv__work\u7ed3\u6784\u5b9a\u4e49\u5982\u4e0b\u3002 1. struct uv__work { 2. void ( * work )( struct uv__work * w ); 3. void ( * done )( struct uv__work * w , int status ); 4. struct uv_loop_s * loop ; 5. void * wq [ 2 ]; 6. }; \u7136\u540e\u8c03\u8c03\u7528post\u51fd\u6570\u5f80\u7ebf\u7a0b\u6c60\u7684\u961f\u5217\u4e2d\u52a0\u5165\u4e00\u4e2a\u65b0\u7684\u4efb\u52a1\u3002Libuv\u628a\u4efb\u52a1\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff0c\u6162IO\uff08DNS\u89e3\u6790\uff09\u3001\u5febIO\uff08\u6587\u4ef6\u64cd\u4f5c\uff09\u3001CPU\u5bc6\u96c6\u578b\u7b49\uff0ckind\u5c31\u662f\u8bf4\u660e\u4efb\u52a1\u7684\u7c7b\u578b\u7684\u3002\u6211\u4eec\u63a5\u7740\u770bpost\u51fd\u6570\u3002 1. static void post ( QUEUE * q , enum uv__work_kind kind ) { 2. // \u52a0\u9501\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u961f\u5217\u662f\u7ebf\u7a0b\u6c60\u5171\u4eab\u7684 3. uv_mutex_lock ( & mutex ); 4. // \u7c7b\u578b\u662f\u6162IO 5. if ( kind == UV__WORK_SLOW_IO ) { 6. /* 7. \u63d2\u5165\u6162IO\u5bf9\u5e94\u7684\u961f\u5217\uff0cLibuv\u8fd9\u4e2a\u7248\u672c\u628a\u4efb\u52a1\u5206\u4e3a\u51e0\u79cd\u7c7b\u578b\uff0c 8. \u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u662f\u5f80\u4efb\u52a1\u961f\u5217\u91cc\u9762\u63d2\u5165\u4e00\u4e2a\u7279\u6b8a\u7684\u8282\u70b9 9. run_slow_work_message\uff0c\u7136\u540e\u7528slow_io_pending_wq\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6162IO 10. \u4efb\u52a1\u7684\u961f\u5217\uff0c\u5f53\u5904\u7406\u5230run_slow_work_message\u8fd9\u4e2a\u8282\u70b9\u7684\u65f6\u5019\uff0c 11. Libuv\u4f1a\u4eceslow_io_pending_wq\u961f\u5217\u91cc\u9010\u4e2a\u53d6\u51fa\u4efb\u52a1\u8282\u70b9\u6765\u6267\u884c\u3002 12. */ 13. QUEUE_INSERT_TAIL ( & slow_io_pending_wq , q ); 14. /* 15. \u6709\u6162IO\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u9700\u8981\u7ed9\u4e3b\u961f\u5217wq\u63d2\u5165\u4e00\u4e2a\u6d88\u606f\u8282\u70b9 16. run_slow_work_message,\u8bf4\u660e\u6709\u6162IO\u4efb\u52a1\uff0c\u6240\u4ee5\u5982\u679c 17. run_slow_work_message\u662f\u7a7a\uff0c\u8bf4\u660e\u8fd8\u6ca1\u6709\u63d2\u5165\u4e3b\u961f\u5217\u3002\u9700\u8981\u8fdb\u884c 18. q = &run_slow_work_message;\u8d4b\u503c\uff0c\u7136\u540e\u628a 19. run_slow_work_message\u63d2\u5165\u4e3b\u961f\u5217\u3002\u5982\u679crun_slow_work_message 20. \u975e\u7a7a\uff0c\u8bf4\u660e\u5df2\u7ecf\u63d2\u5165\u7ebf\u7a0b\u6c60\u7684\u4efb\u52a1\u961f\u5217\u4e86\u3002\u89e3\u9501\u7136\u540e\u76f4\u63a5\u8fd4\u56de\u3002 21. */ 22. if ( ! QUEUE_EMPTY ( & run_slow_work_message )) { 23. uv_mutex_unlock ( & mutex ); 24. return ; 25. } 26. // \u8bf4\u660erun_slow_work_message\u8fd8\u6ca1\u6709\u63d2\u5165\u961f\u5217\uff0c\u51c6\u5907\u63d2\u5165\u961f\u5217 27. q = & run_slow_work_message ; 28. } 29. // \u628a\u8282\u70b9\u63d2\u5165\u4e3b\u961f\u5217\uff0c\u53ef\u80fd\u662f\u6162IO\u6d88\u606f\u8282\u70b9\u6216\u8005\u4e00\u822c\u4efb\u52a1 30. QUEUE_INSERT_TAIL ( & wq , q ); 31. /* 32. \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u5982\u679c\u5927\u5bb6\u90fd\u5728\u5fd9\uff0c 33. \u5219\u7b49\u5230\u5b83\u5fd9\u5b8c\u540e\u5c31\u4f1a\u91cd\u65b0\u5224\u65ad\u662f\u5426\u8fd8\u6709\u65b0\u4efb\u52a1 34. */ 35. if ( idle_threads > 0 ) 36. uv_cond_signal ( & cond ); 37. // \u64cd\u4f5c\u5b8c\u961f\u5217\uff0c\u89e3\u9501 38. uv_mutex_unlock ( & mutex ); 39. } \u8fd9\u5c31\u662fLibuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u751f\u4ea7\u8005\u903b\u8f91\u3002\u4efb\u52a1\u961f\u5217\u7684\u67b6\u6784\u5982\u56fe4-3\u6240\u793a\u3002 \u9664\u4e86\u4e0a\u9762\u63d0\u5230\u7684\uff0cLibuv\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u79cd\u751f\u4ea7\u4efb\u52a1\u7684\u65b9\u5f0f\uff0c\u5373uv_queue_work\u51fd\u6570\uff0c\u5b83\u53ea\u63d0\u4ea4CPU\u5bc6\u96c6\u578b\u7684\u4efb\u52a1\uff08\u5728Node.js\u7684crypto\u6a21\u5757\u4e2d\u4f7f\u7528\uff09\u3002\u4e0b\u9762\u6211\u4eec\u770buv_queue_work\u7684\u5b9e\u73b0\u3002 1. int uv_queue_work ( uv_loop_t * loop , 2. uv_work_t * req , 3. uv_work_cb work_cb , 4. uv_after_work_cb after_work_cb ) { 5. if ( work_cb == NULL ) 6. return UV_EINVAL ; 7. 8. uv__req_init ( loop , req , UV_WORK ); 9. req -> loop = loop ; 10. req -> work_cb = work_cb ; 11. req -> after_work_cb = after_work_cb ; 12. uv__work_submit ( loop , 13. & req -> work_req , 14. UV__WORK_CPU , 15. uv__queue_work , 16. uv__queue_done ); 17. return 0 ; 18. } uv_queue_work\u51fd\u6570\u5176\u5b9e\u4e5f\u6ca1\u6709\u592a\u591a\u7684\u903b\u8f91\uff0c\u5b83\u4fdd\u5b58\u7528\u6237\u7684\u5de5\u4f5c\u51fd\u6570\u548c\u56de\u8c03\u5230request\u4e2d\u3002\u7136\u540e\u628auv__queue_work\u548cuv__queue_done\u5c01\u88c5\u5230uv__work\u4e2d\uff0c\u63a5\u7740\u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60\u4e2d\u3002\u6240\u4ee5\u5f53\u8fd9\u4e2a\u4efb\u52a1\u88ab\u6267\u884c\u7684\u65f6\u5019\u3002\u5b83\u4f1a\u6267\u884c\u5de5\u4f5c\u51fd\u6570uv__queue_work\u3002 1. static void uv__queue_work ( struct uv__work * w ) { 2. // \u901a\u8fc7\u7ed3\u6784\u4f53\u67d0\u5b57\u6bb5\u62ff\u5230\u7ed3\u6784\u4f53\u5730\u5740 3. uv_work_t * req = container_of ( w , uv_work_t , work_req ); 4. req -> work_cb ( req ); 5. } \u6211\u4eec\u770b\u5230uv__queue_work\u5176\u5b9e\u5c31\u662f\u5bf9\u7528\u6237\u5b9a\u4e49\u7684\u4efb\u52a1\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u731c\u5230\uff0cuv__queue_done\u4e5f\u53ea\u662f\u5bf9\u7528\u6237\u56de\u8c03\u7684\u7b80\u5355\u5c01\u88c5\uff0c\u5373\u5b83\u4f1a\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002","title":"4.2.2 \u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#423","text":"\u6211\u4eec\u63d0\u4ea4\u4e86\u4efb\u52a1\u540e\uff0c\u7ebf\u7a0b\u81ea\u7136\u8981\u5904\u7406\uff0c\u521d\u59cb\u5316\u7ebf\u7a0b\u6c60\u7684\u65f6\u5019\u6211\u4eec\u5206\u6790\u8fc7\uff0cworker\u51fd\u6570\u662f\u8d1f\u8d23\u5904\u7406\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0bworker\u51fd\u6570\u7684\u903b\u8f91\u3002 1. static void worker ( void * arg ) { 2. struct uv__work * w ; 3. QUEUE * q ; 4. int is_slow_work ; 5. // \u7ebf\u7a0b\u542f\u52a8\u6210\u529f 6. uv_sem_post (( uv_sem_t * ) arg ); 7. arg = NULL ; 8. // \u52a0\u9501\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 9. uv_mutex_lock ( & mutex ); 10. for (;;) { 11. /* 12. 1 \u961f\u5217\u4e3a\u7a7a 13. 2 \u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u4f46\u662f\u961f\u5217\u4e2d\u53ea\u6709\u6162IO\u4efb\u52a1\u4e14\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4efb\u52a1 14. \u4e2a\u6570\u8fbe\u5230\u9608\u503c\u5219\u7a7a\u95f2\u7ebf\u7a0b\u52a0\u4e00\uff0c\u9632\u6b62\u6162IO\u5360\u7528\u8fc7\u591a\u7ebf\u7a0b\uff0c\u5bfc\u81f4 15. \u5176\u5b83\u5feb\u7684\u4efb\u52a1\u65e0\u6cd5\u5f97\u5230\u6267\u884c 16. */ 17. while ( QUEUE_EMPTY ( & wq ) || 18. ( QUEUE_HEAD ( & wq ) == & run_slow_work_message && 19. QUEUE_NEXT ( & run_slow_work_message ) == & wq && 20. slow_io_work_running >= slow_work_thread_threshold ())) { 21. idle_threads += 1 ; 22. // \u963b\u585e\uff0c\u7b49\u5f85\u5524\u9192 23. uv_cond_wait ( & cond , & mutex ); 24. // \u88ab\u5524\u9192\uff0c\u5f00\u59cb\u5e72\u6d3b\uff0c\u7a7a\u95f2\u7ebf\u7a0b\u6570\u51cf\u4e00 25. idle_threads -= 1 ; 26. } 27. // \u53d6\u51fa\u5934\u7ed3\u70b9\uff0c\u5934\u6307\u70b9\u53ef\u80fd\u662f\u9000\u51fa\u6d88\u606f\u3001\u6162IO\uff0c\u4e00\u822c\u8bf7\u6c42 28. q = QUEUE_HEAD ( & wq ); 29. // \u5982\u679c\u5934\u7ed3\u70b9\u662f\u9000\u51fa\u6d88\u606f\uff0c\u5219\u7ed3\u675f\u7ebf\u7a0b 30. if ( q == & exit_message ) { 31. /* 32. \u5524\u9192\u5176\u5b83\u56e0\u4e3a\u6ca1\u6709\u4efb\u52a1\u6b63\u963b\u585e\u7b49\u5f85\u4efb\u52a1\u7684\u7ebf\u7a0b\uff0c 33. \u544a\u8bc9\u5b83\u4eec\u51c6\u5907\u9000\u51fa 34. */ 35. uv_cond_signal ( & cond ); 36. uv_mutex_unlock ( & mutex ); 37. break ; 38. } 39. // \u79fb\u9664\u8282\u70b9 40. QUEUE_REMOVE ( q ); 41. // \u91cd\u7f6e\u524d\u540e\u6307\u9488 42. QUEUE_INIT ( q ); 43. is_slow_work = 0 ; 44. /* 45. \u5982\u679c\u5f53\u524d\u8282\u70b9\u7b49\u4e8e\u6162IO\u8282\u70b9\uff0c\u4e0a\u9762\u7684while\u53ea\u5224\u65ad\u4e86\u662f\u4e0d\u662f\u53ea\u6709\u6162 46. IO\u4efb\u52a1\u4e14\u8fbe\u5230\u9608\u503c\uff0c\u8fd9\u91cc\u662f\u4efb\u52a1\u961f\u5217\u91cc\u80af\u5b9a\u6709\u975e\u6162IO\u4efb\u52a1\uff0c\u53ef\u80fd\u6709 47. \u6162IO\uff0c\u5982\u679c\u6709\u6162IO\u5e76\u4e14\u6b63\u5728\u6267\u884c\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5219\u5148\u4e0d\u5904\u7406\u8be5\u6162 48. IO\u4efb\u52a1\uff0c\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u8fd8\u6709\u975e\u6162IO\u4efb\u52a1\u53ef\u6267\u884c\u3002 49. */ 50. if ( q == & run_slow_work_message ) { 51. // \u8fbe\u5230\u9608\u503c\uff0c\u8be5\u8282\u70b9\u91cd\u65b0\u5165\u961f\uff0c\u56e0\u4e3a\u521a\u624d\u88ab\u5220\u9664\u4e86 52. if ( slow_io_work_running >= slow_work_thread_threshold ()) { 53. QUEUE_INSERT_TAIL ( & wq , q ); 54. continue ; 55. } 56. /* 57. \u6ca1\u6709\u6162IO\u4efb\u52a1\u5219\u7ee7\u7eed\uff0c\u8fd9\u65f6\u5019run_slow_work_message 58. \u5df2\u7ecf\u4ece\u961f\u5217\u4e2d\u88ab\u5220\u9664\uff0c\u4e0b\u6b21\u6709\u6162IO\u7684\u65f6\u5019\u91cd\u65b0\u5165\u961f 59. */ 60. if ( QUEUE_EMPTY ( & slow_io_pending_wq )) 61. continue ; 62. // \u6709\u6162IO\uff0c\u5f00\u59cb\u5904\u7406\u6162IO\u4efb\u52a1 63. is_slow_work = 1 ; 64. /* 65. \u6b63\u5728\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u4e2a\u6570\u7d2f\u52a0\uff0c\u7528\u4e8e\u5176\u5b83\u7ebf\u7a0b\u5224\u65ad\u6162IO\u4efb\u52a1\u4e2a 66. \u6570\u662f\u5426\u8fbe\u5230\u9608\u503c, slow_io_work_running\u662f\u591a\u4e2a\u7ebf\u7a0b\u5171\u4eab\u7684\u53d8\u91cf 67. */ 68. slow_io_work_running ++ ; 69. // \u6458\u4e0b\u4e00\u4e2a\u6162IO\u4efb\u52a1 70. q = QUEUE_HEAD ( & slow_io_pending_wq ); 71. // \u4ece\u6162IO\u961f\u5217\u79fb\u9664 72. QUEUE_REMOVE ( q ); 73. QUEUE_INIT ( q ); 74. /* 75. \u53d6\u51fa\u4e00\u4e2a\u4efb\u52a1\u540e\uff0c\u5982\u679c\u8fd8\u6709\u6162IO\u4efb\u52a1\u5219\u628a\u6162IO\u6807\u8bb0\u8282\u70b9\u91cd\u65b0\u5165 76. \u961f\uff0c\u8868\u793a\u8fd8\u6709\u6162IO\u4efb\u52a1\uff0c\u56e0\u4e3a\u4e0a\u9762\u628a\u8be5\u6807\u8bb0\u8282\u70b9\u51fa\u961f\u4e86 77. */ 78. if ( ! QUEUE_EMPTY ( & slow_io_pending_wq )) { 79. QUEUE_INSERT_TAIL ( & wq , & run_slow_work_message ); 80. // \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u56e0\u4e3a\u8fd8\u6709\u4efb\u52a1\u5904\u7406 81. if ( idle_threads > 0 ) 82. uv_cond_signal ( & cond ); 83. } 84. } 85. // \u4e0d\u9700\u8981\u64cd\u4f5c\u961f\u5217\u4e86\uff0c\u5c3d\u5feb\u91ca\u653e\u9501 86. uv_mutex_unlock ( & mutex ); 87. // q\u662f\u6162IO\u6216\u8005\u4e00\u822c\u4efb\u52a1 88. w = QUEUE_DATA ( q , struct uv__work , wq ); 89. // \u6267\u884c\u4e1a\u52a1\u7684\u4efb\u52a1\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u4e00\u822c\u4f1a\u963b\u585e 90. w -> work ( w ); 91. // \u51c6\u5907\u64cd\u4f5cloop\u7684\u4efb\u52a1\u5b8c\u6210\u961f\u5217\uff0c\u52a0\u9501 92. uv_mutex_lock ( & w -> loop -> wq_mutex ); 93. // \u7f6e\u7a7a\u8bf4\u660e\u6267\u884c\u5b8c\u4e86\uff0c\u89c1cancel\u903b\u8f91 94. w -> work = NULL ; 95. /* 96. \u6267\u884c\u5b8c\u4efb\u52a1,\u63d2\u5165\u5230loop\u7684wq\u961f\u5217,\u5728uv__work_done\u7684\u65f6\u5019\u4f1a 97. \u6267\u884c\u8be5\u961f\u5217\u7684\u8282\u70b9 98. */ 99. QUEUE_INSERT_TAIL ( & w -> loop -> wq , & w -> wq ); 100. // \u901a\u77e5loop\u7684wq_async\u8282\u70b9 101. uv_async_send ( & w -> loop -> wq_async ); 102. uv_mutex_unlock ( & w -> loop -> wq_mutex ); 103. // \u4e3a\u4e0b\u4e00\u8f6e\u64cd\u4f5c\u4efb\u52a1\u961f\u5217\u52a0\u9501 104. uv_mutex_lock ( & mutex ); 105. /* 106. \u6267\u884c\u5b8c\u6162IO\u4efb\u52a1\uff0c\u8bb0\u5f55\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4e2a\u6570\u53d8\u91cf\u51cf1\uff0c 107. \u4e0a\u9762\u52a0\u9501\u4fdd\u8bc1\u4e86\u4e92\u65a5\u8bbf\u95ee\u8fd9\u4e2a\u53d8\u91cf 108. */ 109. if ( is_slow_work ) { 110. slow_io_work_running -- ; 111. } 112. } 113. } \u6211\u4eec\u770b\u5230\u6d88\u8d39\u8005\u7684\u903b\u8f91\u4f3c\u4e4e\u6bd4\u8f83\u590d\u6742\uff0c\u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u9650\u5236\u4e86\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u7ebf\u7a0b\u6570\uff0c\u907f\u514d\u8017\u65f6\u6bd4\u8f83\u5c11\u7684\u4efb\u52a1\u5f97\u4e0d\u5230\u5904\u7406\u3002\u5176\u4f59\u7684\u903b\u8f91\u548c\u4e00\u822c\u7684\u7ebf\u7a0b\u6c60\u7c7b\u4f3c\uff0c\u5c31\u662f\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u53d6\u51fa\u8282\u70b9\u6267\u884c\uff0c\u6267\u884c\u5b8c\u540e\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002\u7ed3\u6784\u5982\u56fe4-4\u6240\u793a\u3002","title":"4.2.3 \u5904\u7406\u4efb\u52a1"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#424","text":"\u7ebf\u7a0b\u6267\u884c\u5b8c\u4efb\u52a1\u540e\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u800c\u662f\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u7531\u4e3b\u7ebf\u7a0b\u7edf\u4e00\u5904\u7406\uff0c\u8fd9\u662fNode.js\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684\u8981\u6c42\uff0c\u4e5f\u907f\u514d\u4e86\u591a\u7ebf\u7a0b\u5e26\u6765\u7684\u590d\u6742\u95ee\u9898\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u5757\u7684\u903b\u8f91\u3002\u4e00\u5207\u8981\u4eceLibuv\u7684\u521d\u59cb\u5316\u5f00\u59cb uv_default_loop (); -> uv_loop_init (); -> uv_async_init ( loop , & loop -> wq_async , uv__work_done ); \u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\uff0cwq_async\u662f\u7528\u4e8e\u7ebf\u7a0b\u6c60\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684async handle\uff0c\u5b83\u5bf9\u5e94\u7684\u56de\u8c03\u662fuv__work_done\u3002\u6240\u4ee5\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u6c60\u7684\u7ebf\u7a0b\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u901a\u8fc7uv_async_send(&w->loop->wq_async)\u8bbe\u7f6eloop->wq_async.pending = 1\uff0c\u7136\u540e\u901a\u77e5IO\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u8be5handle\u5bf9\u5e94\u7684\u56de\u8c03uv__work_done\u51fd\u6570\u3002\u90a3\u4e48\u6211\u4eec\u5c31\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u3002 1. void uv__work_done ( uv_async_t * handle ) { 2. struct uv__work * w ; 3. uv_loop_t * loop ; 4. QUEUE * q ; 5. QUEUE wq ; 6. int err ; 7. // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 8. loop = container_of ( handle , uv_loop_t , wq_async ); 9. // \u51c6\u5907\u5904\u7406\u961f\u5217\uff0c\u52a0\u9501 10. uv_mutex_lock ( & loop -> wq_mutex ); 11. /* 12. loop->wq\u662f\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u961f\u5217\u3002\u628aloop->wq\u961f\u5217\u7684\u8282\u70b9\u5168\u90e8\u79fb\u5230 13. wp\u53d8\u91cf\u4e2d\uff0c\u8fd9\u6837\u4e00\u6765\u53ef\u4ee5\u5c3d\u5feb\u91ca\u653e\u9501 14. */ 15. QUEUE_MOVE ( & loop -> wq , & wq ); 16. // \u4e0d\u9700\u8981\u4f7f\u7528\u4e86\uff0c\u89e3\u9501 17. uv_mutex_unlock ( & loop -> wq_mutex ); 18. // wq\u961f\u5217\u7684\u8282\u70b9\u6765\u81ea\u5b50\u7ebf\u7a0b\u63d2\u5165 19. while ( ! QUEUE_EMPTY ( & wq )) { 20. q = QUEUE_HEAD ( & wq ); 21. QUEUE_REMOVE ( q ); 22. w = container_of ( q , struct uv__work , wq ); 23. // \u7b49\u4e8euv__canceled\u8bf4\u660e\u8fd9\u4e2a\u4efb\u52a1\u88ab\u53d6\u6d88\u4e86 24. err = ( w -> work == uv__cancelled ) ? UV_ECANCELED : 0 ; 25. // \u6267\u884c\u56de\u8c03 26. w -> done ( w , err ); 27. } 28. } \u8be5\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9010\u4e2a\u5904\u7406\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u8282\u70b9\uff0c\u6267\u884c\u56de\u8c03\uff0c\u5728Node.js\u4e2d\uff0c\u8fd9\u91cc\u7684\u56de\u8c03\u662fC++\u5c42\uff0c\u7136\u540e\u518d\u5230JS\u5c42\u3002\u7ed3\u6784\u56fe\u5982\u56fe4-5\u6240\u793a\u3002","title":"4.2.4 \u901a\u77e5\u4e3b\u7ebf\u7a0b"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#425","text":"\u7ebf\u7a0b\u6c60\u7684\u8bbe\u8ba1\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u662f\u4e00\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u80fd\u529b\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u91cc\u6267\u884c\u7684\u90fd\u662f\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u5f15\u8d77\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u80fd\u53ca\u65f6\u53d6\u6d88\u4e00\u4e2a\u4efb\u52a1\uff0c\u5c06\u4f1a\u51cf\u8f7b\u5f88\u591a\u6ca1\u5fc5\u8981\u7684\u5904\u7406\u3002\u4e0d\u8fc7Libuv\u5b9e\u73b0\u4e2d\uff0c\u53ea\u6709\u5f53\u4efb\u52a1\u8fd8\u5728\u7b49\u5f85\u961f\u5217\u4e2d\u624d\u80fd\u88ab\u53d6\u6d88\uff0c\u5982\u679c\u4e00\u4e2a\u4efb\u52a1\u6b63\u5728\u88ab\u7ebf\u7a0b\u5904\u7406\uff0c\u5219\u65e0\u6cd5\u53d6\u6d88\u4e86\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bLibuv\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u53d6\u6d88\u4efb\u52a1\u7684\u3002Libuv\u63d0\u4f9b\u4e86uv__work_cancel\u51fd\u6570\u652f\u6301\u7528\u6237\u53d6\u6d88\u63d0\u4ea4\u7684\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u903b\u8f91\u3002 1. static int uv__work_cancel ( uv_loop_t * loop , uv_req_t * req , struct uv__work * w ) { 2. int cancelled ; 3. // \u52a0\u9501\uff0c\u4e3a\u4e86\u628a\u8282\u70b9\u79fb\u51fa\u961f\u5217 4. uv_mutex_lock ( & mutex ); 5. // \u52a0\u9501\uff0c\u4e3a\u4e86\u5224\u65adw->wq\u662f\u5426\u4e3a\u7a7a 6. uv_mutex_lock ( & w -> loop -> wq_mutex ); 7. /* 8. cancelled\u4e3atrue\u8bf4\u660e\u4efb\u52a1\u8fd8\u5728\u7ebf\u7a0b\u6c60\u961f\u5217\u7b49\u5f85\u5904\u7406 9. 1 \u5904\u7406\u5b8c\uff0cw->work == NULL 10. 2 \u5904\u7406\u4e2d\uff0cQUEUE_EMPTY(&w->wq)\u4e3atrue\uff0c\u56e0 11. \u4e3aworker\u5728\u6458\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u91cd\u7f6eprev\u548cnext\u6307\u9488 12. 3 \u672a\u5904\u7406\uff0c!QUEUE_EMPTY(&w->wq)\u662ftrue \u4e14w->work != NULL 13. */ 14. cancelled = ! QUEUE_EMPTY ( & w -> wq ) && w -> work != NULL ; 15. // \u4ece\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9 16. if ( cancelled ) 17. QUEUE_REMOVE ( & w -> wq ); 18. 19. uv_mutex_unlock ( & w -> loop -> wq_mutex ); 20. uv_mutex_unlock ( & mutex ); 21. // \u6b63\u5728\u6267\u884c\u6216\u8005\u5df2\u7ecf\u6267\u884c\u5b8c\u4e86\uff0c\u5219\u4e0d\u80fd\u53d6\u6d88 22. if ( ! cancelled ) 23. return UV_EBUSY ; 24. // \u6253\u53d6\u6d88\u6807\u8bb0\uff0cLibuv\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u7528\u5230 25. w -> work = uv__cancelled ; 26. 27. uv_mutex_lock ( & loop -> wq_mutex ); 28. /* 29. \u63d2\u5165loop\u7684wq\u961f\u5217\uff0c\u5bf9\u4e8e\u53d6\u6d88\u7684\u52a8\u4f5c\uff0cLibuv\u8ba4\u4e3a\u662f\u4efb\u52a1\u6267\u884c\u5b8c\u4e86\u3002 30. \u6240\u4ee5\u63d2\u5165\u5df2\u5b8c\u6210\u7684\u961f\u5217\uff0c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4f1a\u901a\u77e5\u7528\u6237\u8be5\u4efb\u52a1\u7684\u6267\u884c\u7ed3\u679c 31. \u662f\u53d6\u6d88\uff0c\u9519\u8bef\u7801\u662fUV_ECANCELED 32. */ 33. QUEUE_INSERT_TAIL ( & loop -> wq , & w -> wq ); 34. // \u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210 35. uv_async_send ( & loop -> wq_async ); 36. uv_mutex_unlock ( & loop -> wq_mutex ); 37. 38. return 0 ; 39. } \u5728Libuv\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u7684\u65b9\u5f0f\u5c31\u662f\u628a\u8282\u70b9\u4ece\u7ebf\u7a0b\u6c60\u5f85\u5904\u7406\u961f\u5217\u4e2d\u5220\u9664\uff0c\u7136\u540e\u6253\u4e0a\u53d6\u6d88\u7684\u6807\u8bb0\uff08w->work = uv__cancelled\uff09\uff0c\u63a5\u7740\u628a\u8be5\u8282\u70b9\u63d2\u5165\u5df2\u5b8c\u6210\u961f\u5217\uff0cLibuv\u5728\u5904\u7406\u5df2\u5b8c\u6210\u961f\u5217\u7684\u8282\u70b9\u65f6\uff0c\u5224\u65ad\u5982\u679cw->work == uv__cancelled\u5219\u5728\u6267\u884c\u7528\u6237\u56de\u8c03\u65f6\uff0c\u4f20\u5165\u9519\u8bef\u7801UV_ECANCELED\uff0c\u6211\u4eec\u770b\u5230uv__work_cancel\u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u524d\u9762\u52a0\u4e86\u4e00\u4e2astatic\uff0c\u8bf4\u660e\u8fd9\u4e2a\u51fd\u6570\u662f\u53ea\u5728\u672c\u6587\u4ef6\u5185\u4f7f\u7528\u7684\uff0cLibuv\u5bf9\u5916\u63d0\u4f9b\u7684\u53d6\u6d88\u4efb\u52a1\u7684\u63a5\u53e3\u662fuv_cancel\u3002","title":"4.2.5 \u53d6\u6d88\u4efb\u52a1"},{"location":"chapter05-Libuv%E6%B5%81/","text":"\u7b2c\u4e94\u7ae0 Libuv\u6d41 \u00b6 \u6d41\u7684\u5b9e\u73b0\u5728Libuv\u91cc\u5360\u4e86\u5f88\u5927\u7684\u7bc7\u5e45\uff0c\u662f\u975e\u5e38\u6838\u5fc3\u7684\u903b\u8f91\u3002\u6d41\u7684\u672c\u8d28\u662f\u5c01\u88c5\u4e86\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\uff0c\u4f8b\u5982\u8bfb\u3001\u5199\uff0c\u8fde\u63a5\u3001\u76d1\u542c\u3002\u6211\u4eec\u9996\u5148\u770b\u770b\u6570\u636e\u7ed3\u6784\uff0c\u6d41\u5728Libuv\u91cc\u7528uv_stream_s\u8868\u793a\uff0c\u7ee7\u627f\u4e8euv_handle_s\u3002 1. struct uv_stream_s { 2. // uv_handle_s\u7684\u5b57\u6bb5 3. void * data ; 4. // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af 5. uv_loop_t * loop ; 6. // handle\u7c7b\u578b 7. uv_handle_type type ; 8. // \u5173\u95edhandle\u65f6\u7684\u56de\u8c03 9. uv_close_cb close_cb ; 10. // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217 11. void * handle_queue [ 2 ]; 12. union { 13. int fd ; 14. void * reserved [ 4 ]; 15. } u ; 16. // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684closing\u9636\u6bb5 17. uv_handle_t * next_closing ; 18. // \u5404\u79cd\u6807\u8bb0 19. unsigned int flags ; 20. // \u6d41\u62d3\u5c55\u7684\u5b57\u6bb5 21. /* 22. \u6237\u5199\u5165\u6d41\u7684\u5b57\u8282\u5927\u5c0f\uff0c\u6d41\u7f13\u5b58\u7528\u6237\u7684\u8f93\u5165\uff0c 23. \u7136\u540e\u7b49\u5230\u53ef\u5199\u7684\u65f6\u5019\u624d\u6267\u884c\u771f\u6b63\u7684\u5199 24. */ 25. size_t write_queue_size ; 26. // \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\uff0c\u5185\u5b58\u7531\u7528\u6237\u5b9a\u4e49\uff0c\u7528\u6765\u4fdd\u5b58\u8bfb\u53d6\u7684\u6570\u636e 27. uv_alloc_cb alloc_cb ; 28. // \u8bfb\u56de\u8c03 29. uv_read_cb read_cb ; 30. // \u8fde\u63a5\u8bf7\u6c42\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 31. uv_connect_t * connect_req ; 32. /* 33. \u5173\u95ed\u5199\u7aef\u7684\u65f6\u5019\uff0c\u53d1\u9001\u5b8c\u7f13\u5b58\u7684\u6570\u636e\uff0c 34. \u6267\u884cshutdown_req\u7684\u56de\u8c03\uff08shutdown_req\u5728uv_shutdown\u7684\u65f6\u5019\u8d4b\u503c\uff09 35. */ 36. uv_shutdown_t * shutdown_req ; 37. /* 38. \u6d41\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005 39. */ 40. uv__io_t io_watcher ; 41. // \u7f13\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 42. void * write_queue [ 2 ]; 43. // \u5df2\u7ecf\u5b8c\u6210\u4e86\u6570\u636e\u5199\u5165\u7684\u961f\u5217\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 44. void * write_completed_queue [ 2 ]; 45. // \u6709\u8fde\u63a5\u5230\u6765\u5e76\u4e14\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\uff0c\u6267\u884c\u7684\u56de\u8c03 46. uv_connection_cb connection_cb ; 47. // \u64cd\u4f5c\u6d41\u65f6\u51fa\u9519\u7801 48. int delayed_error ; 49. // accept\u8fd4\u56de\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0 50. int accepted_fd ; 51. // \u540c\u4e0a\uff0c\u7528\u4e8eIPC\u65f6\uff0c\u7f13\u5b58\u591a\u4e2a\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 52. void * queued_fds ; 53. } \u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u6700\u6838\u5fc3\u7684\u5b57\u6bb5\u662fIO\u89c2\u5bdf\u8005\uff0c\u5176\u4f59\u7684\u5b57\u6bb5\u662f\u548c\u6d41\u7684\u6027\u8d28\u76f8\u5173\u7684\u3002IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03\u3002\u6bd4\u5982\u8bfb\u4e00\u4e2a\u6d41\u3001\u5199\u4e00\u4e2a\u6d41\u3001\u5173\u95ed\u4e00\u4e2a\u6d41\u3001\u8fde\u63a5\u4e00\u4e2a\u6d41\u3001\u76d1\u542c\u4e00\u4e2a\u6d41\uff0c\u5728uv_stream_s\u4e2d\u90fd\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u53bb\u652f\u6301\u3002\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u9760IO\u89c2\u5bdf\u8005\u53bb\u9a71\u52a8\u7684\u3002 1 \u8bfb\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u7528\u6237\u7684\u8bfb\u56de\u8c03\u3002 2 \u5199\u4e00\u4e2a\u6d41\uff0c\u5148\u628a\u6570\u636e\u5199\u5230\u6d41\u4e2d\uff0c\u7b49\u5230IO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u771f\u6b63\u7684\u5199\u5165\uff0c\u5e76\u6267\u884c\u7528\u6237\u7684\u5199\u7ed3\u675f\u56de\u8c03\u3002 3 \u5173\u95ed\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u5219\u5148\u5199\u5b8c\uff08\u6bd4\u5982\u53d1\u9001\uff09\u540e\u518d\u6267\u884c\u5173\u95ed\u64cd\u4f5c\uff0c\u63a5\u7740\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 4 \u8fde\u63a5\u6d41\uff0c\u6bd4\u5982\u4f5c\u4e3a\u5ba2\u6237\u7aef\u53bb\u8fde\u63a5\u670d\u52a1\u5668\u3002\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u5efa\u7acb\u4e09\u6b21\u63e1\u624b\u6210\u529f\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 5 \u76d1\u542c\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u6d41\u7684\u5177\u4f53\u5b9e\u73b0 5.1 \u521d\u59cb\u5316\u6d41 \u00b6 \u5728\u4f7f\u7528uv_stream_t\u4e4b\u524d\u9700\u8981\u9996\u5148\u521d\u59cb\u5316\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u3002 1. void uv__stream_init ( uv_loop_t * loop , 2. uv_stream_t * stream , 3. uv_handle_type type ) { 4. int err ; 5. // \u8bb0\u5f55handle\u7684\u7c7b\u578b 6. uv__handle_init ( loop , ( uv_handle_t * ) stream , type ); 7. stream -> read_cb = NULL ; 8. stream -> alloc_cb = NULL ; 9. stream -> close_cb = NULL ; 10. stream -> connection_cb = NULL ; 11. stream -> connect_req = NULL ; 12. stream -> shutdown_req = NULL ; 13. stream -> accepted_fd = -1 ; 14. stream -> queued_fds = NULL ; 15. stream -> delayed_error = 0 ; 16. QUEUE_INIT ( & stream -> write_queue ); 17. QUEUE_INIT ( & stream -> write_completed_queue ); 18. stream -> write_queue_size = 0 ; 19. /* 20. \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u8fd9\u91cc\u8fd8\u6ca1\u6709\uff0c\u6240\u4ee5\u662f-1\uff09\u548c 21. \u56de\u8c03uv__stream_io\u8bb0\u5f55\u5728io_watcher\u4e0a\uff0cfd\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u7edf\u4e00 22. \u7531uv__stream_io\u51fd\u6570\u5904\u7406\uff0c\u4f46\u4e5f\u4f1a\u6709\u7279\u6b8a\u60c5\u51b5\uff08\u4e0b\u9762\u4f1a\u8bb2\u5230\uff09 23. */ 24. uv__io_init ( & stream -> io_watcher , uv__stream_io , -1 ); 25. } \u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u7684\u903b\u8f91\u5f88\u7b80\u5355\u660e\u4e86\uff0c\u5c31\u662f\u521d\u59cb\u5316\u76f8\u5173\u7684\u5b57\u6bb5\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\u65f6\uff0c\u8bbe\u7f6e\u7684\u5904\u7406\u51fd\u6570\u662fuv__stream_io\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790\u8fd9\u4e2a\u51fd\u6570\u7684\u5177\u4f53\u903b\u8f91\u3002 5.2 \u6253\u5f00\u6d41 \u00b6 26. int uv__stream_open ( uv_stream_t * stream , int fd , int flags ) { 27. // \u8fd8\u6ca1\u6709\u8bbe\u7f6efd\u6216\u8005\u8bbe\u7f6e\u7684\u540c\u4e00\u4e2afd\u5219\u7ee7\u7eed\uff0c\u5426\u5219\u8fd4\u56deUV_EBUSY 28. if ( ! ( stream -> io_watcher . fd == -1 || 29. stream -> io_watcher . fd == fd )) 30. return UV_EBUSY ; 31. // \u8bbe\u7f6e\u6d41\u7684\u6807\u8bb0 32. stream -> flags |= flags ; 33. // \u662fTCP\u6d41\u5219\u53ef\u4ee5\u8bbe\u7f6e\u4e0b\u9762\u7684\u5c5e\u6027 34. if ( stream -> type == UV_TCP ) { 35. // \u5173\u95ednagle\u7b97\u6cd5 36. if (( stream -> flags & UV_HANDLE_TCP_NODELAY ) && 37. uv__tcp_nodelay ( fd , 1 )) 38. return UV__ERR ( errno ); 39. /* 40. \u5f00\u542fkeepalive\u673a\u5236 41. */ 42. if (( stream -> flags & UV_HANDLE_TCP_KEEPALIVE ) && 43. uv__tcp_keepalive ( fd , 1 , 60 )) { 44. return UV__ERR ( errno ); 45. } 46. } 47. /* 48. \u4fdd\u5b58socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d\uff0cLibuv\u4f1a\u5728 49. Poll IO\u9636\u6bb5\u76d1\u542c\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26 50. */ 51. stream -> io_watcher . fd = fd ; 52. return 0 ; 53. } \u6253\u5f00\u4e00\u4e2a\u6d41\uff0c\u672c\u8d28\u4e0a\u5c31\u662f\u7ed9\u8fd9\u4e2a\u6d41\u5173\u8054\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u540e\u7eed\u7684\u64cd\u4f5c\u7684\u65f6\u5019\u90fd\u662f\u57fa\u4e8e\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5c5e\u6027\u7684\u8bbe\u7f6e\u3002 5.3 \u8bfb\u6d41 \u00b6 \u6211\u4eec\u5728\u4e00\u4e2a\u6d41\u4e0a\u6267\u884cuv_read_start\u540e\uff0c\u6d41\u7684\u6570\u636e\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u5c31\u4f1a\u901a\u8fc7read_cb\u56de\u8c03\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u8c03\u7528\u65b9\u3002 1. int uv_read_start ( uv_stream_t * stream , 2. uv_alloc_cb alloc_cb , 3. uv_read_cb read_cb ) { 4. // \u6d41\u5df2\u7ecf\u5173\u95ed\uff0c\u4e0d\u80fd\u8bfb 5. if ( stream -> flags & UV_HANDLE_CLOSING ) 6. return UV_EINVAL ; 7. // \u6d41\u4e0d\u53ef\u8bfb\uff0c\u8bf4\u660e\u53ef\u80fd\u662f\u53ea\u5199\u6d41 8. if ( ! ( stream -> flags & UV_HANDLE_READABLE )) 9. return - ENOTCONN ; 10. // \u6807\u8bb0\u6b63\u5728\u8bfb 11. stream -> flags |= UV_HANDLE_READING ; 12. // \u8bb0\u5f55\u8bfb\u56de\u8c03\uff0c\u6709\u6570\u636e\u7684\u65f6\u5019\u4f1a\u6267\u884c\u8fd9\u4e2a\u56de\u8c03 13. stream -> read_cb = read_cb ; 14. // \u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u7528\u4e8e\u5b58\u50a8\u8bfb\u53d6\u7684\u6570\u636e 15. stream -> alloc_cb = alloc_cb ; 16. // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 17. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); 18. // \u6fc0\u6d3bhandle\uff0c\u6709\u6fc0\u6d3b\u7684handle\uff0c\u4e8b\u4ef6\u5faa\u73af\u4e0d\u4f1a\u9000\u51fa 19. uv__handle_start ( stream ); 20. return 0 ; 21. } \u6267\u884cuv_read_start\u672c\u8d28\u4e0a\u662f\u7ed9\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5728epoll\u4e2d\u6ce8\u518c\u4e86\u4e00\u4e2a\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u8bb0\u5f55\u76f8\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u8bfb\u56de\u8c03\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\u3002\u63a5\u7740\u6253\u4e0a\u6b63\u5728\u505a\u8bfb\u53d6\u64cd\u4f5c\u7684\u6807\u8bb0\u3002\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8bfb\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\uff0c\u9664\u4e86\u8bfb\u53d6\u6570\u636e\uff0c\u8fd8\u6709\u4e00\u4e2a\u8bfb\u64cd\u4f5c\u5c31\u662f\u505c\u6b62\u8bfb\u53d6\u3002\u5bf9\u5e94\u7684\u51fd\u6570\u662fuv_read_stop\u3002 1. int uv_read_stop ( uv_stream_t * stream ) { 2. // \u662f\u5426\u6b63\u5728\u6267\u884c\u8bfb\u53d6\u64cd\u4f5c\uff0c\u5982\u679c\u4e0d\u662f\uff0c\u5219\u6ca1\u6709\u5fc5\u8981\u505c\u6b62 3. if ( ! ( stream -> flags & UV_HANDLE_READING )) 4. return 0 ; 5. // \u6e05\u9664\u6b63\u5728\u8bfb\u53d6\u7684\u6807\u8bb0 6. stream -> flags &= ~ UV_HANDLE_READING ; 7. // \u64a4\u9500\u7b49\u5f85\u8bfb\u4e8b\u4ef6 8. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); 9. // \u5bf9\u5199\u4e8b\u4ef6\u4e5f\u4e0d\u611f\u5174\u8da3\uff0c\u505c\u6389handle\u3002\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 10. if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) 11. uv__handle_stop ( stream ); 12. stream -> read_cb = NULL ; 13. stream -> alloc_cb = NULL ; 14. return 0 ; 15. } \u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\uff0c\u5224\u65ad\u6d41\u662f\u5426\u8bbe\u7f6e\u4e86\u53ef\u8bfb\u5c5e\u6027\u3002 1. int uv_is_readable ( const uv_stream_t * stream ) { 2. return !! ( stream -> flags & UV_HANDLE_READABLE ); 3. } \u4e0a\u9762\u7684\u51fd\u6570\u53ea\u662f\u6ce8\u518c\u548c\u6ce8\u9500\u8bfb\u4e8b\u4ef6\uff0c\u5982\u679c\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u81ea\u5df1\u53bb\u8bfb\u53d6\u6570\u636e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u771f\u6b63\u7684\u8bfb\u903b\u8f91 1. static void uv__read ( uv_stream_t * stream ) { 2. uv_buf_t buf ; 3. ssize_t nread ; 4. struct msghdr msg ; 5. char cmsg_space [ CMSG_SPACE ( UV__CMSG_FD_SIZE )]; 6. int count ; 7. int err ; 8. int is_ipc ; 9. // \u6e05\u9664\u8bfb\u53d6\u90e8\u5206\u6807\u8bb0 10. stream -> flags &= ~ UV_STREAM_READ_PARTIAL ; 11. count = 32 ; 12. /* 13. \u6d41\u662fUnix\u57df\u7c7b\u578b\u5e76\u4e14\u7528\u4e8eIPC\uff0cUnix\u57df\u4e0d\u4e00\u5b9a\u7528\u4e8eIPC\uff0c 14. \u7528\u4f5cIPC\u53ef\u4ee5\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 15. */ 16. is_ipc = stream -> type == UV_NAMED_PIPE && 17. (( uv_pipe_t * ) stream ) -> ipc ; 18. // \u8bbe\u7f6e\u4e86\u8bfb\u56de\u8c03\uff0c\u6b63\u5728\u8bfb\uff0ccount\u5927\u4e8e0 19. while ( stream -> read_cb 20. && ( stream -> flags & UV_STREAM_READING ) 21. && ( count -- > 0 )) { 22. buf = uv_buf_init ( NULL , 0 ); 23. // \u8c03\u7528\u8c03\u7528\u65b9\u63d0\u4f9b\u7684\u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e 24. stream -> alloc_cb (( uv_handle_t * ) stream , 64 * 1024 , & buf ); 25. /* 26. \u4e0d\u662fIPC\u5219\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\u5230buf\uff0c\u5426\u5219\u7528recvmsg\u8bfb\u53d6\u6570\u636e 27. \u548c\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 28. */ 29. if ( ! is_ipc ) { 30. do { 31. nread = read ( uv__stream_fd ( stream ), 32. buf . base , 33. buf . len ); 34. } 35. while ( nread < 0 && errno == EINTR ); 36. } else { 37. /* ipc uses recvmsg */ 38. msg . msg_flags = 0 ; 39. msg . msg_iov = ( struct iovec * ) & buf ; 40. msg . msg_iovlen = 1 ; 41. msg . msg_name = NULL ; 42. msg . msg_namelen = 0 ; 43. msg . msg_controllen = sizeof ( cmsg_space ); 44. msg . msg_control = cmsg_space ; 45. do { 46. nread = uv__recvmsg ( uv__stream_fd ( stream ), & msg , 0 ); 47. } 48. while ( nread < 0 && errno == EINTR ); 49. } 50. // \u8bfb\u5931\u8d25 51. if ( nread < 0 ) { 52. // \u8bfb\u7e41\u5fd9 53. if ( errno == EAGAIN || errno == EWOULDBLOCK ) { 54. // \u6267\u884c\u8bfb\u56de\u8c03 55. stream -> read_cb ( stream , 0 , & buf ); 56. } else { 57. /* Error. User should call uv_close(). */ 58. // \u8bfb\u5931\u8d25 59. stream -> read_cb ( stream , - errno , & buf ); 60. } 61. return ; 62. } else if ( nread == 0 ) { 63. // \u8bfb\u5230\u7ed3\u5c3e\u4e86 64. uv__stream_eof ( stream , & buf ); 65. return ; 66. } else { 67. // \u8bfb\u6210\u529f\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u957f\u5ea6 68. ssize_t buflen = buf . len ; 69. /* 70. \u662fIPC\u5219\u89e3\u6790\u8bfb\u53d6\u7684\u6570\u636e\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u89e3\u6790\u51fa\u6765\uff0c 71. \u653e\u5230stream\u7684accepted_fd\u548cqueued_fds\u5b57\u6bb5 72. */ 73. if ( is_ipc ) { 74. err = uv__stream_recv_cmsg ( stream , & msg ); 75. if ( err != 0 ) { 76. stream -> read_cb ( stream , err , & buf ); 77. return ; 78. } 79. } 80. // \u6267\u884c\u8bfb\u56de\u8c03 81. stream -> read_cb ( stream , nread , & buf ); 82. } 83. } 84. } uv_read\u9664\u4e86\u53ef\u4ee5\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\u5916\uff0c\u8fd8\u652f\u6301\u8bfb\u53d6\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u539f\u7406\u3002\u6211\u4eec\u77e5\u9053\uff0c\u7236\u8fdb\u7a0bfork\u51fa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u662f\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5217\u8868\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002 fork\u4e4b\u524d\u5982\u56fe5-1\u6240\u793a\u3002 \u6211\u4eec\u518d\u770b\u4e00\u4e0bfork\u4e4b\u540e\u7684\u7ed3\u6784\u5982\u56fe5-2\u6240\u793a\u3002 \u5982\u679c\u7236\u8fdb\u7a0b\u6216\u8005\u5b50\u8fdb\u7a0b\u5728fork\u4e4b\u540e\u521b\u5efa\u4e86\u65b0\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u90a3\u7236\u5b50\u8fdb\u7a0b\u95f4\u5c31\u4e0d\u80fd\u5171\u4eab\u4e86\uff0c\u5047\u8bbe\u7236\u8fdb\u7a0b\u8981\u628a\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u90a3\u600e\u4e48\u529e\u5462\uff1f\u6839\u636e\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u8981\u505a\u7684\u4e8b\u60c5\uff0c\u4e0d\u4ec5\u4ec5\u662f\u5728\u5b50\u8fdb\u7a0b\u4e2d\u65b0\u5efa\u4e00\u4e2afd\uff0c\u8fd8\u8981\u5efa\u7acb\u8d77fd->file->inode\u7684\u5173\u8054\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u5173\u6ce8\u8fd9\u4e9b\uff0c\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u90fd\u5e2e\u6211\u4eec\u5904\u7406\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7sendmsg\u628a\u60f3\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d1\u9001\u7ed9Unix\u57df\u7684\u53e6\u4e00\u7aef\u3002Unix\u57df\u53e6\u4e00\u7aef\u5c31\u53ef\u4ee5\u901a\u8fc7recvmsg\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4ece\u6570\u636e\u4e2d\u8bfb\u53d6\u51fa\u6765\u3002\u63a5\u7740\u4f7f\u7528uv__stream_recv_cmsg\u51fd\u6570\u4fdd\u5b58\u6570\u636e\u91cc\u89e3\u6790\u51fa\u6765\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1. static int uv__stream_recv_cmsg ( uv_stream_t * stream , 2. struct msghdr * msg ) { 3. struct cmsghdr * cmsg ; 4. // \u904d\u5386msg 5. for ( cmsg = CMSG_FIRSTHDR ( msg ); 6. cmsg != NULL ; 7. cmsg = CMSG_NXTHDR ( msg , cmsg )) { 8. char * start ; 9. char * end ; 10. int err ; 11. void * pv ; 12. int * pi ; 13. unsigned int i ; 14. unsigned int count ; 15. 16. pv = CMSG_DATA ( cmsg ); 17. pi = pv ; 18. start = ( char * ) cmsg ; 19. end = ( char * ) cmsg + cmsg -> cmsg_len ; 20. count = 0 ; 21. while ( start + CMSG_LEN ( count * sizeof ( * pi )) < end ) 22. count ++ ; 23. for ( i = 0 ; i < count ; i ++ ) { 24. /* 25. accepted_fd\u4ee3\u8868\u5f53\u524d\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c 26. \u5982\u679c\u5df2\u7ecf\u6709\u503c\u5219\u5269\u4f59\u63cf\u8ff0\u7b26\u5c31\u901a\u8fc7uv__stream_queue_fd\u6392\u961f 27. \u5982\u679c\u8fd8\u6ca1\u6709\u503c\u5219\u5148\u8d4b\u503c 28. */ 29. if ( stream -> accepted_fd != -1 ) { 30. err = uv__stream_queue_fd ( stream , pi [ i ]); 31. } else { 32. stream -> accepted_fd = pi [ i ]; 33. } 34. } 35. } 36. 37. return 0 ; 38. } uv__stream_recv_cmsg\u4f1a\u4ece\u6570\u636e\u4e2d\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5b58\u5230stream\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5728accepted_fd\uff0c\u5269\u4e0b\u7684\u4f7f\u7528uv__stream_queue_fd\u5904\u7406\u3002 1. struct uv__stream_queued_fds_s { 2. unsigned int size ; 3. unsigned int offset ; 4. int fds [ 1 ]; 5. }; 6. 7. static int uv__stream_queue_fd ( uv_stream_t * stream , int fd ) { 8. uv__stream_queued_fds_t * queued_fds ; 9. unsigned int queue_size ; 10. // \u539f\u6765\u7684\u5185\u5b58 11. queued_fds = stream -> queued_fds ; 12. // \u6ca1\u6709\u5185\u5b58\uff0c\u5219\u5206\u914d 13. if ( queued_fds == NULL ) { 14. // \u9ed8\u8ba48\u4e2a 15. queue_size = 8 ; 16. /* 17. \u4e00\u4e2a\u5143\u6570\u636e\u5185\u5b58+\u591a\u4e2afd\u7684\u5185\u5b58 18. \uff08\u524d\u9762\u52a0*\u4ee3\u8868\u89e3\u5f15\u7528\u540e\u7684\u503c\u7684\u7c7b\u578b\u6240\u5360\u7684\u5185\u5b58\u5927\u5c0f\uff0c 19. \u51cf\u4e00\u662f\u56e0\u4e3auv__stream_queued_fds_t 20. \u7ed3\u6784\u4f53\u672c\u8eab\u6709\u4e00\u4e2a\u7a7a\u95f4\uff09 21. */ 22. queued_fds = uv__malloc (( queue_size - 1 ) * 23. sizeof ( * queued_fds -> fds ) + 24. sizeof ( * queued_fds )); 25. if ( queued_fds == NULL ) 26. return UV_ENOMEM ; 27. // \u5bb9\u91cf 28. queued_fds -> size = queue_size ; 29. // \u5df2\u4f7f\u7528\u4e2a\u6570 30. queued_fds -> offset = 0 ; 31. // \u6307\u5411\u53ef\u7528\u7684\u5185\u5b58 32. stream -> queued_fds = queued_fds ; 33. // \u4e4b\u524d\u7684\u5185\u5b58\u7528\u5b8c\u4e86\uff0c\u6269\u5bb9 34. } else if ( queued_fds -> size == queued_fds -> offset ) { 35. // \u6bcf\u6b21\u52a08\u4e2a 36. queue_size = queued_fds -> size + 8 ; 37. queued_fds = uv__realloc ( queued_fds , 38. ( queue_size - 1 ) * sizeof ( * queued_fds -> fds ) + sizeof ( * queued_fds )); 39. 40. if ( queued_fds == NULL ) 41. return UV_ENOMEM ; 42. // \u66f4\u65b0\u5bb9\u91cf\u5927\u5c0f 43. queued_fds -> size = queue_size ; 44. // \u4fdd\u5b58\u65b0\u7684\u5185\u5b58 45. stream -> queued_fds = queued_fds ; 46. } 47. 48. /* Put fd in a queue */ 49. // \u4fdd\u5b58fd 50. queued_fds -> fds [ queued_fds -> offset ++ ] = fd ; 51. 52. return 0 ; 53. } \u5185\u5b58\u7ed3\u6784\u5982\u56fe5-3\u6240\u793a\u3002 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7ed3\u675f\u540e\u7684\u5904\u7406\uff0c 1. static void uv__stream_eof ( uv_stream_t * stream , 2. const uv_buf_t * buf ) { 3. // \u6253\u4e0a\u8bfb\u7ed3\u675f\u6807\u8bb0 4. stream -> flags |= UV_STREAM_READ_EOF ; 5. // \u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 6. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); 7. // \u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u5219\u505c\u6389handle\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 8. if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) 9. uv__handle_stop ( stream ); 10. uv__stream_osx_interrupt_select ( stream ); 11. // \u6267\u884c\u8bfb\u56de\u8c03 12. stream -> read_cb ( stream , UV_EOF , buf ); 13. // \u6e05\u9664\u6b63\u5728\u8bfb\u6807\u8bb0 14. stream -> flags &= ~ UV_STREAM_READING ; 15. } \u6211\u4eec\u770b\u5230\uff0c\u6d41\u7ed3\u675f\u7684\u65f6\u5019\uff0c\u9996\u5148\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7136\u540e\u901a\u8fc7\u56de\u8c03\u901a\u77e5\u4e0a\u5c42\u3002 5.4 \u5199\u6d41 \u00b6 \u6211\u4eec\u5728\u6d41\u4e0a\u6267\u884cuv_write\u5c31\u53ef\u4ee5\u5f80\u6d41\u4e2d\u5199\u5165\u6570\u636e\u3002 1. int uv_write ( 2. /* 3. \u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u8bb0\u5f55\u4e86\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u548c\u4fe1\u606f\u3002 4. \u6570\u636e\u6765\u81ea\u4e0b\u9762\u7684const uv_buf_t bufs[] 5. */ 6. uv_write_t * req , 7. // \u5f80\u54ea\u4e2a\u6d41\u5199 8. uv_stream_t * handle , 9. // \u9700\u8981\u5199\u5165\u7684\u6570\u636e 10. const uv_buf_t bufs [], 11. // uv_buf_t\u4e2a\u6570 12. unsigned int nbufs , 13. // \u5199\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 14. uv_write_cb cb 15. ) { 16. return uv_write2 ( req , handle , bufs , nbufs , NULL , cb ); 17. } uv_write\u662f\u76f4\u63a5\u8c03\u7528uv_write2\u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u662fNULL\u3002\u4ee3\u8868\u662f\u4e00\u822c\u7684\u5199\u6570\u636e\uff0c\u4e0d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1. int uv_write2 ( uv_write_t * req , 2. uv_stream_t * stream , 3. const uv_buf_t bufs [], 4. unsigned int nbufs , 5. uv_stream_t * send_handle , 6. uv_write_cb cb ) { 7. int empty_queue ; 8. // \u5f85\u53d1\u9001\u961f\u5217\u662f\u5426\u4e3a\u7a7a 9. empty_queue = ( stream -> write_queue_size == 0 ); 10. // \u6784\u9020\u4e00\u4e2a\u5199\u8bf7\u6c42 11. uv__req_init ( stream -> loop , req , UV_WRITE ); 12. // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 13. req -> cb = cb ; 14. // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u6d41 15. req -> handle = stream ; 16. req -> error = 0 ; 17. // \u9700\u8981\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e5f\u53ef\u4ee5\u662fNULL\u8bf4\u660e\u4e0d\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 18. req -> send_handle = send_handle ; 19. QUEUE_INIT ( & req -> queue ); 20. // bufs\u6307\u5411\u5f85\u5199\u7684\u6570\u636e 21. req -> bufs = req -> bufsml ; 22. // \u590d\u5236\u8c03\u7528\u65b9\u7684\u6570\u636e\u8fc7\u6765 23. memcpy ( req -> bufs , bufs , nbufs * sizeof ( bufs [ 0 ])); 24. // buf\u4e2a\u6570 25. req -> nbufs = nbufs ; 26. // \u5f53\u524d\u5199\u6210\u529f\u7684buf\u7d22\u5f15\uff0c\u9488\u5bf9bufs\u6570\u7ec4 27. req -> write_index = 0 ; 28. // \u5f85\u5199\u7684\u6570\u636e\u5927\u5c0f = \u4e4b\u524d\u7684\u5927\u5c0f + \u672c\u6b21\u5927\u5c0f 29. stream -> write_queue_size += uv__count_bufs ( bufs , nbufs ); 30. // \u63d2\u5165\u5f85\u5199\u961f\u5217 31. QUEUE_INSERT_TAIL ( & stream -> write_queue , & req -> queue ); 32. // \u975e\u7a7a\u8bf4\u660e\u6b63\u5728\u8fde\u63a5\uff0c\u8fd8\u4e0d\u80fd\u5199\uff0c\u6bd4\u5982TCP\u6d41 33. if ( stream -> connect_req ) { 34. /* Still connecting, do nothing. */ 35. } 36. else if ( empty_queue ) { // \u5f53\u524d\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u5199 37. uv__write ( stream ); 38. } 39. else { 40. // \u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u7b49\u5f85\u5199\u4e8b\u4ef6 41. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); 42. uv__stream_osx_interrupt_select ( stream ); 43. } 44. return 0 ; 45. } uv_write2\u7684\u4e3b\u8981\u903b\u8f91\u5c31\u662f\u5c01\u88c5\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u63d2\u5165\u5230\u6d41\u7684\u5f85\u5199\u961f\u5217\u3002\u7136\u540e\u6839\u636e\u5f53\u524d\u6d41\u7684\u60c5\u51b5\u3002\u770b\u662f\u76f4\u63a5\u5199\u5165\u8fd8\u662f\u7b49\u5f85\u4f1a\u518d\u5199\u5165\u3002\u5173\u7cfb\u56fe\u5927\u81f4\u5982\u56fe5-4\u6240\u793a\u3002 uv_write2\u53ea\u662f\u5bf9\u5199\u8bf7\u6c42\u8fdb\u884c\u4e00\u4e9b\u9884\u5904\u7406\uff0c\u771f\u6b63\u6267\u884c\u5199\u7684\u51fd\u6570\u662fuv__write 1. static void uv__write ( uv_stream_t * stream ) { 2. struct iovec * iov ; 3. QUEUE * q ; 4. uv_write_t * req ; 5. int iovmax ; 6. int iovcnt ; 7. ssize_t n ; 8. int err ; 9. 10. start : 11. // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199 12. if ( QUEUE_EMPTY ( & stream -> write_queue )) 13. return ; 14. q = QUEUE_HEAD ( & stream -> write_queue ); 15. req = QUEUE_DATA ( q , uv_write_t , queue ); 16. // \u4ece\u54ea\u91cc\u5f00\u59cb\u5199 17. iov = ( struct iovec * ) & ( req -> bufs [ req -> write_index ]); 18. // \u8fd8\u6709\u591a\u5c11\u6ca1\u5199 19. iovcnt = req -> nbufs - req -> write_index ; 20. // \u6700\u591a\u53ef\u4ee5\u5199\u591a\u5c11 21. iovmax = uv__getiovmax (); 22. // \u53d6\u6700\u5c0f\u503c 23. if ( iovcnt > iovmax ) 24. iovcnt = iovmax ; 25. // \u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 26. if ( req -> send_handle ) { 27. int fd_to_send ; 28. struct msghdr msg ; 29. struct cmsghdr * cmsg ; 30. union { 31. char data [ 64 ]; 32. struct cmsghdr alias ; 33. } scratch ; 34. 35. if ( uv__is_closing ( req -> send_handle )) { 36. err = - EBADF ; 37. goto error ; 38. } 39. // \u5f85\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 40. fd_to_send = uv__handle_fd (( uv_handle_t * ) req -> send_handle ); 41. memset ( & scratch , 0 , sizeof ( scratch )); 42. 43. msg . msg_name = NULL ; 44. msg . msg_namelen = 0 ; 45. msg . msg_iov = iov ; 46. msg . msg_iovlen = iovcnt ; 47. msg . msg_flags = 0 ; 48. 49. msg . msg_control = & scratch . alias ; 50. msg . msg_controllen = CMSG_SPACE ( sizeof ( fd_to_send )); 51. 52. cmsg = CMSG_FIRSTHDR ( & msg ); 53. cmsg -> cmsg_level = SOL_SOCKET ; 54. cmsg -> cmsg_type = SCM_RIGHTS ; 55. cmsg -> cmsg_len = CMSG_LEN ( sizeof ( fd_to_send )); 56. 57. { 58. void * pv = CMSG_DATA ( cmsg ); 59. int * pi = pv ; 60. * pi = fd_to_send ; 61. } 62. 63. do { 64. // \u4f7f\u7528sendmsg\u51fd\u6570\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 65. n = sendmsg ( uv__stream_fd ( stream ), & msg , 0 ); 66. } 67. while ( n == -1 && errno == EINTR ); 68. } else { 69. do { 70. // \u5199\u4e00\u4e2a\u6216\u8005\u5199\u6279\u91cf\u5199 71. if ( iovcnt == 1 ) { 72. n = write ( uv__stream_fd ( stream ), 73. iov [ 0 ]. iov_base , 74. iov [ 0 ]. iov_len ); 75. } else { 76. n = writev ( uv__stream_fd ( stream ), iov , iovcnt ); 77. } 78. } 79. while ( n == -1 && errno == EINTR ); 80. } 81. // \u5199\u5931\u8d25 82. if ( n < 0 ) { 83. /* 84. \u4e0d\u662f\u5199\u7e41\u5fd9\uff0c\u5219\u62a5\u9519\uff0c 85. \u5426\u5219\u5982\u679c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\u6807\u8bb0\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199 86. */ 87. if ( errno != EAGAIN && 88. errno != EWOULDBLOCK && 89. errno != ENOBUFS ) { 90. err = - errno ; 91. goto error ; 92. } else if ( stream -> flags & UV_STREAM_BLOCKING ) { 93. /* If this is a blocking stream, try again. */ 94. goto start ; 95. } 96. } else { 97. // \u5199\u6210\u529f 98. while ( n >= 0 ) { 99. // \u5f53\u524dbuf\u9996\u5730\u5740 100. uv_buf_t * buf = & ( req -> bufs [ req -> write_index ]); 101. // \u5f53\u524dbuf\u7684\u6570\u636e\u957f\u5ea6 102. size_t len = buf -> len ; 103. // \u5c0f\u4e8e\u8bf4\u660e\u5f53\u524dbuf\u8fd8\u6ca1\u6709\u5199\u5b8c\uff08\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c\uff09 104. if (( size_t ) n < len ) { 105. // \u66f4\u65b0\u5f85\u5199\u7684\u9996\u5730\u5740 106. buf -> base += n ; 107. // \u66f4\u65b0\u5f85\u5199\u7684\u6570\u636e\u957f\u5ea6 108. buf -> len -= n ; 109. /* 110. \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6\uff0c\u8fd9\u4e2a\u961f\u5217\u662f\u5f85\u5199\u6570\u636e\u7684 111. \u603b\u957f\u5ea6\uff0c\u7b49\u4e8e\u591a\u4e2abuf\u7684\u548c 112. */ 113. stream -> write_queue_size -= n ; 114. n = 0 ; 115. /* 116. \u8fd8\u6ca1\u5199\u5b8c\uff0c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199\uff0c 117. \u5426\u5219\u9000\u51fa\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6 118. */ 119. if ( stream -> flags & UV_STREAM_BLOCKING ) { 120. goto start ; 121. } else { 122. break ; 123. } 124. } else { 125. /* 126. \u5f53\u524dbuf\u7684\u6570\u636e\u90fd\u5199\u5b8c\u4e86\uff0c\u5219\u66f4\u65b0\u5f85\u5199\u6570\u636e\u7684\u7684\u9996 127. \u5730\u5740\uff0c\u5373\u4e0b\u4e00\u4e2abuf\uff0c\u56e0\u4e3a\u5f53\u524dbuf\u5199\u5b8c\u4e86 128. */ 129. req -> write_index ++ ; 130. // \u66f4\u65b0n\uff0c\u7528\u4e8e\u4e0b\u4e00\u4e2a\u5faa\u73af\u7684\u8ba1\u7b97 131. n -= len ; 132. // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6 133. stream -> write_queue_size -= len ; 134. /* 135. \u7b49\u4e8e\u6700\u540e\u4e00\u4e2abuf\u4e86\uff0c\u8bf4\u660e\u5f85\u5199\u961f\u5217\u7684\u6570\u636e 136. \u90fd\u5199\u5b8c\u4e86 137. */ 138. if ( req -> write_index == req -> nbufs ) { 139. /* 140. \u91ca\u653ebuf\u5bf9\u5e94\u7684\u5185\u5b58\uff0c\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210 141. \u961f\u5217\uff0c\u7136\u540e\u51c6\u5907\u89e6\u53d1\u5199\u5b8c\u6210\u56de\u8c03 142. */ 143. uv__write_req_finish ( req ); 144. return ; 145. } 146. } 147. } 148. } 149. /* 150. \u5199\u6210\u529f\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6\uff0c 151. \u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u7ee7\u7eed\u5199 152. */ 153. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); 154. uv__stream_osx_interrupt_select ( stream ); 155. 156. return ; 157. // \u5199\u51fa\u9519 158. error : 159. // \u8bb0\u5f55\u9519\u8bef 160. req -> error = err ; 161. /* 162. \u91ca\u653e\u5185\u5b58\uff0c\u4e22\u5f03\u6570\u636e\uff0c\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c 163. \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 164. */ 165. uv__write_req_finish ( req ); 166. // \u6ce8\u9500\u5f85\u5199\u4e8b\u4ef6 167. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); 168. // \u5982\u679c\u4e5f\u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5219\u628ahandle\u5173\u95ed 169. if ( ! uv__io_active ( & stream -> io_watcher , POLLIN )) 170. uv__handle_stop ( stream ); 171. uv__stream_osx_interrupt_select ( stream ); 172. } \u6211\u4eec\u770b\u4e00\u4e0b\u4e00\u4e2a\u5199\u8bf7\u6c42\u7ed3\u675f\u540e\uff08\u6210\u529f\u6216\u8005\u5931\u8d25\uff09\uff0cLibuv\u5982\u4f55\u5904\u7406\u7684\u3002\u903b\u8f91\u5728uv__write_req_finish\u51fd\u6570\u3002 1. static void uv__write_req_finish ( uv_write_t * req ) { 2. uv_stream_t * stream = req -> handle ; 3. // \u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 4. QUEUE_REMOVE ( & req -> queue ); 5. // \u5199\u6210\u529f\uff0c\u5e76\u4e14\u5206\u914d\u4e86\u989d\u5916\u7684\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e\uff0c\u89c1uv__write 6. if ( req -> error == 0 ) { 7. if ( req -> bufs != req -> bufsml ) 8. uv__free ( req -> bufs ); 9. req -> bufs = NULL ; 10. } 11. // \u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217 12. QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); 13. /* 14. \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0cLibuv\u5728\u5904\u7406pending\u9636\u6bb5\u65f6, 15. \u4f1a\u89e6\u53d1IO\u89c2\u5bdf\u8005\u7684\u5199\u4e8b\u4ef6 16. */ 17. uv__io_feed ( stream -> loop , & stream -> io_watcher ); 18. } uv__write_req_finish\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355 1\u628a\u8282\u70b9\u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 2 req->bufs != req->bufsml\u4e0d\u76f8\u7b49\u8bf4\u660e\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u9700\u8981\u81ea\u5df1\u91ca\u653e 3\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\uff0c\u5728pending\u8282\u70b9\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff08uv__stream_io\uff09\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv__stream_io\u5982\u4f55\u5904\u7406\u7684\uff0c\u4e0b\u9762\u662f\u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u3002 1. // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 2. if ( events & ( POLLOUT | POLLERR | POLLHUP )) { 3. // \u7ee7\u7eed\u6267\u884c\u5199 4. uv__write ( stream ); 5. // \u5904\u7406\u5199\u6210\u529f\u56de\u8c03 6. uv__write_callbacks ( stream ); 7. // \u5f85\u5199\u961f\u5217\u7a7a\uff0c\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5373\u4e0d\u9700\u8981\u5199\u4e86 8. if ( QUEUE_EMPTY ( & stream -> write_queue )) 9. uv__drain ( stream ); 10. } \u6211\u4eec\u53ea\u5173\u6ce8uv__write_callbacks\u3002 1. static void uv__write_callbacks ( uv_stream_t * stream ) { 2. uv_write_t * req ; 3. QUEUE * q ; 4. // \u5199\u5b8c\u6210\u961f\u5217\u975e\u7a7a 5. while ( ! QUEUE_EMPTY ( & stream -> write_completed_queue )) { 6. q = QUEUE_HEAD ( & stream -> write_completed_queue ); 7. req = QUEUE_DATA ( q , uv_write_t , queue ); 8. QUEUE_REMOVE ( q ); 9. uv__req_unregister ( stream -> loop , req ); 10. // bufs\u7684\u5185\u5b58\u8fd8\u6ca1\u6709\u88ab\u91ca\u653e 11. if ( req -> bufs != NULL ) { 12. // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u5927\u5c0f\uff0c\u5373\u51cf\u53bbreq\u5bf9\u5e94\u7684\u6240\u6709\u6570\u636e\u7684\u5927\u5c0f 13. stream -> write_queue_size -= uv__write_req_size ( req ); 14. /* 15. bufs\u9ed8\u8ba4\u6307\u5411bufsml\uff0c\u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\u65f6\uff0c 16. bufs\u6307\u5411\u65b0\u7533\u8bf7\u7684\u5806\u5185\u5b58\uff0c\u6240\u4ee5\u9700\u8981\u91ca\u653e 17. */ 18. if ( req -> bufs != req -> bufsml ) 19. uv__free ( req -> bufs ); 20. req -> bufs = NULL ; 21. } 22. // \u6267\u884c\u56de\u8c03 23. if ( req -> cb ) 24. req -> cb ( req , req -> error ); 25. } 26. } uv__write_callbacks\u8d1f\u8d23\u66f4\u65b0\u6d41\u7684\u5f85\u5199\u961f\u5217\u5927\u5c0f\u3001\u91ca\u653e\u989d\u5916\u7533\u8bf7\u7684\u5806\u5185\u5b58\u3001\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\u3002 5.5 \u5173\u95ed\u6d41\u7684\u5199\u7aef \u00b6 1. // \u5173\u95ed\u6d41\u7684\u5199\u7aef 2. int uv_shutdown ( uv_shutdown_t * req , 3. uv_stream_t * stream , 4. uv_shutdown_cb cb ) { 5. // \u521d\u59cb\u5316\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u5173\u8054\u7684handle\u662fstream 6. uv__req_init ( stream -> loop , req , UV_SHUTDOWN ); 7. req -> handle = stream ; 8. // \u5173\u95ed\u540e\u6267\u884c\u7684\u56de\u8c03 9. req -> cb = cb ; 10. stream -> shutdown_req = req ; 11. // \u8bbe\u7f6e\u6b63\u5728\u5173\u95ed\u7684\u6807\u8bb0 12. stream -> flags |= UV_HANDLE_SHUTTING ; 13. // \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 14. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); 15. return 0 ; 16. } \u5173\u95ed\u6d41\u7684\u5199\u7aef\u5c31\u662f\u76f8\u5f53\u4e8e\u7ed9\u6d41\u53d1\u9001\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u628a\u8bf7\u6c42\u6302\u8f7d\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5728\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u64cd\u4f5c\u3002\u5728\u5206\u6790\u5199\u6d41\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u63d0\u5230\uff0c\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cuv__drain\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u9664\u6b64\u4e4b\u5916\uff0cuv__drain\u8fd8\u505a\u4e86\u4e00\u4e2a\u4e8b\u60c5\uff0c\u5c31\u662f\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u770b\u5177\u4f53\u7684\u903b\u8f91\u3002 1. static void uv__drain ( uv_stream_t * stream ) { 2. uv_shutdown_t * req ; 3. int err ; 4. // \u64a4\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u56e0\u4e3a\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86 5. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); 6. uv__stream_osx_interrupt_select ( stream ); 7. 8. // \u8bbe\u7f6e\u4e86\u5173\u95ed\u5199\u7aef\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u6267\u884c\u5173\u95ed\u5199\u7aef 9. if (( stream -> flags & UV_HANDLE_SHUTTING ) && 10. ! ( stream -> flags & UV_HANDLE_CLOSING ) && 11. ! ( stream -> flags & UV_HANDLE_SHUT )) { 12. req = stream -> shutdown_req ; 13. stream -> shutdown_req = NULL ; 14. // \u6e05\u9664\u6807\u8bb0 15. stream -> flags &= ~ UV_HANDLE_SHUTTING ; 16. uv__req_unregister ( stream -> loop , req ); 17. 18. err = 0 ; 19. // \u5173\u95ed\u5199\u7aef 20. if ( shutdown ( uv__stream_fd ( stream ), SHUT_WR )) 21. err = UV__ERR ( errno ); 22. // \u6807\u8bb0\u5df2\u5173\u95ed\u5199\u7aef 23. if ( err == 0 ) 24. stream -> flags |= UV_HANDLE_SHUT ; 25. // \u6267\u884c\u56de\u8c03 26. if ( req -> cb != NULL ) 27. req -> cb ( req , err ); 28. } 29. } \u901a\u8fc7\u8c03\u7528shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u6bd4\u5982TCP\u6d41\u53d1\u9001\u5b8c\u6570\u636e\u540e\u53ef\u4ee5\u5173\u95ed\u5199\u7aef\u3002\u4f46\u662f\u4ecd\u7136\u53ef\u4ee5\u8bfb\u3002 5.6 \u5173\u95ed\u6d41 \u00b6 1. void uv__stream_close ( uv_stream_t * handle ) { 2. unsigned int i ; 3. uv__stream_queued_fds_t * queued_fds ; 4. // \u4ece\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5220\u9664IO\u89c2\u5bdf\u8005\uff0c\u79fb\u51fapending\u961f\u5217 5. uv__io_close ( handle -> loop , & handle -> io_watcher ); 6. // \u505c\u6b62\u8bfb 7. uv_read_stop ( handle ); 8. // \u505c\u6389handle 9. uv__handle_stop ( handle ); 10. // \u4e0d\u53ef\u8bfb\u3001\u5199 11. handle -> flags &= ~ ( UV_HANDLE_READABLE | UV_HANDLE_WRITABLE ); 12. // \u5173\u95ed\u975e\u6807\u51c6\u6d41\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 13. if ( handle -> io_watcher . fd != -1 ) { 14. /* 15. Don't close stdio file descriptors. 16. Nothing good comes from it. 17. */ 18. if ( handle -> io_watcher . fd > STDERR_FILENO ) 19. uv__close ( handle -> io_watcher . fd ); 20. handle -> io_watcher . fd = -1 ; 21. } 22. // \u5173\u95ed\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 23. if ( handle -> accepted_fd != -1 ) { 24. uv__close ( handle -> accepted_fd ); 25. handle -> accepted_fd = -1 ; 26. } 27. // \u540c\u4e0a\uff0c\u8fd9\u662f\u5728\u6392\u961f\u7b49\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 28. if ( handle -> queued_fds != NULL ) { 29. queued_fds = handle -> queued_fds ; 30. for ( i = 0 ; i < queued_fds -> offset ; i ++ ) 31. uv__close ( queued_fds -> fds [ i ]); 32. uv__free ( handle -> queued_fds ); 33. handle -> queued_fds = NULL ; 34. } 35. } \u5173\u95ed\u6d41\u5c31\u662f\u628a\u6d41\u6ce8\u518c\u5728epoll\u7684\u4e8b\u4ef6\u6ce8\u9500\uff0c\u5173\u95ed\u6240\u6301\u6709\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 5.7 \u8fde\u63a5\u6d41 \u00b6 \u8fde\u63a5\u6d41\u662f\u9488\u5bf9TCP\u548cUnix\u57df\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9996\u5148\u4ecb\u7ecd\u4e00\u4e0b\u4e00\u4e9b\u7f51\u7edc\u7f16\u7a0b\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u9996\u5148\u6211\u4eec\u5148\u8981\u6709\u4e00\u4e2asocket\u3002\u6211\u4eec\u770bLibuv\u4e2d\u5982\u4f55\u65b0\u5efa\u4e00\u4e2asocket\u3002 1. int uv__socket ( int domain , int type , int protocol ) { 2. int sockfd ; 3. int err ; 4. // \u65b0\u5efa\u4e00\u4e2asocket\uff0c\u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u548cLOEXEC\u6807\u8bb0 5. sockfd = socket ( domain , type | SOCK_NONBLOCK | SOCK_CLOEXEC , protocol ); 6. // \u4e0d\u89e6\u53d1SIGPIPE\u4fe1\u53f7\uff0c\u6bd4\u5982\u5bf9\u7aef\u5df2\u7ecf\u5173\u95ed\uff0c\u672c\u7aef\u53c8\u6267\u884c\u5199 7. # if defined ( SO_NOSIGPIPE ) 8. { 9. int on = 1 ; 10. setsockopt ( sockfd , SOL_SOCKET , SO_NOSIGPIPE , & on , sizeof ( on )); 11. } 12. # endif 13. 14. return sockfd ; 15. } \u5728Libuv\u4e2d\uff0csocket\u7684\u6a21\u5f0f\u90fd\u662f\u975e\u963b\u585e\u7684\uff0cuv__socket\u662fLibuv\u4e2d\u7533\u8bf7socket\u7684\u51fd\u6570\uff0c\u4e0d\u8fc7Libuv\u4e0d\u76f4\u63a5\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u800c\u662f\u5c01\u88c5\u4e86\u4e00\u4e0b\u3002 1. /* 2. 1 \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684socket fd 3. 2 \u628afd\u4fdd\u5b58\u5230handle\u91cc\uff0c\u5e76\u6839\u636eflag\u8fdb\u884c\u76f8\u5173\u8bbe\u7f6e 4. 3 \u7ed1\u5b9a\u5230\u672c\u673a\u968f\u610f\u7684\u5730\u5740\uff08\u5982\u679c\u8bbe\u7f6e\u4e86\u8be5\u6807\u8bb0\u7684\u8bdd\uff09 5. */ 6. static int new_socket ( uv_tcp_t * handle , 7. int domain , 8. unsigned long flags ) { 9. struct sockaddr_storage saddr ; 10. socklen_t slen ; 11. int sockfd ; 12. // \u83b7\u53d6\u4e00\u4e2asocket 13. sockfd = uv__socket ( domain , SOCK_STREAM , 0 ); 14. 15. // \u8bbe\u7f6e\u9009\u9879\u548c\u4fdd\u5b58socket\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d 16. uv__stream_open (( uv_stream_t * ) handle , sockfd , flags ); 17. // \u8bbe\u7f6e\u4e86\u9700\u8981\u7ed1\u5b9a\u6807\u8bb0UV_HANDLE_BOUND 18. if ( flags & UV_HANDLE_BOUND ) { 19. slen = sizeof ( saddr ); 20. memset ( & saddr , 0 , sizeof ( saddr )); 21. // \u83b7\u53d6fd\u5bf9\u5e94\u7684socket\u4fe1\u606f\uff0c\u6bd4\u5982IP\uff0c\u7aef\u53e3\uff0c\u53ef\u80fd\u6ca1\u6709 22. getsockname ( uv__stream_fd ( handle ), 23. ( struct sockaddr * ) & saddr , 24. & slen ); 25. 26. // \u7ed1\u5b9a\u5230socket\u4e2d\uff0c\u5982\u679c\u6ca1\u6709\u5219\u7ed1\u5b9a\u5230\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740 27. bind ( uv__stream_fd ( handle ),( struct sockaddr * ) & saddr , slen ); 28. } 29. 30. return 0 ; 31. } \u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u662f\u5728Libuv\u7533\u8bf7\u4e00\u4e2asocket\u7684\u903b\u8f91\uff0c\u53e6\u5916\u5b83\u8fd8\u652f\u6301\u65b0\u5efa\u7684socket\uff0c\u53ef\u4ee5\u7ed1\u5b9a\u5230\u4e00\u4e2a\u7528\u6237\u8bbe\u7f6e\u7684\uff0c\u6216\u8005\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740\u3002\u4e0d\u8fc7Libuv\u5e76\u4e0d\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u662f\u53c8\u5c01\u88c5\u4e86\u4e00\u5c42\u3002 1. // \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\uff0c\u5982\u679c\u6709\u5219\u4fee\u6539\u6d41\u7684\u914d\u7f6e 2. static int maybe_new_socket ( uv_tcp_t * handle , 3. int domain , 4. unsigned long flags ) { 5. struct sockaddr_storage saddr ; 6. socklen_t slen ; 7. 8. // \u5df2\u7ecf\u6709fd\u4e86 9. if ( uv__stream_fd ( handle ) != -1 ) { 10. // \u8be5\u6d41\u9700\u8981\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 11. if ( flags & UV_HANDLE_BOUND ) { 12. /* 13. \u6d41\u662f\u5426\u5df2\u7ecf\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u4e86\u3002handle\u7684flag\u662f\u5728 14. new_socket\u91cc\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8fd9\u4e2a\u6807\u8bb0\u8bf4\u660e\u5df2\u7ecf\u6267\u884c\u8fc7\u7ed1\u5b9a\u4e86\uff0c 15. \u76f4\u63a5\u66f4\u65b0flags\u5c31\u884c\u3002 16. */ 17. if ( handle -> flags & UV_HANDLE_BOUND ) { 18. handle -> flags |= flags ; 19. return 0 ; 20. } 21. // \u6709fd\uff0c\u4f46\u662f\u53ef\u80fd\u8fd8\u6ca1\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 22. slen = sizeof ( saddr ); 23. memset ( & saddr , 0 , sizeof ( saddr )); 24. // \u83b7\u53d6socket\u7ed1\u5b9a\u5230\u7684\u5730\u5740 25. if ( getsockname ( uv__stream_fd ( handle ), 26. ( struct sockaddr * ) & saddr , 27. & slen )) 28. return UV__ERR ( errno ); 29. // \u7ed1\u5b9a\u8fc7\u4e86socket\u5730\u5740\uff0c\u5219\u66f4\u65b0flags\u5c31\u884c 30. if (( saddr . ss_family == AF_INET6 && 31. (( struct sockaddr_in6 * ) & saddr ) -> sin6_port != 0 ) || 32. ( saddr . ss_family == AF_INET && 33. (( struct sockaddr_in * ) & saddr ) -> sin_port != 0 )) { 34. handle -> flags |= flags ; 35. return 0 ; 36. } 37. // \u6ca1\u7ed1\u5b9a\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff0cbind\u4e2d\u5b9e\u73b0 38. if ( bind ( uv__stream_fd ( handle ), 39. ( struct sockaddr * ) & saddr , 40. slen )) 41. return UV__ERR ( errno ); 42. } 43. 44. handle -> flags |= flags ; 45. return 0 ; 46. } 47. // \u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41 48. return new_socket ( handle , domain , flags ); 49. } maybe_new_socket\u51fd\u6570\u7684\u903b\u8f91\u5206\u652f\u5f88\u591a\uff0c\u4e3b\u8981\u5982\u4e0b 1 \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5173\u8054\u5230fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41\u4e0a 2 \u5982\u679c\u6d41\u5df2\u7ecf\u5173\u8054\u4e86\u4e00\u4e2afd\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u5df2\u7ecf\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff08Libuv\u4f1a\u8bbe\u7f6eUV_HANDLE_BOUND\u6807\u8bb0\uff0c\u7528\u6237\u4e5f\u53ef\u80fd\u662f\u76f4\u63a5\u8c03bind\u51fd\u6570\u7ed1\u5b9a\u4e86\uff09\u3002\u5219\u4e0d\u9700\u8981\u518d\u6b21\u7ed1\u5b9a\uff0c\u66f4\u65b0flags\u5c31\u884c\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u8fd9\u65f6\u5019\u901a\u8fc7getsocketname\u5224\u65ad\u7528\u6237\u662f\u5426\u81ea\u5df1\u901a\u8fc7bind\u51fd\u6570\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff0c\u662f\u7684\u8bdd\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6267\u884c\u7ed1\u5b9a\u64cd\u4f5c\u3002\u5426\u5219\u968f\u673a\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u3002 \u4ee5\u4e0a\u4e24\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u4e3b\u8981\u662f\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed9socket\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u770b\u4e00\u4e0b\u8fde\u63a5\u6d41\u7684\u5b9e\u73b0\u3002 1. int uv__tcp_connect ( uv_connect_t * req , 2. uv_tcp_t * handle , 3. const struct sockaddr * addr , 4. unsigned int addrlen , 5. uv_connect_cb cb ) { 6. int err ; 7. int r ; 8. 9. // \u5df2\u7ecf\u53d1\u8d77\u4e86connect\u4e86 10. if ( handle -> connect_req != NULL ) 11. return UV_EALREADY ; 12. // \u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd 13. err = maybe_new_socket ( handle , addr -> sa_family , 14. UV_HANDLE_READABLE | UV_HANDLE_WRITABLE 15. if ( err ) 16. return err ; 17. handle -> delayed_error = 0 ; 18. 19. do { 20. // \u6e05\u9664\u5168\u5c40\u9519\u8bef\u53d8\u91cf\u7684\u503c 21. errno = 0 ; 22. // \u975e\u963b\u585e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b 23. r = connect ( uv__stream_fd ( handle ), addr , addrlen ); 24. } while ( r == -1 && errno == EINTR ); 25. 26. if ( r == -1 && errno != 0 ) { 27. // \u4e09\u6b21\u63e1\u624b\u8fd8\u6ca1\u6709\u5b8c\u6210 28. if ( errno == EINPROGRESS ) 29. ; /* not an error */ 30. else if ( errno == ECONNREFUSED ) 31. // \u5bf9\u65b9\u62d2\u7edd\u5efa\u7acb\u8fde\u63a5\uff0c\u5ef6\u8fdf\u62a5\u9519 32. handle -> delayed_error = UV__ERR ( errno ); 33. else 34. // \u76f4\u63a5\u62a5\u9519 35. return UV__ERR ( errno ); 36. } 37. // \u521d\u59cb\u5316\u4e00\u4e2a\u8fde\u63a5\u578brequest\uff0c\u5e76\u8bbe\u7f6e\u67d0\u4e9b\u5b57\u6bb5 38. uv__req_init ( handle -> loop , req , UV_CONNECT ); 39. req -> cb = cb ; 40. req -> handle = ( uv_stream_t * ) handle ; 41. QUEUE_INIT ( & req -> queue ); 42. // \u8fde\u63a5\u8bf7\u6c42 43. handle -> connect_req = req ; 44. // \u6ce8\u518c\u5230Libuv\u89c2\u5bdf\u8005\u961f\u5217 45. uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); 46. // \u8fde\u63a5\u51fa\u9519\uff0c\u63d2\u5165pending\u961f\u5c3e 47. if ( handle -> delayed_error ) 48. uv__io_feed ( handle -> loop , & handle -> io_watcher ); 49. 50. return 0 ; 51. } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\uff0c\u5927\u81f4\u5982\u4e0b 1 \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002 2 \u6839\u636e\u7ed9\u5b9a\u7684\u670d\u52a1\u5668\u5730\u5740\uff0c\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\uff0c\u975e\u963b\u585e\u7684\uff0c\u4f1a\u76f4\u63a5\u8fd4\u56de\u7ee7\u7eed\u6267\u884c\uff0c\u4e0d\u4f1a\u7b49\u5230\u4e09\u6b21\u63e1\u624b\u5b8c\u6210\u3002 3 \u5f80\u6d41\u4e0a\u6302\u8f7d\u4e00\u4e2aconnect\u578b\u7684\u8bf7\u6c42\u3002 4 \u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u5199\u3002\u7136\u540e\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u3002\u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u65f6\u5019\uff08\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\uff09\uff0c\u5c31\u4f1a\u6267\u884ccb\u56de\u8c03\u3002 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cuv__stream_io\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1. if ( stream -> connect_req ) { 2. uv__stream_connect ( stream ); 3. return ; 4. } \u6211\u4eec\u7ee7\u7eed\u770buv__stream_connect\u3002 1. static void uv__stream_connect ( uv_stream_t * stream ) { 2. int error ; 3. uv_connect_t * req = stream -> connect_req ; 4. socklen_t errorsize = sizeof ( int ); 5. // \u8fde\u63a5\u51fa\u9519 6. if ( stream -> delayed_error ) { 7. error = stream -> delayed_error ; 8. stream -> delayed_error = 0 ; 9. } else { 10. // \u8fd8\u662f\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u4e0d\u662f\u51fa\u9519\u4e86 11. getsockopt ( uv__stream_fd ( stream ), 12. SOL_SOCKET , 13. SO_ERROR , 14. & error , 15. & errorsize ); 16. error = UV__ERR ( error ); 17. } 18. // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\uff0c\u5148\u8fd4\u56de\uff0c\u7b49\u5f85\u4e0b\u6b21\u53ef\u5199\u4e8b\u4ef6\u7684\u89e6\u53d1 19. if ( error == UV__ERR ( EINPROGRESS )) 20. return ; 21. // \u6e05\u7a7a 22. stream -> connect_req = NULL ; 23. uv__req_unregister ( stream -> loop , req ); 24. /* 25. \u8fde\u63a5\u51fa\u9519\u5219\u6ce8\u9500\u4e4b\u524d\u6ce8\u518c\u7684\u7b49\u5f85\u53ef\u5199\u961f\u5217\uff0c 26. \u8fde\u63a5\u6210\u529f\u5982\u679c\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u4e5f\u6ce8\u9500\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u9700\u8981\u5199\u7684\u65f6\u5019\u518d\u6ce8\u518c 27. */ 28. if ( error < 0 || QUEUE_EMPTY ( & stream -> write_queue )) { 29. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); 30. } 31. // \u6267\u884c\u56de\u8c03\uff0c\u901a\u77e5\u4e0a\u5c42\u8fde\u63a5\u7ed3\u679c 32. if ( req -> cb ) 33. req -> cb ( req , error ); 34. 35. if ( uv__stream_fd ( stream ) == -1 ) 36. return ; 37. // \u8fde\u63a5\u5931\u8d25\uff0c\u6e05\u7a7a\u5f85\u5199\u7684\u6570\u636e\u548c\u6267\u884c\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 38. if ( error < 0 ) { 39. uv__stream_flush_write_queue ( stream , UV_ECANCELED ); 40. uv__write_callbacks ( stream ); 41. } 42. } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\u662f 1\u53d1\u8d77\u975e\u963b\u585e\u5f0f\u8fde\u63a5 2 \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 3 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u628a\u8fde\u63a5\u7ed3\u679c\u544a\u8bc9\u8c03\u7528\u65b9 4 \u8fde\u63a5\u6210\u529f\u5219\u53d1\u9001\u5199\u961f\u5217\u7684\u6570\u636e\uff0c\u8fde\u63a5\u5931\u8d25\u5219\u6e05\u9664\u5199\u961f\u5217\u7684\u6570\u636e\u5e76\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u6709\u7684\u8bdd\uff09\u3002 5.8 \u76d1\u542c\u6d41 \u00b6 \u76d1\u542c\u6d41\u662f\u9488\u5bf9TCP\u6216Unix\u57df\u7684\uff0c\u4e3b\u8981\u662f\u628a\u4e00\u4e2asocket\u53d8\u6210listen\u72b6\u6001\u3002\u5e76\u4e14\u8bbe\u7f6e\u4e00\u4e9b\u5c5e\u6027\u3002 1. int uv_tcp_listen ( uv_tcp_t * tcp , int backlog , uv_connection_cb cb ) { 2. static int single_accept = -1 ; 3. unsigned long flags ; 4. int err ; 5. 6. if ( tcp -> delayed_error ) 7. return tcp -> delayed_error ; 8. // \u662f\u5426\u8bbe\u7f6e\u4e86\u4e0d\u8fde\u7eedaccept\u3002\u9ed8\u8ba4\u662f\u8fde\u7eedaccept\u3002 9. if ( single_accept == -1 ) { 10. const char * val = getenv ( \"UV_TCP_SINGLE_ACCEPT\" ); 11. single_accept = ( val != NULL && atoi ( val ) != 0 ); 12. } 13. // \u8bbe\u7f6e\u4e0d\u8fde\u7eedaccept 14. if ( single_accept ) 15. tcp -> flags |= UV_HANDLE_TCP_SINGLE_ACCEPT ; 16. 17. flags = 0 ; 18. /* 19. \u53ef\u80fd\u8fd8\u6ca1\u6709\u7528\u4e8elisten\u7684fd\uff0csocket\u5730\u5740\u7b49\u3002 20. \u8fd9\u91cc\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 21. \uff08\u5982\u679c\u8c03listen\u4e4b\u524d\u6ca1\u6709\u8c03bind\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff09 22. */ 23. err = maybe_new_socket ( tcp , AF_INET , flags ); 24. if ( err ) 25. return err ; 26. // \u8bbe\u7f6efd\u4e3alisten\u72b6\u6001 27. if ( listen ( tcp -> io_watcher . fd , backlog )) 28. return UV__ERR ( errno ); 29. // \u5efa\u7acb\u8fde\u63a5\u540e\u7684\u4e1a\u52a1\u56de\u8c03 30. tcp -> connection_cb = cb ; 31. tcp -> flags |= UV_HANDLE_BOUND ; 32. // \u8bbe\u7f6eio\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u7531epoll\u76d1\u542c\u5230\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c 33. tcp -> io_watcher . cb = uv__server_io ; 34. /* 35. \u63d2\u5165\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u589e\u52a0\u5230epoll\uff0c 36. Poll IO\u9636\u6bb5\u518d\u904d\u5386\u89c2\u5bdf\u8005\u961f\u5217\u8fdb\u884c\u5904\u7406\uff08epoll_ctl\uff09 37. */ 38. uv__io_start ( tcp -> loop , & tcp -> io_watcher , POLLIN ); 39. 40. return 0 ; 41. } \u76d1\u542c\u6d41\u7684\u903b\u8f91\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4f46\u662f\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u6d41\u5bf9\u7684fd\u6539\u6210listen\u72b6\u6001\uff0c\u8fd9\u6837\u6d41\u5c31\u53ef\u4ee5\u63a5\u6536\u8fde\u63a5\u8bf7\u6c42\u4e86\u3002\u63a5\u7740\u8bbe\u7f6e\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u6700\u540e\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230\u4e8b\u4ef6\u5faa\u73af\u3002\u7b49\u5f85\u8fde\u63a5\u5230\u6765\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u3002uv__server_io\u518d\u6267\u884cconnection_cb\u3002\u76d1\u542c\u6d41\u548c\u5176\u5b83\u6d41\u6709\u4e00\u4e2a\u533a\u522b\u662f\uff0c\u5f53IO\u89c2\u5bdf\u8005\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u76d1\u542c\u6d41\u6267\u884c\u7684\u56de\u8c03\u662fuv__server_io\u51fd\u6570\u3002\u800c\u5176\u5b83\u6d41\u662f\u5728uv__stream_io\u91cc\u7edf\u4e00\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fde\u63a5\u5230\u6765\u6216\u8005Unix\u57df\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1. void uv__server_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { 2. uv_stream_t * stream ; 3. int err ; 4. stream = container_of ( w , uv_stream_t , io_watcher ); 5. // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 6. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); 7. while ( uv__stream_fd ( stream ) != -1 ) { 8. /* 9. \u901a\u8fc7accept\u62ff\u5230\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684fd\uff0c\u6211\u4eec\u770b\u5230\u8fd9\u4e2a 10. fd\u548c\u670d\u52a1\u5668\u7684fd\u662f\u4e0d\u4e00\u6837\u7684 11. */ 12. err = uv__accept ( uv__stream_fd ( stream )); 13. // \u9519\u8bef\u5904\u7406 14. if ( err < 0 ) { 15. /* 16. uv__stream_fd(stream)\u5bf9\u5e94\u7684fd\u662f\u975e\u963b\u585e\u7684\uff0c 17. \u8fd4\u56de\u8fd9\u4e2a\u9519\u8bf4\u660e\u6ca1\u6709\u8fde\u63a5\u53ef\u7528accept\u4e86\uff0c\u76f4\u63a5\u8fd4\u56de 18. */ 19. if ( err == - EAGAIN || err == - EWOULDBLOCK ) 20. return ; /* Not an error. */ 21. if ( err == - ECONNABORTED ) 22. continue ; 23. // \u8fdb\u7a0b\u7684\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u770b\u662f\u5426\u6709\u5907\u7528\u7684 24. if ( err == - EMFILE || err == - ENFILE ) { 25. err = uv__emfile_trick ( loop , uv__stream_fd ( stream )); 26. if ( err == - EAGAIN || err == - EWOULDBLOCK ) 27. break ; 28. } 29. // \u53d1\u751f\u9519\u8bef\uff0c\u6267\u884c\u56de\u8c03 30. stream -> connection_cb ( stream , err ); 31. continue ; 32. } 33. // \u8bb0\u5f55\u62ff\u5230\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684fd 34. stream -> accepted_fd = err ; 35. // \u6267\u884c\u4e0a\u4f20\u56de\u8c03 36. stream -> connection_cb ( stream , 0 ); 37. /* 38. stream->accepted_fd\u4e3a-1\u8bf4\u660e\u5728\u56de\u8c03connection_cb\u91cc\u5df2\u7ecf\u6d88\u8d39 39. \u4e86 accepted_fd\uff0c\u5426\u5219\u5148\u6ce8\u9500\u670d\u52a1\u5668\u5728epoll\u4e2d\u7684fd\u7684\u8bfb\u4e8b\u4ef6\uff0c\u7b49 40. \u5f85\u6d88\u8d39\u540e\u518d\u6ce8\u518c\uff0c\u5373\u4e0d\u518d\u5904\u7406\u8bf7\u6c42\u4e86 41. */ 42. if ( stream -> accepted_fd != -1 ) { 43. /* 44. The user hasn't yet accepted called uv_accept() 45. */ 46. uv__io_stop ( loop , & stream -> io_watcher , POLLIN ); 47. return ; 48. } 49. /* 50. \u662fTCP\u7c7b\u578b\u7684\u6d41\u5e76\u4e14\u8bbe\u7f6e\u6bcf\u6b21\u53eaaccpet\u4e00\u4e2a\u8fde\u63a5\uff0c\u5219\u5b9a\u65f6\u963b\u585e\uff0c 51. \u88ab\u5524\u9192\u540e\u518daccept\uff0c\u5426\u5219\u4e00\u76f4accept\uff08\u5982\u679c\u7528\u6237\u5728connect\u56de 52. \u8c03\u91cc\u6d88\u8d39\u4e86accept_fd\u7684\u8bdd\uff09\uff0c\u5b9a\u65f6\u963b\u585e\u7528\u4e8e\u591a\u8fdb\u7a0b\u7ade\u4e89\u5904\u7406\u8fde\u63a5 53. */ 54. if ( stream -> type == UV_TCP && 55. ( stream -> flags & UV_TCP_SINGLE_ACCEPT )) { 56. struct timespec timeout = { 0 , 1 }; 57. nanosleep ( & timeout , NULL ); 58. } 59. } 60. } \u6211\u4eec\u770b\u5230\u8fde\u63a5\u5230\u6765\u65f6\uff0cLibuv\u4f1a\u4ece\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u961f\u5217\u4e2d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002\u5728connection_cb\u56de\u8c03\u91cc\uff0c\u9700\u8981uv_accept\u6d88\u8d39accpet_fd\u3002 1. int uv_accept ( uv_stream_t * server , uv_stream_t * client ) { 2. int err ; 3. switch ( client -> type ) { 4. case UV_NAMED_PIPE : 5. case UV_TCP : 6. // \u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230client 7. err = uv__stream_open ( client , 8. server -> accepted_fd , 9. UV_STREAM_READABLE 10. | UV_STREAM_WRITABLE ); 11. if ( err ) { 12. uv__close ( server -> accepted_fd ); 13. goto done ; 14. } 15. break ; 16. 17. case UV_UDP : 18. err = uv_udp_open (( uv_udp_t * ) client , 19. server -> accepted_fd ); 20. if ( err ) { 21. uv__close ( server -> accepted_fd ); 22. goto done ; 23. } 24. break ; 25. default : 26. return - EINVAL ; 27. } 28. client -> flags |= UV_HANDLE_BOUND ; 29. 30. done : 31. // \u975e\u7a7a\u5219\u7ee7\u7eed\u653e\u4e00\u4e2a\u5230accpet_fd\u4e2d\u7b49\u5f85accept,\u7528\u4e8e\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 32. if ( server -> queued_fds != NULL ) { 33. uv__stream_queued_fds_t * queued_fds ; 34. queued_fds = server -> queued_fds ; 35. // \u628a\u7b2c\u4e00\u4e2a\u8d4b\u503c\u5230accept_fd 36. server -> accepted_fd = queued_fds -> fds [ 0 ]; 37. /* 38. offset\u51cf\u53bb\u4e00\u4e2a\u5355\u4f4d\uff0c\u5982\u679c\u6ca1\u6709\u4e86\uff0c\u5219\u91ca\u653e\u5185\u5b58\uff0c 39. \u5426\u5219\u9700\u8981\u628a\u540e\u9762\u7684\u5f80\u524d\u632a\uff0coffset\u6267\u884c\u6700\u540e\u4e00\u4e2a 40. */ 41. if ( -- queued_fds -> offset == 0 ) { 42. uv__free ( queued_fds ); 43. server -> queued_fds = NULL ; 44. } else { 45. memmove ( queued_fds -> fds , 46. queued_fds -> fds + 1 , 47. queued_fds -> offset * sizeof ( * queued_fds -> fds )); 48. } 49. } else { 50. // \u6ca1\u6709\u6392\u961f\u7684fd\u4e86\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85accept\u65b0\u7684fd 51. server -> accepted_fd = -1 ; 52. if ( err == 0 ) 53. uv__io_start ( server -> loop , & server -> io_watcher , POLLIN ); 54. } 55. return err ; 56. } client\u662f\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u8fdb\u884c\u901a\u4fe1\u7684\u6d41\uff0caccept\u5c31\u662f\u628aaccept_fd\u4fdd\u5b58\u5230client\u4e2d\uff0cclient\u5c31\u53ef\u4ee5\u901a\u8fc7fd\u548c\u5bf9\u7aef\u8fdb\u884c\u901a\u4fe1\u4e86\u3002\u6d88\u8d39\u5b8caccept_fd\u540e\uff0c\u5982\u679c\u8fd8\u6709\u5f85\u5904\u7406\u7684fd\u7684\u8bdd\uff0c\u9700\u8981\u8865\u5145\u4e00\u4e2a\u5230accept_fd\uff08\u9488\u5bf9Unix\u57df\uff09\uff0c\u5176\u5b83\u7684\u7ee7\u7eed\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u5f85\u5904\u7406\u7684fd\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7ee7\u7eed\u5904\u7406\u65b0\u7684\u8fde\u63a5\u3002 5.9 \u9500\u6bc1\u6d41 \u00b6 \u5f53\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4e00\u4e2a\u6d41\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f1a\u9996\u5148\u8c03\u7528uv_close\u5173\u95ed\u8fd9\u4e2a\u6d41\uff0c\u5173\u95ed\u6d41\u53ea\u662f\u6ce8\u9500\u4e86\u4e8b\u4ef6\u548c\u91ca\u653e\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8c03\u7528uv_close\u4e4b\u540e\uff0c\u6d41\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u5c31\u4f1a\u88ab\u52a0\u5165\u5230closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u6267\u884c\u9500\u6bc1\u6d41\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4e22\u5f03\u8fd8\u6ca1\u6709\u5199\u5b8c\u6210\u7684\u6570\u636e\uff0c\u6267\u884c\u5bf9\u5e94\u6d41\u7684\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u51fd\u6570uv__stream_destroy\u3002 1. void uv__stream_destroy ( uv_stream_t * stream ) { 2. // \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u6267\u884c\u56de\u8c03 3. if ( stream -> connect_req ) { 4. uv__req_unregister ( stream -> loop , stream -> connect_req ); 5. stream -> connect_req -> cb ( stream -> connect_req , - ECANCELED ); 6. stream -> connect_req = NULL ; 7. } 8. // \u4e22\u5f03\u5f85\u5199\u7684\u6570\u636e\uff0c\u5982\u679c\u6709\u7684\u8bdd 9. uv__stream_flush_write_queue ( stream , - ECANCELED ); 10. // \u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\uff0c\u8fd9\u91cc\u662f\u5904\u7406\u88ab\u4e22\u5f03\u7684\u6570\u636e 11. uv__write_callbacks ( stream ); 12. // \u6b63\u5728\u5173\u95ed\u6d41\uff0c\u76f4\u63a5\u56de\u8c03 13. if ( stream -> shutdown_req ) { 14. uv__req_unregister ( stream -> loop , stream -> shutdown_req ); 15. stream -> shutdown_req -> cb ( stream -> shutdown_req , - ECANCELED ); 16. stream -> shutdown_req = NULL ; 17. } 18. } \u6211\u4eec\u770b\u5230\uff0c\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0c\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u5f85\u5199\u7684\u6570\u636e\uff0c\u5219\u4f1a\u4e22\u5f03\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__stream_flush_write_queue\u548cuv__write_callbacks\u3002 1. void uv__stream_flush_write_queue ( uv_stream_t * stream , int error ) { 2. uv_write_t * req ; 3. QUEUE * q ; 4. while ( ! QUEUE_EMPTY ( & stream -> write_queue )) { 5. q = QUEUE_HEAD ( & stream -> write_queue ); 6. QUEUE_REMOVE ( q ); 7. req = QUEUE_DATA ( q , uv_write_t , queue ); 8. // \u628a\u9519\u8bef\u5199\u5230\u6bcf\u4e2a\u8bf7\u6c42\u4e2d 9. req -> error = error ; 10. QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); 11. } 12. } uv__stream_flush_write_queue\u4e22\u5f03\u5f85\u5199\u961f\u5217\u4e2d\u7684\u8bf7\u6c42\uff0c\u5e76\u76f4\u63a5\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u3002uv__write_callbacks\u662f\u5199\u5b8c\u6216\u8005\u5199\u51fa\u9519\u65f6\u6267\u884c\u7684\u51fd\u6570\uff0c\u5b83\u9010\u4e2a\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u6bcf\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\uff0c\u5982\u4f55\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u5219\u91ca\u653e\u5185\u5b58\u3002\u5728\u5199\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\uff0c\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\u3002 5.10 \u4e8b\u4ef6\u89e6\u53d1\u7684\u5904\u7406 \u00b6 \u5728\u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u8bfb\u5199\u7b49\u64cd\u4f5c\u90fd\u53ea\u662f\u6ce8\u518c\u4e8b\u4ef6\u5230epoll\uff0c\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c\u7edf\u4e00\u7684\u56de\u8c03\u51fd\u6570uv__stream_io\u3002\u4e0b\u9762\u5217\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u5b9e\u73b0\u5728\u5176\u5b83\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u3002 1. static void uv__stream_io ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. uv_stream_t * stream ; 5. stream = container_of ( w , uv_stream_t , io_watcher ); 6. // \u662f\u8fde\u63a5\u6d41\uff0c\u5219\u6267\u884c\u8fde\u63a5\u5904\u7406\u51fd\u6570 7. if ( stream -> connect_req ) { 8. uv__stream_connect ( stream ); 9. return ; 10. } 11. /* 12. Ignore POLLHUP here. Even it it's set, 13. there may still be data to read. 14. */ 15. // \u53ef\u8bfb\u662f\u89e6\u53d1\uff0c\u5219\u6267\u884c\u8bfb\u5904\u7406 16. if ( events & ( POLLIN | POLLERR | POLLHUP )) 17. uv__read ( stream ); 18. // \u8bfb\u56de\u8c03\u5173\u95ed\u4e86\u6d41 19. if ( uv__stream_fd ( stream ) == -1 ) 20. return ; /* read_cb closed stream. */ 21. /* \u00ac\u00ac 22. POLLHUP\u8bf4\u660e\u5bf9\u7aef\u5173\u95ed\u4e86\uff0c\u5373\u4e0d\u4f1a\u53d1\u751f\u6570\u636e\u8fc7\u6765\u4e86\u3002 23. \u5982\u679c\u6d41\u7684\u6a21\u5f0f\u662f\u6301\u7eed\u8bfb\uff0c 24. 1 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff08\u8bbe\u7f6eUV_STREAM_READ_PARTIAL\uff09\uff0c 25. \u5e76\u4e14\u6ca1\u6709\u8bfb\u5230\u7ed3\u5c3e(\u6ca1\u6709\u8bbe\u7f6eUV_STREAM_READ_EOF)\uff0c 26. \u5219\u76f4\u63a5\u4f5c\u8bfb\u7ed3\u675f\u5904\u7406\uff0c 27. 2 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff0c\u4e0a\u9762\u7684\u8bfb\u56de\u8c03\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c 28. \u5219\u8fd9\u91cc\u5c31\u4e0d\u9700\u8981\u5904\u7406\u4e86 29. 3 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u8fd8\u6ca1\u6709\u6267\u884c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c 30. \u5219\u4e0d\u80fd\u4f5c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5bf9\u7aef\u867d\u7136\u5173\u95ed\u4e86\uff0c\u4f46\u662f\u4e4b 31. \u524d\u7684\u4f20\u8fc7\u6765\u7684\u6570\u636e\u53ef\u80fd\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c 32. 4 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u90a3\u8fd9 33. \u91cc\u4e5f\u4e0d\u9700\u8981\u5904\u7406 34. */ 35. if (( events & POLLHUP ) && 36. ( stream -> flags & UV_STREAM_READING ) && 37. ( stream -> flags & UV_STREAM_READ_PARTIAL ) && 38. ! ( stream -> flags & UV_STREAM_READ_EOF )) { 39. uv_buf_t buf = { NULL , 0 }; 40. uv__stream_eof ( stream , & buf ); 41. } 42. 43. if ( uv__stream_fd ( stream ) == -1 ) 44. return ; /* read_cb closed stream. */ 45. // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 46. if ( events & ( POLLOUT | POLLERR | POLLHUP )) { 47. // \u5199\u6570\u636e 48. uv__write ( stream ); 49. // \u5199\u5b8c\u540e\u505a\u540e\u7f6e\u5904\u7406\uff0c\u91ca\u653e\u5185\u5b58\uff0c\u6267\u884c\u56de\u8c03\u7b49 50. uv__write_callbacks ( stream ); 51. // \u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u5199\u4e8b\u4ef6 52. if ( QUEUE_EMPTY ( & stream -> write_queue )) 53. uv__drain ( stream ); 54. } 55. }","title":"05-Libuv\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#libuv","text":"\u6d41\u7684\u5b9e\u73b0\u5728Libuv\u91cc\u5360\u4e86\u5f88\u5927\u7684\u7bc7\u5e45\uff0c\u662f\u975e\u5e38\u6838\u5fc3\u7684\u903b\u8f91\u3002\u6d41\u7684\u672c\u8d28\u662f\u5c01\u88c5\u4e86\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\uff0c\u4f8b\u5982\u8bfb\u3001\u5199\uff0c\u8fde\u63a5\u3001\u76d1\u542c\u3002\u6211\u4eec\u9996\u5148\u770b\u770b\u6570\u636e\u7ed3\u6784\uff0c\u6d41\u5728Libuv\u91cc\u7528uv_stream_s\u8868\u793a\uff0c\u7ee7\u627f\u4e8euv_handle_s\u3002 1. struct uv_stream_s { 2. // uv_handle_s\u7684\u5b57\u6bb5 3. void * data ; 4. // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af 5. uv_loop_t * loop ; 6. // handle\u7c7b\u578b 7. uv_handle_type type ; 8. // \u5173\u95edhandle\u65f6\u7684\u56de\u8c03 9. uv_close_cb close_cb ; 10. // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217 11. void * handle_queue [ 2 ]; 12. union { 13. int fd ; 14. void * reserved [ 4 ]; 15. } u ; 16. // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684closing\u9636\u6bb5 17. uv_handle_t * next_closing ; 18. // \u5404\u79cd\u6807\u8bb0 19. unsigned int flags ; 20. // \u6d41\u62d3\u5c55\u7684\u5b57\u6bb5 21. /* 22. \u6237\u5199\u5165\u6d41\u7684\u5b57\u8282\u5927\u5c0f\uff0c\u6d41\u7f13\u5b58\u7528\u6237\u7684\u8f93\u5165\uff0c 23. \u7136\u540e\u7b49\u5230\u53ef\u5199\u7684\u65f6\u5019\u624d\u6267\u884c\u771f\u6b63\u7684\u5199 24. */ 25. size_t write_queue_size ; 26. // \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\uff0c\u5185\u5b58\u7531\u7528\u6237\u5b9a\u4e49\uff0c\u7528\u6765\u4fdd\u5b58\u8bfb\u53d6\u7684\u6570\u636e 27. uv_alloc_cb alloc_cb ; 28. // \u8bfb\u56de\u8c03 29. uv_read_cb read_cb ; 30. // \u8fde\u63a5\u8bf7\u6c42\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 31. uv_connect_t * connect_req ; 32. /* 33. \u5173\u95ed\u5199\u7aef\u7684\u65f6\u5019\uff0c\u53d1\u9001\u5b8c\u7f13\u5b58\u7684\u6570\u636e\uff0c 34. \u6267\u884cshutdown_req\u7684\u56de\u8c03\uff08shutdown_req\u5728uv_shutdown\u7684\u65f6\u5019\u8d4b\u503c\uff09 35. */ 36. uv_shutdown_t * shutdown_req ; 37. /* 38. \u6d41\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005 39. */ 40. uv__io_t io_watcher ; 41. // \u7f13\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 42. void * write_queue [ 2 ]; 43. // \u5df2\u7ecf\u5b8c\u6210\u4e86\u6570\u636e\u5199\u5165\u7684\u961f\u5217\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 44. void * write_completed_queue [ 2 ]; 45. // \u6709\u8fde\u63a5\u5230\u6765\u5e76\u4e14\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\uff0c\u6267\u884c\u7684\u56de\u8c03 46. uv_connection_cb connection_cb ; 47. // \u64cd\u4f5c\u6d41\u65f6\u51fa\u9519\u7801 48. int delayed_error ; 49. // accept\u8fd4\u56de\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0 50. int accepted_fd ; 51. // \u540c\u4e0a\uff0c\u7528\u4e8eIPC\u65f6\uff0c\u7f13\u5b58\u591a\u4e2a\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 52. void * queued_fds ; 53. } \u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u6700\u6838\u5fc3\u7684\u5b57\u6bb5\u662fIO\u89c2\u5bdf\u8005\uff0c\u5176\u4f59\u7684\u5b57\u6bb5\u662f\u548c\u6d41\u7684\u6027\u8d28\u76f8\u5173\u7684\u3002IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03\u3002\u6bd4\u5982\u8bfb\u4e00\u4e2a\u6d41\u3001\u5199\u4e00\u4e2a\u6d41\u3001\u5173\u95ed\u4e00\u4e2a\u6d41\u3001\u8fde\u63a5\u4e00\u4e2a\u6d41\u3001\u76d1\u542c\u4e00\u4e2a\u6d41\uff0c\u5728uv_stream_s\u4e2d\u90fd\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u53bb\u652f\u6301\u3002\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u9760IO\u89c2\u5bdf\u8005\u53bb\u9a71\u52a8\u7684\u3002 1 \u8bfb\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u7528\u6237\u7684\u8bfb\u56de\u8c03\u3002 2 \u5199\u4e00\u4e2a\u6d41\uff0c\u5148\u628a\u6570\u636e\u5199\u5230\u6d41\u4e2d\uff0c\u7b49\u5230IO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u771f\u6b63\u7684\u5199\u5165\uff0c\u5e76\u6267\u884c\u7528\u6237\u7684\u5199\u7ed3\u675f\u56de\u8c03\u3002 3 \u5173\u95ed\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u5219\u5148\u5199\u5b8c\uff08\u6bd4\u5982\u53d1\u9001\uff09\u540e\u518d\u6267\u884c\u5173\u95ed\u64cd\u4f5c\uff0c\u63a5\u7740\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 4 \u8fde\u63a5\u6d41\uff0c\u6bd4\u5982\u4f5c\u4e3a\u5ba2\u6237\u7aef\u53bb\u8fde\u63a5\u670d\u52a1\u5668\u3002\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u5efa\u7acb\u4e09\u6b21\u63e1\u624b\u6210\u529f\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 5 \u76d1\u542c\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u6d41\u7684\u5177\u4f53\u5b9e\u73b0","title":"\u7b2c\u4e94\u7ae0 Libuv\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#51","text":"\u5728\u4f7f\u7528uv_stream_t\u4e4b\u524d\u9700\u8981\u9996\u5148\u521d\u59cb\u5316\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u3002 1. void uv__stream_init ( uv_loop_t * loop , 2. uv_stream_t * stream , 3. uv_handle_type type ) { 4. int err ; 5. // \u8bb0\u5f55handle\u7684\u7c7b\u578b 6. uv__handle_init ( loop , ( uv_handle_t * ) stream , type ); 7. stream -> read_cb = NULL ; 8. stream -> alloc_cb = NULL ; 9. stream -> close_cb = NULL ; 10. stream -> connection_cb = NULL ; 11. stream -> connect_req = NULL ; 12. stream -> shutdown_req = NULL ; 13. stream -> accepted_fd = -1 ; 14. stream -> queued_fds = NULL ; 15. stream -> delayed_error = 0 ; 16. QUEUE_INIT ( & stream -> write_queue ); 17. QUEUE_INIT ( & stream -> write_completed_queue ); 18. stream -> write_queue_size = 0 ; 19. /* 20. \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u8fd9\u91cc\u8fd8\u6ca1\u6709\uff0c\u6240\u4ee5\u662f-1\uff09\u548c 21. \u56de\u8c03uv__stream_io\u8bb0\u5f55\u5728io_watcher\u4e0a\uff0cfd\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u7edf\u4e00 22. \u7531uv__stream_io\u51fd\u6570\u5904\u7406\uff0c\u4f46\u4e5f\u4f1a\u6709\u7279\u6b8a\u60c5\u51b5\uff08\u4e0b\u9762\u4f1a\u8bb2\u5230\uff09 23. */ 24. uv__io_init ( & stream -> io_watcher , uv__stream_io , -1 ); 25. } \u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u7684\u903b\u8f91\u5f88\u7b80\u5355\u660e\u4e86\uff0c\u5c31\u662f\u521d\u59cb\u5316\u76f8\u5173\u7684\u5b57\u6bb5\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\u65f6\uff0c\u8bbe\u7f6e\u7684\u5904\u7406\u51fd\u6570\u662fuv__stream_io\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790\u8fd9\u4e2a\u51fd\u6570\u7684\u5177\u4f53\u903b\u8f91\u3002","title":"5.1 \u521d\u59cb\u5316\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#52","text":"26. int uv__stream_open ( uv_stream_t * stream , int fd , int flags ) { 27. // \u8fd8\u6ca1\u6709\u8bbe\u7f6efd\u6216\u8005\u8bbe\u7f6e\u7684\u540c\u4e00\u4e2afd\u5219\u7ee7\u7eed\uff0c\u5426\u5219\u8fd4\u56deUV_EBUSY 28. if ( ! ( stream -> io_watcher . fd == -1 || 29. stream -> io_watcher . fd == fd )) 30. return UV_EBUSY ; 31. // \u8bbe\u7f6e\u6d41\u7684\u6807\u8bb0 32. stream -> flags |= flags ; 33. // \u662fTCP\u6d41\u5219\u53ef\u4ee5\u8bbe\u7f6e\u4e0b\u9762\u7684\u5c5e\u6027 34. if ( stream -> type == UV_TCP ) { 35. // \u5173\u95ednagle\u7b97\u6cd5 36. if (( stream -> flags & UV_HANDLE_TCP_NODELAY ) && 37. uv__tcp_nodelay ( fd , 1 )) 38. return UV__ERR ( errno ); 39. /* 40. \u5f00\u542fkeepalive\u673a\u5236 41. */ 42. if (( stream -> flags & UV_HANDLE_TCP_KEEPALIVE ) && 43. uv__tcp_keepalive ( fd , 1 , 60 )) { 44. return UV__ERR ( errno ); 45. } 46. } 47. /* 48. \u4fdd\u5b58socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d\uff0cLibuv\u4f1a\u5728 49. Poll IO\u9636\u6bb5\u76d1\u542c\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26 50. */ 51. stream -> io_watcher . fd = fd ; 52. return 0 ; 53. } \u6253\u5f00\u4e00\u4e2a\u6d41\uff0c\u672c\u8d28\u4e0a\u5c31\u662f\u7ed9\u8fd9\u4e2a\u6d41\u5173\u8054\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u540e\u7eed\u7684\u64cd\u4f5c\u7684\u65f6\u5019\u90fd\u662f\u57fa\u4e8e\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5c5e\u6027\u7684\u8bbe\u7f6e\u3002","title":"5.2 \u6253\u5f00\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#53","text":"\u6211\u4eec\u5728\u4e00\u4e2a\u6d41\u4e0a\u6267\u884cuv_read_start\u540e\uff0c\u6d41\u7684\u6570\u636e\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u5c31\u4f1a\u901a\u8fc7read_cb\u56de\u8c03\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u8c03\u7528\u65b9\u3002 1. int uv_read_start ( uv_stream_t * stream , 2. uv_alloc_cb alloc_cb , 3. uv_read_cb read_cb ) { 4. // \u6d41\u5df2\u7ecf\u5173\u95ed\uff0c\u4e0d\u80fd\u8bfb 5. if ( stream -> flags & UV_HANDLE_CLOSING ) 6. return UV_EINVAL ; 7. // \u6d41\u4e0d\u53ef\u8bfb\uff0c\u8bf4\u660e\u53ef\u80fd\u662f\u53ea\u5199\u6d41 8. if ( ! ( stream -> flags & UV_HANDLE_READABLE )) 9. return - ENOTCONN ; 10. // \u6807\u8bb0\u6b63\u5728\u8bfb 11. stream -> flags |= UV_HANDLE_READING ; 12. // \u8bb0\u5f55\u8bfb\u56de\u8c03\uff0c\u6709\u6570\u636e\u7684\u65f6\u5019\u4f1a\u6267\u884c\u8fd9\u4e2a\u56de\u8c03 13. stream -> read_cb = read_cb ; 14. // \u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u7528\u4e8e\u5b58\u50a8\u8bfb\u53d6\u7684\u6570\u636e 15. stream -> alloc_cb = alloc_cb ; 16. // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 17. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); 18. // \u6fc0\u6d3bhandle\uff0c\u6709\u6fc0\u6d3b\u7684handle\uff0c\u4e8b\u4ef6\u5faa\u73af\u4e0d\u4f1a\u9000\u51fa 19. uv__handle_start ( stream ); 20. return 0 ; 21. } \u6267\u884cuv_read_start\u672c\u8d28\u4e0a\u662f\u7ed9\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5728epoll\u4e2d\u6ce8\u518c\u4e86\u4e00\u4e2a\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u8bb0\u5f55\u76f8\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u8bfb\u56de\u8c03\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\u3002\u63a5\u7740\u6253\u4e0a\u6b63\u5728\u505a\u8bfb\u53d6\u64cd\u4f5c\u7684\u6807\u8bb0\u3002\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8bfb\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\uff0c\u9664\u4e86\u8bfb\u53d6\u6570\u636e\uff0c\u8fd8\u6709\u4e00\u4e2a\u8bfb\u64cd\u4f5c\u5c31\u662f\u505c\u6b62\u8bfb\u53d6\u3002\u5bf9\u5e94\u7684\u51fd\u6570\u662fuv_read_stop\u3002 1. int uv_read_stop ( uv_stream_t * stream ) { 2. // \u662f\u5426\u6b63\u5728\u6267\u884c\u8bfb\u53d6\u64cd\u4f5c\uff0c\u5982\u679c\u4e0d\u662f\uff0c\u5219\u6ca1\u6709\u5fc5\u8981\u505c\u6b62 3. if ( ! ( stream -> flags & UV_HANDLE_READING )) 4. return 0 ; 5. // \u6e05\u9664\u6b63\u5728\u8bfb\u53d6\u7684\u6807\u8bb0 6. stream -> flags &= ~ UV_HANDLE_READING ; 7. // \u64a4\u9500\u7b49\u5f85\u8bfb\u4e8b\u4ef6 8. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); 9. // \u5bf9\u5199\u4e8b\u4ef6\u4e5f\u4e0d\u611f\u5174\u8da3\uff0c\u505c\u6389handle\u3002\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 10. if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) 11. uv__handle_stop ( stream ); 12. stream -> read_cb = NULL ; 13. stream -> alloc_cb = NULL ; 14. return 0 ; 15. } \u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\uff0c\u5224\u65ad\u6d41\u662f\u5426\u8bbe\u7f6e\u4e86\u53ef\u8bfb\u5c5e\u6027\u3002 1. int uv_is_readable ( const uv_stream_t * stream ) { 2. return !! ( stream -> flags & UV_HANDLE_READABLE ); 3. } \u4e0a\u9762\u7684\u51fd\u6570\u53ea\u662f\u6ce8\u518c\u548c\u6ce8\u9500\u8bfb\u4e8b\u4ef6\uff0c\u5982\u679c\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u81ea\u5df1\u53bb\u8bfb\u53d6\u6570\u636e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u771f\u6b63\u7684\u8bfb\u903b\u8f91 1. static void uv__read ( uv_stream_t * stream ) { 2. uv_buf_t buf ; 3. ssize_t nread ; 4. struct msghdr msg ; 5. char cmsg_space [ CMSG_SPACE ( UV__CMSG_FD_SIZE )]; 6. int count ; 7. int err ; 8. int is_ipc ; 9. // \u6e05\u9664\u8bfb\u53d6\u90e8\u5206\u6807\u8bb0 10. stream -> flags &= ~ UV_STREAM_READ_PARTIAL ; 11. count = 32 ; 12. /* 13. \u6d41\u662fUnix\u57df\u7c7b\u578b\u5e76\u4e14\u7528\u4e8eIPC\uff0cUnix\u57df\u4e0d\u4e00\u5b9a\u7528\u4e8eIPC\uff0c 14. \u7528\u4f5cIPC\u53ef\u4ee5\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 15. */ 16. is_ipc = stream -> type == UV_NAMED_PIPE && 17. (( uv_pipe_t * ) stream ) -> ipc ; 18. // \u8bbe\u7f6e\u4e86\u8bfb\u56de\u8c03\uff0c\u6b63\u5728\u8bfb\uff0ccount\u5927\u4e8e0 19. while ( stream -> read_cb 20. && ( stream -> flags & UV_STREAM_READING ) 21. && ( count -- > 0 )) { 22. buf = uv_buf_init ( NULL , 0 ); 23. // \u8c03\u7528\u8c03\u7528\u65b9\u63d0\u4f9b\u7684\u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e 24. stream -> alloc_cb (( uv_handle_t * ) stream , 64 * 1024 , & buf ); 25. /* 26. \u4e0d\u662fIPC\u5219\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\u5230buf\uff0c\u5426\u5219\u7528recvmsg\u8bfb\u53d6\u6570\u636e 27. \u548c\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 28. */ 29. if ( ! is_ipc ) { 30. do { 31. nread = read ( uv__stream_fd ( stream ), 32. buf . base , 33. buf . len ); 34. } 35. while ( nread < 0 && errno == EINTR ); 36. } else { 37. /* ipc uses recvmsg */ 38. msg . msg_flags = 0 ; 39. msg . msg_iov = ( struct iovec * ) & buf ; 40. msg . msg_iovlen = 1 ; 41. msg . msg_name = NULL ; 42. msg . msg_namelen = 0 ; 43. msg . msg_controllen = sizeof ( cmsg_space ); 44. msg . msg_control = cmsg_space ; 45. do { 46. nread = uv__recvmsg ( uv__stream_fd ( stream ), & msg , 0 ); 47. } 48. while ( nread < 0 && errno == EINTR ); 49. } 50. // \u8bfb\u5931\u8d25 51. if ( nread < 0 ) { 52. // \u8bfb\u7e41\u5fd9 53. if ( errno == EAGAIN || errno == EWOULDBLOCK ) { 54. // \u6267\u884c\u8bfb\u56de\u8c03 55. stream -> read_cb ( stream , 0 , & buf ); 56. } else { 57. /* Error. User should call uv_close(). */ 58. // \u8bfb\u5931\u8d25 59. stream -> read_cb ( stream , - errno , & buf ); 60. } 61. return ; 62. } else if ( nread == 0 ) { 63. // \u8bfb\u5230\u7ed3\u5c3e\u4e86 64. uv__stream_eof ( stream , & buf ); 65. return ; 66. } else { 67. // \u8bfb\u6210\u529f\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u957f\u5ea6 68. ssize_t buflen = buf . len ; 69. /* 70. \u662fIPC\u5219\u89e3\u6790\u8bfb\u53d6\u7684\u6570\u636e\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u89e3\u6790\u51fa\u6765\uff0c 71. \u653e\u5230stream\u7684accepted_fd\u548cqueued_fds\u5b57\u6bb5 72. */ 73. if ( is_ipc ) { 74. err = uv__stream_recv_cmsg ( stream , & msg ); 75. if ( err != 0 ) { 76. stream -> read_cb ( stream , err , & buf ); 77. return ; 78. } 79. } 80. // \u6267\u884c\u8bfb\u56de\u8c03 81. stream -> read_cb ( stream , nread , & buf ); 82. } 83. } 84. } uv_read\u9664\u4e86\u53ef\u4ee5\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\u5916\uff0c\u8fd8\u652f\u6301\u8bfb\u53d6\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u539f\u7406\u3002\u6211\u4eec\u77e5\u9053\uff0c\u7236\u8fdb\u7a0bfork\u51fa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u662f\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5217\u8868\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002 fork\u4e4b\u524d\u5982\u56fe5-1\u6240\u793a\u3002 \u6211\u4eec\u518d\u770b\u4e00\u4e0bfork\u4e4b\u540e\u7684\u7ed3\u6784\u5982\u56fe5-2\u6240\u793a\u3002 \u5982\u679c\u7236\u8fdb\u7a0b\u6216\u8005\u5b50\u8fdb\u7a0b\u5728fork\u4e4b\u540e\u521b\u5efa\u4e86\u65b0\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u90a3\u7236\u5b50\u8fdb\u7a0b\u95f4\u5c31\u4e0d\u80fd\u5171\u4eab\u4e86\uff0c\u5047\u8bbe\u7236\u8fdb\u7a0b\u8981\u628a\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u90a3\u600e\u4e48\u529e\u5462\uff1f\u6839\u636e\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u8981\u505a\u7684\u4e8b\u60c5\uff0c\u4e0d\u4ec5\u4ec5\u662f\u5728\u5b50\u8fdb\u7a0b\u4e2d\u65b0\u5efa\u4e00\u4e2afd\uff0c\u8fd8\u8981\u5efa\u7acb\u8d77fd->file->inode\u7684\u5173\u8054\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u5173\u6ce8\u8fd9\u4e9b\uff0c\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u90fd\u5e2e\u6211\u4eec\u5904\u7406\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7sendmsg\u628a\u60f3\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d1\u9001\u7ed9Unix\u57df\u7684\u53e6\u4e00\u7aef\u3002Unix\u57df\u53e6\u4e00\u7aef\u5c31\u53ef\u4ee5\u901a\u8fc7recvmsg\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4ece\u6570\u636e\u4e2d\u8bfb\u53d6\u51fa\u6765\u3002\u63a5\u7740\u4f7f\u7528uv__stream_recv_cmsg\u51fd\u6570\u4fdd\u5b58\u6570\u636e\u91cc\u89e3\u6790\u51fa\u6765\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1. static int uv__stream_recv_cmsg ( uv_stream_t * stream , 2. struct msghdr * msg ) { 3. struct cmsghdr * cmsg ; 4. // \u904d\u5386msg 5. for ( cmsg = CMSG_FIRSTHDR ( msg ); 6. cmsg != NULL ; 7. cmsg = CMSG_NXTHDR ( msg , cmsg )) { 8. char * start ; 9. char * end ; 10. int err ; 11. void * pv ; 12. int * pi ; 13. unsigned int i ; 14. unsigned int count ; 15. 16. pv = CMSG_DATA ( cmsg ); 17. pi = pv ; 18. start = ( char * ) cmsg ; 19. end = ( char * ) cmsg + cmsg -> cmsg_len ; 20. count = 0 ; 21. while ( start + CMSG_LEN ( count * sizeof ( * pi )) < end ) 22. count ++ ; 23. for ( i = 0 ; i < count ; i ++ ) { 24. /* 25. accepted_fd\u4ee3\u8868\u5f53\u524d\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c 26. \u5982\u679c\u5df2\u7ecf\u6709\u503c\u5219\u5269\u4f59\u63cf\u8ff0\u7b26\u5c31\u901a\u8fc7uv__stream_queue_fd\u6392\u961f 27. \u5982\u679c\u8fd8\u6ca1\u6709\u503c\u5219\u5148\u8d4b\u503c 28. */ 29. if ( stream -> accepted_fd != -1 ) { 30. err = uv__stream_queue_fd ( stream , pi [ i ]); 31. } else { 32. stream -> accepted_fd = pi [ i ]; 33. } 34. } 35. } 36. 37. return 0 ; 38. } uv__stream_recv_cmsg\u4f1a\u4ece\u6570\u636e\u4e2d\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5b58\u5230stream\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5728accepted_fd\uff0c\u5269\u4e0b\u7684\u4f7f\u7528uv__stream_queue_fd\u5904\u7406\u3002 1. struct uv__stream_queued_fds_s { 2. unsigned int size ; 3. unsigned int offset ; 4. int fds [ 1 ]; 5. }; 6. 7. static int uv__stream_queue_fd ( uv_stream_t * stream , int fd ) { 8. uv__stream_queued_fds_t * queued_fds ; 9. unsigned int queue_size ; 10. // \u539f\u6765\u7684\u5185\u5b58 11. queued_fds = stream -> queued_fds ; 12. // \u6ca1\u6709\u5185\u5b58\uff0c\u5219\u5206\u914d 13. if ( queued_fds == NULL ) { 14. // \u9ed8\u8ba48\u4e2a 15. queue_size = 8 ; 16. /* 17. \u4e00\u4e2a\u5143\u6570\u636e\u5185\u5b58+\u591a\u4e2afd\u7684\u5185\u5b58 18. \uff08\u524d\u9762\u52a0*\u4ee3\u8868\u89e3\u5f15\u7528\u540e\u7684\u503c\u7684\u7c7b\u578b\u6240\u5360\u7684\u5185\u5b58\u5927\u5c0f\uff0c 19. \u51cf\u4e00\u662f\u56e0\u4e3auv__stream_queued_fds_t 20. \u7ed3\u6784\u4f53\u672c\u8eab\u6709\u4e00\u4e2a\u7a7a\u95f4\uff09 21. */ 22. queued_fds = uv__malloc (( queue_size - 1 ) * 23. sizeof ( * queued_fds -> fds ) + 24. sizeof ( * queued_fds )); 25. if ( queued_fds == NULL ) 26. return UV_ENOMEM ; 27. // \u5bb9\u91cf 28. queued_fds -> size = queue_size ; 29. // \u5df2\u4f7f\u7528\u4e2a\u6570 30. queued_fds -> offset = 0 ; 31. // \u6307\u5411\u53ef\u7528\u7684\u5185\u5b58 32. stream -> queued_fds = queued_fds ; 33. // \u4e4b\u524d\u7684\u5185\u5b58\u7528\u5b8c\u4e86\uff0c\u6269\u5bb9 34. } else if ( queued_fds -> size == queued_fds -> offset ) { 35. // \u6bcf\u6b21\u52a08\u4e2a 36. queue_size = queued_fds -> size + 8 ; 37. queued_fds = uv__realloc ( queued_fds , 38. ( queue_size - 1 ) * sizeof ( * queued_fds -> fds ) + sizeof ( * queued_fds )); 39. 40. if ( queued_fds == NULL ) 41. return UV_ENOMEM ; 42. // \u66f4\u65b0\u5bb9\u91cf\u5927\u5c0f 43. queued_fds -> size = queue_size ; 44. // \u4fdd\u5b58\u65b0\u7684\u5185\u5b58 45. stream -> queued_fds = queued_fds ; 46. } 47. 48. /* Put fd in a queue */ 49. // \u4fdd\u5b58fd 50. queued_fds -> fds [ queued_fds -> offset ++ ] = fd ; 51. 52. return 0 ; 53. } \u5185\u5b58\u7ed3\u6784\u5982\u56fe5-3\u6240\u793a\u3002 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7ed3\u675f\u540e\u7684\u5904\u7406\uff0c 1. static void uv__stream_eof ( uv_stream_t * stream , 2. const uv_buf_t * buf ) { 3. // \u6253\u4e0a\u8bfb\u7ed3\u675f\u6807\u8bb0 4. stream -> flags |= UV_STREAM_READ_EOF ; 5. // \u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 6. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); 7. // \u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u5219\u505c\u6389handle\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 8. if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) 9. uv__handle_stop ( stream ); 10. uv__stream_osx_interrupt_select ( stream ); 11. // \u6267\u884c\u8bfb\u56de\u8c03 12. stream -> read_cb ( stream , UV_EOF , buf ); 13. // \u6e05\u9664\u6b63\u5728\u8bfb\u6807\u8bb0 14. stream -> flags &= ~ UV_STREAM_READING ; 15. } \u6211\u4eec\u770b\u5230\uff0c\u6d41\u7ed3\u675f\u7684\u65f6\u5019\uff0c\u9996\u5148\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7136\u540e\u901a\u8fc7\u56de\u8c03\u901a\u77e5\u4e0a\u5c42\u3002","title":"5.3 \u8bfb\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#54","text":"\u6211\u4eec\u5728\u6d41\u4e0a\u6267\u884cuv_write\u5c31\u53ef\u4ee5\u5f80\u6d41\u4e2d\u5199\u5165\u6570\u636e\u3002 1. int uv_write ( 2. /* 3. \u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u8bb0\u5f55\u4e86\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u548c\u4fe1\u606f\u3002 4. \u6570\u636e\u6765\u81ea\u4e0b\u9762\u7684const uv_buf_t bufs[] 5. */ 6. uv_write_t * req , 7. // \u5f80\u54ea\u4e2a\u6d41\u5199 8. uv_stream_t * handle , 9. // \u9700\u8981\u5199\u5165\u7684\u6570\u636e 10. const uv_buf_t bufs [], 11. // uv_buf_t\u4e2a\u6570 12. unsigned int nbufs , 13. // \u5199\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 14. uv_write_cb cb 15. ) { 16. return uv_write2 ( req , handle , bufs , nbufs , NULL , cb ); 17. } uv_write\u662f\u76f4\u63a5\u8c03\u7528uv_write2\u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u662fNULL\u3002\u4ee3\u8868\u662f\u4e00\u822c\u7684\u5199\u6570\u636e\uff0c\u4e0d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1. int uv_write2 ( uv_write_t * req , 2. uv_stream_t * stream , 3. const uv_buf_t bufs [], 4. unsigned int nbufs , 5. uv_stream_t * send_handle , 6. uv_write_cb cb ) { 7. int empty_queue ; 8. // \u5f85\u53d1\u9001\u961f\u5217\u662f\u5426\u4e3a\u7a7a 9. empty_queue = ( stream -> write_queue_size == 0 ); 10. // \u6784\u9020\u4e00\u4e2a\u5199\u8bf7\u6c42 11. uv__req_init ( stream -> loop , req , UV_WRITE ); 12. // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 13. req -> cb = cb ; 14. // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u6d41 15. req -> handle = stream ; 16. req -> error = 0 ; 17. // \u9700\u8981\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e5f\u53ef\u4ee5\u662fNULL\u8bf4\u660e\u4e0d\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 18. req -> send_handle = send_handle ; 19. QUEUE_INIT ( & req -> queue ); 20. // bufs\u6307\u5411\u5f85\u5199\u7684\u6570\u636e 21. req -> bufs = req -> bufsml ; 22. // \u590d\u5236\u8c03\u7528\u65b9\u7684\u6570\u636e\u8fc7\u6765 23. memcpy ( req -> bufs , bufs , nbufs * sizeof ( bufs [ 0 ])); 24. // buf\u4e2a\u6570 25. req -> nbufs = nbufs ; 26. // \u5f53\u524d\u5199\u6210\u529f\u7684buf\u7d22\u5f15\uff0c\u9488\u5bf9bufs\u6570\u7ec4 27. req -> write_index = 0 ; 28. // \u5f85\u5199\u7684\u6570\u636e\u5927\u5c0f = \u4e4b\u524d\u7684\u5927\u5c0f + \u672c\u6b21\u5927\u5c0f 29. stream -> write_queue_size += uv__count_bufs ( bufs , nbufs ); 30. // \u63d2\u5165\u5f85\u5199\u961f\u5217 31. QUEUE_INSERT_TAIL ( & stream -> write_queue , & req -> queue ); 32. // \u975e\u7a7a\u8bf4\u660e\u6b63\u5728\u8fde\u63a5\uff0c\u8fd8\u4e0d\u80fd\u5199\uff0c\u6bd4\u5982TCP\u6d41 33. if ( stream -> connect_req ) { 34. /* Still connecting, do nothing. */ 35. } 36. else if ( empty_queue ) { // \u5f53\u524d\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u5199 37. uv__write ( stream ); 38. } 39. else { 40. // \u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u7b49\u5f85\u5199\u4e8b\u4ef6 41. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); 42. uv__stream_osx_interrupt_select ( stream ); 43. } 44. return 0 ; 45. } uv_write2\u7684\u4e3b\u8981\u903b\u8f91\u5c31\u662f\u5c01\u88c5\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u63d2\u5165\u5230\u6d41\u7684\u5f85\u5199\u961f\u5217\u3002\u7136\u540e\u6839\u636e\u5f53\u524d\u6d41\u7684\u60c5\u51b5\u3002\u770b\u662f\u76f4\u63a5\u5199\u5165\u8fd8\u662f\u7b49\u5f85\u4f1a\u518d\u5199\u5165\u3002\u5173\u7cfb\u56fe\u5927\u81f4\u5982\u56fe5-4\u6240\u793a\u3002 uv_write2\u53ea\u662f\u5bf9\u5199\u8bf7\u6c42\u8fdb\u884c\u4e00\u4e9b\u9884\u5904\u7406\uff0c\u771f\u6b63\u6267\u884c\u5199\u7684\u51fd\u6570\u662fuv__write 1. static void uv__write ( uv_stream_t * stream ) { 2. struct iovec * iov ; 3. QUEUE * q ; 4. uv_write_t * req ; 5. int iovmax ; 6. int iovcnt ; 7. ssize_t n ; 8. int err ; 9. 10. start : 11. // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199 12. if ( QUEUE_EMPTY ( & stream -> write_queue )) 13. return ; 14. q = QUEUE_HEAD ( & stream -> write_queue ); 15. req = QUEUE_DATA ( q , uv_write_t , queue ); 16. // \u4ece\u54ea\u91cc\u5f00\u59cb\u5199 17. iov = ( struct iovec * ) & ( req -> bufs [ req -> write_index ]); 18. // \u8fd8\u6709\u591a\u5c11\u6ca1\u5199 19. iovcnt = req -> nbufs - req -> write_index ; 20. // \u6700\u591a\u53ef\u4ee5\u5199\u591a\u5c11 21. iovmax = uv__getiovmax (); 22. // \u53d6\u6700\u5c0f\u503c 23. if ( iovcnt > iovmax ) 24. iovcnt = iovmax ; 25. // \u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 26. if ( req -> send_handle ) { 27. int fd_to_send ; 28. struct msghdr msg ; 29. struct cmsghdr * cmsg ; 30. union { 31. char data [ 64 ]; 32. struct cmsghdr alias ; 33. } scratch ; 34. 35. if ( uv__is_closing ( req -> send_handle )) { 36. err = - EBADF ; 37. goto error ; 38. } 39. // \u5f85\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 40. fd_to_send = uv__handle_fd (( uv_handle_t * ) req -> send_handle ); 41. memset ( & scratch , 0 , sizeof ( scratch )); 42. 43. msg . msg_name = NULL ; 44. msg . msg_namelen = 0 ; 45. msg . msg_iov = iov ; 46. msg . msg_iovlen = iovcnt ; 47. msg . msg_flags = 0 ; 48. 49. msg . msg_control = & scratch . alias ; 50. msg . msg_controllen = CMSG_SPACE ( sizeof ( fd_to_send )); 51. 52. cmsg = CMSG_FIRSTHDR ( & msg ); 53. cmsg -> cmsg_level = SOL_SOCKET ; 54. cmsg -> cmsg_type = SCM_RIGHTS ; 55. cmsg -> cmsg_len = CMSG_LEN ( sizeof ( fd_to_send )); 56. 57. { 58. void * pv = CMSG_DATA ( cmsg ); 59. int * pi = pv ; 60. * pi = fd_to_send ; 61. } 62. 63. do { 64. // \u4f7f\u7528sendmsg\u51fd\u6570\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 65. n = sendmsg ( uv__stream_fd ( stream ), & msg , 0 ); 66. } 67. while ( n == -1 && errno == EINTR ); 68. } else { 69. do { 70. // \u5199\u4e00\u4e2a\u6216\u8005\u5199\u6279\u91cf\u5199 71. if ( iovcnt == 1 ) { 72. n = write ( uv__stream_fd ( stream ), 73. iov [ 0 ]. iov_base , 74. iov [ 0 ]. iov_len ); 75. } else { 76. n = writev ( uv__stream_fd ( stream ), iov , iovcnt ); 77. } 78. } 79. while ( n == -1 && errno == EINTR ); 80. } 81. // \u5199\u5931\u8d25 82. if ( n < 0 ) { 83. /* 84. \u4e0d\u662f\u5199\u7e41\u5fd9\uff0c\u5219\u62a5\u9519\uff0c 85. \u5426\u5219\u5982\u679c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\u6807\u8bb0\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199 86. */ 87. if ( errno != EAGAIN && 88. errno != EWOULDBLOCK && 89. errno != ENOBUFS ) { 90. err = - errno ; 91. goto error ; 92. } else if ( stream -> flags & UV_STREAM_BLOCKING ) { 93. /* If this is a blocking stream, try again. */ 94. goto start ; 95. } 96. } else { 97. // \u5199\u6210\u529f 98. while ( n >= 0 ) { 99. // \u5f53\u524dbuf\u9996\u5730\u5740 100. uv_buf_t * buf = & ( req -> bufs [ req -> write_index ]); 101. // \u5f53\u524dbuf\u7684\u6570\u636e\u957f\u5ea6 102. size_t len = buf -> len ; 103. // \u5c0f\u4e8e\u8bf4\u660e\u5f53\u524dbuf\u8fd8\u6ca1\u6709\u5199\u5b8c\uff08\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c\uff09 104. if (( size_t ) n < len ) { 105. // \u66f4\u65b0\u5f85\u5199\u7684\u9996\u5730\u5740 106. buf -> base += n ; 107. // \u66f4\u65b0\u5f85\u5199\u7684\u6570\u636e\u957f\u5ea6 108. buf -> len -= n ; 109. /* 110. \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6\uff0c\u8fd9\u4e2a\u961f\u5217\u662f\u5f85\u5199\u6570\u636e\u7684 111. \u603b\u957f\u5ea6\uff0c\u7b49\u4e8e\u591a\u4e2abuf\u7684\u548c 112. */ 113. stream -> write_queue_size -= n ; 114. n = 0 ; 115. /* 116. \u8fd8\u6ca1\u5199\u5b8c\uff0c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199\uff0c 117. \u5426\u5219\u9000\u51fa\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6 118. */ 119. if ( stream -> flags & UV_STREAM_BLOCKING ) { 120. goto start ; 121. } else { 122. break ; 123. } 124. } else { 125. /* 126. \u5f53\u524dbuf\u7684\u6570\u636e\u90fd\u5199\u5b8c\u4e86\uff0c\u5219\u66f4\u65b0\u5f85\u5199\u6570\u636e\u7684\u7684\u9996 127. \u5730\u5740\uff0c\u5373\u4e0b\u4e00\u4e2abuf\uff0c\u56e0\u4e3a\u5f53\u524dbuf\u5199\u5b8c\u4e86 128. */ 129. req -> write_index ++ ; 130. // \u66f4\u65b0n\uff0c\u7528\u4e8e\u4e0b\u4e00\u4e2a\u5faa\u73af\u7684\u8ba1\u7b97 131. n -= len ; 132. // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6 133. stream -> write_queue_size -= len ; 134. /* 135. \u7b49\u4e8e\u6700\u540e\u4e00\u4e2abuf\u4e86\uff0c\u8bf4\u660e\u5f85\u5199\u961f\u5217\u7684\u6570\u636e 136. \u90fd\u5199\u5b8c\u4e86 137. */ 138. if ( req -> write_index == req -> nbufs ) { 139. /* 140. \u91ca\u653ebuf\u5bf9\u5e94\u7684\u5185\u5b58\uff0c\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210 141. \u961f\u5217\uff0c\u7136\u540e\u51c6\u5907\u89e6\u53d1\u5199\u5b8c\u6210\u56de\u8c03 142. */ 143. uv__write_req_finish ( req ); 144. return ; 145. } 146. } 147. } 148. } 149. /* 150. \u5199\u6210\u529f\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6\uff0c 151. \u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u7ee7\u7eed\u5199 152. */ 153. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); 154. uv__stream_osx_interrupt_select ( stream ); 155. 156. return ; 157. // \u5199\u51fa\u9519 158. error : 159. // \u8bb0\u5f55\u9519\u8bef 160. req -> error = err ; 161. /* 162. \u91ca\u653e\u5185\u5b58\uff0c\u4e22\u5f03\u6570\u636e\uff0c\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c 163. \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 164. */ 165. uv__write_req_finish ( req ); 166. // \u6ce8\u9500\u5f85\u5199\u4e8b\u4ef6 167. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); 168. // \u5982\u679c\u4e5f\u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5219\u628ahandle\u5173\u95ed 169. if ( ! uv__io_active ( & stream -> io_watcher , POLLIN )) 170. uv__handle_stop ( stream ); 171. uv__stream_osx_interrupt_select ( stream ); 172. } \u6211\u4eec\u770b\u4e00\u4e0b\u4e00\u4e2a\u5199\u8bf7\u6c42\u7ed3\u675f\u540e\uff08\u6210\u529f\u6216\u8005\u5931\u8d25\uff09\uff0cLibuv\u5982\u4f55\u5904\u7406\u7684\u3002\u903b\u8f91\u5728uv__write_req_finish\u51fd\u6570\u3002 1. static void uv__write_req_finish ( uv_write_t * req ) { 2. uv_stream_t * stream = req -> handle ; 3. // \u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 4. QUEUE_REMOVE ( & req -> queue ); 5. // \u5199\u6210\u529f\uff0c\u5e76\u4e14\u5206\u914d\u4e86\u989d\u5916\u7684\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e\uff0c\u89c1uv__write 6. if ( req -> error == 0 ) { 7. if ( req -> bufs != req -> bufsml ) 8. uv__free ( req -> bufs ); 9. req -> bufs = NULL ; 10. } 11. // \u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217 12. QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); 13. /* 14. \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0cLibuv\u5728\u5904\u7406pending\u9636\u6bb5\u65f6, 15. \u4f1a\u89e6\u53d1IO\u89c2\u5bdf\u8005\u7684\u5199\u4e8b\u4ef6 16. */ 17. uv__io_feed ( stream -> loop , & stream -> io_watcher ); 18. } uv__write_req_finish\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355 1\u628a\u8282\u70b9\u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 2 req->bufs != req->bufsml\u4e0d\u76f8\u7b49\u8bf4\u660e\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u9700\u8981\u81ea\u5df1\u91ca\u653e 3\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\uff0c\u5728pending\u8282\u70b9\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff08uv__stream_io\uff09\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv__stream_io\u5982\u4f55\u5904\u7406\u7684\uff0c\u4e0b\u9762\u662f\u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u3002 1. // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 2. if ( events & ( POLLOUT | POLLERR | POLLHUP )) { 3. // \u7ee7\u7eed\u6267\u884c\u5199 4. uv__write ( stream ); 5. // \u5904\u7406\u5199\u6210\u529f\u56de\u8c03 6. uv__write_callbacks ( stream ); 7. // \u5f85\u5199\u961f\u5217\u7a7a\uff0c\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5373\u4e0d\u9700\u8981\u5199\u4e86 8. if ( QUEUE_EMPTY ( & stream -> write_queue )) 9. uv__drain ( stream ); 10. } \u6211\u4eec\u53ea\u5173\u6ce8uv__write_callbacks\u3002 1. static void uv__write_callbacks ( uv_stream_t * stream ) { 2. uv_write_t * req ; 3. QUEUE * q ; 4. // \u5199\u5b8c\u6210\u961f\u5217\u975e\u7a7a 5. while ( ! QUEUE_EMPTY ( & stream -> write_completed_queue )) { 6. q = QUEUE_HEAD ( & stream -> write_completed_queue ); 7. req = QUEUE_DATA ( q , uv_write_t , queue ); 8. QUEUE_REMOVE ( q ); 9. uv__req_unregister ( stream -> loop , req ); 10. // bufs\u7684\u5185\u5b58\u8fd8\u6ca1\u6709\u88ab\u91ca\u653e 11. if ( req -> bufs != NULL ) { 12. // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u5927\u5c0f\uff0c\u5373\u51cf\u53bbreq\u5bf9\u5e94\u7684\u6240\u6709\u6570\u636e\u7684\u5927\u5c0f 13. stream -> write_queue_size -= uv__write_req_size ( req ); 14. /* 15. bufs\u9ed8\u8ba4\u6307\u5411bufsml\uff0c\u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\u65f6\uff0c 16. bufs\u6307\u5411\u65b0\u7533\u8bf7\u7684\u5806\u5185\u5b58\uff0c\u6240\u4ee5\u9700\u8981\u91ca\u653e 17. */ 18. if ( req -> bufs != req -> bufsml ) 19. uv__free ( req -> bufs ); 20. req -> bufs = NULL ; 21. } 22. // \u6267\u884c\u56de\u8c03 23. if ( req -> cb ) 24. req -> cb ( req , req -> error ); 25. } 26. } uv__write_callbacks\u8d1f\u8d23\u66f4\u65b0\u6d41\u7684\u5f85\u5199\u961f\u5217\u5927\u5c0f\u3001\u91ca\u653e\u989d\u5916\u7533\u8bf7\u7684\u5806\u5185\u5b58\u3001\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\u3002","title":"5.4 \u5199\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#55","text":"1. // \u5173\u95ed\u6d41\u7684\u5199\u7aef 2. int uv_shutdown ( uv_shutdown_t * req , 3. uv_stream_t * stream , 4. uv_shutdown_cb cb ) { 5. // \u521d\u59cb\u5316\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u5173\u8054\u7684handle\u662fstream 6. uv__req_init ( stream -> loop , req , UV_SHUTDOWN ); 7. req -> handle = stream ; 8. // \u5173\u95ed\u540e\u6267\u884c\u7684\u56de\u8c03 9. req -> cb = cb ; 10. stream -> shutdown_req = req ; 11. // \u8bbe\u7f6e\u6b63\u5728\u5173\u95ed\u7684\u6807\u8bb0 12. stream -> flags |= UV_HANDLE_SHUTTING ; 13. // \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 14. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); 15. return 0 ; 16. } \u5173\u95ed\u6d41\u7684\u5199\u7aef\u5c31\u662f\u76f8\u5f53\u4e8e\u7ed9\u6d41\u53d1\u9001\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u628a\u8bf7\u6c42\u6302\u8f7d\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5728\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u64cd\u4f5c\u3002\u5728\u5206\u6790\u5199\u6d41\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u63d0\u5230\uff0c\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cuv__drain\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u9664\u6b64\u4e4b\u5916\uff0cuv__drain\u8fd8\u505a\u4e86\u4e00\u4e2a\u4e8b\u60c5\uff0c\u5c31\u662f\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u770b\u5177\u4f53\u7684\u903b\u8f91\u3002 1. static void uv__drain ( uv_stream_t * stream ) { 2. uv_shutdown_t * req ; 3. int err ; 4. // \u64a4\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u56e0\u4e3a\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86 5. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); 6. uv__stream_osx_interrupt_select ( stream ); 7. 8. // \u8bbe\u7f6e\u4e86\u5173\u95ed\u5199\u7aef\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u6267\u884c\u5173\u95ed\u5199\u7aef 9. if (( stream -> flags & UV_HANDLE_SHUTTING ) && 10. ! ( stream -> flags & UV_HANDLE_CLOSING ) && 11. ! ( stream -> flags & UV_HANDLE_SHUT )) { 12. req = stream -> shutdown_req ; 13. stream -> shutdown_req = NULL ; 14. // \u6e05\u9664\u6807\u8bb0 15. stream -> flags &= ~ UV_HANDLE_SHUTTING ; 16. uv__req_unregister ( stream -> loop , req ); 17. 18. err = 0 ; 19. // \u5173\u95ed\u5199\u7aef 20. if ( shutdown ( uv__stream_fd ( stream ), SHUT_WR )) 21. err = UV__ERR ( errno ); 22. // \u6807\u8bb0\u5df2\u5173\u95ed\u5199\u7aef 23. if ( err == 0 ) 24. stream -> flags |= UV_HANDLE_SHUT ; 25. // \u6267\u884c\u56de\u8c03 26. if ( req -> cb != NULL ) 27. req -> cb ( req , err ); 28. } 29. } \u901a\u8fc7\u8c03\u7528shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u6bd4\u5982TCP\u6d41\u53d1\u9001\u5b8c\u6570\u636e\u540e\u53ef\u4ee5\u5173\u95ed\u5199\u7aef\u3002\u4f46\u662f\u4ecd\u7136\u53ef\u4ee5\u8bfb\u3002","title":"5.5 \u5173\u95ed\u6d41\u7684\u5199\u7aef"},{"location":"chapter05-Libuv%E6%B5%81/#56","text":"1. void uv__stream_close ( uv_stream_t * handle ) { 2. unsigned int i ; 3. uv__stream_queued_fds_t * queued_fds ; 4. // \u4ece\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5220\u9664IO\u89c2\u5bdf\u8005\uff0c\u79fb\u51fapending\u961f\u5217 5. uv__io_close ( handle -> loop , & handle -> io_watcher ); 6. // \u505c\u6b62\u8bfb 7. uv_read_stop ( handle ); 8. // \u505c\u6389handle 9. uv__handle_stop ( handle ); 10. // \u4e0d\u53ef\u8bfb\u3001\u5199 11. handle -> flags &= ~ ( UV_HANDLE_READABLE | UV_HANDLE_WRITABLE ); 12. // \u5173\u95ed\u975e\u6807\u51c6\u6d41\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 13. if ( handle -> io_watcher . fd != -1 ) { 14. /* 15. Don't close stdio file descriptors. 16. Nothing good comes from it. 17. */ 18. if ( handle -> io_watcher . fd > STDERR_FILENO ) 19. uv__close ( handle -> io_watcher . fd ); 20. handle -> io_watcher . fd = -1 ; 21. } 22. // \u5173\u95ed\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 23. if ( handle -> accepted_fd != -1 ) { 24. uv__close ( handle -> accepted_fd ); 25. handle -> accepted_fd = -1 ; 26. } 27. // \u540c\u4e0a\uff0c\u8fd9\u662f\u5728\u6392\u961f\u7b49\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 28. if ( handle -> queued_fds != NULL ) { 29. queued_fds = handle -> queued_fds ; 30. for ( i = 0 ; i < queued_fds -> offset ; i ++ ) 31. uv__close ( queued_fds -> fds [ i ]); 32. uv__free ( handle -> queued_fds ); 33. handle -> queued_fds = NULL ; 34. } 35. } \u5173\u95ed\u6d41\u5c31\u662f\u628a\u6d41\u6ce8\u518c\u5728epoll\u7684\u4e8b\u4ef6\u6ce8\u9500\uff0c\u5173\u95ed\u6240\u6301\u6709\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"5.6 \u5173\u95ed\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#57","text":"\u8fde\u63a5\u6d41\u662f\u9488\u5bf9TCP\u548cUnix\u57df\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9996\u5148\u4ecb\u7ecd\u4e00\u4e0b\u4e00\u4e9b\u7f51\u7edc\u7f16\u7a0b\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u9996\u5148\u6211\u4eec\u5148\u8981\u6709\u4e00\u4e2asocket\u3002\u6211\u4eec\u770bLibuv\u4e2d\u5982\u4f55\u65b0\u5efa\u4e00\u4e2asocket\u3002 1. int uv__socket ( int domain , int type , int protocol ) { 2. int sockfd ; 3. int err ; 4. // \u65b0\u5efa\u4e00\u4e2asocket\uff0c\u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u548cLOEXEC\u6807\u8bb0 5. sockfd = socket ( domain , type | SOCK_NONBLOCK | SOCK_CLOEXEC , protocol ); 6. // \u4e0d\u89e6\u53d1SIGPIPE\u4fe1\u53f7\uff0c\u6bd4\u5982\u5bf9\u7aef\u5df2\u7ecf\u5173\u95ed\uff0c\u672c\u7aef\u53c8\u6267\u884c\u5199 7. # if defined ( SO_NOSIGPIPE ) 8. { 9. int on = 1 ; 10. setsockopt ( sockfd , SOL_SOCKET , SO_NOSIGPIPE , & on , sizeof ( on )); 11. } 12. # endif 13. 14. return sockfd ; 15. } \u5728Libuv\u4e2d\uff0csocket\u7684\u6a21\u5f0f\u90fd\u662f\u975e\u963b\u585e\u7684\uff0cuv__socket\u662fLibuv\u4e2d\u7533\u8bf7socket\u7684\u51fd\u6570\uff0c\u4e0d\u8fc7Libuv\u4e0d\u76f4\u63a5\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u800c\u662f\u5c01\u88c5\u4e86\u4e00\u4e0b\u3002 1. /* 2. 1 \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684socket fd 3. 2 \u628afd\u4fdd\u5b58\u5230handle\u91cc\uff0c\u5e76\u6839\u636eflag\u8fdb\u884c\u76f8\u5173\u8bbe\u7f6e 4. 3 \u7ed1\u5b9a\u5230\u672c\u673a\u968f\u610f\u7684\u5730\u5740\uff08\u5982\u679c\u8bbe\u7f6e\u4e86\u8be5\u6807\u8bb0\u7684\u8bdd\uff09 5. */ 6. static int new_socket ( uv_tcp_t * handle , 7. int domain , 8. unsigned long flags ) { 9. struct sockaddr_storage saddr ; 10. socklen_t slen ; 11. int sockfd ; 12. // \u83b7\u53d6\u4e00\u4e2asocket 13. sockfd = uv__socket ( domain , SOCK_STREAM , 0 ); 14. 15. // \u8bbe\u7f6e\u9009\u9879\u548c\u4fdd\u5b58socket\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d 16. uv__stream_open (( uv_stream_t * ) handle , sockfd , flags ); 17. // \u8bbe\u7f6e\u4e86\u9700\u8981\u7ed1\u5b9a\u6807\u8bb0UV_HANDLE_BOUND 18. if ( flags & UV_HANDLE_BOUND ) { 19. slen = sizeof ( saddr ); 20. memset ( & saddr , 0 , sizeof ( saddr )); 21. // \u83b7\u53d6fd\u5bf9\u5e94\u7684socket\u4fe1\u606f\uff0c\u6bd4\u5982IP\uff0c\u7aef\u53e3\uff0c\u53ef\u80fd\u6ca1\u6709 22. getsockname ( uv__stream_fd ( handle ), 23. ( struct sockaddr * ) & saddr , 24. & slen ); 25. 26. // \u7ed1\u5b9a\u5230socket\u4e2d\uff0c\u5982\u679c\u6ca1\u6709\u5219\u7ed1\u5b9a\u5230\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740 27. bind ( uv__stream_fd ( handle ),( struct sockaddr * ) & saddr , slen ); 28. } 29. 30. return 0 ; 31. } \u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u662f\u5728Libuv\u7533\u8bf7\u4e00\u4e2asocket\u7684\u903b\u8f91\uff0c\u53e6\u5916\u5b83\u8fd8\u652f\u6301\u65b0\u5efa\u7684socket\uff0c\u53ef\u4ee5\u7ed1\u5b9a\u5230\u4e00\u4e2a\u7528\u6237\u8bbe\u7f6e\u7684\uff0c\u6216\u8005\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740\u3002\u4e0d\u8fc7Libuv\u5e76\u4e0d\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u662f\u53c8\u5c01\u88c5\u4e86\u4e00\u5c42\u3002 1. // \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\uff0c\u5982\u679c\u6709\u5219\u4fee\u6539\u6d41\u7684\u914d\u7f6e 2. static int maybe_new_socket ( uv_tcp_t * handle , 3. int domain , 4. unsigned long flags ) { 5. struct sockaddr_storage saddr ; 6. socklen_t slen ; 7. 8. // \u5df2\u7ecf\u6709fd\u4e86 9. if ( uv__stream_fd ( handle ) != -1 ) { 10. // \u8be5\u6d41\u9700\u8981\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 11. if ( flags & UV_HANDLE_BOUND ) { 12. /* 13. \u6d41\u662f\u5426\u5df2\u7ecf\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u4e86\u3002handle\u7684flag\u662f\u5728 14. new_socket\u91cc\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8fd9\u4e2a\u6807\u8bb0\u8bf4\u660e\u5df2\u7ecf\u6267\u884c\u8fc7\u7ed1\u5b9a\u4e86\uff0c 15. \u76f4\u63a5\u66f4\u65b0flags\u5c31\u884c\u3002 16. */ 17. if ( handle -> flags & UV_HANDLE_BOUND ) { 18. handle -> flags |= flags ; 19. return 0 ; 20. } 21. // \u6709fd\uff0c\u4f46\u662f\u53ef\u80fd\u8fd8\u6ca1\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 22. slen = sizeof ( saddr ); 23. memset ( & saddr , 0 , sizeof ( saddr )); 24. // \u83b7\u53d6socket\u7ed1\u5b9a\u5230\u7684\u5730\u5740 25. if ( getsockname ( uv__stream_fd ( handle ), 26. ( struct sockaddr * ) & saddr , 27. & slen )) 28. return UV__ERR ( errno ); 29. // \u7ed1\u5b9a\u8fc7\u4e86socket\u5730\u5740\uff0c\u5219\u66f4\u65b0flags\u5c31\u884c 30. if (( saddr . ss_family == AF_INET6 && 31. (( struct sockaddr_in6 * ) & saddr ) -> sin6_port != 0 ) || 32. ( saddr . ss_family == AF_INET && 33. (( struct sockaddr_in * ) & saddr ) -> sin_port != 0 )) { 34. handle -> flags |= flags ; 35. return 0 ; 36. } 37. // \u6ca1\u7ed1\u5b9a\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff0cbind\u4e2d\u5b9e\u73b0 38. if ( bind ( uv__stream_fd ( handle ), 39. ( struct sockaddr * ) & saddr , 40. slen )) 41. return UV__ERR ( errno ); 42. } 43. 44. handle -> flags |= flags ; 45. return 0 ; 46. } 47. // \u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41 48. return new_socket ( handle , domain , flags ); 49. } maybe_new_socket\u51fd\u6570\u7684\u903b\u8f91\u5206\u652f\u5f88\u591a\uff0c\u4e3b\u8981\u5982\u4e0b 1 \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5173\u8054\u5230fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41\u4e0a 2 \u5982\u679c\u6d41\u5df2\u7ecf\u5173\u8054\u4e86\u4e00\u4e2afd\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u5df2\u7ecf\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff08Libuv\u4f1a\u8bbe\u7f6eUV_HANDLE_BOUND\u6807\u8bb0\uff0c\u7528\u6237\u4e5f\u53ef\u80fd\u662f\u76f4\u63a5\u8c03bind\u51fd\u6570\u7ed1\u5b9a\u4e86\uff09\u3002\u5219\u4e0d\u9700\u8981\u518d\u6b21\u7ed1\u5b9a\uff0c\u66f4\u65b0flags\u5c31\u884c\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u8fd9\u65f6\u5019\u901a\u8fc7getsocketname\u5224\u65ad\u7528\u6237\u662f\u5426\u81ea\u5df1\u901a\u8fc7bind\u51fd\u6570\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff0c\u662f\u7684\u8bdd\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6267\u884c\u7ed1\u5b9a\u64cd\u4f5c\u3002\u5426\u5219\u968f\u673a\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u3002 \u4ee5\u4e0a\u4e24\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u4e3b\u8981\u662f\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed9socket\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u770b\u4e00\u4e0b\u8fde\u63a5\u6d41\u7684\u5b9e\u73b0\u3002 1. int uv__tcp_connect ( uv_connect_t * req , 2. uv_tcp_t * handle , 3. const struct sockaddr * addr , 4. unsigned int addrlen , 5. uv_connect_cb cb ) { 6. int err ; 7. int r ; 8. 9. // \u5df2\u7ecf\u53d1\u8d77\u4e86connect\u4e86 10. if ( handle -> connect_req != NULL ) 11. return UV_EALREADY ; 12. // \u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd 13. err = maybe_new_socket ( handle , addr -> sa_family , 14. UV_HANDLE_READABLE | UV_HANDLE_WRITABLE 15. if ( err ) 16. return err ; 17. handle -> delayed_error = 0 ; 18. 19. do { 20. // \u6e05\u9664\u5168\u5c40\u9519\u8bef\u53d8\u91cf\u7684\u503c 21. errno = 0 ; 22. // \u975e\u963b\u585e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b 23. r = connect ( uv__stream_fd ( handle ), addr , addrlen ); 24. } while ( r == -1 && errno == EINTR ); 25. 26. if ( r == -1 && errno != 0 ) { 27. // \u4e09\u6b21\u63e1\u624b\u8fd8\u6ca1\u6709\u5b8c\u6210 28. if ( errno == EINPROGRESS ) 29. ; /* not an error */ 30. else if ( errno == ECONNREFUSED ) 31. // \u5bf9\u65b9\u62d2\u7edd\u5efa\u7acb\u8fde\u63a5\uff0c\u5ef6\u8fdf\u62a5\u9519 32. handle -> delayed_error = UV__ERR ( errno ); 33. else 34. // \u76f4\u63a5\u62a5\u9519 35. return UV__ERR ( errno ); 36. } 37. // \u521d\u59cb\u5316\u4e00\u4e2a\u8fde\u63a5\u578brequest\uff0c\u5e76\u8bbe\u7f6e\u67d0\u4e9b\u5b57\u6bb5 38. uv__req_init ( handle -> loop , req , UV_CONNECT ); 39. req -> cb = cb ; 40. req -> handle = ( uv_stream_t * ) handle ; 41. QUEUE_INIT ( & req -> queue ); 42. // \u8fde\u63a5\u8bf7\u6c42 43. handle -> connect_req = req ; 44. // \u6ce8\u518c\u5230Libuv\u89c2\u5bdf\u8005\u961f\u5217 45. uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); 46. // \u8fde\u63a5\u51fa\u9519\uff0c\u63d2\u5165pending\u961f\u5c3e 47. if ( handle -> delayed_error ) 48. uv__io_feed ( handle -> loop , & handle -> io_watcher ); 49. 50. return 0 ; 51. } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\uff0c\u5927\u81f4\u5982\u4e0b 1 \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002 2 \u6839\u636e\u7ed9\u5b9a\u7684\u670d\u52a1\u5668\u5730\u5740\uff0c\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\uff0c\u975e\u963b\u585e\u7684\uff0c\u4f1a\u76f4\u63a5\u8fd4\u56de\u7ee7\u7eed\u6267\u884c\uff0c\u4e0d\u4f1a\u7b49\u5230\u4e09\u6b21\u63e1\u624b\u5b8c\u6210\u3002 3 \u5f80\u6d41\u4e0a\u6302\u8f7d\u4e00\u4e2aconnect\u578b\u7684\u8bf7\u6c42\u3002 4 \u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u5199\u3002\u7136\u540e\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u3002\u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u65f6\u5019\uff08\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\uff09\uff0c\u5c31\u4f1a\u6267\u884ccb\u56de\u8c03\u3002 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cuv__stream_io\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1. if ( stream -> connect_req ) { 2. uv__stream_connect ( stream ); 3. return ; 4. } \u6211\u4eec\u7ee7\u7eed\u770buv__stream_connect\u3002 1. static void uv__stream_connect ( uv_stream_t * stream ) { 2. int error ; 3. uv_connect_t * req = stream -> connect_req ; 4. socklen_t errorsize = sizeof ( int ); 5. // \u8fde\u63a5\u51fa\u9519 6. if ( stream -> delayed_error ) { 7. error = stream -> delayed_error ; 8. stream -> delayed_error = 0 ; 9. } else { 10. // \u8fd8\u662f\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u4e0d\u662f\u51fa\u9519\u4e86 11. getsockopt ( uv__stream_fd ( stream ), 12. SOL_SOCKET , 13. SO_ERROR , 14. & error , 15. & errorsize ); 16. error = UV__ERR ( error ); 17. } 18. // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\uff0c\u5148\u8fd4\u56de\uff0c\u7b49\u5f85\u4e0b\u6b21\u53ef\u5199\u4e8b\u4ef6\u7684\u89e6\u53d1 19. if ( error == UV__ERR ( EINPROGRESS )) 20. return ; 21. // \u6e05\u7a7a 22. stream -> connect_req = NULL ; 23. uv__req_unregister ( stream -> loop , req ); 24. /* 25. \u8fde\u63a5\u51fa\u9519\u5219\u6ce8\u9500\u4e4b\u524d\u6ce8\u518c\u7684\u7b49\u5f85\u53ef\u5199\u961f\u5217\uff0c 26. \u8fde\u63a5\u6210\u529f\u5982\u679c\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u4e5f\u6ce8\u9500\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u9700\u8981\u5199\u7684\u65f6\u5019\u518d\u6ce8\u518c 27. */ 28. if ( error < 0 || QUEUE_EMPTY ( & stream -> write_queue )) { 29. uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); 30. } 31. // \u6267\u884c\u56de\u8c03\uff0c\u901a\u77e5\u4e0a\u5c42\u8fde\u63a5\u7ed3\u679c 32. if ( req -> cb ) 33. req -> cb ( req , error ); 34. 35. if ( uv__stream_fd ( stream ) == -1 ) 36. return ; 37. // \u8fde\u63a5\u5931\u8d25\uff0c\u6e05\u7a7a\u5f85\u5199\u7684\u6570\u636e\u548c\u6267\u884c\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 38. if ( error < 0 ) { 39. uv__stream_flush_write_queue ( stream , UV_ECANCELED ); 40. uv__write_callbacks ( stream ); 41. } 42. } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\u662f 1\u53d1\u8d77\u975e\u963b\u585e\u5f0f\u8fde\u63a5 2 \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 3 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u628a\u8fde\u63a5\u7ed3\u679c\u544a\u8bc9\u8c03\u7528\u65b9 4 \u8fde\u63a5\u6210\u529f\u5219\u53d1\u9001\u5199\u961f\u5217\u7684\u6570\u636e\uff0c\u8fde\u63a5\u5931\u8d25\u5219\u6e05\u9664\u5199\u961f\u5217\u7684\u6570\u636e\u5e76\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u6709\u7684\u8bdd\uff09\u3002","title":"5.7 \u8fde\u63a5\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#58","text":"\u76d1\u542c\u6d41\u662f\u9488\u5bf9TCP\u6216Unix\u57df\u7684\uff0c\u4e3b\u8981\u662f\u628a\u4e00\u4e2asocket\u53d8\u6210listen\u72b6\u6001\u3002\u5e76\u4e14\u8bbe\u7f6e\u4e00\u4e9b\u5c5e\u6027\u3002 1. int uv_tcp_listen ( uv_tcp_t * tcp , int backlog , uv_connection_cb cb ) { 2. static int single_accept = -1 ; 3. unsigned long flags ; 4. int err ; 5. 6. if ( tcp -> delayed_error ) 7. return tcp -> delayed_error ; 8. // \u662f\u5426\u8bbe\u7f6e\u4e86\u4e0d\u8fde\u7eedaccept\u3002\u9ed8\u8ba4\u662f\u8fde\u7eedaccept\u3002 9. if ( single_accept == -1 ) { 10. const char * val = getenv ( \"UV_TCP_SINGLE_ACCEPT\" ); 11. single_accept = ( val != NULL && atoi ( val ) != 0 ); 12. } 13. // \u8bbe\u7f6e\u4e0d\u8fde\u7eedaccept 14. if ( single_accept ) 15. tcp -> flags |= UV_HANDLE_TCP_SINGLE_ACCEPT ; 16. 17. flags = 0 ; 18. /* 19. \u53ef\u80fd\u8fd8\u6ca1\u6709\u7528\u4e8elisten\u7684fd\uff0csocket\u5730\u5740\u7b49\u3002 20. \u8fd9\u91cc\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 21. \uff08\u5982\u679c\u8c03listen\u4e4b\u524d\u6ca1\u6709\u8c03bind\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff09 22. */ 23. err = maybe_new_socket ( tcp , AF_INET , flags ); 24. if ( err ) 25. return err ; 26. // \u8bbe\u7f6efd\u4e3alisten\u72b6\u6001 27. if ( listen ( tcp -> io_watcher . fd , backlog )) 28. return UV__ERR ( errno ); 29. // \u5efa\u7acb\u8fde\u63a5\u540e\u7684\u4e1a\u52a1\u56de\u8c03 30. tcp -> connection_cb = cb ; 31. tcp -> flags |= UV_HANDLE_BOUND ; 32. // \u8bbe\u7f6eio\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u7531epoll\u76d1\u542c\u5230\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c 33. tcp -> io_watcher . cb = uv__server_io ; 34. /* 35. \u63d2\u5165\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u589e\u52a0\u5230epoll\uff0c 36. Poll IO\u9636\u6bb5\u518d\u904d\u5386\u89c2\u5bdf\u8005\u961f\u5217\u8fdb\u884c\u5904\u7406\uff08epoll_ctl\uff09 37. */ 38. uv__io_start ( tcp -> loop , & tcp -> io_watcher , POLLIN ); 39. 40. return 0 ; 41. } \u76d1\u542c\u6d41\u7684\u903b\u8f91\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4f46\u662f\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u6d41\u5bf9\u7684fd\u6539\u6210listen\u72b6\u6001\uff0c\u8fd9\u6837\u6d41\u5c31\u53ef\u4ee5\u63a5\u6536\u8fde\u63a5\u8bf7\u6c42\u4e86\u3002\u63a5\u7740\u8bbe\u7f6e\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u6700\u540e\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230\u4e8b\u4ef6\u5faa\u73af\u3002\u7b49\u5f85\u8fde\u63a5\u5230\u6765\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u3002uv__server_io\u518d\u6267\u884cconnection_cb\u3002\u76d1\u542c\u6d41\u548c\u5176\u5b83\u6d41\u6709\u4e00\u4e2a\u533a\u522b\u662f\uff0c\u5f53IO\u89c2\u5bdf\u8005\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u76d1\u542c\u6d41\u6267\u884c\u7684\u56de\u8c03\u662fuv__server_io\u51fd\u6570\u3002\u800c\u5176\u5b83\u6d41\u662f\u5728uv__stream_io\u91cc\u7edf\u4e00\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fde\u63a5\u5230\u6765\u6216\u8005Unix\u57df\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1. void uv__server_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { 2. uv_stream_t * stream ; 3. int err ; 4. stream = container_of ( w , uv_stream_t , io_watcher ); 5. // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 6. uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); 7. while ( uv__stream_fd ( stream ) != -1 ) { 8. /* 9. \u901a\u8fc7accept\u62ff\u5230\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684fd\uff0c\u6211\u4eec\u770b\u5230\u8fd9\u4e2a 10. fd\u548c\u670d\u52a1\u5668\u7684fd\u662f\u4e0d\u4e00\u6837\u7684 11. */ 12. err = uv__accept ( uv__stream_fd ( stream )); 13. // \u9519\u8bef\u5904\u7406 14. if ( err < 0 ) { 15. /* 16. uv__stream_fd(stream)\u5bf9\u5e94\u7684fd\u662f\u975e\u963b\u585e\u7684\uff0c 17. \u8fd4\u56de\u8fd9\u4e2a\u9519\u8bf4\u660e\u6ca1\u6709\u8fde\u63a5\u53ef\u7528accept\u4e86\uff0c\u76f4\u63a5\u8fd4\u56de 18. */ 19. if ( err == - EAGAIN || err == - EWOULDBLOCK ) 20. return ; /* Not an error. */ 21. if ( err == - ECONNABORTED ) 22. continue ; 23. // \u8fdb\u7a0b\u7684\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u770b\u662f\u5426\u6709\u5907\u7528\u7684 24. if ( err == - EMFILE || err == - ENFILE ) { 25. err = uv__emfile_trick ( loop , uv__stream_fd ( stream )); 26. if ( err == - EAGAIN || err == - EWOULDBLOCK ) 27. break ; 28. } 29. // \u53d1\u751f\u9519\u8bef\uff0c\u6267\u884c\u56de\u8c03 30. stream -> connection_cb ( stream , err ); 31. continue ; 32. } 33. // \u8bb0\u5f55\u62ff\u5230\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684fd 34. stream -> accepted_fd = err ; 35. // \u6267\u884c\u4e0a\u4f20\u56de\u8c03 36. stream -> connection_cb ( stream , 0 ); 37. /* 38. stream->accepted_fd\u4e3a-1\u8bf4\u660e\u5728\u56de\u8c03connection_cb\u91cc\u5df2\u7ecf\u6d88\u8d39 39. \u4e86 accepted_fd\uff0c\u5426\u5219\u5148\u6ce8\u9500\u670d\u52a1\u5668\u5728epoll\u4e2d\u7684fd\u7684\u8bfb\u4e8b\u4ef6\uff0c\u7b49 40. \u5f85\u6d88\u8d39\u540e\u518d\u6ce8\u518c\uff0c\u5373\u4e0d\u518d\u5904\u7406\u8bf7\u6c42\u4e86 41. */ 42. if ( stream -> accepted_fd != -1 ) { 43. /* 44. The user hasn't yet accepted called uv_accept() 45. */ 46. uv__io_stop ( loop , & stream -> io_watcher , POLLIN ); 47. return ; 48. } 49. /* 50. \u662fTCP\u7c7b\u578b\u7684\u6d41\u5e76\u4e14\u8bbe\u7f6e\u6bcf\u6b21\u53eaaccpet\u4e00\u4e2a\u8fde\u63a5\uff0c\u5219\u5b9a\u65f6\u963b\u585e\uff0c 51. \u88ab\u5524\u9192\u540e\u518daccept\uff0c\u5426\u5219\u4e00\u76f4accept\uff08\u5982\u679c\u7528\u6237\u5728connect\u56de 52. \u8c03\u91cc\u6d88\u8d39\u4e86accept_fd\u7684\u8bdd\uff09\uff0c\u5b9a\u65f6\u963b\u585e\u7528\u4e8e\u591a\u8fdb\u7a0b\u7ade\u4e89\u5904\u7406\u8fde\u63a5 53. */ 54. if ( stream -> type == UV_TCP && 55. ( stream -> flags & UV_TCP_SINGLE_ACCEPT )) { 56. struct timespec timeout = { 0 , 1 }; 57. nanosleep ( & timeout , NULL ); 58. } 59. } 60. } \u6211\u4eec\u770b\u5230\u8fde\u63a5\u5230\u6765\u65f6\uff0cLibuv\u4f1a\u4ece\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u961f\u5217\u4e2d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002\u5728connection_cb\u56de\u8c03\u91cc\uff0c\u9700\u8981uv_accept\u6d88\u8d39accpet_fd\u3002 1. int uv_accept ( uv_stream_t * server , uv_stream_t * client ) { 2. int err ; 3. switch ( client -> type ) { 4. case UV_NAMED_PIPE : 5. case UV_TCP : 6. // \u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230client 7. err = uv__stream_open ( client , 8. server -> accepted_fd , 9. UV_STREAM_READABLE 10. | UV_STREAM_WRITABLE ); 11. if ( err ) { 12. uv__close ( server -> accepted_fd ); 13. goto done ; 14. } 15. break ; 16. 17. case UV_UDP : 18. err = uv_udp_open (( uv_udp_t * ) client , 19. server -> accepted_fd ); 20. if ( err ) { 21. uv__close ( server -> accepted_fd ); 22. goto done ; 23. } 24. break ; 25. default : 26. return - EINVAL ; 27. } 28. client -> flags |= UV_HANDLE_BOUND ; 29. 30. done : 31. // \u975e\u7a7a\u5219\u7ee7\u7eed\u653e\u4e00\u4e2a\u5230accpet_fd\u4e2d\u7b49\u5f85accept,\u7528\u4e8e\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 32. if ( server -> queued_fds != NULL ) { 33. uv__stream_queued_fds_t * queued_fds ; 34. queued_fds = server -> queued_fds ; 35. // \u628a\u7b2c\u4e00\u4e2a\u8d4b\u503c\u5230accept_fd 36. server -> accepted_fd = queued_fds -> fds [ 0 ]; 37. /* 38. offset\u51cf\u53bb\u4e00\u4e2a\u5355\u4f4d\uff0c\u5982\u679c\u6ca1\u6709\u4e86\uff0c\u5219\u91ca\u653e\u5185\u5b58\uff0c 39. \u5426\u5219\u9700\u8981\u628a\u540e\u9762\u7684\u5f80\u524d\u632a\uff0coffset\u6267\u884c\u6700\u540e\u4e00\u4e2a 40. */ 41. if ( -- queued_fds -> offset == 0 ) { 42. uv__free ( queued_fds ); 43. server -> queued_fds = NULL ; 44. } else { 45. memmove ( queued_fds -> fds , 46. queued_fds -> fds + 1 , 47. queued_fds -> offset * sizeof ( * queued_fds -> fds )); 48. } 49. } else { 50. // \u6ca1\u6709\u6392\u961f\u7684fd\u4e86\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85accept\u65b0\u7684fd 51. server -> accepted_fd = -1 ; 52. if ( err == 0 ) 53. uv__io_start ( server -> loop , & server -> io_watcher , POLLIN ); 54. } 55. return err ; 56. } client\u662f\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u8fdb\u884c\u901a\u4fe1\u7684\u6d41\uff0caccept\u5c31\u662f\u628aaccept_fd\u4fdd\u5b58\u5230client\u4e2d\uff0cclient\u5c31\u53ef\u4ee5\u901a\u8fc7fd\u548c\u5bf9\u7aef\u8fdb\u884c\u901a\u4fe1\u4e86\u3002\u6d88\u8d39\u5b8caccept_fd\u540e\uff0c\u5982\u679c\u8fd8\u6709\u5f85\u5904\u7406\u7684fd\u7684\u8bdd\uff0c\u9700\u8981\u8865\u5145\u4e00\u4e2a\u5230accept_fd\uff08\u9488\u5bf9Unix\u57df\uff09\uff0c\u5176\u5b83\u7684\u7ee7\u7eed\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u5f85\u5904\u7406\u7684fd\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7ee7\u7eed\u5904\u7406\u65b0\u7684\u8fde\u63a5\u3002","title":"5.8 \u76d1\u542c\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#59","text":"\u5f53\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4e00\u4e2a\u6d41\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f1a\u9996\u5148\u8c03\u7528uv_close\u5173\u95ed\u8fd9\u4e2a\u6d41\uff0c\u5173\u95ed\u6d41\u53ea\u662f\u6ce8\u9500\u4e86\u4e8b\u4ef6\u548c\u91ca\u653e\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8c03\u7528uv_close\u4e4b\u540e\uff0c\u6d41\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u5c31\u4f1a\u88ab\u52a0\u5165\u5230closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u6267\u884c\u9500\u6bc1\u6d41\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4e22\u5f03\u8fd8\u6ca1\u6709\u5199\u5b8c\u6210\u7684\u6570\u636e\uff0c\u6267\u884c\u5bf9\u5e94\u6d41\u7684\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u51fd\u6570uv__stream_destroy\u3002 1. void uv__stream_destroy ( uv_stream_t * stream ) { 2. // \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u6267\u884c\u56de\u8c03 3. if ( stream -> connect_req ) { 4. uv__req_unregister ( stream -> loop , stream -> connect_req ); 5. stream -> connect_req -> cb ( stream -> connect_req , - ECANCELED ); 6. stream -> connect_req = NULL ; 7. } 8. // \u4e22\u5f03\u5f85\u5199\u7684\u6570\u636e\uff0c\u5982\u679c\u6709\u7684\u8bdd 9. uv__stream_flush_write_queue ( stream , - ECANCELED ); 10. // \u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\uff0c\u8fd9\u91cc\u662f\u5904\u7406\u88ab\u4e22\u5f03\u7684\u6570\u636e 11. uv__write_callbacks ( stream ); 12. // \u6b63\u5728\u5173\u95ed\u6d41\uff0c\u76f4\u63a5\u56de\u8c03 13. if ( stream -> shutdown_req ) { 14. uv__req_unregister ( stream -> loop , stream -> shutdown_req ); 15. stream -> shutdown_req -> cb ( stream -> shutdown_req , - ECANCELED ); 16. stream -> shutdown_req = NULL ; 17. } 18. } \u6211\u4eec\u770b\u5230\uff0c\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0c\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u5f85\u5199\u7684\u6570\u636e\uff0c\u5219\u4f1a\u4e22\u5f03\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__stream_flush_write_queue\u548cuv__write_callbacks\u3002 1. void uv__stream_flush_write_queue ( uv_stream_t * stream , int error ) { 2. uv_write_t * req ; 3. QUEUE * q ; 4. while ( ! QUEUE_EMPTY ( & stream -> write_queue )) { 5. q = QUEUE_HEAD ( & stream -> write_queue ); 6. QUEUE_REMOVE ( q ); 7. req = QUEUE_DATA ( q , uv_write_t , queue ); 8. // \u628a\u9519\u8bef\u5199\u5230\u6bcf\u4e2a\u8bf7\u6c42\u4e2d 9. req -> error = error ; 10. QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); 11. } 12. } uv__stream_flush_write_queue\u4e22\u5f03\u5f85\u5199\u961f\u5217\u4e2d\u7684\u8bf7\u6c42\uff0c\u5e76\u76f4\u63a5\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u3002uv__write_callbacks\u662f\u5199\u5b8c\u6216\u8005\u5199\u51fa\u9519\u65f6\u6267\u884c\u7684\u51fd\u6570\uff0c\u5b83\u9010\u4e2a\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u6bcf\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\uff0c\u5982\u4f55\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u5219\u91ca\u653e\u5185\u5b58\u3002\u5728\u5199\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\uff0c\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\u3002","title":"5.9 \u9500\u6bc1\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#510","text":"\u5728\u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u8bfb\u5199\u7b49\u64cd\u4f5c\u90fd\u53ea\u662f\u6ce8\u518c\u4e8b\u4ef6\u5230epoll\uff0c\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c\u7edf\u4e00\u7684\u56de\u8c03\u51fd\u6570uv__stream_io\u3002\u4e0b\u9762\u5217\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u5b9e\u73b0\u5728\u5176\u5b83\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u3002 1. static void uv__stream_io ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. uv_stream_t * stream ; 5. stream = container_of ( w , uv_stream_t , io_watcher ); 6. // \u662f\u8fde\u63a5\u6d41\uff0c\u5219\u6267\u884c\u8fde\u63a5\u5904\u7406\u51fd\u6570 7. if ( stream -> connect_req ) { 8. uv__stream_connect ( stream ); 9. return ; 10. } 11. /* 12. Ignore POLLHUP here. Even it it's set, 13. there may still be data to read. 14. */ 15. // \u53ef\u8bfb\u662f\u89e6\u53d1\uff0c\u5219\u6267\u884c\u8bfb\u5904\u7406 16. if ( events & ( POLLIN | POLLERR | POLLHUP )) 17. uv__read ( stream ); 18. // \u8bfb\u56de\u8c03\u5173\u95ed\u4e86\u6d41 19. if ( uv__stream_fd ( stream ) == -1 ) 20. return ; /* read_cb closed stream. */ 21. /* \u00ac\u00ac 22. POLLHUP\u8bf4\u660e\u5bf9\u7aef\u5173\u95ed\u4e86\uff0c\u5373\u4e0d\u4f1a\u53d1\u751f\u6570\u636e\u8fc7\u6765\u4e86\u3002 23. \u5982\u679c\u6d41\u7684\u6a21\u5f0f\u662f\u6301\u7eed\u8bfb\uff0c 24. 1 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff08\u8bbe\u7f6eUV_STREAM_READ_PARTIAL\uff09\uff0c 25. \u5e76\u4e14\u6ca1\u6709\u8bfb\u5230\u7ed3\u5c3e(\u6ca1\u6709\u8bbe\u7f6eUV_STREAM_READ_EOF)\uff0c 26. \u5219\u76f4\u63a5\u4f5c\u8bfb\u7ed3\u675f\u5904\u7406\uff0c 27. 2 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff0c\u4e0a\u9762\u7684\u8bfb\u56de\u8c03\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c 28. \u5219\u8fd9\u91cc\u5c31\u4e0d\u9700\u8981\u5904\u7406\u4e86 29. 3 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u8fd8\u6ca1\u6709\u6267\u884c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c 30. \u5219\u4e0d\u80fd\u4f5c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5bf9\u7aef\u867d\u7136\u5173\u95ed\u4e86\uff0c\u4f46\u662f\u4e4b 31. \u524d\u7684\u4f20\u8fc7\u6765\u7684\u6570\u636e\u53ef\u80fd\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c 32. 4 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u90a3\u8fd9 33. \u91cc\u4e5f\u4e0d\u9700\u8981\u5904\u7406 34. */ 35. if (( events & POLLHUP ) && 36. ( stream -> flags & UV_STREAM_READING ) && 37. ( stream -> flags & UV_STREAM_READ_PARTIAL ) && 38. ! ( stream -> flags & UV_STREAM_READ_EOF )) { 39. uv_buf_t buf = { NULL , 0 }; 40. uv__stream_eof ( stream , & buf ); 41. } 42. 43. if ( uv__stream_fd ( stream ) == -1 ) 44. return ; /* read_cb closed stream. */ 45. // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 46. if ( events & ( POLLOUT | POLLERR | POLLHUP )) { 47. // \u5199\u6570\u636e 48. uv__write ( stream ); 49. // \u5199\u5b8c\u540e\u505a\u540e\u7f6e\u5904\u7406\uff0c\u91ca\u653e\u5185\u5b58\uff0c\u6267\u884c\u56de\u8c03\u7b49 50. uv__write_callbacks ( stream ); 51. // \u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u5199\u4e8b\u4ef6 52. if ( QUEUE_EMPTY ( & stream -> write_queue )) 53. uv__drain ( stream ); 54. } 55. }","title":"5.10 \u4e8b\u4ef6\u89e6\u53d1\u7684\u5904\u7406"},{"location":"chapter06-C%2B%2B%E5%B1%82/","text":"\u672c\u7ae0\u4ecb\u7ecdNode.js\u4e2dC++\u5c42\u7684\u4e00\u4e9b\u6838\u5fc3\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\uff0c\u8fd9\u4e9b\u6a21\u5757\u662fNode.js\u4e2d\u5f88\u591a\u6a21\u5757\u90fd\u4f1a\u4f7f\u7528\u7684\u3002\u7406\u89e3\u8fd9\u4e9b\u6a21\u5757\u7684\u539f\u7406\uff0c\u624d\u80fd\u66f4\u597d\u5730\u7406\u89e3\u5728Node.js\u4e2d\uff0cJS\u662f\u5982\u4f55\u901a\u8fc7C++\u5c42\u8c03\u7528Libuv\uff0c\u53c8\u662f\u5982\u4f55\u4eceLibuv\u8fd4\u56de\u7684\u3002 6.1 BaseObject \u00b6 BaseObject\u662fC++\u5c42\u5927\u591a\u6570\u7c7b\u7684\u57fa\u7c7b\u3002 1. class BaseObject : public MemoryRetainer { 2. public : 3. // \u2026 4. private : 5. v8 :: Local < v8 :: Object > WrappedObject () const override ; 6. // \u6307\u5411\u5c01\u88c5\u7684\u5bf9\u8c61 7. v8 :: Global < v8 :: Object > persistent_handle_ ; 8. Environment * env_ ; 9. }; BaseObject\u7684\u5b9e\u73b0\u5f88\u590d\u6742\uff0c\u8fd9\u91cc\u53ea\u4ecb\u7ecd\u5e38\u7528\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002 6.1.1 \u6784\u9020\u51fd\u6570 \u00b6 1. // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 2. BaseObject :: BaseObject ( Environment * env , 3. v8 :: Local < v8 :: Object > object ) 4. : persistent_handle_ ( env -> isolate (), object ), 5. env_ ( env ) { 6. // \u628athis\u5b58\u5230object\u4e2d 7. object -> SetAlignedPointerInInternalField ( 0 , static_cast < void *> ( this )); 8. } \u6784\u9020\u51fd\u6570\u7528\u4e8e\u4fdd\u5b58\u5bf9\u8c61\u95f4\u7684\u5173\u7cfb\uff08JS\u4f7f\u7528\u7684\u5bf9\u8c61\u548c\u4e0e\u5176\u5173\u7cfb\u7684C++\u5c42\u5bf9\u8c61\uff0c\u4e0b\u56fe\u4e2d\u7684\u5bf9\u8c61\u5373\u6211\u4eec\u5e73\u65f6\u5728JS\u5c42\u4f7f\u7528C++\u6a21\u5757\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6bd4\u5982new TCP()\uff09\u3002\u540e\u9762\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7528\u5904\uff0c\u5173\u7cfb\u5982\u56fe6-1\u6240\u793a\u3002 \u56fe6-1 6.1.2 \u83b7\u53d6\u5c01\u88c5\u7684\u5bf9\u8c61 \u00b6 1. v8 :: Local < v8 :: Object > BaseObject :: object () const { 2. return PersistentToLocal :: Default ( env () -> isolate (), 3. persistent_handle_ ); 4. } 6.1.3 \u4ece\u5bf9\u8c61\u4e2d\u83b7\u53d6\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61 \u00b6 1. // \u901a\u8fc7obj\u53d6\u51fa\u91cc\u9762\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61 2. BaseObject * BaseObject :: FromJSObject ( v8 :: Local < v8 :: Object > obj ) { 3. return static_cast < BaseObject *> ( obj -> GetAlignedPointerFromInternalField ( 0 )); 4. } 5. 6. template < typename T > 7. T * BaseObject :: FromJSObject ( v8 :: Local < v8 :: Object > object ) { 8. return static_cast < T *> ( FromJSObject ( object )); 9. } 6.1.4 \u89e3\u5305 \u00b6 1. // \u4eceobj\u4e2d\u53d6\u51fa\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61 2. template < typename T > 3. inline T * Unwrap ( v8 :: Local < v8 :: Object > obj ) { 4. return BaseObject :: FromJSObject < T > ( obj ); 5. } 6. 7. // \u4eceobj\u4e2d\u83b7\u53d6\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61\uff0c\u5982\u679c\u4e3a\u7a7a\u5219\u8fd4\u56de\u7b2c\u4e09\u4e2a\u53c2\u6570\u7684\u503c\uff08\u9ed8\u8ba4\u503c\uff09 8. # define ASSIGN_OR_RETURN_UNWRAP ( ptr , obj , ...) \\ 9. do { \\ 10. * ptr = static_cast < typename std :: remove_reference < decltype ( * ptr ) >:: type > ( \\ 11. BaseObject :: FromJSObject ( obj )); \\ 12. if ( * ptr == nullptr ) \\ 13. return __VA_ARGS__ ; \\ 14. } while ( 0 ) 6.2 AsyncWrap \u00b6 AsyncWrap\u5b9e\u73b0async_hook\u7684\u6a21\u5757\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8\u5b83\u56de\u8c03JS\u7684\u529f\u80fd\u3002 1. inline v8 :: MaybeLocal < v8 :: Value > AsyncWrap :: MakeCallback ( 2. const v8 :: Local < v8 :: Name > symbol , 3. int argc , 4. v8 :: Local < v8 :: Value >* argv ) { 5. v8 :: Local < v8 :: Value > cb_v ; 6. // \u6839\u636e\u5b57\u7b26\u4e32\u8868\u793a\u7684\u5c5e\u6027\u503c\uff0c\u4ece\u5bf9\u8c61\u4e2d\u53d6\u51fa\u8be5\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u3002\u662f\u4e2a\u51fd\u6570 7. if ( ! object () -> Get ( env () -> context (), symbol ). ToLocal ( & cb_v )) 8. return v8 :: MaybeLocal < v8 :: Value > (); 9. // \u662f\u4e2a\u51fd\u6570 10. if ( ! cb_v -> IsFunction ()) { 11. return v8 :: MaybeLocal < v8 :: Value > (); 12. } 13. // \u56de\u8c03,\u89c1async_wrap.cc 14. return MakeCallback ( cb_v . As < v8 :: Function > (), argc , argv ); 15. } \u4ee5\u4e0a\u53ea\u662f\u5165\u53e3\u51fd\u6570\uff0c\u6211\u4eec\u770b\u770b\u771f\u6b63\u7684\u5b9e\u73b0\u3002 1. MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb, 2. int argc, 3. Local<Value>* argv) { 4. 5. MaybeLocal<Value> ret = InternalMakeCallback(env(), object(), cb, argc, argv, context); 6. return ret; 7. } \u63a5\u7740\u770b\u4e00\u4e0bInternalMakeCallback 1. MaybeLocal<Value> InternalMakeCallback(Environment* env, 2. Local<Object> recv, 3. const Local<Function> callback, 4. int argc, 5. Local<Value> argv[], 6. async_context asyncContext) { 7. // \u2026\u7701\u7565\u5176\u4ed6\u4ee3\u7801 8. // \u6267\u884c\u56de\u8c03 9. callback->Call(env->context(), recv, argc, argv);} 6.3 HandleWrap \u00b6 HandleWrap\u662f\u5bf9Libuv uv_handle_t\u7684\u5c01\u88c5,\u4e5f\u662f\u5f88\u591aC++\u7c7b\u7684\u57fa\u7c7b\u3002 1. class HandleWrap : public AsyncWrap { 2. public: 3. // \u64cd\u4f5c\u548c\u5224\u65adhandle\u72b6\u6001\u51fd\u6570\uff0c\u89c1Libuv 4. static void Close(const v8::FunctionCallbackInfo<v8::Value>& args); 5. static void Ref(const v8::FunctionCallbackInfo<v8::Value>& args); 6. static void Unref(const v8::FunctionCallbackInfo<v8::Value>& args); 7. static void HasRef(const v8::FunctionCallbackInfo<v8::Value>& args); 8. static inline bool IsAlive(const HandleWrap* wrap) { 9. return wrap != nullptr && wrap->state_ != kClosed; 10. } 11. 12. static inline bool HasRef(const HandleWrap* wrap) { 13. return IsAlive(wrap) && uv_has_ref(wrap->GetHandle()); 14. } 15. // \u83b7\u53d6\u5c01\u88c5\u7684handle 16. inline uv_handle_t* GetHandle() const { return handle_; } 17. // \u5173\u95edhandle\uff0c\u5173\u95ed\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 18. virtual void Close( 19. v8::Local<v8::Value> close_callback = 20. v8::Local<v8::Value>()); 21. 22. static v8::Local<v8::FunctionTemplate> GetConstructorTemplate( 23. Environment* env); 24. 25. protected: 26. HandleWrap(Environment* env, 27. v8::Local<v8::Object> object, 28. uv_handle_t* handle, 29. AsyncWrap::ProviderType provider); 30. virtual void OnClose() {} 31. // handle\u72b6\u6001 32. inline bool IsHandleClosing() const { 33. return state_ == kClosing || state_ == kClosed; 34. } 35. 36. private: 37. friend class Environment; 38. friend void GetActiveHandles(const v8::FunctionCallbackInfo<v8::Value>&); 39. static void OnClose(uv_handle_t* handle); 40. 41. // handle\u961f\u5217 42. ListNode<HandleWrap> handle_wrap_queue_; 43. // handle\u7684\u72b6\u6001 44. enum { kInitialized, kClosing, kClosed } state_; 45. // \u6240\u6709handle\u7684\u57fa\u7c7b 46. uv_handle_t* const handle_; 47. }; 6.3.1 \u65b0\u5efahandle\u548c\u521d\u59cb\u5316 \u00b6 1. Local<FunctionTemplate> HandleWrap::GetConstructorTemplate(Environment* env) { 2. Local<FunctionTemplate> tmpl = env->handle_wrap_ctor_template(); 3. if (tmpl.IsEmpty()) { 4. tmpl = env->NewFunctionTemplate(nullptr); 5. tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), 6. \"HandleWrap\")); 7. tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env)); 8. env->SetProtoMethod(tmpl, \"close\", HandleWrap::Close); 9. env->SetProtoMethodNoSideEffect(tmpl, 10. \"hasRef\", 11. HandleWrap::HasRef); 12. env->SetProtoMethod(tmpl, \"ref\", HandleWrap::Ref); 13. env->SetProtoMethod(tmpl, \"unref\", HandleWrap::Unref); 14. env->set_handle_wrap_ctor_template(tmpl); 15. } 16. return tmpl; 17. } 18. /* 19. object\u4e3aC++\u5c42\u4e3aJS\u5c42\u63d0\u4f9b\u7684\u5bf9\u8c61 20. handle\u4e3a\u5b50\u7c7b\u5177\u4f53\u7684handle\u7c7b\u578b\uff0c\u4e0d\u540c\u6a21\u5757\u4e0d\u4e00\u6837 21. */ 22. HandleWrap::HandleWrap(Environment* env, 23. Local<Object> object, 24. uv_handle_t* handle, 25. AsyncWrap::ProviderType provider) 26. : AsyncWrap(env, object, provider), 27. state_(kInitialized), 28. handle_(handle) { 29. // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb 30. handle_->data = this; 31. HandleScope scope(env->isolate()); 32. CHECK(env->has_run_bootstrapping_code()); 33. // \u63d2\u5165handle\u961f\u5217 34. env->handle_wrap_queue()->PushBack(this); 35. } HandleWrap\u7ee7\u627fBaseObject\u7c7b\uff0c\u521d\u59cb\u5316\u540e\u5173\u7cfb\u56fe\u5982\u56fe6-2\u6240\u793a\u3002 \u56fe6-2 6.3.2 \u5224\u65ad\u548c\u64cd\u4f5chandle\u72b6\u6001 \u00b6 1. // \u4fee\u6539handle\u4e3a\u6d3b\u8dc3\u72b6\u6001 2. void HandleWrap::Ref(const FunctionCallbackInfo<Value>& args) { 3. HandleWrap* wrap; 4. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 5. 6. if (IsAlive(wrap)) 7. uv_ref(wrap->GetHandle()); 8. } 9. 10. // \u4fee\u6539hande\u4e3a\u4e0d\u6d3b\u8dc3\u72b6\u6001 11. void HandleWrap::Unref(const FunctionCallbackInfo<Value>& args) { 12. HandleWrap* wrap; 13. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 14. 15. if (IsAlive(wrap)) 16. uv_unref(wrap->GetHandle()); 17. } 18. 19. // \u5224\u65adhandle\u662f\u5426\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001 20. void HandleWrap::HasRef(const FunctionCallbackInfo<Value>& args) { 21. HandleWrap* wrap; 22. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 23. args.GetReturnValue().Set(HasRef(wrap)); 24. } 6.3.3 \u5173\u95edhandle \u00b6 1. // \u5173\u95edhandle\uff08JS\u5c42\u8c03\u7528\uff09\uff0c\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 2. void HandleWrap::Close(const FunctionCallbackInfo<Value>& args) { 3. HandleWrap* wrap; 4. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 5. // \u4f20\u5165\u56de\u8c03 6. wrap->Close(args[0]); 7. } 8. // \u771f\u6b63\u5173\u95edhandle\u7684\u51fd\u6570 9. void HandleWrap::Close(Local<Value> close_callback) { 10. // \u6b63\u5728\u5173\u95ed\u6216\u5df2\u7ecf\u5173\u95ed 11. if (state_ != kInitialized) 12. return; 13. // \u8c03\u7528Libuv\u51fd\u6570 14. uv_close(handle_, OnClose); 15. // \u5173\u95ed\u4e2d 16. state_ = kClosing; 17. // \u4f20\u4e86\u56de\u8c03\u5219\u4fdd\u5b58\u8d77\u6765 18. if (!close_callback.IsEmpty() && 19. close_callback->IsFunction() && 20. !persistent().IsEmpty()) { 21. object()->Set(env()->context(), 22. env()->handle_onclose_symbol(), 23. close_callback).Check(); 24. } 25. } 26. 27. // \u5173\u95edhandle\u6210\u529f\u540e\u56de\u8c03 28. void HandleWrap::OnClose(uv_handle_t* handle) { 29. BaseObjectPtr<HandleWrap> wrap { 30. static_cast<HandleWrap*>(handle->data) 31. }; 32. wrap->Detach(); 33. 34. Environment* env = wrap->env(); 35. HandleScope scope(env->isolate()); 36. Context::Scope context_scope(env->context()); 37. wrap->state_ = kClosed; 38. 39. wrap->OnClose(); 40. wrap->handle_wrap_queue_.Remove(); 41. // \u6709onclose\u56de\u8c03\u5219\u6267\u884c 42. if (!wrap->persistent().IsEmpty() && 43. wrap->object()->Has(env->context(), 44. env->handle_onclose_symbol()) 45. .FromMaybe(false)) { 46. wrap->MakeCallback(env->handle_onclose_symbol(), 47. 0, 48. nullptr); 49. } 50. } 6.4 ReqWrap \u00b6 ReqWrap\u8868\u793a\u901a\u8fc7Libuv\u5bf9handle\u7684\u4e00\u6b21\u8bf7\u6c42\u3002 6.4.1 ReqWrapBase \u00b6 1. class ReqWrapBase { 2. public: 3. explicit inline ReqWrapBase(Environment* env); 4. virtual ~ReqWrapBase() = default; 5. virtual void Cancel() = 0; 6. virtual AsyncWrap* GetAsyncWrap() = 0; 7. 8. private: 9. // \u4e00\u4e2a\u5e26\u524d\u540e\u6307\u9488\u7684\u8282\u70b9 10. ListNode<ReqWrapBase> req_wrap_queue_; 11. }; ReqWrapBase\u4e3b\u8981\u662f\u5b9a\u4e49\u63a5\u53e3\u7684\u534f\u8bae\u3002\u6211\u4eec\u770b\u4e00\u4e0bReqWrapBase\u7684\u5b9e\u73b0 1. ReqWrapBase::ReqWrapBase(Environment* env) { 2. env->req_wrap_queue()->PushBack(this); 3. } ReqWrapBase\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628a\u81ea\u5df1\u52a0\u5230env\u5bf9\u8c61\u7684req\u961f\u5217\u4e2d\u3002 6.4.2 ReqWrap \u00b6 1. template <typename T> 2. class ReqWrap : public AsyncWrap, public ReqWrapBase { 3. public: 4. inline ReqWrap(Environment* env, 5. v8::Local<v8::Object> object, 6. AsyncWrap::ProviderType provider); 7. inline ~ReqWrap() override; 8. inline void Dispatched(); 9. inline void Reset(); 10. T* req() { return &req_; } 11. inline void Cancel() final; 12. inline AsyncWrap* GetAsyncWrap() override; 13. static ReqWrap* from_req(T* req); 14. template <typename LibuvFunction, typename... Args> 15. // \u8c03\u7528Libuv 16. inline int Dispatch(LibuvFunction fn, Args... args); 17. 18. public: 19. typedef void (*callback_t)(); 20. callback_t original_callback_ = nullptr; 21. 22. protected: 23. T req_; 24. }; 25. 26. } \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1. template <typename T> 2. ReqWrap<T>::ReqWrap(Environment* env, 3. v8::Local<v8::Object> object, 4. AsyncWrap::ProviderType provider) 5. : AsyncWrap(env, object, provider), 6. ReqWrapBase(env) { 7. // \u521d\u59cb\u5316\u72b6\u6001 8. Reset(); 9. } 10. 11. // \u4fdd\u5b58libuv\u6570\u636e\u7ed3\u6784\u548cReqWrap\u5b9e\u4f8b\u7684\u5173\u7cfb 12. template <typename T> 13. void ReqWrap<T>::Dispatched() { 14. req_.data = this; 15. } 16. 17. // \u91cd\u7f6e\u5b57\u6bb5 18. template <typename T> 19. void ReqWrap<T>::Reset() { 20. original_callback_ = nullptr; 21. req_.data = nullptr; 22. } 23. 24. // \u901a\u8fc7req\u6210\u5458\u627e\u6240\u5c5e\u5bf9\u8c61\u7684\u5730\u5740 25. template <typename T> 26. ReqWrap<T>* ReqWrap<T>::from_req(T* req) { 27. return ContainerOf(&ReqWrap<T>::req_, req); 28. } 29. 30. // \u53d6\u6d88\u7ebf\u7a0b\u6c60\u4e2d\u7684\u8bf7\u6c42 31. template <typename T> 32. void ReqWrap<T>::Cancel() { 33. if (req_.data == this) 34. uv_cancel(reinterpret_cast<uv_req_t*>(&req_)); 35. } 36. 37. template <typename T> 38. AsyncWrap* ReqWrap<T>::GetAsyncWrap() { 39. return this; 40. } 41. // \u8c03\u7528Libuv\u51fd\u6570 42. template <typename T> 43. template <typename LibuvFunction, typename... Args> 44. int ReqWrap<T>::Dispatch(LibuvFunction fn, Args... args) { 45. Dispatched(); 46. int err = CallLibuvFunction<T, LibuvFunction>::Call( 47. // Libuv\u51fd\u6570 48. fn, 49. env()->event_loop(), 50. req(), 51. MakeLibuvRequestCallback<T, Args>::For(this, args)...); 52. if (err >= 0) 53. env()->IncreaseWaitingRequestCounter(); 54. return err; 55. } \u6211\u4eec\u770b\u5230ReqWrap\u62bd\u8c61\u4e86\u8bf7\u6c42Libuv\u7684\u8fc7\u7a0b\uff0c\u5177\u4f53\u8bbe\u8ba1\u7684\u6570\u636e\u7ed3\u6784\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u67d0\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\u3002 1. // \u8bf7\u6c42Libuv\u65f6\uff0c\u6570\u636e\u7ed3\u6784\u662fuv_connect_t\uff0c\u8868\u793a\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 2. class ConnectWrap : public ReqWrap<uv_connect_t> { 3. public: 4. ConnectWrap(Environment* env, 5. v8::Local<v8::Object> req_wrap_obj, 6. AsyncWrap::ProviderType provider); 7. }; 6.5 JS\u5982\u4f55\u4f7f\u7528C++ \u00b6 JS\u8c03\u7528C++\u6a21\u5757\u662fV8\u63d0\u4f9b\u7684\u80fd\u529b\uff0cNode.js\u662f\u4f7f\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u9762\u5bf9JS\uff0c\u5269\u4e0b\u7684\u4e8b\u60c5\u4ea4\u7ed9Node.js\u5c31\u884c\u3002\u672c\u6587\u9996\u5148\u8bb2\u4e00\u4e0b\u5229\u7528V8\u5982\u4f55\u5b9e\u73b0JS\u8c03\u7528C++\uff0c\u7136\u540e\u518d\u8bb2\u4e00\u4e0bNode.js\u662f\u600e\u4e48\u505a\u7684\u3002 1 JS\u8c03\u7528C++ \u9996\u5148\u4ecb\u7ecd\u4e00\u4e0bV8\u4e2d\u4e24\u4e2a\u975e\u5e38\u6838\u5fc3\u7684\u7c7bFunctionTemplate\u548cObjectTemplate\u3002\u987e\u540d\u601d\u4e49\uff0c\u8fd9\u4e24\u4e2a\u7c7b\u662f\u5b9a\u4e49\u6a21\u677f\u7684\uff0c\u597d\u6bd4\u5efa\u623f\u5b50\u65f6\u7684\u8bbe\u8ba1\u56fe\u4e00\u6837\uff0c\u901a\u8fc7\u8bbe\u8ba1\u56fe\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u9020\u51fa\u5bf9\u5e94\u7684\u623f\u5b50\u3002V8\u4e5f\u662f\uff0c\u5b9a\u4e49\u67d0\u79cd\u6a21\u677f\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6a21\u677f\u521b\u5efa\u51fa\u5bf9\u5e94\u7684\u5b9e\u4f8b\u3002\u4e0b\u9762\u4ecb\u7ecd\u4e00\u4e0b\u8fd9\u4e9b\u6982\u5ff5\uff08\u4e3a\u4e86\u65b9\u4fbf\uff0c\u4e0b\u9762\u90fd\u662f\u4f2a\u4ee3\u7801)\u3002 1.1 \u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 1. Local<FunctionTemplate> functionTemplate = v8::FunctionTemplate::New(isolate(), New); 2. // \u5b9a\u4e49\u51fd\u6570\u7684\u540d\u5b57 3. functionTemplate->SetClassName(\u2018TCP\u2019) \u9996\u5148\u5b9a\u4e49\u4e00\u4e2aFunctionTemplate\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u5230FunctionTemplate\u7684\u7b2c\u4e8c\u4e2a\u5165\u53c2\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5f53\u6211\u4eec\u6267\u884c\u7531FunctionTemplate\u521b\u5efa\u7684\u51fd\u6570\u65f6\uff0cv8\u5c31\u4f1a\u6267\u884cNew\u51fd\u6570\u3002\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e0d\u4f20\u3002 1.2 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u7684prototype\u5185\u5bb9 prototype\u5c31\u662fJS\u91cc\u7684function.prototype\u3002\u5982\u679c\u4f60\u7406\u89e3JS\u91cc\u7684\u77e5\u8bc6\uff0c\u5c31\u5f88\u5bb9\u6613\u7406\u89e3C++\u7684\u4ee3\u7801\u3002 1. v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate(), callback); 2. t->SetClassName('test'); 3. // \u5728prototype\u4e0a\u5b9a\u4e49\u4e00\u4e2a\u5c5e\u6027 4. t->PrototypeTemplate()->Set('hello', 'world'); 1.3 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u5bf9\u5e94\u7684\u5b9e\u4f8b\u6a21\u677f\u7684\u5185\u5bb9 \u5b9e\u4f8b\u6a21\u677f\u5c31\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002\u5b83\u5b9a\u4e49\u4e86\uff0c\u5f53\u4ee5new\u7684\u65b9\u5f0f\u6267\u884c\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u51fd\u6570\u65f6\uff0c\u8fd4\u56de\u503c\u6240\u5177\u6709\u7684\u5c5e\u6027\u3002 1. function A() { 2. this.a = 1; 3. this.b = 2; 4. } 5. new A(); \u5b9e\u4f8b\u6a21\u677f\u7c7b\u4f3c\u4e0a\u9762\u4ee3\u7801\u4e2dA\u51fd\u6570\u91cc\u9762\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u600e\u4e48\u5b9a\u4e49\u3002 1. t->InstanceTemplate()->Set(key, val); 2. t->InstanceTemplate()->SetInternalFieldCount(1); InstanceTemplate\u8fd4\u56de\u7684\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002SetInternalFieldCount\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u7279\u6b8a\uff0c\u4e5f\u662f\u6bd4\u8f83\u91cd\u8981\u7684\u4e00\u4e2a\u5730\u65b9\uff0c\u6211\u4eec\u77e5\u9053\u5bf9\u8c61\u5c31\u662f\u4e00\u5757\u5185\u5b58\uff0c\u5bf9\u8c61\u6709\u5b83\u81ea\u5df1\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053\u5728C++\u91cc\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7c7b\uff0c\u4e5f\u5c31\u5b9a\u4e49\u4e86\u5bf9\u8c61\u7684\u5e03\u5c40\u3002\u6bd4\u5982\u6211\u4eec\u6709\u4ee5\u4e0b\u5b9a\u4e49\u3002 1. class demo 2. { 3. private: 4. int a; 5. int b; 6. }; \u5728\u5185\u5b58\u4e2d\u5e03\u5c40\u5982\u56fe6-3\u6240\u793a\u3002 \u56fe6-3 \u4e0a\u9762\u8fd9\u79cd\u65b9\u5f0f\u6709\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u7c7b\u5b9a\u4e49\u4e4b\u540e\uff0c\u5185\u5b58\u5e03\u5c40\u5c31\u56fa\u5b9a\u4e86\u3002\u800cV8\u662f\u81ea\u5df1\u53bb\u63a7\u5236\u5bf9\u8c61\u7684\u5185\u5b58\u5e03\u5c40\u7684\u3002\u5f53\u6211\u4eec\u5728V8\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u7684\u65f6\u5019\uff0c\u662f\u6ca1\u6709\u4efb\u4f55\u5c5e\u6027\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0bV8\u4e2dHeapObject\u7c7b\u7684\u5b9a\u4e49\u3002 1. class HeapObject: public Object { 2. static const int kMapOffset = Object::kSize; // Object::kSize\u662f0 3. static const int kSize = kMapOffset + kPointerSize; 4. }; \u8fd9\u65f6\u5019\u7684\u5185\u5b58\u5e03\u5c40\u5982\u4e0b\u3002 \u7136\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0bHeapObject\u5b50\u7c7bHeapNumber\u7684\u5b9a\u4e49\u3002 1. class HeapNumber: public HeapObject { 2. // kSize\u4e4b\u524d\u7684\u7a7a\u95f4\u5b58\u50a8map\u5bf9\u8c61\u7684\u6307\u9488 3. static const int kValueOffset = HeapObject::kSize; 4. // kValueOffset - kSize\u4e4b\u95f4\u5b58\u50a8\u6570\u5b57\u7684\u503c 5. static const int kSize = kValueOffset + kDoubleSize; 6. }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-4\u6240\u793a\u3002 \u56fe6-4 \u6211\u4eec\u53d1\u73b0\u8fd9\u4e9b\u7c7b\u53ea\u6709\u51e0\u4e2a\u7c7b\u53d8\u91cf\uff0c\u7c7b\u53d8\u91cf\u662f\u4e0d\u4fdd\u5b58\u5728\u5bf9\u8c61\u5185\u5b58\u7a7a\u95f4\u7684\u3002\u8fd9\u4e9b\u7c7b\u53d8\u91cf\u5c31\u662f\u5b9a\u4e49\u4e86\u5bf9\u8c61\u6bcf\u4e2a\u57df\u6240\u5360\u5185\u5b58\u7a7a\u95f4\u7684\u4fe1\u606f\uff0c\u5f53\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2aHeapObject\u5bf9\u8c61\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u628a\u8fd9\u5757\u5185\u5b58\u9996\u5730\u5740\u5f3a\u884c\u8f6c\u6210\u5bf9\u5e94\u5bf9\u8c61\u7684\u6307\u9488\u3002\u7136\u540e\u901a\u8fc7\u7c7b\u53d8\u91cf\u5bf9\u5c5e\u6027\u7684\u5185\u5b58\u8fdb\u884c\u5b58\u53d6\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u5982\u4f55\u7533\u8bf7\u4e00\u4e2aHeapNumber\u5bf9\u8c61 1. Object* Heap::AllocateHeapNumber(double value, PretenureFlag pretenure) { 2. // \u5728\u54ea\u4e2a\u7a7a\u95f4\u5206\u914d\u5185\u5b58\uff0c\u6bd4\u5982\u65b0\u751f\u4ee3\uff0c\u8001\u751f\u4ee3 3. AllocationSpace space = (pretenure == TENURED) ? CODE_SPACE : NEW_SPACE; 4. // \u5728space\u4e0a\u5206\u914d\u4e00\u4e2aHeapNumber\u5bf9\u8c61\u5927\u5c0f\u7684\u5185\u5b58 5. Object* result = AllocateRaw(HeapNumber::kSize, space); 6. /* 7. \u8f6c\u6210HeapObect\uff0c\u8bbe\u7f6emap\u5c5e\u6027\uff0cmap\u5c5e\u6027\u662f\u8868\u793a\u5bf9\u8c61\u7c7b\u578b\u3001\u5927\u5c0f\u7b49\u4fe1\u606f\u7684 8. */ 9. HeapObject::cast(result)->set_map(heap_number_map()); 10. // \u8f6c\u6210HeapNumber\u5bf9\u8c61 11. HeapNumber::cast(result)->set_value(value); 12. return result; 13. } \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u8c61\u6a21\u677f\u7684\u5b9a\u4e49\u3002 1. class TemplateInfo: public Struct { 2. static const int kTagOffset = HeapObject::kSize; 3. static const int kPropertyListOffset = kTagOffset + kPointerSize; 4. static const int kHeaderSize = kPropertyListOffset + kPointerSize; 5. }; 6. 7. class ObjectTemplateInfo: public TemplateInfo { 8. static const int kConstructorOffset = TemplateInfo::kHeaderSize; 9. static const int kInternalFieldCountOffset = kConstructorOffset + kPointerSize; 10. static const int kSize = kInternalFieldCountOffset + kHeaderSize; 11. }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-5\u6240\u793a\u3002 \u56fe6-5 \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\uff0c\u6211\u4eec\u770b\u770bSet(key, val)\u505a\u4e86\u4ec0\u4e48\u3002 1. void Template::Set(v8::Handle<String> name, v8::Handle<Data> value, 2. v8::PropertyAttribute attribute) { 3. // ... 4. i::Handle<i::Object> list(Utils::OpenHandle(this)->property_list()); 5. NeanderArray array(list); 6. array.add(Utils::OpenHandle(*name)); 7. array.add(Utils::OpenHandle(*value)); 8. array.add(Utils::OpenHandle(*v8::Integer::New(attribute))); 9. } \u4e0a\u9762\u7684\u4ee3\u7801\u5927\u81f4\u5c31\u662f\u7ed9\u4e00\u4e2alist\u540e\u9762\u8ffd\u52a0\u4e00\u4e9b\u5185\u5bb9\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2alist\u662f\u600e\u4e48\u6765\u7684\uff0c\u5373property_list\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. // \u8bfb\u53d6\u5bf9\u8c61\u4e2d\u67d0\u4e2a\u5c5e\u6027\u7684\u503c 2. #define READ_FIELD(p, offset) (*reinterpret_cast<Object**>(FIELD_ADDR(p, offset)) 3. 4. static Object* cast(Object* value) { 5. return value; 6. } 7. 8. Object* TemplateInfo::property_list() { 9. return Object::cast(READ_FIELD(this, kPropertyListOffset)); 10. } \u4ece\u4e0a\u9762\u4ee3\u7801\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u5185\u90e8\u5e03\u5c40\u5982\u56fe6-6\u6240\u793a\u3002 \u56fe6-6 \u6839\u636e\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053property_list\u7684\u503c\u662flist\u6307\u5411\u7684\u503c\u3002\u6240\u4ee5Set(key, val)\u64cd\u4f5c\u7684\u5185\u5b58\u5e76\u4e0d\u662f\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\uff0c\u5bf9\u8c61\u5229\u7528\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e00\u5757\u5185\u5b58\u4fdd\u5b58Set(key, val)\u7684\u503c\u3002SetInternalFieldCount\u51fd\u6570\u5c31\u4e0d\u4e00\u6837\u4e86\uff0c\u5b83\u4f1a\u5f71\u54cd\uff08\u6269\u5f20\uff09\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1. void ObjectTemplate::SetInternalFieldCount(int value) { 2. // \u4fee\u6539\u7684\u662fkInternalFieldCountOffset\u5bf9\u5e94\u7684\u5185\u5b58\u7684\u503c 3. Utils::OpenHandle(this)->set_internal_field_count(i::Smi::FromInt(value)); 4. } \u6211\u4eec\u770b\u5230SetInternalFieldCount\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5728\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6570\u5b57\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b57\u6bb5\u7684\u4f7f\u7528\u3002\u540e\u9762\u4f1a\u8be6\u7ec6\u4ecb\u7ecd\u5b83\u7684\u7528\u5904\u3002 1. Handle<JSFunction> Factory::CreateApiFunction( 2. Handle<FunctionTemplateInfo> obj, 3. bool is_global) { 4. 5. int internal_field_count = 0; 6. if (!obj->instance_template()->IsUndefined()) { 7. // \u83b7\u53d6\u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u6a21\u677f 8. Handle<ObjectTemplateInfo> instance_template = Handle<ObjectTemplateInfo>(ObjectTemplateInfo::cast(obj->instance_template())); 9. // \u83b7\u53d6\u5b9e\u4f8b\u6a21\u677f\u7684internal_field_count\u5b57\u6bb5\u7684\u503c\uff08\u901a\u8fc7SetInternalFieldCount\u8bbe\u7f6e\u7684\u90a3\u4e2a\u503c\uff09 10. internal_field_count = Smi::cast(instance_template->internal_field_count())->value(); 11. } 12. // \u8ba1\u7b97\u65b0\u5efa\u5bf9\u8c61\u9700\u8981\u7684\u7a7a\u95f4\uff0c\u5982\u679c 13. int instance_size = kPointerSize * internal_field_count; 14. if (is_global) { 15. instance_size += JSGlobalObject::kSize; 16. } else { 17. instance_size += JSObject::kHeaderSize; 18. } 19. 20. InstanceType type = is_global ? JS_GLOBAL_OBJECT_TYPE : JS_OBJECT_TYPE; 21. // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u5bf9\u8c61 22. Handle<JSFunction> result = 23. Factory::NewFunction(Factory::empty_symbol(), type, instance_size, 24. code, true); 25. } \u6211\u4eec\u770b\u5230internal_field_count\u7684\u503c\u7684\u610f\u4e49\u662f\uff0c\u4f1a\u6269\u5f20\u5bf9\u8c61\u7684\u5185\u5b58\uff0c\u6bd4\u5982\u4e00\u4e2a\u5bf9\u8c61\u672c\u8eab\u53ea\u6709n\u5b57\u8282\uff0c\u5982\u679c\u5b9a\u4e49internal_field_count\u7684\u503c\u662f1\uff0c\u5bf9\u8c61\u7684\u5185\u5b58\u5c31\u4f1a\u53d8\u6210n+internal_field_count * \u4e00\u4e2a\u6307\u9488\u7684\u5b57\u8282\u6570\u3002\u5185\u5b58\u5e03\u5c40\u5982\u56fe6-7\u6240\u793a\u3002 \u56fe6-7 1.4 \u901a\u8fc7\u51fd\u6570\u6a21\u677f\u521b\u5efa\u4e00\u4e2a\u51fd\u6570 1. Local functionTemplate = v8::FunctionTemplate::New(isolate(), New); 2. global->Set('demo', functionTemplate ->GetFunction()); \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728JS\u91cc\u76f4\u63a5\u8c03\u7528demo\u8fd9\u4e2a\u53d8\u91cf\uff0c\u7136\u540e\u5bf9\u5e94\u7684\u51fd\u6570\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u8fd9\u5c31\u662fJS\u8c03\u7528C++\u7684\u539f\u7406\u3002 2 Node.js\u662f\u5982\u4f55\u5904\u7406JS\u8c03\u7528C++\u95ee\u9898\u7684 \u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 1. constant { TCP } = process.binding('tcp_wrap'); 2. new TCP(...); Node.js\u901a\u8fc7\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u53d8\u91cfprocess\u7edf\u4e00\u5904\u7406C++\u6a21\u5757\u7684\u8c03\u7528\uff0c\u5177\u4f53\u53c2\u8003\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u7684\u5185\u5bb9\u3002\u5728Node.js\u4e2d\uff0cC++\u6a21\u5757\uff08\u7c7b\uff09\u4e00\u822c\u53ea\u4f1a\u5b9a\u4e49\u5bf9\u5e94\u7684Libuv\u7ed3\u6784\u4f53\u548c\u4e00\u7cfb\u5217\u7c7b\u51fd\u6570\uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u7248\uff0c\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\uff0c\u63a5\u7740\u628a\u8fd9\u4e9b\u7c7b\u51fd\u6570\u6302\u8f7d\u5230\u51fd\u6570\u6a21\u677f\u4e2d,\u6700\u540e\u901a\u8fc7\u51fd\u6570\u6a21\u677f\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570F\u7ed9JS\u5c42\u4f7f\u7528\uff0c\u7ffb\u8bd1\u6210JS\u5927\u81f4\u5982\u4e0b 1. // Libuv 2. function uv_tcp_connect(uv_tcp_t, addr,cb) { cb(); } 3. 4. // C++ 5. class TCPWrap { 6. 7. uv_tcp_t = {}; 8. 9. static Connect(cb) { 10. 11. const tcpWrap = this[0]; 12. 13. uv_tcp_connect( 14. 15. tcpWrap.uv_tcp_t, 16. 17. {ip: '127.0.0.1', port: 80}, 18. 19. () => { cb(); } 20. 21. ); 22. 23. } 24. 25. } 26. 27. function FunctionTemplate(cb) { 28. function Tmp() { 29. Object.assign(this, map); 30. cb(this); 31. } 32. const map = {}; 33. return { 34. PrototypeTemplate: function() { 35. return { 36. set: function(k, v) { 37. Tmp.prototype[k] = v; 38. } 39. } 40. }, 41. InstanceTemplate: function() { 42. return { 43. set: function(k, v) { 44. map[k] = v; 45. } 46. } 47. }, 48. GetFunction() { 49. return Tmp; 50. } 51. } 52. 53. } 54. 55. const TCPFunctionTemplate = FunctionTemplate((target) => { target[0] = new TCPWrap(); }) 56. 57. TCPFunctionTemplate.PrototypeTemplate().set('connect', TCPWrap.Connect); 58. TCPFunctionTemplate.InstanceTemplate().set('name', 'hi'); 59. const TCP = TCPFunctionTemplate.GetFunction(); 60. 61. // js 62. const tcp = new TCP(); 63. tcp.connect(() => { console.log('\u8fde\u63a5\u6210\u529f'); }); 64. tcp.name; \u6211\u4eec\u4eceC++\u7684\u5c42\u9762\u5206\u6790\u6267\u884cnew TCP()\u7684\u903b\u8f91\uff0c\u7136\u540e\u518d\u5206\u6790connect\u7684\u903b\u8f91\uff0c\u8fd9\u4e24\u4e2a\u903b\u8f91\u6d89\u53ca\u7684\u673a\u5236\u662f\u5176\u5b83C++\u6a21\u5757\u4e5f\u4f1a\u4f7f\u7528\u5230\u7684\u3002\u56e0\u4e3aTCP\u5bf9\u5e94\u7684\u51fd\u6570\u662fInitialize\u51fd\u6570\u91cc\u7684t->GetFunction()\u5bf9\u5e94\u7684\u503c\u3002\u6240\u4ee5new TCP()\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\u3002 1. void TCPWrap::New(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. int type_value = args[0].As<Int32>()->Value(); 5. TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value); 6. 7. ProviderType provider; 8. switch (type) { 9. case SOCKET: 10. provider = PROVIDER_TCPWRAP; 11. break; 12. case SERVER: 13. provider = PROVIDER_TCPSERVERWRAP; 14. break; 15. default: 16. UNREACHABLE(); 17. } 18. /* 19. args.This()\u4e3av8\u63d0\u4f9b\u7684\u4e00\u4e2aC++\u5bf9\u8c61\uff08\u7531Initialize\u51fd\u6570\u5b9a\u4e49\u7684\u6a21\u5757\u521b\u5efa\u7684\uff09 20. \u8c03\u7528\u8be5C++\u5bf9\u8c61\u7684SetAlignedPointerInInternalField(0,this)\u5173\u8054this\uff08new TCPWrap()\uff09, 21. \u89c1HandleWrap 22. */ 23. 24. new TCPWrap(env, args.This(), provider); 25. } \u6211\u4eec\u6cbf\u7740TCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\uff0c\u4e00\u76f4\u5230HandleWrap 1. HandleWrap::HandleWrap(Environment* env, 2. Local<Object> object, 3. uv_handle_t* handle, 4. AsyncWrap::ProviderType provider) 5. : AsyncWrap(env, object, provider), 6. state_(kInitialized), 7. handle_(handle) { 8. // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb 9. handle_->data = this; 10. HandleScope scope(env->isolate()); 11. // \u63d2\u5165handle\u961f\u5217 12. env->handle_wrap_queue()->PushBack(this); 13. } HandleWrap\u9996\u5148\u4fdd\u5b58\u4e86Libuv\u7ed3\u6784\u4f53\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb\u3002\u7136\u540e\u6211\u4eec\u7ee7\u7eed\u6cbf\u7740AsyncWrap\u5206\u6790\uff0cAsyncWrap\u7ee7\u627fBaseObject\uff0c\u6211\u4eec\u76f4\u63a5\u770bBaseObject\u3002 1. // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 2. BaseObject::BaseObject(Environment* env, v8::Local<v8::Object> object) 3. : persistent_handle_(env->isolate(), object), env_(env) { 4. // \u628athis\u5b58\u5230object\u4e2d 5. object->SetAlignedPointerInInternalField(0, static_cast<void*>(this)); 6. env->AddCleanupHook(DeleteMe, static_cast<void*>(this)); 7. env->modify_base_object_count(1); 8. } \u6211\u4eec\u770bSetAlignedPointerInInternalField\u3002 1. void v8::Object::SetAlignedPointerInInternalField(int index, void* value) { 2. i::Handle<i::JSReceiver> obj = Utils::OpenHandle(this); 3. i::Handle<i::JSObject>::cast(obj)->SetEmbedderField( 4. index, EncodeAlignedAsSmi(value, location)); 5. } 6. 7. void JSObject::SetEmbedderField(int index, Smi* value) { 8. // GetHeaderSize\u4e3a\u5bf9\u8c61\u56fa\u5b9a\u5e03\u5c40\u7684\u5927\u5c0f\uff0ckPointerSize * index\u4e3a\u62d3\u5c55\u7684\u5185\u5b58\u5927\u5c0f\uff0c\u6839\u636e\u7d22\u5f15\u627e\u5230\u5bf9\u5e94\u4f4d\u7f6e 9. int offset = GetHeaderSize() + (kPointerSize * index); 10. // \u5199\u5bf9\u5e94\u4f4d\u7f6e\u7684\u5185\u5b58\uff0c\u5373\u4fdd\u5b58\u5bf9\u5e94\u7684\u5185\u5bb9\u5230\u5185\u5b58 11. WRITE_FIELD(this, offset, value); 12. } SetAlignedPointerInInternalField\u51fd\u6570\u5c55\u5f00\u540e\uff0c\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2a\u503c\u4fdd\u5b58\u5230V8 C++\u5bf9\u8c61\u7684\u5185\u5b58\u91cc\u3002\u90a3\u4fdd\u5b58\u7684\u8fd9\u4e2a\u503c\u662f\u5565\u5462\uff1fBaseObject\u7684\u5165\u53c2object\u662f\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\uff0cthis\u662f\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u6240\u4ee5SetAlignedPointerInInternalField\u51fd\u6570\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u4fdd\u5b58\u5230\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u91cc\uff0c\u5982\u56fe6-8\u6240\u793a\u3002 \u56fe6-8 \u8fd9\u6709\u5565\u7528\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u3002\u8fd9\u65f6\u5019new TCP\u5c31\u6267\u884c\u5b8c\u6bd5\u4e86\u3002\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u6267\u884ctcp.connect()\u51fd\u6570\u7684\u903b\u8f91\u3002 1. template <typename T> 2. void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args, 3. std::function<int(const char* ip_address, T* addr)> uv_ip_addr) { 4. Environment* env = Environment::GetCurrent(args); 5. 6. TCPWrap* wrap; 7. ASSIGN_OR_RETURN_UNWRAP(&wrap, 8. args.Holder(), 9. args.GetReturnValue().Set(UV_EBADF)); 10. // \u7701\u7565\u90e8\u5206\u4e0d\u76f8\u5173\u4ee3\u7801 11. 12. args.GetReturnValue().Set(err); 13. } \u6211\u4eec\u53ea\u9700\u770b\u4e00\u4e0bASSIGN_OR_RETURN_UNWRAP\u5b8f\u7684\u903b\u8f91\u3002\u5176\u4e2dargs.Holder()\u8868\u793aConnect\u51fd\u6570\u7684\u5c5e\u4e3b\uff0c\u6839\u636e\u524d\u9762\u7684\u5206\u6790\u6211\u4eec\u77e5\u9053\u5c5e\u4e3b\u662fInitialize\u51fd\u6570\u5b9a\u4e49\u7684\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4fdd\u5b58\u4e86\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002ASSIGN_OR_RETURN_UNWRAP\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u5728C++\u5bf9\u8c61\u4e2d\u4fdd\u5b58\u7684\u90a3\u4e2aTCPWrap\u5bf9\u8c61\u53d6\u51fa\u6765\u3002\u7136\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528TCPWrap\u5bf9\u8c61\u7684handle\u53bb\u8bf7\u6c42Libuv\u4e86\u3002 6.7 C++\u5c42\u8c03\u7528Libuv \u00b6 \u521a\u624d\u6211\u4eec\u5206\u6790\u4e86JS\u8c03\u7528C++\u5c42\u65f6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bC++\u8c03\u7528Libuv\u548cLibuv\u56de\u8c03C++\u5c42\u53c8\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u6211\u4eec\u901a\u8fc7TCP\u6a21\u5757\u7684connect\u51fd\u6570\u7ee7\u7eed\u5206\u6790\u8be5\u8fc7\u7a0b\u3002 1. template <typename T> 2. void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args, 3. std::function<int(const char* ip_address, T* addr)> uv_ip_addr) { 4. Environment* env = Environment::GetCurrent(args); 5. 6. TCPWrap* wrap; 7. ASSIGN_OR_RETURN_UNWRAP(&wrap, 8. args.Holder(), 9. args.GetReturnValue().Set(UV_EBADF)); 10. 11. // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662fTCPConnectWrap\u5bf9\u8c61\uff0c\u89c1net\u6a21\u5757 12. Local<Object> req_wrap_obj = args[0].As<Object>(); 13. // \u7b2c\u4e8c\u4e2a\u662fip\u5730\u5740 14. node::Utf8Value ip_address(env->isolate(), args[1]); 15. 16. T addr; 17. // \u628a\u7aef\u53e3\uff0cIP\u8bbe\u7f6e\u5230addr\u4e0a\uff0c\u7aef\u53e3\u4fe1\u606f\u5728uv_ip_addr\u4e0a\u4e0b\u6587\u91cc\u4e86 18. int err = uv_ip_addr(*ip_address, &addr); 19. 20. if (err == 0) { 21. ConnectWrap* req_wrap = 22. new ConnectWrap(env, 23. req_wrap_obj, 24. AsyncWrap::PROVIDER_TCPCONNECTWRAP); 25. err = req_wrap->Dispatch(uv_tcp_connect, 26. &wrap->handle_, 27. reinterpret_cast<const sockaddr*>(&addr), 28. AfterConnect); 29. if (err) 30. delete req_wrap; 31. } 32. 33. args.GetReturnValue().Set(err); 34. } \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bConnectWrap\u3002\u6211\u4eec\u77e5\u9053ConnectWrap\u662fReqWrap\u7684\u5b50\u7c7b\u3002req_wrap_obj\u662fJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002New ConnectWrap\u540e\u7ed3\u6784\u5982\u56fe6-9\u6240\u793a\u3002 \u56fe6-9 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bDispatch\u3002 1. // \u8c03\u7528Libuv\u51fd\u6570 2. template <typename T> 3. template <typename LibuvFunction, typename... Args> 4. int ReqWrap<T>::Dispatch(LibuvFunction fn, Args... args) { 5. // \u4fdd\u5b58Libuv\u7ed3\u6784\u4f53\u548cC++\u5c42\u5bf9\u8c61ConnectWrap\u7684\u5173\u7cfb 6. req_.data = this; 7. int err = CallLibuvFunction<T, LibuvFunction>::Call( 8. fn, 9. env()->event_loop(), 10. req(), 11. MakeLibuvRequestCallback<T, Args>::For(this, args)...); 12. if (err >= 0) 13. env()->IncreaseWaitingRequestCounter(); 14. return err; 15. } \u8c03\u7528Libuv\u4e4b\u524d\u7684\u7ed3\u6784\u5982\u56fe6-10\u6240\u793a\u3002 \u56fe6-10 \u63a5\u4e0b\u6765\u6211\u4eec\u5206\u6790\u8c03\u7528Libuv\u7684\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u770b\u5230Dispatch\u51fd\u6570\u662f\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u3002 \u9996\u5148\u770b\u4e00\u4e0bCallLibuvFunction\u7684\u5b9e\u73b0\u3002 1. template <typename ReqT, typename T> 2. struct CallLibuvFunction; 3. 4. // Detect `int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);`. 5. template <typename ReqT, typename... Args> 6. struct CallLibuvFunction<ReqT, int(*)(uv_loop_t*, ReqT*, Args...)> { 7. using T = int(*)(uv_loop_t*, ReqT*, Args...); 8. template <typename... PassedArgs> 9. static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) { 10. return fn(loop, req, args...); 11. } 12. }; 13. 14. // Detect `int uv_foo(uv_req_t* request, ...);`. 15. template <typename ReqT, typename... Args> 16. struct CallLibuvFunction<ReqT, int(*)(ReqT*, Args...)> { 17. using T = int(*)(ReqT*, Args...); 18. template <typename... PassedArgs> 19. static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) { 20. return fn(req, args...); 21. } 22. }; 23. 24. // Detect `void uv_foo(uv_req_t* request, ...);`. 25. template <typename ReqT, typename... Args> 26. struct CallLibuvFunction<ReqT, void(*)(ReqT*, Args...)> { 27. using T = void(*)(ReqT*, Args...); 28. template <typename... PassedArgs> 29. static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) { 30. fn(req, args...); 31. return 0; 32. } 33. }; CallLibuvFunction\u7684\u5b9e\u73b0\u770b\u8d77\u6765\u975e\u5e38\u590d\u6742\uff0c\u90a3\u662f\u56e0\u4e3a\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\uff0cCallLibuvFunction\u672c\u8d28\u4e0a\u662f\u4e00\u4e2astruct\uff0c\u5728C++\u91cc\u548c\u7c7b\u4f5c\u7528\u7c7b\u4f3c\uff0c\u91cc\u9762\u53ea\u6709\u4e00\u4e2a\u7c7b\u51fd\u6570Call\uff0cNode.js\u4e3a\u4e86\u9002\u914dLibuv\u5c42\u5404\u79cd\u7c7b\u578b\u51fd\u6570\u7684\u8c03\u7528\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e86\u4e09\u79cd\u7c7b\u578b\u7684CallLibuvFunction,\u5e76\u4e14\u4f7f\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\u3002\u6211\u4eec\u53ea\u9700\u8981\u5206\u6790\u4e00\u79cd\u5c31\u53ef\u4ee5\u4e86\u3002\u6211\u4eec\u6839\u636eTCP\u7684connect\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002\u6211\u4eec\u9996\u5148\u5177\u4f53\u4e0bDispatch\u51fd\u6570\u7684\u6a21\u677f\u53c2\u6570\u3002 1. template <typename T> 2. template <typename LibuvFunction, typename... Args> T\u5bf9\u5e94ReqWrap\u7684\u7c7b\u578b\uff0cLibuvFunction\u5bf9\u5e94Libuv\u7684\u51fd\u6570\u7c7b\u578b\uff0c\u8fd9\u91cc\u662fint uv_tcp_connect(uv_connect_t* req, ...)\uff0c\u6240\u4ee5\u662f\u5bf9\u5e94LibuvFunction\u7684\u7b2c\u4e8c\u79cd\u60c5\u51b5\uff0cArgs\u662f\u6267\u884cDispatch\u65f6\u9664\u4e86\u7b2c\u4e00\u4e2a\u5b9e\u53c2\u5916\u7684\u5269\u4f59\u53c2\u6570\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5316Dispatch\u3002 1. int ReqWrap<uv_connect_t>::Dispatch(int(*)(uv_connect_t*, Args...), Args... args) { 2. req_.data = this; 3. int err = CallLibuvFunction<uv_connect_t, int(*)(uv_connect_t*, Args...)>::Call( 4. fn, 5. env()->event_loop(), 6. req(), 7. MakeLibuvRequestCallback<T, Args>::For(this, args)...); 8. 9. return err; 10. } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bMakeLibuvRequestCallback\u7684\u5b9e\u73b0\u3002 1. // \u900f\u4f20\u53c2\u6570\u7ed9Libuv 2. template <typename ReqT, typename T> 3. struct MakeLibuvRequestCallback { 4. static T For(ReqWrap<ReqT>* req_wrap, T v) { 5. static_assert(!is_callable<T>::value, 6. \"MakeLibuvRequestCallback missed a callback\"); 7. return v; 8. } 9. }; 10. 11. template <typename ReqT, typename... Args> 12. struct MakeLibuvRequestCallback<ReqT, void(*)(ReqT*, Args...)> { 13. using F = void(*)(ReqT* req, Args... args); 14. // Libuv\u56de\u8c03 15. static void Wrapper(ReqT* req, Args... args) { 16. // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 17. ReqWrap<ReqT>* req_wrap = ReqWrap<ReqT>::from_req(req); 18. req_wrap->env()->DecreaseWaitingRequestCounter(); 19. // \u62ff\u5230\u539f\u59cb\u7684\u56de\u8c03\u6267\u884c 20. F original_callback = reinterpret_cast<F>(req_wrap->original_callback_); 21. original_callback(req, args...); 22. } 23. 24. static F For(ReqWrap<ReqT>* req_wrap, F v) { 25. // \u4fdd\u5b58\u539f\u6765\u7684\u51fd\u6570 26. CHECK_NULL(req_wrap->original_callback_); 27. req_wrap->original_callback_ = 28. reinterpret_cast<typename ReqWrap<ReqT>::callback_t>(v); 29. // \u8fd4\u56de\u5305\u88f9\u51fd\u6570 30. return Wrapper; 31. } 32. }; MakeLibuvRequestCallback\u7684\u5b9e\u73b0\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u6a21\u7248\u53c2\u6570\u7684\u7b2c\u4e00\u4e2a\u4e00\u822c\u662fReqWrap\u5b50\u7c7b\uff0c\u7b2c\u4e8c\u4e2a\u4e00\u822c\u662fhandle\uff0c\u521d\u59cb\u5316ReqWrap\u7c7b\u7684\u65f6\u5019\uff0cenv\u4e2d\u4f1a\u8bb0\u5f55ReqWrap\u5b9e\u4f8b\u7684\u4e2a\u6570\uff0c\u4ece\u800c\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u8bf7\u6c42\u6b63\u5728\u88abLibuv\u5904\u7406\uff0c\u6a21\u677f\u53c2\u6570\u7684\u7b2c\u4e8c\u4e2a\u5982\u679c\u662f\u51fd\u6570\u5219\u8bf4\u660e\u6ca1\u6709\u4f7f\u7528ReqWrap\u8bf7\u6c42Libuv\uff0c\u5219\u4f7f\u7528\u7b2c\u4e8c\u79cd\u5b9e\u73b0\uff0c\u52ab\u6301\u56de\u8c03\u4ece\u800c\u8bb0\u5f55\u6b63\u5728\u88abLibuv\u5904\u7406\u7684\u8bf7\u6c42\u6570\uff08\u5982GetAddrInfo\u7684\u5b9e\u73b0\uff09\u3002\u6240\u4ee5\u6211\u4eec\u8fd9\u91cc\u662f\u9002\u914d\u7b2c\u4e00\u79cd\u5b9e\u73b0\u3002\u900f\u4f20C++\u5c42\u53c2\u6570\u7ed9Libuv\u3002\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b Dispatch 1. int ReqWrap<uv_connect_t>::Dispatch(int(*)(uv_connect_t*, Args...), Args... args) { 2. req_.data = this; 3. int err = CallLibuvFunction<uv_connect_t, int(*)(uv_connect_t*, Args...)>::Call( 4. fn, 5. env()->event_loop(), 6. req(), 7. args...); 8. 9. return err; 10. } \u518d\u8fdb\u4e00\u6b65\u5c55\u5f00\u3002 1. static int Call(int(*fn)(uv_connect_t*, Args...), uv_loop_t* loop, uv_connect_t* req, PassedArgs... args) { 2. return fn(req, args...); 3. } \u6700\u540e\u5c55\u5f00 1. static int Call(int(*fn)(uv_connect_t*, Args...), uv_loop_t* loop, uv_connect_t* req, PassedArgs... args) { 2. return fn(req, args...); 3. } 4. 5. Call( 6. uv_tcp_connect, 7. env()->event_loop(), 8. req(), 9. &wrap->handle_, 10. AfterConnec 11. ) 12. 13. uv_tcp_connect( 14. env()->event_loop(), 15. req(), 16. &wrap->handle_, 17. AfterConnect 18. ); \u63a5\u7740\u6211\u4eec\u770b\u770buv_tcp_connect\u505a\u4e86\u4ec0\u4e48\u3002 1. int uv_tcp_connect(uv_connect_t* req, 2. uv_tcp_t* handle, 3. const struct sockaddr* addr, 4. uv_connect_cb cb) { 5. // ... 6. return uv__tcp_connect(req, handle, addr, addrlen, cb); 7. } 8. 9. int uv__tcp_connect(uv_connect_t* req, 10. uv_tcp_t* handle, 11. const struct sockaddr* addr, 12. unsigned int addrlen, 13. uv_connect_cb cb) { 14. int err; 15. int r; 16. 17. // \u5173\u8054\u8d77\u6765 18. req->handle = (uv_stream_t*) handle; 19. // ... 20. } Libuv\u4e2d\u628areq\u548chandle\u505a\u4e86\u5173\u8054\uff0c\u5982\u56fe6-11\u6240\u793a\u3002 \u56fe6-11 \u5206\u6790\u5b8cC++\u8c03\u7528Libuv\u540e\uff0c\u6211\u4eec\u770b\u770bLibuv\u56de\u8c03C++\u548cC++\u56de\u8c03JS\u7684\u8fc7\u7a0b\u3002\u5f53Libuv\u5904\u7406\u5b8c\u8bf7\u6c42\u540e\u4f1a\u6267\u884cAfterConnect \u3002 1. template <typename WrapType, typename UVType> 2. void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req, 3. int status) { 4. // \u4eceLibuv\u7ed3\u6784\u4f53\u62ff\u5230C++\u7684\u8bf7\u6c42\u5bf9\u8c61 5. std::unique_ptr<ConnectWrap> req_wrap 6. (static_cast<ConnectWrap*>(req->data)); 7. // \u4eceC++\u5c42\u8bf7\u6c42\u5bf9\u8c61\u62ff\u5230\u5bf9\u5e94\u7684handle\u7ed3\u6784\u4f53\uff08Libuv\u91cc\u5173\u8054\u8d77\u6765\u7684\uff09\uff0c\u518d\u901a\u8fc7handle\u62ff\u5230\u5bf9\u5e94\u7684C++\u5c42handle\u5bf9\u8c61\uff08HandleWrap\u5173\u8054\u7684\uff09 8. WrapType* wrap = static_cast<WrapType*>(req->handle->data); 9. Environment* env = wrap->env(); 10. ... 11. Local<Value> argv[5] = { 12. Integer::New(env->isolate(), status), 13. wrap->object(), 14. req_wrap->object(), 15. Boolean::New(env->isolate(), readable), 16. Boolean::New(env->isolate(), writable) 17. }; 18. // \u56de\u8c03JS\u5c42oncomplete 19. req_wrap->MakeCallback(env->oncomplete_string(), 20. arraysize(argv), 21. argv); 22. } 6.8 \u6d41\u5c01\u88c5 \u00b6 Node.js\u5728C++\u5c42\u5bf9\u6d41\u8fdb\u884c\u4e86\u975e\u5e38\u591a\u7684\u5c01\u88c5\uff0c\u5f88\u591a\u6a21\u5757\u90fd\u4f9d\u8d56C++\u5c42\u6d41\u7684\u673a\u5236\uff0c\u6d41\u673a\u5236\u7684\u8bbe\u8ba1\u4e2d\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 \u8d44\u6e90\uff0c\u8fd9\u662f\u6d41\u673a\u5236\u7684\u6838\u5fc3\uff08StreamResource\uff09, 2 \u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\uff08StreamReq\uff09 3 \u6d41\u4e8b\u4ef6\u7684\u76d1\u542c\u8005\uff0c\u5f53\u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\u6216\u6d41\u672c\u8eab\u6709\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u628a\u4e8b\u4ef6\u548c\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u4f20\u9012\u7ed9\u76d1\u542c\u8005\uff0c\u76d1\u542c\u8005\u5904\u7406\u5b8c\u540e\uff0c\u518d\u901a\u77e5\u6d41\uff08StreamListener\uff09\u3002 \u901a\u8fc7\u7ee7\u627f\u7684\u6a21\u5f0f\uff0c\u57fa\u7c7b\u5b9a\u4e49\u63a5\u53e3\uff0c\u5b50\u7c7b\u5b9e\u73b0\u63a5\u53e3\u7684\u65b9\u5f0f\u3002\u5bf9\u6d41\u7684\u64cd\u4f5c\u8fdb\u884c\u4e86\u62bd\u8c61\u548c\u5c01\u88c5\u3002\u4e09\u8005\u7684\u7c7b\u5173\u7cfb\u5982\u56fe6-12\u6240\u793a\u3002 \u56fe6-12 \u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u4e00\u4e2a\u6d41\u7684\u6570\u636e\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-13\u6240\u793a\u3002 \u56fe6-13 \u518d\u770b\u4e00\u4e0b\u5199\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-14\u6240\u793a\u3002 \u56fe6-14 6.8.1 StreamResource \u00b6 StreamResource\u5b9a\u4e49\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u89e6\u53d1\u7684\u56de\u8c03\u3002\u4f46\u662fStreamResource\u4e0d\u5b9a\u4e49\u6d41\u7684\u7c7b\u578b\uff0c\u6d41\u7684\u7c7b\u578b\u7531\u5b50\u7c7b\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u5728StreamResource\u4e0a\u6ce8\u518clistener\uff0c\u8868\u793a\u5bf9\u6d41\u611f\u5174\u8da3\uff0c\u5f53\u6d41\u4e0a\u6709\u6570\u636e\u53ef\u8bfb\u6216\u8005\u4e8b\u4ef6\u53d1\u751f\u65f6\uff0c\u5c31\u4f1a\u901a\u77e5listener\u3002 1. class StreamResource { 2. public: 3. virtual ~StreamResource(); 4. // \u6ce8\u518c/\u6ce8\u9500\u7b49\u5f85\u6d41\u53ef\u8bfb\u4e8b\u4ef6 5. virtual int ReadStart() = 0; 6. virtual int ReadStop() = 0; 7. // \u5173\u95ed\u6d41 8. virtual int DoShutdown(ShutdownWrap* req_wrap) = 0; 9. // \u5199\u5165\u6d41 10. virtual int DoTryWrite(uv_buf_t** bufs, size_t* count); 11. virtual int DoWrite(WriteWrap* w, 12. uv_buf_t* bufs, 13. size_t count, 14. uv_stream_t* send_handle) = 0; 15. // ...\u5ffd\u7565\u4e00\u4e9b 16. // \u7ed9\u6d41\u589e\u52a0\u6216\u5220\u9664\u76d1\u542c\u8005 17. void PushStreamListener(StreamListener* listener); 18. void RemoveStreamListener(StreamListener* listener); 19. 20. protected: 21. uv_buf_t EmitAlloc(size_t suggested_size); 22. void EmitRead(ssize_t nread, 23. const uv_buf_t& buf = uv_buf_init(nullptr, 0)); 24. // \u6d41\u7684\u76d1\u542c\u8005\uff0c\u5373\u6570\u636e\u6d88\u8d39\u8005 25. StreamListener* listener_ = nullptr; 26. uint64_t bytes_read_ = 0; 27. uint64_t bytes_written_ = 0; 28. friend class StreamListener; 29. }; StreamResource\u662f\u4e00\u4e2a\u57fa\u7c7b\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a\u6210\u5458\u662fStreamListener\u7c7b\u7684\u5b9e\u4f8b\uff0c\u6211\u4eec\u540e\u9762\u5206\u6790\u3002\u6211\u4eec\u770b\u4e00\u4e0bStreamResource\u7684\u5b9e\u73b0\u3002 1\u589e\u52a0\u4e00\u4e2alistener 1. // \u589e\u52a0\u4e00\u4e2alistener 2. inline void StreamResource::PushStreamListener(StreamListener* listener) { 3. // \u5934\u63d2\u6cd5 4. listener->previous_listener_ = listener_; 5. listener->stream_ = this; 6. listener_ = listener; 7. } \u6211\u4eec\u53ef\u4ee5\u5728\u4e00\u4e2a\u6d41\u4e0a\u6ce8\u518c\u591a\u4e2alistener\uff0c\u6d41\u7684listener_\u5b57\u6bb5\u7ef4\u62a4\u4e86\u6d41\u4e0a\u6240\u6709\u7684listener\u961f\u5217\u3002\u5173\u7cfb\u56fe\u5982\u56fe6-15\u6240\u793a\u3002 \u56fe6-15 2\u5220\u9664listener 1. inline void StreamResource::RemoveStreamListener(StreamListener* listener) { 2. StreamListener* previous; 3. StreamListener* current; 4. 5. // \u904d\u5386\u5355\u94fe\u8868 6. for (current = listener_, previous = nullptr; 7. /* No loop condition because we want a crash if listener is not found */ 8. ; previous = current, current = current->previous_listener_) { 9. if (current == listener) { 10. // \u975e\u7a7a\u8bf4\u660e\u9700\u8981\u5220\u9664\u7684\u4e0d\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9 11. if (previous != nullptr) 12. previous->previous_listener_ = current->previous_listener_; 13. else 14. // \u5220\u9664\u7684\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u66f4\u65b0\u5934\u6307\u9488\u5c31\u884c 15. listener_ = listener->previous_listener_; 16. break; 17. } 18. } 19. // \u91cd\u7f6e\u88ab\u5220\u9664listener\u7684\u5b57\u6bb5 20. listener->stream_ = nullptr; 21. listener->previous_listener_ = nullptr; 22. } 3 \u7533\u8bf7\u5b58\u50a8\u6570\u636e 1. // \u7533\u8bf7\u4e00\u5757\u5185\u5b58 2. inline uv_buf_t StreamResource::EmitAlloc(size_t suggested_size) { 3. DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); 4. return listener_->OnStreamAlloc(suggested_size); 5. } StreamResource\u53ea\u662f\u5b9a\u4e49\u4e86\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\uff0c\u6570\u636e\u5b58\u50a8\u548c\u6d88\u8d39\u7531listener\u5b9a\u4e49\u3002 4 \u6570\u636e\u53ef\u8bfb 1. inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { 2. if (nread > 0) 3. // \u8bb0\u5f55\u4ece\u6d41\u4e2d\u8bfb\u53d6\u7684\u6570\u636e\u7684\u5b57\u8282\u5927\u5c0f 4. bytes_read_ += static_cast<uint64_t>(nread); 5. listener_->OnStreamRead(nread, buf); 6. } 5 \u5199\u56de\u8c03 1. inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) { 2. DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); 3. listener_->OnStreamAfterWrite(w, status); 4. } 6 \u5173\u95ed\u6d41\u56de\u8c03 1. inline void StreamResource::EmitAfterShutdown(ShutdownWrap* w, int status) { 2. DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); 3. listener_->OnStreamAfterShutdown(w, status); 4. } 7 \u6d41\u9500\u6bc1\u56de\u8c03 1. inline StreamResource::~StreamResource() { 2. while (listener_ != nullptr) { 3. StreamListener* listener = listener_; 4. listener->OnStreamDestroy(); 5. if (listener == listener_) 6. RemoveStreamListener(listener_); 7. } 8. } \u6d41\u9500\u6bc1\u540e\u9700\u8981\u901a\u77e5listener\uff0c\u5e76\u4e14\u89e3\u9664\u5173\u7cfb\u3002 6.8.2 StreamBase \u00b6 StreamBase\u662fStreamResource\u7684\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86StreamResource\u7684\u529f\u80fd\u3002 1. class StreamBase : public StreamResource { 2. public: 3. static constexpr int kStreamBaseField = 1; 4. static constexpr int kOnReadFunctionField = 2; 5. static constexpr int kStreamBaseFieldCount = 3; 6. // \u5b9a\u4e49\u4e00\u4e9b\u7edf\u4e00\u7684\u903b\u8f91 7. static void AddMethods(Environment* env, 8. v8::Local<v8::FunctionTemplate> target); 9. 10. virtual bool IsAlive() = 0; 11. virtual bool IsClosing() = 0; 12. virtual bool IsIPCPipe(); 13. virtual int GetFD(); 14. 15. // \u6267\u884cJS\u56de\u8c03 16. v8::MaybeLocal<v8::Value> CallJSOnreadMethod( 17. ssize_t nread, 18. v8::Local<v8::ArrayBuffer> ab, 19. size_t offset = 0, 20. StreamBaseJSChecks checks = DONT_SKIP_NREAD_CHECKS); 21. 22. Environment* stream_env() const; 23. // \u5173\u95ed\u6d41 24. int Shutdown(v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); 25. // \u5199\u5165\u6d41 26. StreamWriteResult Write( 27. uv_buf_t* bufs, 28. size_t count, 29. uv_stream_t* send_handle = nullptr, 30. v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); 31. // \u521b\u5efa\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42 32. virtual ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object); 33. // \u521b\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 34. virtual WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object); 35. 36. virtual AsyncWrap* GetAsyncWrap() = 0; 37. virtual v8::Local<v8::Object> GetObject(); 38. static StreamBase* FromObject(v8::Local<v8::Object> obj); 39. 40. protected: 41. explicit StreamBase(Environment* env); 42. 43. // JS Methods 44. int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args); 45. // \u7701\u7565\u7cfb\u5217\u65b9\u6cd5 46. void AttachToObject(v8::Local<v8::Object> obj); 47. 48. template <int (StreamBase::*Method)( 49. const v8::FunctionCallbackInfo<v8::Value>& args)> 50. static void JSMethod(const v8::FunctionCallbackInfo<v8::Value>& args); 51. 52. private: 53. Environment* env_; 54. EmitToJSStreamListener default_listener_; 55. 56. void SetWriteResult(const StreamWriteResult& res); 57. static void AddMethod(Environment* env, 58. v8::Local<v8::Signature> sig, 59. enum v8::PropertyAttribute attributes, 60. v8::Local<v8::FunctionTemplate> t, 61. JSMethodFunction* stream_method, 62. v8::Local<v8::String> str); 63. }; 1 \u521d\u59cb\u5316 1. inline StreamBase::StreamBase(Environment* env) : env_(env) { 2. PushStreamListener(&default_listener_); 3. } StreamBase\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u9ed8\u8ba4\u8bbe\u7f6e\u4e00\u4e2alistener\u3002 2 \u5173\u95ed\u6d41 1. // \u5173\u95ed\u4e00\u4e2a\u6d41\uff0creq_wrap_obj\u662fJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 2. inline int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) { 3. Environment* env = stream_env(); 4. HandleScope handle_scope(env->isolate()); 5. AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); 6. // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u6570\u636e\u7ed3\u6784 7. ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj); 8. // \u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5173\u95ed\u7684\u903b\u8f91\u4e0d\u4e00\u6837 9. int err = DoShutdown(req_wrap); 10. // \u6267\u884c\u51fa\u9519\u5219\u9500\u6bc1JS\u5c42\u5bf9\u8c61 11. if (err != 0 && req_wrap != nullptr) { 12. req_wrap->Dispose(); 13. } 14. 15. const char* msg = Error(); 16. if (msg != nullptr) { 17. req_wrap_obj->Set( 18. env->context(), 19. env->error_string(), 20. OneByteString(env->isolate(), msg)).Check(); 21. ClearError(); 22. } 23. 24. return err; 25. } 3 \u5199 1. // \u5199Buffer\uff0c\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 2. int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. 5. Local<Object> req_wrap_obj = args[0].As<Object>(); 6. uv_buf_t buf; 7. // \u6570\u636e\u5185\u5bb9\u548c\u957f\u5ea6 8. buf.base = Buffer::Data(args[1]); 9. buf.len = Buffer::Length(args[1]); 10. 11. uv_stream_t* send_handle = nullptr; 12. // \u662f\u5bf9\u8c61\u5e76\u4e14\u6d41\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 13. if (args[2]->IsObject() && IsIPCPipe()) { 14. Local<Object> send_handle_obj = args[2].As<Object>(); 15. 16. HandleWrap* wrap; 17. // \u4ece\u8fd4\u56dejs\u7684\u5bf9\u8c61\u4e2d\u83b7\u53d6internalField\u4e2d\u6307\u5411\u7684C++\u5c42\u5bf9\u8c61 18. ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL); 19. // \u62ff\u5230Libuv\u5c42\u7684handle 20. send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); 21. // Reference LibuvStreamWrap instance to prevent it from being garbage 22. // collected before `AfterWrite` is called. 23. // \u8bbe\u7f6e\u5230JS\u5c42\u8bf7\u6c42\u5bf9\u8c61\u4e2d 24. req_wrap_obj->Set(env->context(), 25. env->handle_string(), 26. send_handle_obj).Check(); 27. } 28. 29. StreamWriteResult res = Write(&buf, 1, send_handle, req_wrap_obj); 30. SetWriteResult(res); 31. 32. return res.err; 33. } 1. inline StreamWriteResult StreamBase::Write( 2. uv_buf_t* bufs, 3. size_t count, 4. uv_stream_t* send_handle, 5. v8::Local<v8::Object> req_wrap_obj) { 6. Environment* env = stream_env(); 7. int err; 8. 9. size_t total_bytes = 0; 10. // \u8ba1\u7b97\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u5927\u5c0f 11. for (size_t i = 0; i < count; ++i) 12. total_bytes += bufs[i].len; 13. // \u540c\u4e0a 14. bytes_written_ += total_bytes; 15. // \u662f\u5426\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e0d\u9700\u8981\u5219\u76f4\u63a5\u5199 16. if (send_handle == nullptr) { 17. err = DoTryWrite(&bufs, &count); 18. if (err != 0 || count == 0) { 19. return StreamWriteResult { false, err, nullptr, total_bytes }; 20. } 21. } 22. 23. HandleScope handle_scope(env->isolate()); 24. 25. AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); 26. // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u5199\u8bf7\u6c42\u5bf9\u8c61 27. WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj); 28. // \u6267\u884c\u5199\uff0c\u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5199\u64cd\u4f5c\u4e0d\u4e00\u6837 29. err = DoWrite(req_wrap, bufs, count, send_handle); 30. 31. const char* msg = Error(); 32. if (msg != nullptr) { 33. req_wrap_obj->Set(env->context(), 34. env->error_string(), 35. OneByteString(env->isolate(), msg)).Check(); 36. ClearError(); 37. } 38. 39. return StreamWriteResult { async, err, req_wrap, total_bytes }; 40. } 4 \u8bfb 1. // \u64cd\u4f5c\u6d41\uff0c\u542f\u52a8\u8bfb\u53d6 2. int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) { 3. return ReadStart(); 4. } 5. 6. // \u64cd\u4f5c\u6d41\uff0c\u505c\u6b62\u8bfb\u53d6 7. int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) { 8. return ReadStop(); 9. } 10. 11. // \u89e6\u53d1\u6d41\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u53ef\u8bfb 12. MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, 13. Local<ArrayBuffer> ab, 14. size_t offset, 15. StreamBaseJSChecks checks) { 16. Environment* env = env_; 17. env->stream_base_state()[kReadBytesOrError] = nread; 18. env->stream_base_state()[kArrayBufferOffset] = offset; 19. 20. Local<Value> argv[] = { 21. ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>() 22. }; 23. // GetAsyncWrap\u5728StreamBase\u5b50\u7c7b\u5b9e\u73b0\uff0c\u62ff\u5230StreamBase\u7c7b\u5bf9\u8c61 24. AsyncWrap* wrap = GetAsyncWrap(); 25. // \u83b7\u53d6\u56de\u8c03\u6267\u884c 26. Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); 27. return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); 28. } 4 \u6d41\u901a\u7528\u65b9\u6cd5 1. void StreamBase::AddMethod(Environment* env, 2. Local<Signature> signature, 3. enum PropertyAttribute attributes, 4. Local<FunctionTemplate> t, 5. JSMethodFunction* stream_method, 6. Local<String> string) { 7. // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 8. Local<FunctionTemplate> templ = 9. env->NewFunctionTemplate(stream_method, 10. signature, 11. v8::ConstructorBehavior::kThrow, 12. v8::SideEffectType::kHasNoSideEffect); 13. // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 14. t->PrototypeTemplate()->SetAccessorProperty( 15. string, templ, Local<FunctionTemplate>(), attributes); 16. } 17. 18. void StreamBase::AddMethods(Environment* env, Local<FunctionTemplate> t) { 19. HandleScope scope(env->isolate()); 20. 21. enum PropertyAttribute attributes = 22. static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum); 23. Local<Signature> sig = Signature::New(env->isolate(), t); 24. // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 25. AddMethod(env, sig, attributes, t, GetFD, env->fd_string()); 26. // \u5ffd\u7565\u90e8\u5206 27. env->SetProtoMethod(t, \"readStart\", JSMethod<&StreamBase::ReadStartJS>); 28. env->SetProtoMethod(t, \"readStop\", JSMethod<&StreamBase::ReadStopJS>); 29. env->SetProtoMethod(t, \"shutdown\", JSMethod<&StreamBase::Shutdown>); 30. env->SetProtoMethod(t, \"writev\", JSMethod<&StreamBase::Writev>); 31. env->SetProtoMethod(t, \"writeBuffer\", JSMethod<&StreamBase::WriteBuffer>); 32. env->SetProtoMethod( 33. t, \"writeAsciiString\", JSMethod<&StreamBase::WriteString<ASCII>>); 34. env->SetProtoMethod( 35. t, \"writeUtf8String\", JSMethod<&StreamBase::WriteString<UTF8>>); 36. t->PrototypeTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), 37. \"isStreamBase\"), 38. True(env->isolate())); 39. // \u8bbe\u7f6e\u8bbf\u95ee\u5668 40. t->PrototypeTemplate()->SetAccessor( 41. // \u952e\u540d 42. FIXED_ONE_BYTE_STRING(env->isolate(), \"onread\"), 43. // getter 44. BaseObject::InternalFieldGet<kOnReadFunctionField>, 45. // setter\uff0cValue::IsFunction\u662fset\u4e4b\u524d\u7684\u6821\u9a8c\u51fd\u6570\uff0c\u89c1InternalFieldSet\uff08\u6a21\u677f\u51fd\u6570\uff09\u5b9a\u4e49 46. BaseObject::InternalFieldSet<kOnReadFunctionField, &Value::IsFunction>); 47. } 5 \u5176\u5b83\u51fd\u6570 1. // \u9ed8\u8ba4false\uff0c\u5b50\u7c7b\u91cd\u5199 2. bool StreamBase::IsIPCPipe() { 3. return false; 4. } 5. 6. // \u5b50\u7c7b\u91cd\u5199 7. int StreamBase::GetFD() { 8. return -1; 9. } 10. 11. Local<Object> StreamBase::GetObject() { 12. return GetAsyncWrap()->object(); 13. } 14. 15. // \u5de5\u5177\u51fd\u6570\u548c\u5b9e\u4f8bthis\u65e0\u5173\uff0c\u548c\u5165\u53c2\u6709\u5173 16. void StreamBase::GetFD(const FunctionCallbackInfo<Value>& args) { 17. // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD(). 18. // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5b83\u5173\u8054\u7684C++\u5bf9\u8c61\uff0c\u4e0d\u4e00\u5b9a\u662fthis 19. StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); 20. if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL); 21. 22. if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL); 23. 24. args.GetReturnValue().Set(wrap->GetFD()); 25. } 26. 27. void StreamBase::GetBytesRead(const FunctionCallbackInfo<Value>& args) { 28. StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); 29. if (wrap == nullptr) return args.GetReturnValue().Set(0); 30. 31. // uint64_t -> double. 53bits is enough for all real cases. 32. args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_)); 33. } 6.8.3 LibuvStreamWrap \u00b6 LibuvStreamWrap\u662fStreamBase\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86\u7236\u7c7b\u7684\u63a5\u53e3\uff0c\u4e5f\u62d3\u5c55\u4e86\u6d41\u7684\u80fd\u529b\u3002 1. class LibuvStreamWrap : public HandleWrap, public StreamBase { 2. public: 3. static void Initialize(v8::Local<v8::Object> target, 4. v8::Local<v8::Value> unused, 5. v8::Local<v8::Context> context, 6. void* priv); 7. 8. int GetFD() override; 9. bool IsAlive() override; 10. bool IsClosing() override; 11. bool IsIPCPipe() override; 12. 13. // JavaScript functions 14. int ReadStart() override; 15. int ReadStop() override; 16. 17. // Resource implementation 18. int DoShutdown(ShutdownWrap* req_wrap) override; 19. int DoTryWrite(uv_buf_t** bufs, size_t* count) override; 20. int DoWrite(WriteWrap* w, 21. uv_buf_t* bufs, 22. size_t count, 23. uv_stream_t* send_handle) override; 24. 25. inline uv_stream_t* stream() const { 26. return stream_; 27. } 28. // \u662f\u5426\u662fUnix\u57df\u6216\u547d\u540d\u7ba1\u9053 29. inline bool is_named_pipe() const { 30. return stream()->type == UV_NAMED_PIPE; 31. } 32. // \u662f\u5426\u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 33. inline bool is_named_pipe_ipc() const { 34. return is_named_pipe() && 35. reinterpret_cast<const uv_pipe_t*>(stream())->ipc != 0; 36. } 37. 38. inline bool is_tcp() const { 39. return stream()->type == UV_TCP; 40. } 41. // \u521b\u5efa\u8bf7\u6c42Libuv\u7684\u5bf9\u8c61 42. ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override; 43. WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override; 44. // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5bf9\u4e8e\u7684C++\u5bf9\u8c61 45. static LibuvStreamWrap* From(Environment* env, v8::Local<v8::Object> object); 46. 47. protected: 48. LibuvStreamWrap(Environment* env, 49. v8::Local<v8::Object> object, 50. uv_stream_t* stream, 51. AsyncWrap::ProviderType provider); 52. 53. AsyncWrap* GetAsyncWrap() override; 54. 55. static v8::Local<v8::FunctionTemplate> GetConstructorTemplate( 56. Environment* env); 57. 58. private: 59. static void GetWriteQueueSize( 60. const v8::FunctionCallbackInfo<v8::Value>& info); 61. static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args); 62. 63. // Callbacks for libuv 64. void OnUvAlloc(size_t suggested_size, uv_buf_t* buf); 65. void OnUvRead(ssize_t nread, const uv_buf_t* buf); 66. 67. static void AfterUvWrite(uv_write_t* req, int status); 68. static void AfterUvShutdown(uv_shutdown_t* req, int status); 69. 70. uv_stream_t* const stream_; 71. }; 1 \u521d\u59cb\u5316 1. LibuvStreamWrap::LibuvStreamWrap(Environment* env, 2. Local<Object> object, 3. uv_stream_t* stream, 4. AsyncWrap::ProviderType provider) 5. : HandleWrap(env, 6. object, 7. reinterpret_cast<uv_handle_t*>(stream), 8. provider), 9. StreamBase(env), 10. stream_(stream) { 11. StreamBase::AttachToObject(object); 12. } LibuvStreamWrap\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u7684\u5185\u90e8\u6307\u9488\u6307\u5411\u81ea\u5df1\uff0c\u89c1HandleWrap\u3002 2 \u5199\u64cd\u4f5c 1. // \u5de5\u5177\u51fd\u6570\uff0c\u83b7\u53d6\u5f85\u5199\u6570\u636e\u5b57\u8282\u7684\u5927\u5c0f 2. void LibuvStreamWrap::GetWriteQueueSize( 3. const FunctionCallbackInfo<Value>& info) { 4. LibuvStreamWrap* wrap; 5. ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This()); 6. uint32_t write_queue_size = wrap->stream()->write_queue_size; 7. info.GetReturnValue().Set(write_queue_size); 8. } 9. 10. // \u8bbe\u7f6e\u975e\u963b\u585e 11. void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) { 12. LibuvStreamWrap* wrap; 13. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 14. bool enable = args[0]->IsTrue(); 15. args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable)); 16. } 17. // \u5b9a\u4e49\u4e00\u4e2a\u5173\u95ed\u7684\u8bf7\u6c42 18. typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>> LibuvShutdownWrap; 19. // \u5b9a\u4e49\u4e00\u4e2a\u5199\u8bf7\u6c42 20. typedef SimpleWriteWrap<ReqWrap<uv_write_t>> LibuvWriteWrap; 21. 22. ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) { 23. return new LibuvShutdownWrap(this, object); 24. } 25. 26. WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) { 27. return new LibuvWriteWrap(this, object); 28. } 29. 30. // \u53d1\u8d77\u5173\u95ed\u8bf7\u6c42\uff0c\u7531\u7236\u7c7b\u8c03\u7528\uff0creq_wrap\u662fC++\u5c42\u521b\u5efa\u7684\u5bf9\u8c61 31. int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) { 32. LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_); 33. return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown); 34. } 35. 36. // \u5173\u95ed\u8bf7\u6c42\u7ed3\u675f\u540e\u6267\u884c\u8bf7\u6c42\u7684\u901a\u7528\u56de\u8c03Done 37. void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) { 38. LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>( 39. LibuvShutdownWrap::from_req(req)); 40. HandleScope scope(req_wrap->env()->isolate()); 41. Context::Scope context_scope(req_wrap->env()->context()); 42. req_wrap->Done(status); 43. } 44. 45. int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) { 46. int err; 47. size_t written; 48. uv_buf_t* vbufs = *bufs; 49. size_t vcount = *count; 50. 51. err = uv_try_write(stream(), vbufs, vcount); 52. if (err == UV_ENOSYS || err == UV_EAGAIN) 53. return 0; 54. if (err < 0) 55. return err; 56. // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u66f4\u65b0\u6570\u636e 57. written = err; 58. for (; vcount > 0; vbufs++, vcount--) { 59. // Slice 60. if (vbufs[0].len > written) { 61. vbufs[0].base += written; 62. vbufs[0].len -= written; 63. written = 0; 64. break; 65. 66. // Discard 67. } else { 68. written -= vbufs[0].len; 69. } 70. } 71. 72. *bufs = vbufs; 73. *count = vcount; 74. 75. return 0; 76. } 77. 78. 79. int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap, 80. uv_buf_t* bufs, 81. size_t count, 82. uv_stream_t* send_handle) { 83. LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap); 84. return w->Dispatch(uv_write2, 85. stream(), 86. bufs, 87. count, 88. send_handle, 89. AfterUvWrite); 90. } 91. 92. 93. 94. void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) { 95. LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>( 96. LibuvWriteWrap::from_req(req)); 97. HandleScope scope(req_wrap->env()->isolate()); 98. Context::Scope context_scope(req_wrap->env()->context()); 99. req_wrap->Done(status); 100. } 3 \u8bfb\u64cd\u4f5c 1. // \u8c03\u7528Libuv\u5b9e\u73b0\u542f\u52a8\u8bfb\u903b\u8f91 2. int LibuvStreamWrap::ReadStart() { 3. return uv_read_start(stream(), [](uv_handle_t* handle, 4. size_t suggested_size, 5. uv_buf_t* buf) { 6. static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); 7. }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { 8. static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); 9. }); 10. } 11. 12. // \u5b9e\u73b0\u505c\u6b62\u8bfb\u903b\u8f91 13. int LibuvStreamWrap::ReadStop() { 14. return uv_read_stop(stream()); 15. } 16. 17. // \u9700\u8981\u5206\u914d\u5185\u5b58\u65f6\u7684\u56de\u8c03\uff0c\u7531Libuv\u56de\u8c03\uff0c\u5177\u4f53\u5206\u914d\u5185\u5b58\u903b\u8f91\u7531listener\u5b9e\u73b0 18. void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) { 19. HandleScope scope(env()->isolate()); 20. Context::Scope context_scope(env()->context()); 21. 22. *buf = EmitAlloc(suggested_size); 23. } 24. // \u5904\u7406\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 25. template <class WrapType> 26. static MaybeLocal<Object> AcceptHandle(Environment* env, 27. LibuvStreamWrap* parent) { 28. EscapableHandleScope scope(env->isolate()); 29. Local<Object> wrap_obj; 30. // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5176\u4e2d 31. if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj)) 32. return Local<Object>(); 33. // \u89e3\u51faC++\u5c42\u5bf9\u8c61 34. HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj); 35. CHECK_NOT_NULL(wrap); 36. // \u62ff\u5230C++\u5bf9\u8c61\u4e2d\u5c01\u88c5\u7684handle 37. uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); 38. // \u4ece\u670d\u52a1\u5668\u6d41\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230steam 39. if (uv_accept(parent->stream(), stream)) 40. ABORT(); 41. 42. return scope.Escape(wrap_obj); 43. } 44. 45. // \u5b9e\u73b0OnUvRead\uff0c\u6d41\u4e2d\u6709\u6570\u636e\u6216\u8bfb\u5230\u7ed3\u5c3e\u65f6\u7531Libuv\u56de\u8c03 46. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 47. HandleScope scope(env()->isolate()); 48. Context::Scope context_scope(env()->context()); 49. uv_handle_type type = UV_UNKNOWN_HANDLE; 50. // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b 51. if (is_named_pipe_ipc() && 52. uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) { 53. type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream())); 54. } 55. 56. // \u8bfb\u53d6\u6210\u529f 57. if (nread > 0) { 58. MaybeLocal<Object> pending_obj; 59. // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef 60. if (type == UV_TCP) { 61. pending_obj = AcceptHandle<TCPWrap>(env(), this); 62. } else if (type == UV_NAMED_PIPE) { 63. pending_obj = AcceptHandle<PipeWrap>(env(), this); 64. } else if (type == UV_UDP) { 65. pending_obj = AcceptHandle<UDPWrap>(env(), this); 66. } else { 67. CHECK_EQ(type, UV_UNKNOWN_HANDLE); 68. } 69. // \u6709\u9700\u8981\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u8bbe\u7f6e\u5230JS\u5c42\u5bf9\u8c61\u4e2d\uff0cJS\u5c42\u4f7f\u7528 70. if (!pending_obj.IsEmpty()) { 71. object() 72. ->Set(env()->context(), 73. env()->pending_handle_string(), 74. pending_obj.ToLocalChecked()) 75. .Check(); 76. } 77. } 78. // \u89e6\u53d1\u8bfb\u4e8b\u4ef6\uff0clistener\u5b9e\u73b0 79. EmitRead(nread, *buf); 80. } \u8bfb\u64cd\u4f5c\u4e0d\u4ec5\u652f\u6301\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\uff0c\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u4f1a\u65b0\u5efa\u4e00\u4e2a\u6d41\u5bf9\u8c61\u8868\u793a\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728JS\u5c42\u53ef\u4ee5\u4f7f\u7528\u3002 6.8.4 ConnectionWrap \u00b6 ConnectionWrap\u662fLibuvStreamWrap\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86\u8fde\u63a5\u7684\u63a5\u53e3\u3002\u9002\u7528\u4e8e\u5e26\u6709\u8fde\u63a5\u5c5e\u6027\u7684\u6d41\uff0c\u6bd4\u5982Unix\u57df\u548cTCP\u3002 1. // WrapType\u662fC++\u5c42\u7684\u7c7b\uff0cUVType\u662fLibuv\u7684\u7c7b\u578b 2. template <typename WrapType, typename UVType> 3. class ConnectionWrap : public LibuvStreamWrap { 4. public: 5. static void OnConnection(uv_stream_t* handle, int status); 6. static void AfterConnect(uv_connect_t* req, int status); 7. 8. protected: 9. ConnectionWrap(Environment* env, 10. v8::Local<v8::Object> object, 11. ProviderType provider); 12. 13. UVType handle_; 14. }; 1 \u53d1\u8d77\u8fde\u63a5\u540e\u7684\u56de\u8c03 1. template <typename WrapType, typename UVType> 2. void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req, 3. int status) { 4. // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 5. std::unique_ptr<ConnectWrap> req_wrap = 6. (static_cast<ConnectWrap*>(req->data)); 7. WrapType* wrap = static_cast<WrapType*>(req->handle->data); 8. Environment* env = wrap->env(); 9. 10. HandleScope handle_scope(env->isolate()); 11. Context::Scope context_scope(env->context()); 12. 13. bool readable, writable; 14. // \u8fde\u63a5\u7ed3\u679c 15. if (status) { 16. readable = writable = false; 17. } else { 18. readable = uv_is_readable(req->handle) != 0; 19. writable = uv_is_writable(req->handle) != 0; 20. } 21. 22. Local<Value> argv[5] = { 23. Integer::New(env->isolate(), status), 24. wrap->object(), 25. req_wrap->object(), 26. Boolean::New(env->isolate(), readable), 27. Boolean::New(env->isolate(), writable) 28. }; 29. // \u56de\u8c03js 30. req_wrap->MakeCallback(env->oncomplete_string(), 31. arraysize(argv), 32. argv); 33. } 2 \u8fde\u63a5\u5230\u6765\u65f6\u56de\u8c03 1. // \u6709\u8fde\u63a5\u65f6\u89e6\u53d1\u7684\u56de\u8c03 2. template <typename WrapType, typename UVType> 3. void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle, 4. int status) { 5. // \u62ff\u5230Libuv\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61 6. WrapType* wrap_data = static_cast<WrapType*>(handle->data); 7. Environment* env = wrap_data->env(); 8. HandleScope handle_scope(env->isolate()); 9. Context::Scope context_scope(env->context()); 10. 11. // \u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61 12. Local<Value> client_handle; 13. 14. if (status == 0) { 15. // Instantiate the client javascript object and handle. 16. // \u65b0\u5efa\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u5bf9\u8c61 17. Local<Object> client_obj; 18. if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET) 19. .ToLocal(&client_obj)) 20. return; 21. 22. // Unwrap the client javascript object. 23. WrapType* wrap; 24. // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61client_obj\u6240\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61\u5b58\u5230wrap\u4e2d 25. ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj); 26. // \u62ff\u5230\u5bf9\u5e94\u7684handle 27. uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_); 28. 29. // \u4ecehandleaccpet\u5230\u7684fd\u4e2d\u62ff\u4e00\u4e2a\u4fdd\u5b58\u5230client\uff0cclient\u5c31\u53ef\u4ee5\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u4e86 30. if (uv_accept(handle, client)) 31. return; 32. client_handle = client_obj; 33. } else { 34. client_handle = Undefined(env->isolate()); 35. } 36. // \u56de\u8c03JS\uff0cclient_handle\u76f8\u5f53\u4e8e\u5728JS\u5c42\u6267\u884cnew TCP 37. Local<Value> argv[] = { 38. Integer::New(env->isolate(), status), 39. client_handle 40. }; 41. wrap_data->MakeCallback(env->onconnection_string(), 42. arraysize(argv), 43. argv); 44. } \u6211\u4eec\u770b\u4e00\u4e0bTCP\u7684Instantiate\u3002 1. MaybeLocal<Object> TCPWrap::Instantiate(Environment* env, 2. AsyncWrap* parent, 3. TCPWrap::SocketType type) { 4. EscapableHandleScope handle_scope(env->isolate()); 5. AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent); 6. 7. // \u62ff\u5230\u5bfc\u51fa\u5230JS\u5c42\u7684TCP\u6784\u9020\u51fd\u6570\uff0c\u7f13\u5b58\u5728env\u4e2d 8. Local<Function> constructor = env->tcp_constructor_template() 9. ->GetFunction(env->context()) 10. .ToLocalChecked(); 11. Local<Value> type_value = Int32::New(env->isolate(), type); 12. // \u76f8\u5f53\u4e8e\u6211\u4eec\u5728JS\u5c42\u8c03\u7528new TCP()\u65f6\u62ff\u5230\u7684\u5bf9\u8c61 13. return handle_scope.EscapeMaybe( 14. constructor->NewInstance(env->context(), 1, &type_value)); 15. } 6.8.5 StreamReq \u00b6 StreamReq\u8868\u793a\u64cd\u4f5c\u6d41\u7684\u4e00\u6b21\u8bf7\u6c42\u3002\u4e3b\u8981\u4fdd\u5b58\u4e86\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u7684\u901a\u7528\u903b\u8f91\u3002 1. // \u8bf7\u6c42Libuv\u7684\u57fa\u7c7b 2. class StreamReq { 3. public: 4. // JS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61\u7684internalField[1]\u4fdd\u5b58\u4e86StreamReq\u7c7b\u5bf9\u8c61 5. static constexpr int kStreamReqField = 1; 6. // stream\u4e3a\u6240\u64cd\u4f5c\u7684\u6d41\uff0creq_wrap_obj\u4e3aJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 7. explicit StreamReq(StreamBase* stream, 8. v8::Local<v8::Object> req_wrap_obj) : stream_(stream) { 9. // JS\u5c42\u5bf9\u8c61\u6307\u5411\u5f53\u524dStreamReq\u5bf9\u8c61 10. AttachToObject(req_wrap_obj); 11. } 12. // \u5b50\u7c7b\u5b9a\u4e49 13. virtual AsyncWrap* GetAsyncWrap() = 0; 14. // \u83b7\u53d6\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 15. v8::Local<v8::Object> object(); 16. // \u8bf7\u6c42\u7ed3\u675f\u540e\u7684\u56de\u8c03\uff0c\u4f1a\u6267\u884c\u5b50\u7c7b\u7684onDone\uff0conDone\u7531\u5b50\u7c7b\u5b9e\u73b0 17. void Done(int status, const char* error_str = nullptr); 18. // JS\u5c42\u5bf9\u8c61\u4e0d\u518d\u6267\u884cStreamReq\u5b9e\u4f8b 19. void Dispose(); 20. // \u83b7\u53d6\u6240\u64cd\u4f5c\u7684\u6d41 21. inline StreamBase* stream() const { return stream_; } 22. // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6StreamReq\u5bf9\u8c61 23. static StreamReq* FromObject(v8::Local<v8::Object> req_wrap_obj); 24. // \u8bf7\u6c42JS\u5c42\u5bf9\u8c61\u7684internalField\u6240\u6709\u6307\u5411 25. static inline void ResetObject(v8::Local<v8::Object> req_wrap_obj); 26. 27. protected: 28. // \u8bf7\u6c42\u7ed3\u675f\u540e\u56de\u8c03 29. virtual void OnDone(int status) = 0; 30. void AttachToObject(v8::Local<v8::Object> req_wrap_obj); 31. 32. private: 33. StreamBase* const stream_; 34. }; StreamReq\u6709\u4e00\u4e2a\u6210\u5458\u4e3astream_\uff0c\u8868\u793aStreamReq\u8bf7\u6c42\u4e2d\u64cd\u4f5c\u7684\u6d41\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 JS\u5c42\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548cStreamReq\u7684\u5173\u7cfb\u7ba1\u7406\u3002 1. inline void StreamReq::AttachToObject(v8::Local<v8::Object> req_wrap_obj) { 2. req_wrap_obj->SetAlignedPointerInInternalField(kStreamReqField, this); 3. } 4. 5. inline StreamReq* StreamReq::FromObject(v8::Local<v8::Object> req_wrap_obj) { 6. return static_cast<StreamReq*>( 7. req_wrap_obj->GetAlignedPointerFromInternalField(kStreamReqField)); 8. } 9. 10. inline void StreamReq::Dispose() { 11. object()->SetAlignedPointerInInternalField(kStreamReqField, nullptr); 12. delete this; 13. } 14. 15. inline void StreamReq::ResetObject(v8::Local<v8::Object> obj) { 16. obj->SetAlignedPointerInInternalField(0, nullptr); // BaseObject field. 17. obj->SetAlignedPointerInInternalField(StreamReq::kStreamReqField, nullptr); 18. } 2 \u83b7\u53d6\u539f\u59cbJS\u5c42\u8bf7\u6c42\u5bf9\u8c61 1. // \u83b7\u53d6\u548c\u8be5\u8bf7\u6c42\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 2. inline v8::Local<v8::Object> StreamReq::object() { 3. return GetAsyncWrap()->object(); 4. } 3 \u8bf7\u6c42\u7ed3\u675f\u56de\u8c03 1. inline void StreamReq::Done(int status, const char* error_str) { 2. AsyncWrap* async_wrap = GetAsyncWrap(); 3. Environment* env = async_wrap->env(); 4. if (error_str != nullptr) { 5. async_wrap->object()->Set(env->context(), 6. env->error_string(), 7. OneByteString(env->isolate(), 8. error_str)) 9. .Check(); 10. } 11. // \u6267\u884c\u5b50\u7c7b\u7684OnDone 12. OnDone(status); 13. } \u6d41\u64cd\u4f5c\u8bf7\u6c42\u7ed3\u675f\u540e\u4f1a\u7edf\u4e00\u6267\u884cDone\uff0cDone\u4f1a\u6267\u884c\u5b50\u7c7b\u5b9e\u73b0\u7684OnDone\u51fd\u6570\u3002 6.8.6 ShutdownWrap \u00b6 ShutdownWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5173\u95ed\u6d41\u8bf7\u6c42\u3002 1. class ShutdownWrap : public StreamReq { 2. public: 3. ShutdownWrap(StreamBase* stream, 4. v8::Local<v8::Object> req_wrap_obj) 5. : StreamReq(stream, req_wrap_obj) { } 6. 7. void OnDone(int status) override; 8. }; ShutdownWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5173\u95ed\u6d41\u7ed3\u675f\u540e\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1. /* 2. \u5173\u95ed\u7ed3\u675f\u65f6\u56de\u8c03\uff0c\u7531\u8bf7\u6c42\u7c7b\uff08ShutdownWrap\uff09\u8c03\u7528Libuv\uff0c 3. \u6240\u4ee5Libuv\u64cd\u4f5c\u5b8c\u6210\u540e\uff0c\u9996\u5148\u6267\u884c\u8bf7\u6c42\u7c7b\u7684\u56de\u8c03\uff0c\u8bf7\u6c42\u7c7b\u901a\u77e5\u6d41\uff0c\u6d41\u89e6\u53d1 4. \u5bf9\u5e94\u7684\u4e8b\u4ef6\uff0c\u8fdb\u4e00\u6b65\u901a\u77e5listener 5. */ 6. inline void ShutdownWrap::OnDone(int status) { 7. stream()->EmitAfterShutdown(this, status); 8. Dispose(); 9. } 6.8.7 SimpleShutdownWrap \u00b6 SimpleShutdownWrap\u662fShutdownWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002OtherBase\u53ef\u4ee5\u662fReqWrap\u6216\u8005AsyncWrap\u3002 1. template <typename OtherBase> 2. class SimpleShutdownWrap : public ShutdownWrap, public OtherBase { 3. public: 4. SimpleShutdownWrap(StreamBase* stream, 5. v8::Local<v8::Object> req_wrap_obj); 6. 7. AsyncWrap* GetAsyncWrap() override { return this; } 8. }; 6.8.8 WriteWrap \u00b6 WriteWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5f80\u6d41\u5199\u5165\u6570\u636e\u7684\u8bf7\u6c42\u3002 1. class WriteWrap : public StreamReq { 2. public: 3. void SetAllocatedStorage(AllocatedBuffer&& storage); 4. 5. WriteWrap(StreamBase* stream, 6. v8::Local<v8::Object> req_wrap_obj) 7. : StreamReq(stream, req_wrap_obj) { } 8. 9. void OnDone(int status) override; 10. 11. private: 12. AllocatedBuffer storage_; 13. }; WriteWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5199\u7ed3\u675f\u65f6\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1. inline void WriteWrap::OnDone(int status) { 2. stream()->EmitAfterWrite(this, status); 3. Dispose(); 4. } \u8bf7\u6c42\u7ed3\u675f\u540e\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5\u6d41\u5199\u7ed3\u675f\u4e86\uff0c\u6d41\u4f1a\u901a\u77e5listener\uff0clistener\u4f1a\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5JS\u5c42\u3002 6.8.9 SimpleWriteWrap \u00b6 SimpleWriteWrap\u662fWriteWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002\u548cSimpleShutdownWrap\u7c7b\u578b\u3002 1. template <typename OtherBase> 2. class SimpleWriteWrap : public WriteWrap, public OtherBase { 3. public: 4. SimpleWriteWrap(StreamBase* stream, 5. v8::Local<v8::Object> req_wrap_obj); 6. 7. AsyncWrap* GetAsyncWrap() override { return this; } 8. }; 6.8.10 StreamListener \u00b6 1. class StreamListener { 2. public: 3. virtual ~StreamListener(); 4. // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 5. virtual uv_buf_t OnStreamAlloc(size_t suggested_size) = 0; 6. // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u56de\u8c03\uff0c\u6d88\u8d39\u6570\u636e\u7684\u51fd\u6570 7. virtual void OnStreamRead(ssize_t nread, const uv_buf_t& buf) = 0; 8. // \u6d41\u9500\u6bc1\u65f6\u56de\u8c03 9. virtual void OnStreamDestroy() {} 10. // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 11. inline StreamResource* stream() { return stream_; } 12. 13. protected: 14. // \u6d41\u662f\u76d1\u542c\u8005\u662f\u4e00\u6761\u94fe\u8868\uff0c\u8be5\u51fd\u6570\u628a\u7ed3\u6784\u4f20\u9012\u7ed9\u4e0b\u4e00\u4e2a\u8282\u70b9 15. void PassReadErrorToPreviousListener(ssize_t nread); 16. // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 17. StreamResource* stream_ = nullptr; 18. // \u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u5f62\u6210\u94fe\u8868 19. StreamListener* previous_listener_ = nullptr; 20. friend class StreamResource; 21. }; StreamListener\u662f\u7c7b\u4f3c\u4e00\u4e2a\u8ba2\u9605\u8005\uff0c\u5b83\u4f1a\u5bf9\u6d41\u7684\u72b6\u6001\u611f\u5174\u8da3\uff0c\u6bd4\u5982\u6570\u636e\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u6d41\u5173\u95ed\u7b49\u3002\u4e00\u4e2a\u6d41\u53ef\u4ee5\u6ce8\u518c\u591a\u4e2alistener\uff0c\u591a\u4e2alistener\u5f62\u6210\u4e00\u4e2a\u94fe\u8868\u3002 1. // \u4ecelisten\u6240\u5c5e\u7684\u6d41\u7684listener\u961f\u5217\u4e2d\u5220\u9664\u81ea\u5df1 2. inline StreamListener::~StreamListener() { 3. if (stream_ != nullptr) 4. stream_->RemoveStreamListener(this); 5. } 6. // \u8bfb\u51fa\u9519\uff0c\u628a\u4fe1\u606f\u4f20\u9012\u7ed9\u524d\u4e00\u4e2alistener 7. inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) { 8. CHECK_NOT_NULL(previous_listener_); 9. previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0)); 10. } 11. // \u5b9e\u73b0\u6d41\u5173\u95ed\u65f6\u7684\u5904\u7406\u903b\u8f91 12. inline void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) { 13. previous_listener_->OnStreamAfterShutdown(w, status); 14. } 15. // \u5b9e\u73b0\u5199\u7ed3\u675f\u65f6\u7684\u5904\u7406\u903b\u8f91 16. inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) { 17. previous_listener_->OnStreamAfterWrite(w, status); 18. } StreamListener\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u5177\u4f53\u7684\u5b9e\u73b0\u5728\u5b50\u7c7b\u3002 6.8.11 ReportWritesToJSStreamListener \u00b6 ReportWritesToJSStreamListener\u662fStreamListener\u7684\u5b50\u7c7b\u3002\u8986\u76d6\u4e86\u90e8\u5206\u63a5\u53e3\u548c\u62d3\u5c55\u4e86\u4e00\u4e9b\u529f\u80fd\u3002 1. class ReportWritesToJSStreamListener : public StreamListener { 2. public: 3. // \u5b9e\u73b0\u7236\u7c7b\u7684\u8fd9\u4e24\u4e2a\u63a5\u53e3 4. void OnStreamAfterWrite(WriteWrap* w, int status) override; 5. void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; 6. 7. private: 8. void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); 9. }; 1 OnStreamAfterReqFinished OnStreamAfterReqFinished\u662f\u8bf7\u6c42\u64cd\u4f5c\u6d41\u7ed3\u675f\u540e\u7684\u7edf\u4e00\u7684\u56de\u8c03\u3002 1. void ReportWritesToJSStreamListener::OnStreamAfterWrite( 2. WriteWrap* req_wrap, int status) { 3. OnStreamAfterReqFinished(req_wrap, status); 4. } 5. 6. void ReportWritesToJSStreamListener::OnStreamAfterShutdown( 7. ShutdownWrap* req_wrap, int status) { 8. OnStreamAfterReqFinished(req_wrap, status); 9. } \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0 1. void ReportWritesToJSStreamListener::OnStreamAfterReqFinished( 2. StreamReq* req_wrap, int status) { 3. // \u8bf7\u6c42\u6240\u64cd\u4f5c\u7684\u6d41 4. StreamBase* stream = static_cast<StreamBase*>(stream_); 5. Environment* env = stream->stream_env(); 6. AsyncWrap* async_wrap = req_wrap->GetAsyncWrap(); 7. HandleScope handle_scope(env->isolate()); 8. Context::Scope context_scope(env->context()); 9. // \u83b7\u53d6\u539f\u59cb\u7684JS\u5c42\u5bf9\u8c61 10. Local<Object> req_wrap_obj = async_wrap->object(); 11. 12. Local<Value> argv[] = { 13. Integer::New(env->isolate(), status), 14. stream->GetObject(), 15. Undefined(env->isolate()) 16. }; 17. 18. const char* msg = stream->Error(); 19. if (msg != nullptr) { 20. argv[2] = OneByteString(env->isolate(), msg); 21. stream->ClearError(); 22. } 23. // \u56de\u8c03JS\u5c42 24. if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust()) 25. async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv); 26. } OnStreamAfterReqFinished\u4f1a\u56de\u8c03JS\u5c42\u3002 6.8.12 EmitToJSStreamListener EmitToJSStreamListener\u662fReportWritesToJSStreamListener\u7684\u5b50\u7c7b 1. class EmitToJSStreamListener : public ReportWritesToJSStreamListener { 2. public: 3. uv_buf_t OnStreamAlloc(size_t suggested_size) override; 4. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; 5. }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1. // \u5206\u914d\u4e00\u5757\u5185\u5b58 2. uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) { 3. Environment* env = static_cast<StreamBase*>(stream_)->stream_env(); 4. return env->AllocateManaged(suggested_size).release(); 5. } 6. // \u8bfb\u53d6\u6570\u636e\u7ed3\u675f\u540e\u56de\u8c03 7. void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { 8. StreamBase* stream = static_cast<StreamBase*>(stream_); 9. Environment* env = stream->stream_env(); 10. HandleScope handle_scope(env->isolate()); 11. Context::Scope context_scope(env->context()); 12. AllocatedBuffer buf(env, buf_); 13. // \u8bfb\u53d6\u5931\u8d25 14. if (nread <= 0) { 15. if (nread < 0) 16. stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>()); 17. return; 18. } 19. 20. buf.Resize(nread); 21. // \u8bfb\u53d6\u6210\u529f\u56de\u8c03JS\u5c42 22. stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); 23. } \u6211\u4eec\u770b\u5230listener\u5904\u7406\u5b8c\u6570\u636e\u540e\u53c8\u4f1a\u56de\u8c03\u6d41\u7684\u63a5\u53e3\uff0c\u5177\u4f53\u7684\u903b\u8f91\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\uff08\u6d41\u9ed8\u8ba4\u7684listener\uff09\u3002 1. class EmitToJSStreamListener : public ReportWritesToJSStreamListener { 2. public: 3. uv_buf_t OnStreamAlloc(size_t suggested_size) override; 4. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; 5. }; EmitToJSStreamListener\u4f1a\u5b9e\u73b0OnStreamRead\u7b49\u65b9\u6cd5\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u521b\u5efa\u4e00\u4e2aC++\u5c42\u7684TCP\u5bf9\u8c61\u662f\u600e\u6837\u7684\u3002\u4e0b\u9762\u662fTCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\u3002 1. class TCPWrap : public ConnectionWrap<TCPWrap, uv_tcp_t>{} 2. // ConnectionWrap\u62d3\u5c55\u4e86\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u7684\u903b\u8f91 3. class ConnectionWrap : public LibuvStreamWrap{} 4. class LibuvStreamWrap : public HandleWrap, public StreamBase{} 5. class StreamBase : public StreamResource {} \u6211\u4eec\u770b\u5230TCP\u6d41\u662f\u7ee7\u627f\u4e8eStreamResource\u7684\u3002\u65b0\u5efa\u4e00\u4e2aTCP\u7684C++\u7684\u5bf9\u8c61\u65f6\uff08tcp_wrap.cc\uff09\uff0c\u4f1a\u4e0d\u65ad\u5f80\u4e0a\u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5176\u4e2d\u5728StreamBase\u4e2d\u6709\u4e00\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\u3002 1. inline StreamBase::StreamBase(Environment* env) : env_(env) { 2. PushStreamListener(&default_listener_); 3. } 4. 5. EmitToJSStreamListener default_listener_; StreamBase\u4f1a\u9ed8\u8ba4\u7ed9\u6d41\u6ce8\u518c\u4e00\u4e2alistener\u3002\u6211\u4eec\u770b\u4e0bEmitToJSStreamListener \u5177\u4f53\u7684\u5b9a\u4e49\u3002 1. class ReportWritesToJSStreamListener : public StreamListener { 2. public: 3. void OnStreamAfterWrite(WriteWrap* w, int status) override; 4. void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; 5. 6. private: 7. void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); 8. }; 9. 10. class EmitToJSStreamListener : public ReportWritesToJSStreamListener { 11. public: 12. uv_buf_t OnStreamAlloc(size_t suggested_size) override; 13. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; 14. }; EmitToJSStreamListener\u7ee7\u627fStreamListener \uff0c\u5b9a\u4e49\u4e86\u5206\u914d\u5185\u5b58\u548c\u8bfb\u53d6\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bPushStreamListener\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1. inline void StreamResource::PushStreamListener(StreamListener* listener) { 2. // \u5934\u63d2\u6cd5 3. listener->previous_listener_ = listener_; 4. listener->stream_ = this; 5. listener_ = listener; 6. } PushStreamListener\u5c31\u662f\u6784\u9020\u51fa\u4e00\u4e2alistener\u94fe\u8868\u7ed3\u6784\u3002\u7136\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u4e8e\u6d41\u6765\u8bf4\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u6574\u4e2a\u94fe\u8def\u3002\u9996\u5148\u662fJS\u5c42\u8c03\u7528readStart 1. function tryReadStart(socket) { 2. socket._handle.reading = true; 3. const err = socket._handle.readStart(); 4. if (err) 5. socket.destroy(errnoException(err, 'read')); 6. } 7. 8. // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 9. Socket.prototype._read = function(n) { 10. tryReadStart(this); 11. }; \u6211\u4eec\u770b\u770breadStart 1. int LibuvStreamWrap::ReadStart() { 2. return uv_read_start(stream(), [](uv_handle_t* handle, 3. size_t suggested_size, 4. uv_buf_t* buf) { 5. static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); 6. }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { 7. static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); 8. }); 9. } ReadStart\u8c03\u7528Libuv\u7684uv_read_start\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u4e14\u6ce8\u518c\u4e86\u4e24\u4e2a\u56de\u8c03\u51fd\u6570OnUvAlloc\u548cOnUvRead\u3002 1. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 2. EmitRead(nread, *buf); 3. } 4. 5. inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { 6. // bytes_read_\u8868\u793a\u5df2\u8bfb\u7684\u5b57\u8282\u6570 7. if (nread > 0) 8. bytes_read_ += static_cast<uint64_t>(nread); 9. listener_->OnStreamRead(nread, buf); 10. } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u6700\u540e\u4f1a\u8c03\u7528listener_\u7684OnStreamRead\u3002\u6211\u4eec\u770b\u770bTCP\u7684OnStreamRead 1. void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { 2. StreamBase* stream = static_cast<StreamBase*>(stream_); 3. Environment* env = stream->stream_env(); 4. HandleScope handle_scope(env->isolate()); 5. Context::Scope context_scope(env->context()); 6. AllocatedBuffer buf(env, buf_); 7. stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); 8. } \u7ee7\u7eed\u56de\u8c03CallJSOnreadMethod 1. MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, 2. Local<ArrayBuffer> ab, 3. size_t offset, 4. StreamBaseJSChecks checks) { 5. Environment* env = env_; 6. // ... 7. AsyncWrap* wrap = GetAsyncWrap(); 8. CHECK_NOT_NULL(wrap); 9. Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); 10. CHECK(onread->IsFunction()); 11. return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); 12. } CallJSOnreadMethod\u4f1a\u56de\u8c03JS\u5c42\u7684onread\u56de\u8c03\u51fd\u6570\u3002onread\u4f1a\u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u89e6\u53d1data\u4e8b\u4ef6\u3002","title":"06-C++\u5c42"},{"location":"chapter06-C%2B%2B%E5%B1%82/#61-baseobject","text":"BaseObject\u662fC++\u5c42\u5927\u591a\u6570\u7c7b\u7684\u57fa\u7c7b\u3002 1. class BaseObject : public MemoryRetainer { 2. public : 3. // \u2026 4. private : 5. v8 :: Local < v8 :: Object > WrappedObject () const override ; 6. // \u6307\u5411\u5c01\u88c5\u7684\u5bf9\u8c61 7. v8 :: Global < v8 :: Object > persistent_handle_ ; 8. Environment * env_ ; 9. }; BaseObject\u7684\u5b9e\u73b0\u5f88\u590d\u6742\uff0c\u8fd9\u91cc\u53ea\u4ecb\u7ecd\u5e38\u7528\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002","title":"6.1 BaseObject"},{"location":"chapter06-C%2B%2B%E5%B1%82/#611","text":"1. // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 2. BaseObject :: BaseObject ( Environment * env , 3. v8 :: Local < v8 :: Object > object ) 4. : persistent_handle_ ( env -> isolate (), object ), 5. env_ ( env ) { 6. // \u628athis\u5b58\u5230object\u4e2d 7. object -> SetAlignedPointerInInternalField ( 0 , static_cast < void *> ( this )); 8. } \u6784\u9020\u51fd\u6570\u7528\u4e8e\u4fdd\u5b58\u5bf9\u8c61\u95f4\u7684\u5173\u7cfb\uff08JS\u4f7f\u7528\u7684\u5bf9\u8c61\u548c\u4e0e\u5176\u5173\u7cfb\u7684C++\u5c42\u5bf9\u8c61\uff0c\u4e0b\u56fe\u4e2d\u7684\u5bf9\u8c61\u5373\u6211\u4eec\u5e73\u65f6\u5728JS\u5c42\u4f7f\u7528C++\u6a21\u5757\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6bd4\u5982new TCP()\uff09\u3002\u540e\u9762\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7528\u5904\uff0c\u5173\u7cfb\u5982\u56fe6-1\u6240\u793a\u3002 \u56fe6-1","title":"6.1.1 \u6784\u9020\u51fd\u6570"},{"location":"chapter06-C%2B%2B%E5%B1%82/#612","text":"1. v8 :: Local < v8 :: Object > BaseObject :: object () const { 2. return PersistentToLocal :: Default ( env () -> isolate (), 3. persistent_handle_ ); 4. }","title":"6.1.2 \u83b7\u53d6\u5c01\u88c5\u7684\u5bf9\u8c61"},{"location":"chapter06-C%2B%2B%E5%B1%82/#613-baseobject","text":"1. // \u901a\u8fc7obj\u53d6\u51fa\u91cc\u9762\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61 2. BaseObject * BaseObject :: FromJSObject ( v8 :: Local < v8 :: Object > obj ) { 3. return static_cast < BaseObject *> ( obj -> GetAlignedPointerFromInternalField ( 0 )); 4. } 5. 6. template < typename T > 7. T * BaseObject :: FromJSObject ( v8 :: Local < v8 :: Object > object ) { 8. return static_cast < T *> ( FromJSObject ( object )); 9. }","title":"6.1.3 \u4ece\u5bf9\u8c61\u4e2d\u83b7\u53d6\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61"},{"location":"chapter06-C%2B%2B%E5%B1%82/#614","text":"1. // \u4eceobj\u4e2d\u53d6\u51fa\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61 2. template < typename T > 3. inline T * Unwrap ( v8 :: Local < v8 :: Object > obj ) { 4. return BaseObject :: FromJSObject < T > ( obj ); 5. } 6. 7. // \u4eceobj\u4e2d\u83b7\u53d6\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61\uff0c\u5982\u679c\u4e3a\u7a7a\u5219\u8fd4\u56de\u7b2c\u4e09\u4e2a\u53c2\u6570\u7684\u503c\uff08\u9ed8\u8ba4\u503c\uff09 8. # define ASSIGN_OR_RETURN_UNWRAP ( ptr , obj , ...) \\ 9. do { \\ 10. * ptr = static_cast < typename std :: remove_reference < decltype ( * ptr ) >:: type > ( \\ 11. BaseObject :: FromJSObject ( obj )); \\ 12. if ( * ptr == nullptr ) \\ 13. return __VA_ARGS__ ; \\ 14. } while ( 0 )","title":"6.1.4 \u89e3\u5305"},{"location":"chapter06-C%2B%2B%E5%B1%82/#62-asyncwrap","text":"AsyncWrap\u5b9e\u73b0async_hook\u7684\u6a21\u5757\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8\u5b83\u56de\u8c03JS\u7684\u529f\u80fd\u3002 1. inline v8 :: MaybeLocal < v8 :: Value > AsyncWrap :: MakeCallback ( 2. const v8 :: Local < v8 :: Name > symbol , 3. int argc , 4. v8 :: Local < v8 :: Value >* argv ) { 5. v8 :: Local < v8 :: Value > cb_v ; 6. // \u6839\u636e\u5b57\u7b26\u4e32\u8868\u793a\u7684\u5c5e\u6027\u503c\uff0c\u4ece\u5bf9\u8c61\u4e2d\u53d6\u51fa\u8be5\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u3002\u662f\u4e2a\u51fd\u6570 7. if ( ! object () -> Get ( env () -> context (), symbol ). ToLocal ( & cb_v )) 8. return v8 :: MaybeLocal < v8 :: Value > (); 9. // \u662f\u4e2a\u51fd\u6570 10. if ( ! cb_v -> IsFunction ()) { 11. return v8 :: MaybeLocal < v8 :: Value > (); 12. } 13. // \u56de\u8c03,\u89c1async_wrap.cc 14. return MakeCallback ( cb_v . As < v8 :: Function > (), argc , argv ); 15. } \u4ee5\u4e0a\u53ea\u662f\u5165\u53e3\u51fd\u6570\uff0c\u6211\u4eec\u770b\u770b\u771f\u6b63\u7684\u5b9e\u73b0\u3002 1. MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb, 2. int argc, 3. Local<Value>* argv) { 4. 5. MaybeLocal<Value> ret = InternalMakeCallback(env(), object(), cb, argc, argv, context); 6. return ret; 7. } \u63a5\u7740\u770b\u4e00\u4e0bInternalMakeCallback 1. MaybeLocal<Value> InternalMakeCallback(Environment* env, 2. Local<Object> recv, 3. const Local<Function> callback, 4. int argc, 5. Local<Value> argv[], 6. async_context asyncContext) { 7. // \u2026\u7701\u7565\u5176\u4ed6\u4ee3\u7801 8. // \u6267\u884c\u56de\u8c03 9. callback->Call(env->context(), recv, argc, argv);}","title":"6.2 AsyncWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#63-handlewrap","text":"HandleWrap\u662f\u5bf9Libuv uv_handle_t\u7684\u5c01\u88c5,\u4e5f\u662f\u5f88\u591aC++\u7c7b\u7684\u57fa\u7c7b\u3002 1. class HandleWrap : public AsyncWrap { 2. public: 3. // \u64cd\u4f5c\u548c\u5224\u65adhandle\u72b6\u6001\u51fd\u6570\uff0c\u89c1Libuv 4. static void Close(const v8::FunctionCallbackInfo<v8::Value>& args); 5. static void Ref(const v8::FunctionCallbackInfo<v8::Value>& args); 6. static void Unref(const v8::FunctionCallbackInfo<v8::Value>& args); 7. static void HasRef(const v8::FunctionCallbackInfo<v8::Value>& args); 8. static inline bool IsAlive(const HandleWrap* wrap) { 9. return wrap != nullptr && wrap->state_ != kClosed; 10. } 11. 12. static inline bool HasRef(const HandleWrap* wrap) { 13. return IsAlive(wrap) && uv_has_ref(wrap->GetHandle()); 14. } 15. // \u83b7\u53d6\u5c01\u88c5\u7684handle 16. inline uv_handle_t* GetHandle() const { return handle_; } 17. // \u5173\u95edhandle\uff0c\u5173\u95ed\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 18. virtual void Close( 19. v8::Local<v8::Value> close_callback = 20. v8::Local<v8::Value>()); 21. 22. static v8::Local<v8::FunctionTemplate> GetConstructorTemplate( 23. Environment* env); 24. 25. protected: 26. HandleWrap(Environment* env, 27. v8::Local<v8::Object> object, 28. uv_handle_t* handle, 29. AsyncWrap::ProviderType provider); 30. virtual void OnClose() {} 31. // handle\u72b6\u6001 32. inline bool IsHandleClosing() const { 33. return state_ == kClosing || state_ == kClosed; 34. } 35. 36. private: 37. friend class Environment; 38. friend void GetActiveHandles(const v8::FunctionCallbackInfo<v8::Value>&); 39. static void OnClose(uv_handle_t* handle); 40. 41. // handle\u961f\u5217 42. ListNode<HandleWrap> handle_wrap_queue_; 43. // handle\u7684\u72b6\u6001 44. enum { kInitialized, kClosing, kClosed } state_; 45. // \u6240\u6709handle\u7684\u57fa\u7c7b 46. uv_handle_t* const handle_; 47. };","title":"6.3 HandleWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#631-handle","text":"1. Local<FunctionTemplate> HandleWrap::GetConstructorTemplate(Environment* env) { 2. Local<FunctionTemplate> tmpl = env->handle_wrap_ctor_template(); 3. if (tmpl.IsEmpty()) { 4. tmpl = env->NewFunctionTemplate(nullptr); 5. tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), 6. \"HandleWrap\")); 7. tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env)); 8. env->SetProtoMethod(tmpl, \"close\", HandleWrap::Close); 9. env->SetProtoMethodNoSideEffect(tmpl, 10. \"hasRef\", 11. HandleWrap::HasRef); 12. env->SetProtoMethod(tmpl, \"ref\", HandleWrap::Ref); 13. env->SetProtoMethod(tmpl, \"unref\", HandleWrap::Unref); 14. env->set_handle_wrap_ctor_template(tmpl); 15. } 16. return tmpl; 17. } 18. /* 19. object\u4e3aC++\u5c42\u4e3aJS\u5c42\u63d0\u4f9b\u7684\u5bf9\u8c61 20. handle\u4e3a\u5b50\u7c7b\u5177\u4f53\u7684handle\u7c7b\u578b\uff0c\u4e0d\u540c\u6a21\u5757\u4e0d\u4e00\u6837 21. */ 22. HandleWrap::HandleWrap(Environment* env, 23. Local<Object> object, 24. uv_handle_t* handle, 25. AsyncWrap::ProviderType provider) 26. : AsyncWrap(env, object, provider), 27. state_(kInitialized), 28. handle_(handle) { 29. // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb 30. handle_->data = this; 31. HandleScope scope(env->isolate()); 32. CHECK(env->has_run_bootstrapping_code()); 33. // \u63d2\u5165handle\u961f\u5217 34. env->handle_wrap_queue()->PushBack(this); 35. } HandleWrap\u7ee7\u627fBaseObject\u7c7b\uff0c\u521d\u59cb\u5316\u540e\u5173\u7cfb\u56fe\u5982\u56fe6-2\u6240\u793a\u3002 \u56fe6-2","title":"6.3.1 \u65b0\u5efahandle\u548c\u521d\u59cb\u5316"},{"location":"chapter06-C%2B%2B%E5%B1%82/#632-handle","text":"1. // \u4fee\u6539handle\u4e3a\u6d3b\u8dc3\u72b6\u6001 2. void HandleWrap::Ref(const FunctionCallbackInfo<Value>& args) { 3. HandleWrap* wrap; 4. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 5. 6. if (IsAlive(wrap)) 7. uv_ref(wrap->GetHandle()); 8. } 9. 10. // \u4fee\u6539hande\u4e3a\u4e0d\u6d3b\u8dc3\u72b6\u6001 11. void HandleWrap::Unref(const FunctionCallbackInfo<Value>& args) { 12. HandleWrap* wrap; 13. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 14. 15. if (IsAlive(wrap)) 16. uv_unref(wrap->GetHandle()); 17. } 18. 19. // \u5224\u65adhandle\u662f\u5426\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001 20. void HandleWrap::HasRef(const FunctionCallbackInfo<Value>& args) { 21. HandleWrap* wrap; 22. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 23. args.GetReturnValue().Set(HasRef(wrap)); 24. }","title":"6.3.2 \u5224\u65ad\u548c\u64cd\u4f5chandle\u72b6\u6001"},{"location":"chapter06-C%2B%2B%E5%B1%82/#633-handle","text":"1. // \u5173\u95edhandle\uff08JS\u5c42\u8c03\u7528\uff09\uff0c\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 2. void HandleWrap::Close(const FunctionCallbackInfo<Value>& args) { 3. HandleWrap* wrap; 4. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 5. // \u4f20\u5165\u56de\u8c03 6. wrap->Close(args[0]); 7. } 8. // \u771f\u6b63\u5173\u95edhandle\u7684\u51fd\u6570 9. void HandleWrap::Close(Local<Value> close_callback) { 10. // \u6b63\u5728\u5173\u95ed\u6216\u5df2\u7ecf\u5173\u95ed 11. if (state_ != kInitialized) 12. return; 13. // \u8c03\u7528Libuv\u51fd\u6570 14. uv_close(handle_, OnClose); 15. // \u5173\u95ed\u4e2d 16. state_ = kClosing; 17. // \u4f20\u4e86\u56de\u8c03\u5219\u4fdd\u5b58\u8d77\u6765 18. if (!close_callback.IsEmpty() && 19. close_callback->IsFunction() && 20. !persistent().IsEmpty()) { 21. object()->Set(env()->context(), 22. env()->handle_onclose_symbol(), 23. close_callback).Check(); 24. } 25. } 26. 27. // \u5173\u95edhandle\u6210\u529f\u540e\u56de\u8c03 28. void HandleWrap::OnClose(uv_handle_t* handle) { 29. BaseObjectPtr<HandleWrap> wrap { 30. static_cast<HandleWrap*>(handle->data) 31. }; 32. wrap->Detach(); 33. 34. Environment* env = wrap->env(); 35. HandleScope scope(env->isolate()); 36. Context::Scope context_scope(env->context()); 37. wrap->state_ = kClosed; 38. 39. wrap->OnClose(); 40. wrap->handle_wrap_queue_.Remove(); 41. // \u6709onclose\u56de\u8c03\u5219\u6267\u884c 42. if (!wrap->persistent().IsEmpty() && 43. wrap->object()->Has(env->context(), 44. env->handle_onclose_symbol()) 45. .FromMaybe(false)) { 46. wrap->MakeCallback(env->handle_onclose_symbol(), 47. 0, 48. nullptr); 49. } 50. }","title":"6.3.3 \u5173\u95edhandle"},{"location":"chapter06-C%2B%2B%E5%B1%82/#64-reqwrap","text":"ReqWrap\u8868\u793a\u901a\u8fc7Libuv\u5bf9handle\u7684\u4e00\u6b21\u8bf7\u6c42\u3002","title":"6.4 ReqWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#641-reqwrapbase","text":"1. class ReqWrapBase { 2. public: 3. explicit inline ReqWrapBase(Environment* env); 4. virtual ~ReqWrapBase() = default; 5. virtual void Cancel() = 0; 6. virtual AsyncWrap* GetAsyncWrap() = 0; 7. 8. private: 9. // \u4e00\u4e2a\u5e26\u524d\u540e\u6307\u9488\u7684\u8282\u70b9 10. ListNode<ReqWrapBase> req_wrap_queue_; 11. }; ReqWrapBase\u4e3b\u8981\u662f\u5b9a\u4e49\u63a5\u53e3\u7684\u534f\u8bae\u3002\u6211\u4eec\u770b\u4e00\u4e0bReqWrapBase\u7684\u5b9e\u73b0 1. ReqWrapBase::ReqWrapBase(Environment* env) { 2. env->req_wrap_queue()->PushBack(this); 3. } ReqWrapBase\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628a\u81ea\u5df1\u52a0\u5230env\u5bf9\u8c61\u7684req\u961f\u5217\u4e2d\u3002","title":"6.4.1 ReqWrapBase"},{"location":"chapter06-C%2B%2B%E5%B1%82/#642-reqwrap","text":"1. template <typename T> 2. class ReqWrap : public AsyncWrap, public ReqWrapBase { 3. public: 4. inline ReqWrap(Environment* env, 5. v8::Local<v8::Object> object, 6. AsyncWrap::ProviderType provider); 7. inline ~ReqWrap() override; 8. inline void Dispatched(); 9. inline void Reset(); 10. T* req() { return &req_; } 11. inline void Cancel() final; 12. inline AsyncWrap* GetAsyncWrap() override; 13. static ReqWrap* from_req(T* req); 14. template <typename LibuvFunction, typename... Args> 15. // \u8c03\u7528Libuv 16. inline int Dispatch(LibuvFunction fn, Args... args); 17. 18. public: 19. typedef void (*callback_t)(); 20. callback_t original_callback_ = nullptr; 21. 22. protected: 23. T req_; 24. }; 25. 26. } \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1. template <typename T> 2. ReqWrap<T>::ReqWrap(Environment* env, 3. v8::Local<v8::Object> object, 4. AsyncWrap::ProviderType provider) 5. : AsyncWrap(env, object, provider), 6. ReqWrapBase(env) { 7. // \u521d\u59cb\u5316\u72b6\u6001 8. Reset(); 9. } 10. 11. // \u4fdd\u5b58libuv\u6570\u636e\u7ed3\u6784\u548cReqWrap\u5b9e\u4f8b\u7684\u5173\u7cfb 12. template <typename T> 13. void ReqWrap<T>::Dispatched() { 14. req_.data = this; 15. } 16. 17. // \u91cd\u7f6e\u5b57\u6bb5 18. template <typename T> 19. void ReqWrap<T>::Reset() { 20. original_callback_ = nullptr; 21. req_.data = nullptr; 22. } 23. 24. // \u901a\u8fc7req\u6210\u5458\u627e\u6240\u5c5e\u5bf9\u8c61\u7684\u5730\u5740 25. template <typename T> 26. ReqWrap<T>* ReqWrap<T>::from_req(T* req) { 27. return ContainerOf(&ReqWrap<T>::req_, req); 28. } 29. 30. // \u53d6\u6d88\u7ebf\u7a0b\u6c60\u4e2d\u7684\u8bf7\u6c42 31. template <typename T> 32. void ReqWrap<T>::Cancel() { 33. if (req_.data == this) 34. uv_cancel(reinterpret_cast<uv_req_t*>(&req_)); 35. } 36. 37. template <typename T> 38. AsyncWrap* ReqWrap<T>::GetAsyncWrap() { 39. return this; 40. } 41. // \u8c03\u7528Libuv\u51fd\u6570 42. template <typename T> 43. template <typename LibuvFunction, typename... Args> 44. int ReqWrap<T>::Dispatch(LibuvFunction fn, Args... args) { 45. Dispatched(); 46. int err = CallLibuvFunction<T, LibuvFunction>::Call( 47. // Libuv\u51fd\u6570 48. fn, 49. env()->event_loop(), 50. req(), 51. MakeLibuvRequestCallback<T, Args>::For(this, args)...); 52. if (err >= 0) 53. env()->IncreaseWaitingRequestCounter(); 54. return err; 55. } \u6211\u4eec\u770b\u5230ReqWrap\u62bd\u8c61\u4e86\u8bf7\u6c42Libuv\u7684\u8fc7\u7a0b\uff0c\u5177\u4f53\u8bbe\u8ba1\u7684\u6570\u636e\u7ed3\u6784\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u67d0\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\u3002 1. // \u8bf7\u6c42Libuv\u65f6\uff0c\u6570\u636e\u7ed3\u6784\u662fuv_connect_t\uff0c\u8868\u793a\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 2. class ConnectWrap : public ReqWrap<uv_connect_t> { 3. public: 4. ConnectWrap(Environment* env, 5. v8::Local<v8::Object> req_wrap_obj, 6. AsyncWrap::ProviderType provider); 7. };","title":"6.4.2 ReqWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#65-jsc","text":"JS\u8c03\u7528C++\u6a21\u5757\u662fV8\u63d0\u4f9b\u7684\u80fd\u529b\uff0cNode.js\u662f\u4f7f\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u9762\u5bf9JS\uff0c\u5269\u4e0b\u7684\u4e8b\u60c5\u4ea4\u7ed9Node.js\u5c31\u884c\u3002\u672c\u6587\u9996\u5148\u8bb2\u4e00\u4e0b\u5229\u7528V8\u5982\u4f55\u5b9e\u73b0JS\u8c03\u7528C++\uff0c\u7136\u540e\u518d\u8bb2\u4e00\u4e0bNode.js\u662f\u600e\u4e48\u505a\u7684\u3002 1 JS\u8c03\u7528C++ \u9996\u5148\u4ecb\u7ecd\u4e00\u4e0bV8\u4e2d\u4e24\u4e2a\u975e\u5e38\u6838\u5fc3\u7684\u7c7bFunctionTemplate\u548cObjectTemplate\u3002\u987e\u540d\u601d\u4e49\uff0c\u8fd9\u4e24\u4e2a\u7c7b\u662f\u5b9a\u4e49\u6a21\u677f\u7684\uff0c\u597d\u6bd4\u5efa\u623f\u5b50\u65f6\u7684\u8bbe\u8ba1\u56fe\u4e00\u6837\uff0c\u901a\u8fc7\u8bbe\u8ba1\u56fe\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u9020\u51fa\u5bf9\u5e94\u7684\u623f\u5b50\u3002V8\u4e5f\u662f\uff0c\u5b9a\u4e49\u67d0\u79cd\u6a21\u677f\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6a21\u677f\u521b\u5efa\u51fa\u5bf9\u5e94\u7684\u5b9e\u4f8b\u3002\u4e0b\u9762\u4ecb\u7ecd\u4e00\u4e0b\u8fd9\u4e9b\u6982\u5ff5\uff08\u4e3a\u4e86\u65b9\u4fbf\uff0c\u4e0b\u9762\u90fd\u662f\u4f2a\u4ee3\u7801)\u3002 1.1 \u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 1. Local<FunctionTemplate> functionTemplate = v8::FunctionTemplate::New(isolate(), New); 2. // \u5b9a\u4e49\u51fd\u6570\u7684\u540d\u5b57 3. functionTemplate->SetClassName(\u2018TCP\u2019) \u9996\u5148\u5b9a\u4e49\u4e00\u4e2aFunctionTemplate\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u5230FunctionTemplate\u7684\u7b2c\u4e8c\u4e2a\u5165\u53c2\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5f53\u6211\u4eec\u6267\u884c\u7531FunctionTemplate\u521b\u5efa\u7684\u51fd\u6570\u65f6\uff0cv8\u5c31\u4f1a\u6267\u884cNew\u51fd\u6570\u3002\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e0d\u4f20\u3002 1.2 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u7684prototype\u5185\u5bb9 prototype\u5c31\u662fJS\u91cc\u7684function.prototype\u3002\u5982\u679c\u4f60\u7406\u89e3JS\u91cc\u7684\u77e5\u8bc6\uff0c\u5c31\u5f88\u5bb9\u6613\u7406\u89e3C++\u7684\u4ee3\u7801\u3002 1. v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate(), callback); 2. t->SetClassName('test'); 3. // \u5728prototype\u4e0a\u5b9a\u4e49\u4e00\u4e2a\u5c5e\u6027 4. t->PrototypeTemplate()->Set('hello', 'world'); 1.3 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u5bf9\u5e94\u7684\u5b9e\u4f8b\u6a21\u677f\u7684\u5185\u5bb9 \u5b9e\u4f8b\u6a21\u677f\u5c31\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002\u5b83\u5b9a\u4e49\u4e86\uff0c\u5f53\u4ee5new\u7684\u65b9\u5f0f\u6267\u884c\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u51fd\u6570\u65f6\uff0c\u8fd4\u56de\u503c\u6240\u5177\u6709\u7684\u5c5e\u6027\u3002 1. function A() { 2. this.a = 1; 3. this.b = 2; 4. } 5. new A(); \u5b9e\u4f8b\u6a21\u677f\u7c7b\u4f3c\u4e0a\u9762\u4ee3\u7801\u4e2dA\u51fd\u6570\u91cc\u9762\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u600e\u4e48\u5b9a\u4e49\u3002 1. t->InstanceTemplate()->Set(key, val); 2. t->InstanceTemplate()->SetInternalFieldCount(1); InstanceTemplate\u8fd4\u56de\u7684\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002SetInternalFieldCount\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u7279\u6b8a\uff0c\u4e5f\u662f\u6bd4\u8f83\u91cd\u8981\u7684\u4e00\u4e2a\u5730\u65b9\uff0c\u6211\u4eec\u77e5\u9053\u5bf9\u8c61\u5c31\u662f\u4e00\u5757\u5185\u5b58\uff0c\u5bf9\u8c61\u6709\u5b83\u81ea\u5df1\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053\u5728C++\u91cc\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7c7b\uff0c\u4e5f\u5c31\u5b9a\u4e49\u4e86\u5bf9\u8c61\u7684\u5e03\u5c40\u3002\u6bd4\u5982\u6211\u4eec\u6709\u4ee5\u4e0b\u5b9a\u4e49\u3002 1. class demo 2. { 3. private: 4. int a; 5. int b; 6. }; \u5728\u5185\u5b58\u4e2d\u5e03\u5c40\u5982\u56fe6-3\u6240\u793a\u3002 \u56fe6-3 \u4e0a\u9762\u8fd9\u79cd\u65b9\u5f0f\u6709\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u7c7b\u5b9a\u4e49\u4e4b\u540e\uff0c\u5185\u5b58\u5e03\u5c40\u5c31\u56fa\u5b9a\u4e86\u3002\u800cV8\u662f\u81ea\u5df1\u53bb\u63a7\u5236\u5bf9\u8c61\u7684\u5185\u5b58\u5e03\u5c40\u7684\u3002\u5f53\u6211\u4eec\u5728V8\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u7684\u65f6\u5019\uff0c\u662f\u6ca1\u6709\u4efb\u4f55\u5c5e\u6027\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0bV8\u4e2dHeapObject\u7c7b\u7684\u5b9a\u4e49\u3002 1. class HeapObject: public Object { 2. static const int kMapOffset = Object::kSize; // Object::kSize\u662f0 3. static const int kSize = kMapOffset + kPointerSize; 4. }; \u8fd9\u65f6\u5019\u7684\u5185\u5b58\u5e03\u5c40\u5982\u4e0b\u3002 \u7136\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0bHeapObject\u5b50\u7c7bHeapNumber\u7684\u5b9a\u4e49\u3002 1. class HeapNumber: public HeapObject { 2. // kSize\u4e4b\u524d\u7684\u7a7a\u95f4\u5b58\u50a8map\u5bf9\u8c61\u7684\u6307\u9488 3. static const int kValueOffset = HeapObject::kSize; 4. // kValueOffset - kSize\u4e4b\u95f4\u5b58\u50a8\u6570\u5b57\u7684\u503c 5. static const int kSize = kValueOffset + kDoubleSize; 6. }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-4\u6240\u793a\u3002 \u56fe6-4 \u6211\u4eec\u53d1\u73b0\u8fd9\u4e9b\u7c7b\u53ea\u6709\u51e0\u4e2a\u7c7b\u53d8\u91cf\uff0c\u7c7b\u53d8\u91cf\u662f\u4e0d\u4fdd\u5b58\u5728\u5bf9\u8c61\u5185\u5b58\u7a7a\u95f4\u7684\u3002\u8fd9\u4e9b\u7c7b\u53d8\u91cf\u5c31\u662f\u5b9a\u4e49\u4e86\u5bf9\u8c61\u6bcf\u4e2a\u57df\u6240\u5360\u5185\u5b58\u7a7a\u95f4\u7684\u4fe1\u606f\uff0c\u5f53\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2aHeapObject\u5bf9\u8c61\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u628a\u8fd9\u5757\u5185\u5b58\u9996\u5730\u5740\u5f3a\u884c\u8f6c\u6210\u5bf9\u5e94\u5bf9\u8c61\u7684\u6307\u9488\u3002\u7136\u540e\u901a\u8fc7\u7c7b\u53d8\u91cf\u5bf9\u5c5e\u6027\u7684\u5185\u5b58\u8fdb\u884c\u5b58\u53d6\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u5982\u4f55\u7533\u8bf7\u4e00\u4e2aHeapNumber\u5bf9\u8c61 1. Object* Heap::AllocateHeapNumber(double value, PretenureFlag pretenure) { 2. // \u5728\u54ea\u4e2a\u7a7a\u95f4\u5206\u914d\u5185\u5b58\uff0c\u6bd4\u5982\u65b0\u751f\u4ee3\uff0c\u8001\u751f\u4ee3 3. AllocationSpace space = (pretenure == TENURED) ? CODE_SPACE : NEW_SPACE; 4. // \u5728space\u4e0a\u5206\u914d\u4e00\u4e2aHeapNumber\u5bf9\u8c61\u5927\u5c0f\u7684\u5185\u5b58 5. Object* result = AllocateRaw(HeapNumber::kSize, space); 6. /* 7. \u8f6c\u6210HeapObect\uff0c\u8bbe\u7f6emap\u5c5e\u6027\uff0cmap\u5c5e\u6027\u662f\u8868\u793a\u5bf9\u8c61\u7c7b\u578b\u3001\u5927\u5c0f\u7b49\u4fe1\u606f\u7684 8. */ 9. HeapObject::cast(result)->set_map(heap_number_map()); 10. // \u8f6c\u6210HeapNumber\u5bf9\u8c61 11. HeapNumber::cast(result)->set_value(value); 12. return result; 13. } \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u8c61\u6a21\u677f\u7684\u5b9a\u4e49\u3002 1. class TemplateInfo: public Struct { 2. static const int kTagOffset = HeapObject::kSize; 3. static const int kPropertyListOffset = kTagOffset + kPointerSize; 4. static const int kHeaderSize = kPropertyListOffset + kPointerSize; 5. }; 6. 7. class ObjectTemplateInfo: public TemplateInfo { 8. static const int kConstructorOffset = TemplateInfo::kHeaderSize; 9. static const int kInternalFieldCountOffset = kConstructorOffset + kPointerSize; 10. static const int kSize = kInternalFieldCountOffset + kHeaderSize; 11. }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-5\u6240\u793a\u3002 \u56fe6-5 \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\uff0c\u6211\u4eec\u770b\u770bSet(key, val)\u505a\u4e86\u4ec0\u4e48\u3002 1. void Template::Set(v8::Handle<String> name, v8::Handle<Data> value, 2. v8::PropertyAttribute attribute) { 3. // ... 4. i::Handle<i::Object> list(Utils::OpenHandle(this)->property_list()); 5. NeanderArray array(list); 6. array.add(Utils::OpenHandle(*name)); 7. array.add(Utils::OpenHandle(*value)); 8. array.add(Utils::OpenHandle(*v8::Integer::New(attribute))); 9. } \u4e0a\u9762\u7684\u4ee3\u7801\u5927\u81f4\u5c31\u662f\u7ed9\u4e00\u4e2alist\u540e\u9762\u8ffd\u52a0\u4e00\u4e9b\u5185\u5bb9\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2alist\u662f\u600e\u4e48\u6765\u7684\uff0c\u5373property_list\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. // \u8bfb\u53d6\u5bf9\u8c61\u4e2d\u67d0\u4e2a\u5c5e\u6027\u7684\u503c 2. #define READ_FIELD(p, offset) (*reinterpret_cast<Object**>(FIELD_ADDR(p, offset)) 3. 4. static Object* cast(Object* value) { 5. return value; 6. } 7. 8. Object* TemplateInfo::property_list() { 9. return Object::cast(READ_FIELD(this, kPropertyListOffset)); 10. } \u4ece\u4e0a\u9762\u4ee3\u7801\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u5185\u90e8\u5e03\u5c40\u5982\u56fe6-6\u6240\u793a\u3002 \u56fe6-6 \u6839\u636e\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053property_list\u7684\u503c\u662flist\u6307\u5411\u7684\u503c\u3002\u6240\u4ee5Set(key, val)\u64cd\u4f5c\u7684\u5185\u5b58\u5e76\u4e0d\u662f\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\uff0c\u5bf9\u8c61\u5229\u7528\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e00\u5757\u5185\u5b58\u4fdd\u5b58Set(key, val)\u7684\u503c\u3002SetInternalFieldCount\u51fd\u6570\u5c31\u4e0d\u4e00\u6837\u4e86\uff0c\u5b83\u4f1a\u5f71\u54cd\uff08\u6269\u5f20\uff09\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1. void ObjectTemplate::SetInternalFieldCount(int value) { 2. // \u4fee\u6539\u7684\u662fkInternalFieldCountOffset\u5bf9\u5e94\u7684\u5185\u5b58\u7684\u503c 3. Utils::OpenHandle(this)->set_internal_field_count(i::Smi::FromInt(value)); 4. } \u6211\u4eec\u770b\u5230SetInternalFieldCount\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5728\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6570\u5b57\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b57\u6bb5\u7684\u4f7f\u7528\u3002\u540e\u9762\u4f1a\u8be6\u7ec6\u4ecb\u7ecd\u5b83\u7684\u7528\u5904\u3002 1. Handle<JSFunction> Factory::CreateApiFunction( 2. Handle<FunctionTemplateInfo> obj, 3. bool is_global) { 4. 5. int internal_field_count = 0; 6. if (!obj->instance_template()->IsUndefined()) { 7. // \u83b7\u53d6\u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u6a21\u677f 8. Handle<ObjectTemplateInfo> instance_template = Handle<ObjectTemplateInfo>(ObjectTemplateInfo::cast(obj->instance_template())); 9. // \u83b7\u53d6\u5b9e\u4f8b\u6a21\u677f\u7684internal_field_count\u5b57\u6bb5\u7684\u503c\uff08\u901a\u8fc7SetInternalFieldCount\u8bbe\u7f6e\u7684\u90a3\u4e2a\u503c\uff09 10. internal_field_count = Smi::cast(instance_template->internal_field_count())->value(); 11. } 12. // \u8ba1\u7b97\u65b0\u5efa\u5bf9\u8c61\u9700\u8981\u7684\u7a7a\u95f4\uff0c\u5982\u679c 13. int instance_size = kPointerSize * internal_field_count; 14. if (is_global) { 15. instance_size += JSGlobalObject::kSize; 16. } else { 17. instance_size += JSObject::kHeaderSize; 18. } 19. 20. InstanceType type = is_global ? JS_GLOBAL_OBJECT_TYPE : JS_OBJECT_TYPE; 21. // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u5bf9\u8c61 22. Handle<JSFunction> result = 23. Factory::NewFunction(Factory::empty_symbol(), type, instance_size, 24. code, true); 25. } \u6211\u4eec\u770b\u5230internal_field_count\u7684\u503c\u7684\u610f\u4e49\u662f\uff0c\u4f1a\u6269\u5f20\u5bf9\u8c61\u7684\u5185\u5b58\uff0c\u6bd4\u5982\u4e00\u4e2a\u5bf9\u8c61\u672c\u8eab\u53ea\u6709n\u5b57\u8282\uff0c\u5982\u679c\u5b9a\u4e49internal_field_count\u7684\u503c\u662f1\uff0c\u5bf9\u8c61\u7684\u5185\u5b58\u5c31\u4f1a\u53d8\u6210n+internal_field_count * \u4e00\u4e2a\u6307\u9488\u7684\u5b57\u8282\u6570\u3002\u5185\u5b58\u5e03\u5c40\u5982\u56fe6-7\u6240\u793a\u3002 \u56fe6-7 1.4 \u901a\u8fc7\u51fd\u6570\u6a21\u677f\u521b\u5efa\u4e00\u4e2a\u51fd\u6570 1. Local functionTemplate = v8::FunctionTemplate::New(isolate(), New); 2. global->Set('demo', functionTemplate ->GetFunction()); \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728JS\u91cc\u76f4\u63a5\u8c03\u7528demo\u8fd9\u4e2a\u53d8\u91cf\uff0c\u7136\u540e\u5bf9\u5e94\u7684\u51fd\u6570\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u8fd9\u5c31\u662fJS\u8c03\u7528C++\u7684\u539f\u7406\u3002 2 Node.js\u662f\u5982\u4f55\u5904\u7406JS\u8c03\u7528C++\u95ee\u9898\u7684 \u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 1. constant { TCP } = process.binding('tcp_wrap'); 2. new TCP(...); Node.js\u901a\u8fc7\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u53d8\u91cfprocess\u7edf\u4e00\u5904\u7406C++\u6a21\u5757\u7684\u8c03\u7528\uff0c\u5177\u4f53\u53c2\u8003\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u7684\u5185\u5bb9\u3002\u5728Node.js\u4e2d\uff0cC++\u6a21\u5757\uff08\u7c7b\uff09\u4e00\u822c\u53ea\u4f1a\u5b9a\u4e49\u5bf9\u5e94\u7684Libuv\u7ed3\u6784\u4f53\u548c\u4e00\u7cfb\u5217\u7c7b\u51fd\u6570\uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u7248\uff0c\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\uff0c\u63a5\u7740\u628a\u8fd9\u4e9b\u7c7b\u51fd\u6570\u6302\u8f7d\u5230\u51fd\u6570\u6a21\u677f\u4e2d,\u6700\u540e\u901a\u8fc7\u51fd\u6570\u6a21\u677f\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570F\u7ed9JS\u5c42\u4f7f\u7528\uff0c\u7ffb\u8bd1\u6210JS\u5927\u81f4\u5982\u4e0b 1. // Libuv 2. function uv_tcp_connect(uv_tcp_t, addr,cb) { cb(); } 3. 4. // C++ 5. class TCPWrap { 6. 7. uv_tcp_t = {}; 8. 9. static Connect(cb) { 10. 11. const tcpWrap = this[0]; 12. 13. uv_tcp_connect( 14. 15. tcpWrap.uv_tcp_t, 16. 17. {ip: '127.0.0.1', port: 80}, 18. 19. () => { cb(); } 20. 21. ); 22. 23. } 24. 25. } 26. 27. function FunctionTemplate(cb) { 28. function Tmp() { 29. Object.assign(this, map); 30. cb(this); 31. } 32. const map = {}; 33. return { 34. PrototypeTemplate: function() { 35. return { 36. set: function(k, v) { 37. Tmp.prototype[k] = v; 38. } 39. } 40. }, 41. InstanceTemplate: function() { 42. return { 43. set: function(k, v) { 44. map[k] = v; 45. } 46. } 47. }, 48. GetFunction() { 49. return Tmp; 50. } 51. } 52. 53. } 54. 55. const TCPFunctionTemplate = FunctionTemplate((target) => { target[0] = new TCPWrap(); }) 56. 57. TCPFunctionTemplate.PrototypeTemplate().set('connect', TCPWrap.Connect); 58. TCPFunctionTemplate.InstanceTemplate().set('name', 'hi'); 59. const TCP = TCPFunctionTemplate.GetFunction(); 60. 61. // js 62. const tcp = new TCP(); 63. tcp.connect(() => { console.log('\u8fde\u63a5\u6210\u529f'); }); 64. tcp.name; \u6211\u4eec\u4eceC++\u7684\u5c42\u9762\u5206\u6790\u6267\u884cnew TCP()\u7684\u903b\u8f91\uff0c\u7136\u540e\u518d\u5206\u6790connect\u7684\u903b\u8f91\uff0c\u8fd9\u4e24\u4e2a\u903b\u8f91\u6d89\u53ca\u7684\u673a\u5236\u662f\u5176\u5b83C++\u6a21\u5757\u4e5f\u4f1a\u4f7f\u7528\u5230\u7684\u3002\u56e0\u4e3aTCP\u5bf9\u5e94\u7684\u51fd\u6570\u662fInitialize\u51fd\u6570\u91cc\u7684t->GetFunction()\u5bf9\u5e94\u7684\u503c\u3002\u6240\u4ee5new TCP()\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\u3002 1. void TCPWrap::New(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. int type_value = args[0].As<Int32>()->Value(); 5. TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value); 6. 7. ProviderType provider; 8. switch (type) { 9. case SOCKET: 10. provider = PROVIDER_TCPWRAP; 11. break; 12. case SERVER: 13. provider = PROVIDER_TCPSERVERWRAP; 14. break; 15. default: 16. UNREACHABLE(); 17. } 18. /* 19. args.This()\u4e3av8\u63d0\u4f9b\u7684\u4e00\u4e2aC++\u5bf9\u8c61\uff08\u7531Initialize\u51fd\u6570\u5b9a\u4e49\u7684\u6a21\u5757\u521b\u5efa\u7684\uff09 20. \u8c03\u7528\u8be5C++\u5bf9\u8c61\u7684SetAlignedPointerInInternalField(0,this)\u5173\u8054this\uff08new TCPWrap()\uff09, 21. \u89c1HandleWrap 22. */ 23. 24. new TCPWrap(env, args.This(), provider); 25. } \u6211\u4eec\u6cbf\u7740TCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\uff0c\u4e00\u76f4\u5230HandleWrap 1. HandleWrap::HandleWrap(Environment* env, 2. Local<Object> object, 3. uv_handle_t* handle, 4. AsyncWrap::ProviderType provider) 5. : AsyncWrap(env, object, provider), 6. state_(kInitialized), 7. handle_(handle) { 8. // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb 9. handle_->data = this; 10. HandleScope scope(env->isolate()); 11. // \u63d2\u5165handle\u961f\u5217 12. env->handle_wrap_queue()->PushBack(this); 13. } HandleWrap\u9996\u5148\u4fdd\u5b58\u4e86Libuv\u7ed3\u6784\u4f53\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb\u3002\u7136\u540e\u6211\u4eec\u7ee7\u7eed\u6cbf\u7740AsyncWrap\u5206\u6790\uff0cAsyncWrap\u7ee7\u627fBaseObject\uff0c\u6211\u4eec\u76f4\u63a5\u770bBaseObject\u3002 1. // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 2. BaseObject::BaseObject(Environment* env, v8::Local<v8::Object> object) 3. : persistent_handle_(env->isolate(), object), env_(env) { 4. // \u628athis\u5b58\u5230object\u4e2d 5. object->SetAlignedPointerInInternalField(0, static_cast<void*>(this)); 6. env->AddCleanupHook(DeleteMe, static_cast<void*>(this)); 7. env->modify_base_object_count(1); 8. } \u6211\u4eec\u770bSetAlignedPointerInInternalField\u3002 1. void v8::Object::SetAlignedPointerInInternalField(int index, void* value) { 2. i::Handle<i::JSReceiver> obj = Utils::OpenHandle(this); 3. i::Handle<i::JSObject>::cast(obj)->SetEmbedderField( 4. index, EncodeAlignedAsSmi(value, location)); 5. } 6. 7. void JSObject::SetEmbedderField(int index, Smi* value) { 8. // GetHeaderSize\u4e3a\u5bf9\u8c61\u56fa\u5b9a\u5e03\u5c40\u7684\u5927\u5c0f\uff0ckPointerSize * index\u4e3a\u62d3\u5c55\u7684\u5185\u5b58\u5927\u5c0f\uff0c\u6839\u636e\u7d22\u5f15\u627e\u5230\u5bf9\u5e94\u4f4d\u7f6e 9. int offset = GetHeaderSize() + (kPointerSize * index); 10. // \u5199\u5bf9\u5e94\u4f4d\u7f6e\u7684\u5185\u5b58\uff0c\u5373\u4fdd\u5b58\u5bf9\u5e94\u7684\u5185\u5bb9\u5230\u5185\u5b58 11. WRITE_FIELD(this, offset, value); 12. } SetAlignedPointerInInternalField\u51fd\u6570\u5c55\u5f00\u540e\uff0c\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2a\u503c\u4fdd\u5b58\u5230V8 C++\u5bf9\u8c61\u7684\u5185\u5b58\u91cc\u3002\u90a3\u4fdd\u5b58\u7684\u8fd9\u4e2a\u503c\u662f\u5565\u5462\uff1fBaseObject\u7684\u5165\u53c2object\u662f\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\uff0cthis\u662f\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u6240\u4ee5SetAlignedPointerInInternalField\u51fd\u6570\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u4fdd\u5b58\u5230\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u91cc\uff0c\u5982\u56fe6-8\u6240\u793a\u3002 \u56fe6-8 \u8fd9\u6709\u5565\u7528\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u3002\u8fd9\u65f6\u5019new TCP\u5c31\u6267\u884c\u5b8c\u6bd5\u4e86\u3002\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u6267\u884ctcp.connect()\u51fd\u6570\u7684\u903b\u8f91\u3002 1. template <typename T> 2. void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args, 3. std::function<int(const char* ip_address, T* addr)> uv_ip_addr) { 4. Environment* env = Environment::GetCurrent(args); 5. 6. TCPWrap* wrap; 7. ASSIGN_OR_RETURN_UNWRAP(&wrap, 8. args.Holder(), 9. args.GetReturnValue().Set(UV_EBADF)); 10. // \u7701\u7565\u90e8\u5206\u4e0d\u76f8\u5173\u4ee3\u7801 11. 12. args.GetReturnValue().Set(err); 13. } \u6211\u4eec\u53ea\u9700\u770b\u4e00\u4e0bASSIGN_OR_RETURN_UNWRAP\u5b8f\u7684\u903b\u8f91\u3002\u5176\u4e2dargs.Holder()\u8868\u793aConnect\u51fd\u6570\u7684\u5c5e\u4e3b\uff0c\u6839\u636e\u524d\u9762\u7684\u5206\u6790\u6211\u4eec\u77e5\u9053\u5c5e\u4e3b\u662fInitialize\u51fd\u6570\u5b9a\u4e49\u7684\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4fdd\u5b58\u4e86\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002ASSIGN_OR_RETURN_UNWRAP\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u5728C++\u5bf9\u8c61\u4e2d\u4fdd\u5b58\u7684\u90a3\u4e2aTCPWrap\u5bf9\u8c61\u53d6\u51fa\u6765\u3002\u7136\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528TCPWrap\u5bf9\u8c61\u7684handle\u53bb\u8bf7\u6c42Libuv\u4e86\u3002","title":"6.5 JS\u5982\u4f55\u4f7f\u7528C++"},{"location":"chapter06-C%2B%2B%E5%B1%82/#67-clibuv","text":"\u521a\u624d\u6211\u4eec\u5206\u6790\u4e86JS\u8c03\u7528C++\u5c42\u65f6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bC++\u8c03\u7528Libuv\u548cLibuv\u56de\u8c03C++\u5c42\u53c8\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u6211\u4eec\u901a\u8fc7TCP\u6a21\u5757\u7684connect\u51fd\u6570\u7ee7\u7eed\u5206\u6790\u8be5\u8fc7\u7a0b\u3002 1. template <typename T> 2. void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args, 3. std::function<int(const char* ip_address, T* addr)> uv_ip_addr) { 4. Environment* env = Environment::GetCurrent(args); 5. 6. TCPWrap* wrap; 7. ASSIGN_OR_RETURN_UNWRAP(&wrap, 8. args.Holder(), 9. args.GetReturnValue().Set(UV_EBADF)); 10. 11. // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662fTCPConnectWrap\u5bf9\u8c61\uff0c\u89c1net\u6a21\u5757 12. Local<Object> req_wrap_obj = args[0].As<Object>(); 13. // \u7b2c\u4e8c\u4e2a\u662fip\u5730\u5740 14. node::Utf8Value ip_address(env->isolate(), args[1]); 15. 16. T addr; 17. // \u628a\u7aef\u53e3\uff0cIP\u8bbe\u7f6e\u5230addr\u4e0a\uff0c\u7aef\u53e3\u4fe1\u606f\u5728uv_ip_addr\u4e0a\u4e0b\u6587\u91cc\u4e86 18. int err = uv_ip_addr(*ip_address, &addr); 19. 20. if (err == 0) { 21. ConnectWrap* req_wrap = 22. new ConnectWrap(env, 23. req_wrap_obj, 24. AsyncWrap::PROVIDER_TCPCONNECTWRAP); 25. err = req_wrap->Dispatch(uv_tcp_connect, 26. &wrap->handle_, 27. reinterpret_cast<const sockaddr*>(&addr), 28. AfterConnect); 29. if (err) 30. delete req_wrap; 31. } 32. 33. args.GetReturnValue().Set(err); 34. } \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bConnectWrap\u3002\u6211\u4eec\u77e5\u9053ConnectWrap\u662fReqWrap\u7684\u5b50\u7c7b\u3002req_wrap_obj\u662fJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002New ConnectWrap\u540e\u7ed3\u6784\u5982\u56fe6-9\u6240\u793a\u3002 \u56fe6-9 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bDispatch\u3002 1. // \u8c03\u7528Libuv\u51fd\u6570 2. template <typename T> 3. template <typename LibuvFunction, typename... Args> 4. int ReqWrap<T>::Dispatch(LibuvFunction fn, Args... args) { 5. // \u4fdd\u5b58Libuv\u7ed3\u6784\u4f53\u548cC++\u5c42\u5bf9\u8c61ConnectWrap\u7684\u5173\u7cfb 6. req_.data = this; 7. int err = CallLibuvFunction<T, LibuvFunction>::Call( 8. fn, 9. env()->event_loop(), 10. req(), 11. MakeLibuvRequestCallback<T, Args>::For(this, args)...); 12. if (err >= 0) 13. env()->IncreaseWaitingRequestCounter(); 14. return err; 15. } \u8c03\u7528Libuv\u4e4b\u524d\u7684\u7ed3\u6784\u5982\u56fe6-10\u6240\u793a\u3002 \u56fe6-10 \u63a5\u4e0b\u6765\u6211\u4eec\u5206\u6790\u8c03\u7528Libuv\u7684\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u770b\u5230Dispatch\u51fd\u6570\u662f\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u3002 \u9996\u5148\u770b\u4e00\u4e0bCallLibuvFunction\u7684\u5b9e\u73b0\u3002 1. template <typename ReqT, typename T> 2. struct CallLibuvFunction; 3. 4. // Detect `int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);`. 5. template <typename ReqT, typename... Args> 6. struct CallLibuvFunction<ReqT, int(*)(uv_loop_t*, ReqT*, Args...)> { 7. using T = int(*)(uv_loop_t*, ReqT*, Args...); 8. template <typename... PassedArgs> 9. static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) { 10. return fn(loop, req, args...); 11. } 12. }; 13. 14. // Detect `int uv_foo(uv_req_t* request, ...);`. 15. template <typename ReqT, typename... Args> 16. struct CallLibuvFunction<ReqT, int(*)(ReqT*, Args...)> { 17. using T = int(*)(ReqT*, Args...); 18. template <typename... PassedArgs> 19. static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) { 20. return fn(req, args...); 21. } 22. }; 23. 24. // Detect `void uv_foo(uv_req_t* request, ...);`. 25. template <typename ReqT, typename... Args> 26. struct CallLibuvFunction<ReqT, void(*)(ReqT*, Args...)> { 27. using T = void(*)(ReqT*, Args...); 28. template <typename... PassedArgs> 29. static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) { 30. fn(req, args...); 31. return 0; 32. } 33. }; CallLibuvFunction\u7684\u5b9e\u73b0\u770b\u8d77\u6765\u975e\u5e38\u590d\u6742\uff0c\u90a3\u662f\u56e0\u4e3a\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\uff0cCallLibuvFunction\u672c\u8d28\u4e0a\u662f\u4e00\u4e2astruct\uff0c\u5728C++\u91cc\u548c\u7c7b\u4f5c\u7528\u7c7b\u4f3c\uff0c\u91cc\u9762\u53ea\u6709\u4e00\u4e2a\u7c7b\u51fd\u6570Call\uff0cNode.js\u4e3a\u4e86\u9002\u914dLibuv\u5c42\u5404\u79cd\u7c7b\u578b\u51fd\u6570\u7684\u8c03\u7528\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e86\u4e09\u79cd\u7c7b\u578b\u7684CallLibuvFunction,\u5e76\u4e14\u4f7f\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\u3002\u6211\u4eec\u53ea\u9700\u8981\u5206\u6790\u4e00\u79cd\u5c31\u53ef\u4ee5\u4e86\u3002\u6211\u4eec\u6839\u636eTCP\u7684connect\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002\u6211\u4eec\u9996\u5148\u5177\u4f53\u4e0bDispatch\u51fd\u6570\u7684\u6a21\u677f\u53c2\u6570\u3002 1. template <typename T> 2. template <typename LibuvFunction, typename... Args> T\u5bf9\u5e94ReqWrap\u7684\u7c7b\u578b\uff0cLibuvFunction\u5bf9\u5e94Libuv\u7684\u51fd\u6570\u7c7b\u578b\uff0c\u8fd9\u91cc\u662fint uv_tcp_connect(uv_connect_t* req, ...)\uff0c\u6240\u4ee5\u662f\u5bf9\u5e94LibuvFunction\u7684\u7b2c\u4e8c\u79cd\u60c5\u51b5\uff0cArgs\u662f\u6267\u884cDispatch\u65f6\u9664\u4e86\u7b2c\u4e00\u4e2a\u5b9e\u53c2\u5916\u7684\u5269\u4f59\u53c2\u6570\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5316Dispatch\u3002 1. int ReqWrap<uv_connect_t>::Dispatch(int(*)(uv_connect_t*, Args...), Args... args) { 2. req_.data = this; 3. int err = CallLibuvFunction<uv_connect_t, int(*)(uv_connect_t*, Args...)>::Call( 4. fn, 5. env()->event_loop(), 6. req(), 7. MakeLibuvRequestCallback<T, Args>::For(this, args)...); 8. 9. return err; 10. } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bMakeLibuvRequestCallback\u7684\u5b9e\u73b0\u3002 1. // \u900f\u4f20\u53c2\u6570\u7ed9Libuv 2. template <typename ReqT, typename T> 3. struct MakeLibuvRequestCallback { 4. static T For(ReqWrap<ReqT>* req_wrap, T v) { 5. static_assert(!is_callable<T>::value, 6. \"MakeLibuvRequestCallback missed a callback\"); 7. return v; 8. } 9. }; 10. 11. template <typename ReqT, typename... Args> 12. struct MakeLibuvRequestCallback<ReqT, void(*)(ReqT*, Args...)> { 13. using F = void(*)(ReqT* req, Args... args); 14. // Libuv\u56de\u8c03 15. static void Wrapper(ReqT* req, Args... args) { 16. // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 17. ReqWrap<ReqT>* req_wrap = ReqWrap<ReqT>::from_req(req); 18. req_wrap->env()->DecreaseWaitingRequestCounter(); 19. // \u62ff\u5230\u539f\u59cb\u7684\u56de\u8c03\u6267\u884c 20. F original_callback = reinterpret_cast<F>(req_wrap->original_callback_); 21. original_callback(req, args...); 22. } 23. 24. static F For(ReqWrap<ReqT>* req_wrap, F v) { 25. // \u4fdd\u5b58\u539f\u6765\u7684\u51fd\u6570 26. CHECK_NULL(req_wrap->original_callback_); 27. req_wrap->original_callback_ = 28. reinterpret_cast<typename ReqWrap<ReqT>::callback_t>(v); 29. // \u8fd4\u56de\u5305\u88f9\u51fd\u6570 30. return Wrapper; 31. } 32. }; MakeLibuvRequestCallback\u7684\u5b9e\u73b0\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u6a21\u7248\u53c2\u6570\u7684\u7b2c\u4e00\u4e2a\u4e00\u822c\u662fReqWrap\u5b50\u7c7b\uff0c\u7b2c\u4e8c\u4e2a\u4e00\u822c\u662fhandle\uff0c\u521d\u59cb\u5316ReqWrap\u7c7b\u7684\u65f6\u5019\uff0cenv\u4e2d\u4f1a\u8bb0\u5f55ReqWrap\u5b9e\u4f8b\u7684\u4e2a\u6570\uff0c\u4ece\u800c\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u8bf7\u6c42\u6b63\u5728\u88abLibuv\u5904\u7406\uff0c\u6a21\u677f\u53c2\u6570\u7684\u7b2c\u4e8c\u4e2a\u5982\u679c\u662f\u51fd\u6570\u5219\u8bf4\u660e\u6ca1\u6709\u4f7f\u7528ReqWrap\u8bf7\u6c42Libuv\uff0c\u5219\u4f7f\u7528\u7b2c\u4e8c\u79cd\u5b9e\u73b0\uff0c\u52ab\u6301\u56de\u8c03\u4ece\u800c\u8bb0\u5f55\u6b63\u5728\u88abLibuv\u5904\u7406\u7684\u8bf7\u6c42\u6570\uff08\u5982GetAddrInfo\u7684\u5b9e\u73b0\uff09\u3002\u6240\u4ee5\u6211\u4eec\u8fd9\u91cc\u662f\u9002\u914d\u7b2c\u4e00\u79cd\u5b9e\u73b0\u3002\u900f\u4f20C++\u5c42\u53c2\u6570\u7ed9Libuv\u3002\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b Dispatch 1. int ReqWrap<uv_connect_t>::Dispatch(int(*)(uv_connect_t*, Args...), Args... args) { 2. req_.data = this; 3. int err = CallLibuvFunction<uv_connect_t, int(*)(uv_connect_t*, Args...)>::Call( 4. fn, 5. env()->event_loop(), 6. req(), 7. args...); 8. 9. return err; 10. } \u518d\u8fdb\u4e00\u6b65\u5c55\u5f00\u3002 1. static int Call(int(*fn)(uv_connect_t*, Args...), uv_loop_t* loop, uv_connect_t* req, PassedArgs... args) { 2. return fn(req, args...); 3. } \u6700\u540e\u5c55\u5f00 1. static int Call(int(*fn)(uv_connect_t*, Args...), uv_loop_t* loop, uv_connect_t* req, PassedArgs... args) { 2. return fn(req, args...); 3. } 4. 5. Call( 6. uv_tcp_connect, 7. env()->event_loop(), 8. req(), 9. &wrap->handle_, 10. AfterConnec 11. ) 12. 13. uv_tcp_connect( 14. env()->event_loop(), 15. req(), 16. &wrap->handle_, 17. AfterConnect 18. ); \u63a5\u7740\u6211\u4eec\u770b\u770buv_tcp_connect\u505a\u4e86\u4ec0\u4e48\u3002 1. int uv_tcp_connect(uv_connect_t* req, 2. uv_tcp_t* handle, 3. const struct sockaddr* addr, 4. uv_connect_cb cb) { 5. // ... 6. return uv__tcp_connect(req, handle, addr, addrlen, cb); 7. } 8. 9. int uv__tcp_connect(uv_connect_t* req, 10. uv_tcp_t* handle, 11. const struct sockaddr* addr, 12. unsigned int addrlen, 13. uv_connect_cb cb) { 14. int err; 15. int r; 16. 17. // \u5173\u8054\u8d77\u6765 18. req->handle = (uv_stream_t*) handle; 19. // ... 20. } Libuv\u4e2d\u628areq\u548chandle\u505a\u4e86\u5173\u8054\uff0c\u5982\u56fe6-11\u6240\u793a\u3002 \u56fe6-11 \u5206\u6790\u5b8cC++\u8c03\u7528Libuv\u540e\uff0c\u6211\u4eec\u770b\u770bLibuv\u56de\u8c03C++\u548cC++\u56de\u8c03JS\u7684\u8fc7\u7a0b\u3002\u5f53Libuv\u5904\u7406\u5b8c\u8bf7\u6c42\u540e\u4f1a\u6267\u884cAfterConnect \u3002 1. template <typename WrapType, typename UVType> 2. void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req, 3. int status) { 4. // \u4eceLibuv\u7ed3\u6784\u4f53\u62ff\u5230C++\u7684\u8bf7\u6c42\u5bf9\u8c61 5. std::unique_ptr<ConnectWrap> req_wrap 6. (static_cast<ConnectWrap*>(req->data)); 7. // \u4eceC++\u5c42\u8bf7\u6c42\u5bf9\u8c61\u62ff\u5230\u5bf9\u5e94\u7684handle\u7ed3\u6784\u4f53\uff08Libuv\u91cc\u5173\u8054\u8d77\u6765\u7684\uff09\uff0c\u518d\u901a\u8fc7handle\u62ff\u5230\u5bf9\u5e94\u7684C++\u5c42handle\u5bf9\u8c61\uff08HandleWrap\u5173\u8054\u7684\uff09 8. WrapType* wrap = static_cast<WrapType*>(req->handle->data); 9. Environment* env = wrap->env(); 10. ... 11. Local<Value> argv[5] = { 12. Integer::New(env->isolate(), status), 13. wrap->object(), 14. req_wrap->object(), 15. Boolean::New(env->isolate(), readable), 16. Boolean::New(env->isolate(), writable) 17. }; 18. // \u56de\u8c03JS\u5c42oncomplete 19. req_wrap->MakeCallback(env->oncomplete_string(), 20. arraysize(argv), 21. argv); 22. }","title":"6.7 C++\u5c42\u8c03\u7528Libuv"},{"location":"chapter06-C%2B%2B%E5%B1%82/#68","text":"Node.js\u5728C++\u5c42\u5bf9\u6d41\u8fdb\u884c\u4e86\u975e\u5e38\u591a\u7684\u5c01\u88c5\uff0c\u5f88\u591a\u6a21\u5757\u90fd\u4f9d\u8d56C++\u5c42\u6d41\u7684\u673a\u5236\uff0c\u6d41\u673a\u5236\u7684\u8bbe\u8ba1\u4e2d\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 \u8d44\u6e90\uff0c\u8fd9\u662f\u6d41\u673a\u5236\u7684\u6838\u5fc3\uff08StreamResource\uff09, 2 \u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\uff08StreamReq\uff09 3 \u6d41\u4e8b\u4ef6\u7684\u76d1\u542c\u8005\uff0c\u5f53\u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\u6216\u6d41\u672c\u8eab\u6709\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u628a\u4e8b\u4ef6\u548c\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u4f20\u9012\u7ed9\u76d1\u542c\u8005\uff0c\u76d1\u542c\u8005\u5904\u7406\u5b8c\u540e\uff0c\u518d\u901a\u77e5\u6d41\uff08StreamListener\uff09\u3002 \u901a\u8fc7\u7ee7\u627f\u7684\u6a21\u5f0f\uff0c\u57fa\u7c7b\u5b9a\u4e49\u63a5\u53e3\uff0c\u5b50\u7c7b\u5b9e\u73b0\u63a5\u53e3\u7684\u65b9\u5f0f\u3002\u5bf9\u6d41\u7684\u64cd\u4f5c\u8fdb\u884c\u4e86\u62bd\u8c61\u548c\u5c01\u88c5\u3002\u4e09\u8005\u7684\u7c7b\u5173\u7cfb\u5982\u56fe6-12\u6240\u793a\u3002 \u56fe6-12 \u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u4e00\u4e2a\u6d41\u7684\u6570\u636e\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-13\u6240\u793a\u3002 \u56fe6-13 \u518d\u770b\u4e00\u4e0b\u5199\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-14\u6240\u793a\u3002 \u56fe6-14","title":"6.8 \u6d41\u5c01\u88c5"},{"location":"chapter06-C%2B%2B%E5%B1%82/#681-streamresource","text":"StreamResource\u5b9a\u4e49\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u89e6\u53d1\u7684\u56de\u8c03\u3002\u4f46\u662fStreamResource\u4e0d\u5b9a\u4e49\u6d41\u7684\u7c7b\u578b\uff0c\u6d41\u7684\u7c7b\u578b\u7531\u5b50\u7c7b\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u5728StreamResource\u4e0a\u6ce8\u518clistener\uff0c\u8868\u793a\u5bf9\u6d41\u611f\u5174\u8da3\uff0c\u5f53\u6d41\u4e0a\u6709\u6570\u636e\u53ef\u8bfb\u6216\u8005\u4e8b\u4ef6\u53d1\u751f\u65f6\uff0c\u5c31\u4f1a\u901a\u77e5listener\u3002 1. class StreamResource { 2. public: 3. virtual ~StreamResource(); 4. // \u6ce8\u518c/\u6ce8\u9500\u7b49\u5f85\u6d41\u53ef\u8bfb\u4e8b\u4ef6 5. virtual int ReadStart() = 0; 6. virtual int ReadStop() = 0; 7. // \u5173\u95ed\u6d41 8. virtual int DoShutdown(ShutdownWrap* req_wrap) = 0; 9. // \u5199\u5165\u6d41 10. virtual int DoTryWrite(uv_buf_t** bufs, size_t* count); 11. virtual int DoWrite(WriteWrap* w, 12. uv_buf_t* bufs, 13. size_t count, 14. uv_stream_t* send_handle) = 0; 15. // ...\u5ffd\u7565\u4e00\u4e9b 16. // \u7ed9\u6d41\u589e\u52a0\u6216\u5220\u9664\u76d1\u542c\u8005 17. void PushStreamListener(StreamListener* listener); 18. void RemoveStreamListener(StreamListener* listener); 19. 20. protected: 21. uv_buf_t EmitAlloc(size_t suggested_size); 22. void EmitRead(ssize_t nread, 23. const uv_buf_t& buf = uv_buf_init(nullptr, 0)); 24. // \u6d41\u7684\u76d1\u542c\u8005\uff0c\u5373\u6570\u636e\u6d88\u8d39\u8005 25. StreamListener* listener_ = nullptr; 26. uint64_t bytes_read_ = 0; 27. uint64_t bytes_written_ = 0; 28. friend class StreamListener; 29. }; StreamResource\u662f\u4e00\u4e2a\u57fa\u7c7b\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a\u6210\u5458\u662fStreamListener\u7c7b\u7684\u5b9e\u4f8b\uff0c\u6211\u4eec\u540e\u9762\u5206\u6790\u3002\u6211\u4eec\u770b\u4e00\u4e0bStreamResource\u7684\u5b9e\u73b0\u3002 1\u589e\u52a0\u4e00\u4e2alistener 1. // \u589e\u52a0\u4e00\u4e2alistener 2. inline void StreamResource::PushStreamListener(StreamListener* listener) { 3. // \u5934\u63d2\u6cd5 4. listener->previous_listener_ = listener_; 5. listener->stream_ = this; 6. listener_ = listener; 7. } \u6211\u4eec\u53ef\u4ee5\u5728\u4e00\u4e2a\u6d41\u4e0a\u6ce8\u518c\u591a\u4e2alistener\uff0c\u6d41\u7684listener_\u5b57\u6bb5\u7ef4\u62a4\u4e86\u6d41\u4e0a\u6240\u6709\u7684listener\u961f\u5217\u3002\u5173\u7cfb\u56fe\u5982\u56fe6-15\u6240\u793a\u3002 \u56fe6-15 2\u5220\u9664listener 1. inline void StreamResource::RemoveStreamListener(StreamListener* listener) { 2. StreamListener* previous; 3. StreamListener* current; 4. 5. // \u904d\u5386\u5355\u94fe\u8868 6. for (current = listener_, previous = nullptr; 7. /* No loop condition because we want a crash if listener is not found */ 8. ; previous = current, current = current->previous_listener_) { 9. if (current == listener) { 10. // \u975e\u7a7a\u8bf4\u660e\u9700\u8981\u5220\u9664\u7684\u4e0d\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9 11. if (previous != nullptr) 12. previous->previous_listener_ = current->previous_listener_; 13. else 14. // \u5220\u9664\u7684\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u66f4\u65b0\u5934\u6307\u9488\u5c31\u884c 15. listener_ = listener->previous_listener_; 16. break; 17. } 18. } 19. // \u91cd\u7f6e\u88ab\u5220\u9664listener\u7684\u5b57\u6bb5 20. listener->stream_ = nullptr; 21. listener->previous_listener_ = nullptr; 22. } 3 \u7533\u8bf7\u5b58\u50a8\u6570\u636e 1. // \u7533\u8bf7\u4e00\u5757\u5185\u5b58 2. inline uv_buf_t StreamResource::EmitAlloc(size_t suggested_size) { 3. DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); 4. return listener_->OnStreamAlloc(suggested_size); 5. } StreamResource\u53ea\u662f\u5b9a\u4e49\u4e86\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\uff0c\u6570\u636e\u5b58\u50a8\u548c\u6d88\u8d39\u7531listener\u5b9a\u4e49\u3002 4 \u6570\u636e\u53ef\u8bfb 1. inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { 2. if (nread > 0) 3. // \u8bb0\u5f55\u4ece\u6d41\u4e2d\u8bfb\u53d6\u7684\u6570\u636e\u7684\u5b57\u8282\u5927\u5c0f 4. bytes_read_ += static_cast<uint64_t>(nread); 5. listener_->OnStreamRead(nread, buf); 6. } 5 \u5199\u56de\u8c03 1. inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) { 2. DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); 3. listener_->OnStreamAfterWrite(w, status); 4. } 6 \u5173\u95ed\u6d41\u56de\u8c03 1. inline void StreamResource::EmitAfterShutdown(ShutdownWrap* w, int status) { 2. DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); 3. listener_->OnStreamAfterShutdown(w, status); 4. } 7 \u6d41\u9500\u6bc1\u56de\u8c03 1. inline StreamResource::~StreamResource() { 2. while (listener_ != nullptr) { 3. StreamListener* listener = listener_; 4. listener->OnStreamDestroy(); 5. if (listener == listener_) 6. RemoveStreamListener(listener_); 7. } 8. } \u6d41\u9500\u6bc1\u540e\u9700\u8981\u901a\u77e5listener\uff0c\u5e76\u4e14\u89e3\u9664\u5173\u7cfb\u3002","title":"6.8.1 StreamResource"},{"location":"chapter06-C%2B%2B%E5%B1%82/#682-streambase","text":"StreamBase\u662fStreamResource\u7684\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86StreamResource\u7684\u529f\u80fd\u3002 1. class StreamBase : public StreamResource { 2. public: 3. static constexpr int kStreamBaseField = 1; 4. static constexpr int kOnReadFunctionField = 2; 5. static constexpr int kStreamBaseFieldCount = 3; 6. // \u5b9a\u4e49\u4e00\u4e9b\u7edf\u4e00\u7684\u903b\u8f91 7. static void AddMethods(Environment* env, 8. v8::Local<v8::FunctionTemplate> target); 9. 10. virtual bool IsAlive() = 0; 11. virtual bool IsClosing() = 0; 12. virtual bool IsIPCPipe(); 13. virtual int GetFD(); 14. 15. // \u6267\u884cJS\u56de\u8c03 16. v8::MaybeLocal<v8::Value> CallJSOnreadMethod( 17. ssize_t nread, 18. v8::Local<v8::ArrayBuffer> ab, 19. size_t offset = 0, 20. StreamBaseJSChecks checks = DONT_SKIP_NREAD_CHECKS); 21. 22. Environment* stream_env() const; 23. // \u5173\u95ed\u6d41 24. int Shutdown(v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); 25. // \u5199\u5165\u6d41 26. StreamWriteResult Write( 27. uv_buf_t* bufs, 28. size_t count, 29. uv_stream_t* send_handle = nullptr, 30. v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); 31. // \u521b\u5efa\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42 32. virtual ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object); 33. // \u521b\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 34. virtual WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object); 35. 36. virtual AsyncWrap* GetAsyncWrap() = 0; 37. virtual v8::Local<v8::Object> GetObject(); 38. static StreamBase* FromObject(v8::Local<v8::Object> obj); 39. 40. protected: 41. explicit StreamBase(Environment* env); 42. 43. // JS Methods 44. int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args); 45. // \u7701\u7565\u7cfb\u5217\u65b9\u6cd5 46. void AttachToObject(v8::Local<v8::Object> obj); 47. 48. template <int (StreamBase::*Method)( 49. const v8::FunctionCallbackInfo<v8::Value>& args)> 50. static void JSMethod(const v8::FunctionCallbackInfo<v8::Value>& args); 51. 52. private: 53. Environment* env_; 54. EmitToJSStreamListener default_listener_; 55. 56. void SetWriteResult(const StreamWriteResult& res); 57. static void AddMethod(Environment* env, 58. v8::Local<v8::Signature> sig, 59. enum v8::PropertyAttribute attributes, 60. v8::Local<v8::FunctionTemplate> t, 61. JSMethodFunction* stream_method, 62. v8::Local<v8::String> str); 63. }; 1 \u521d\u59cb\u5316 1. inline StreamBase::StreamBase(Environment* env) : env_(env) { 2. PushStreamListener(&default_listener_); 3. } StreamBase\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u9ed8\u8ba4\u8bbe\u7f6e\u4e00\u4e2alistener\u3002 2 \u5173\u95ed\u6d41 1. // \u5173\u95ed\u4e00\u4e2a\u6d41\uff0creq_wrap_obj\u662fJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 2. inline int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) { 3. Environment* env = stream_env(); 4. HandleScope handle_scope(env->isolate()); 5. AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); 6. // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u6570\u636e\u7ed3\u6784 7. ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj); 8. // \u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5173\u95ed\u7684\u903b\u8f91\u4e0d\u4e00\u6837 9. int err = DoShutdown(req_wrap); 10. // \u6267\u884c\u51fa\u9519\u5219\u9500\u6bc1JS\u5c42\u5bf9\u8c61 11. if (err != 0 && req_wrap != nullptr) { 12. req_wrap->Dispose(); 13. } 14. 15. const char* msg = Error(); 16. if (msg != nullptr) { 17. req_wrap_obj->Set( 18. env->context(), 19. env->error_string(), 20. OneByteString(env->isolate(), msg)).Check(); 21. ClearError(); 22. } 23. 24. return err; 25. } 3 \u5199 1. // \u5199Buffer\uff0c\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 2. int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. 5. Local<Object> req_wrap_obj = args[0].As<Object>(); 6. uv_buf_t buf; 7. // \u6570\u636e\u5185\u5bb9\u548c\u957f\u5ea6 8. buf.base = Buffer::Data(args[1]); 9. buf.len = Buffer::Length(args[1]); 10. 11. uv_stream_t* send_handle = nullptr; 12. // \u662f\u5bf9\u8c61\u5e76\u4e14\u6d41\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 13. if (args[2]->IsObject() && IsIPCPipe()) { 14. Local<Object> send_handle_obj = args[2].As<Object>(); 15. 16. HandleWrap* wrap; 17. // \u4ece\u8fd4\u56dejs\u7684\u5bf9\u8c61\u4e2d\u83b7\u53d6internalField\u4e2d\u6307\u5411\u7684C++\u5c42\u5bf9\u8c61 18. ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL); 19. // \u62ff\u5230Libuv\u5c42\u7684handle 20. send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); 21. // Reference LibuvStreamWrap instance to prevent it from being garbage 22. // collected before `AfterWrite` is called. 23. // \u8bbe\u7f6e\u5230JS\u5c42\u8bf7\u6c42\u5bf9\u8c61\u4e2d 24. req_wrap_obj->Set(env->context(), 25. env->handle_string(), 26. send_handle_obj).Check(); 27. } 28. 29. StreamWriteResult res = Write(&buf, 1, send_handle, req_wrap_obj); 30. SetWriteResult(res); 31. 32. return res.err; 33. } 1. inline StreamWriteResult StreamBase::Write( 2. uv_buf_t* bufs, 3. size_t count, 4. uv_stream_t* send_handle, 5. v8::Local<v8::Object> req_wrap_obj) { 6. Environment* env = stream_env(); 7. int err; 8. 9. size_t total_bytes = 0; 10. // \u8ba1\u7b97\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u5927\u5c0f 11. for (size_t i = 0; i < count; ++i) 12. total_bytes += bufs[i].len; 13. // \u540c\u4e0a 14. bytes_written_ += total_bytes; 15. // \u662f\u5426\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e0d\u9700\u8981\u5219\u76f4\u63a5\u5199 16. if (send_handle == nullptr) { 17. err = DoTryWrite(&bufs, &count); 18. if (err != 0 || count == 0) { 19. return StreamWriteResult { false, err, nullptr, total_bytes }; 20. } 21. } 22. 23. HandleScope handle_scope(env->isolate()); 24. 25. AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); 26. // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u5199\u8bf7\u6c42\u5bf9\u8c61 27. WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj); 28. // \u6267\u884c\u5199\uff0c\u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5199\u64cd\u4f5c\u4e0d\u4e00\u6837 29. err = DoWrite(req_wrap, bufs, count, send_handle); 30. 31. const char* msg = Error(); 32. if (msg != nullptr) { 33. req_wrap_obj->Set(env->context(), 34. env->error_string(), 35. OneByteString(env->isolate(), msg)).Check(); 36. ClearError(); 37. } 38. 39. return StreamWriteResult { async, err, req_wrap, total_bytes }; 40. } 4 \u8bfb 1. // \u64cd\u4f5c\u6d41\uff0c\u542f\u52a8\u8bfb\u53d6 2. int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) { 3. return ReadStart(); 4. } 5. 6. // \u64cd\u4f5c\u6d41\uff0c\u505c\u6b62\u8bfb\u53d6 7. int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) { 8. return ReadStop(); 9. } 10. 11. // \u89e6\u53d1\u6d41\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u53ef\u8bfb 12. MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, 13. Local<ArrayBuffer> ab, 14. size_t offset, 15. StreamBaseJSChecks checks) { 16. Environment* env = env_; 17. env->stream_base_state()[kReadBytesOrError] = nread; 18. env->stream_base_state()[kArrayBufferOffset] = offset; 19. 20. Local<Value> argv[] = { 21. ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>() 22. }; 23. // GetAsyncWrap\u5728StreamBase\u5b50\u7c7b\u5b9e\u73b0\uff0c\u62ff\u5230StreamBase\u7c7b\u5bf9\u8c61 24. AsyncWrap* wrap = GetAsyncWrap(); 25. // \u83b7\u53d6\u56de\u8c03\u6267\u884c 26. Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); 27. return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); 28. } 4 \u6d41\u901a\u7528\u65b9\u6cd5 1. void StreamBase::AddMethod(Environment* env, 2. Local<Signature> signature, 3. enum PropertyAttribute attributes, 4. Local<FunctionTemplate> t, 5. JSMethodFunction* stream_method, 6. Local<String> string) { 7. // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 8. Local<FunctionTemplate> templ = 9. env->NewFunctionTemplate(stream_method, 10. signature, 11. v8::ConstructorBehavior::kThrow, 12. v8::SideEffectType::kHasNoSideEffect); 13. // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 14. t->PrototypeTemplate()->SetAccessorProperty( 15. string, templ, Local<FunctionTemplate>(), attributes); 16. } 17. 18. void StreamBase::AddMethods(Environment* env, Local<FunctionTemplate> t) { 19. HandleScope scope(env->isolate()); 20. 21. enum PropertyAttribute attributes = 22. static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum); 23. Local<Signature> sig = Signature::New(env->isolate(), t); 24. // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 25. AddMethod(env, sig, attributes, t, GetFD, env->fd_string()); 26. // \u5ffd\u7565\u90e8\u5206 27. env->SetProtoMethod(t, \"readStart\", JSMethod<&StreamBase::ReadStartJS>); 28. env->SetProtoMethod(t, \"readStop\", JSMethod<&StreamBase::ReadStopJS>); 29. env->SetProtoMethod(t, \"shutdown\", JSMethod<&StreamBase::Shutdown>); 30. env->SetProtoMethod(t, \"writev\", JSMethod<&StreamBase::Writev>); 31. env->SetProtoMethod(t, \"writeBuffer\", JSMethod<&StreamBase::WriteBuffer>); 32. env->SetProtoMethod( 33. t, \"writeAsciiString\", JSMethod<&StreamBase::WriteString<ASCII>>); 34. env->SetProtoMethod( 35. t, \"writeUtf8String\", JSMethod<&StreamBase::WriteString<UTF8>>); 36. t->PrototypeTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), 37. \"isStreamBase\"), 38. True(env->isolate())); 39. // \u8bbe\u7f6e\u8bbf\u95ee\u5668 40. t->PrototypeTemplate()->SetAccessor( 41. // \u952e\u540d 42. FIXED_ONE_BYTE_STRING(env->isolate(), \"onread\"), 43. // getter 44. BaseObject::InternalFieldGet<kOnReadFunctionField>, 45. // setter\uff0cValue::IsFunction\u662fset\u4e4b\u524d\u7684\u6821\u9a8c\u51fd\u6570\uff0c\u89c1InternalFieldSet\uff08\u6a21\u677f\u51fd\u6570\uff09\u5b9a\u4e49 46. BaseObject::InternalFieldSet<kOnReadFunctionField, &Value::IsFunction>); 47. } 5 \u5176\u5b83\u51fd\u6570 1. // \u9ed8\u8ba4false\uff0c\u5b50\u7c7b\u91cd\u5199 2. bool StreamBase::IsIPCPipe() { 3. return false; 4. } 5. 6. // \u5b50\u7c7b\u91cd\u5199 7. int StreamBase::GetFD() { 8. return -1; 9. } 10. 11. Local<Object> StreamBase::GetObject() { 12. return GetAsyncWrap()->object(); 13. } 14. 15. // \u5de5\u5177\u51fd\u6570\u548c\u5b9e\u4f8bthis\u65e0\u5173\uff0c\u548c\u5165\u53c2\u6709\u5173 16. void StreamBase::GetFD(const FunctionCallbackInfo<Value>& args) { 17. // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD(). 18. // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5b83\u5173\u8054\u7684C++\u5bf9\u8c61\uff0c\u4e0d\u4e00\u5b9a\u662fthis 19. StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); 20. if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL); 21. 22. if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL); 23. 24. args.GetReturnValue().Set(wrap->GetFD()); 25. } 26. 27. void StreamBase::GetBytesRead(const FunctionCallbackInfo<Value>& args) { 28. StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); 29. if (wrap == nullptr) return args.GetReturnValue().Set(0); 30. 31. // uint64_t -> double. 53bits is enough for all real cases. 32. args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_)); 33. }","title":"6.8.2 StreamBase"},{"location":"chapter06-C%2B%2B%E5%B1%82/#683-libuvstreamwrap","text":"LibuvStreamWrap\u662fStreamBase\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86\u7236\u7c7b\u7684\u63a5\u53e3\uff0c\u4e5f\u62d3\u5c55\u4e86\u6d41\u7684\u80fd\u529b\u3002 1. class LibuvStreamWrap : public HandleWrap, public StreamBase { 2. public: 3. static void Initialize(v8::Local<v8::Object> target, 4. v8::Local<v8::Value> unused, 5. v8::Local<v8::Context> context, 6. void* priv); 7. 8. int GetFD() override; 9. bool IsAlive() override; 10. bool IsClosing() override; 11. bool IsIPCPipe() override; 12. 13. // JavaScript functions 14. int ReadStart() override; 15. int ReadStop() override; 16. 17. // Resource implementation 18. int DoShutdown(ShutdownWrap* req_wrap) override; 19. int DoTryWrite(uv_buf_t** bufs, size_t* count) override; 20. int DoWrite(WriteWrap* w, 21. uv_buf_t* bufs, 22. size_t count, 23. uv_stream_t* send_handle) override; 24. 25. inline uv_stream_t* stream() const { 26. return stream_; 27. } 28. // \u662f\u5426\u662fUnix\u57df\u6216\u547d\u540d\u7ba1\u9053 29. inline bool is_named_pipe() const { 30. return stream()->type == UV_NAMED_PIPE; 31. } 32. // \u662f\u5426\u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 33. inline bool is_named_pipe_ipc() const { 34. return is_named_pipe() && 35. reinterpret_cast<const uv_pipe_t*>(stream())->ipc != 0; 36. } 37. 38. inline bool is_tcp() const { 39. return stream()->type == UV_TCP; 40. } 41. // \u521b\u5efa\u8bf7\u6c42Libuv\u7684\u5bf9\u8c61 42. ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override; 43. WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override; 44. // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5bf9\u4e8e\u7684C++\u5bf9\u8c61 45. static LibuvStreamWrap* From(Environment* env, v8::Local<v8::Object> object); 46. 47. protected: 48. LibuvStreamWrap(Environment* env, 49. v8::Local<v8::Object> object, 50. uv_stream_t* stream, 51. AsyncWrap::ProviderType provider); 52. 53. AsyncWrap* GetAsyncWrap() override; 54. 55. static v8::Local<v8::FunctionTemplate> GetConstructorTemplate( 56. Environment* env); 57. 58. private: 59. static void GetWriteQueueSize( 60. const v8::FunctionCallbackInfo<v8::Value>& info); 61. static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args); 62. 63. // Callbacks for libuv 64. void OnUvAlloc(size_t suggested_size, uv_buf_t* buf); 65. void OnUvRead(ssize_t nread, const uv_buf_t* buf); 66. 67. static void AfterUvWrite(uv_write_t* req, int status); 68. static void AfterUvShutdown(uv_shutdown_t* req, int status); 69. 70. uv_stream_t* const stream_; 71. }; 1 \u521d\u59cb\u5316 1. LibuvStreamWrap::LibuvStreamWrap(Environment* env, 2. Local<Object> object, 3. uv_stream_t* stream, 4. AsyncWrap::ProviderType provider) 5. : HandleWrap(env, 6. object, 7. reinterpret_cast<uv_handle_t*>(stream), 8. provider), 9. StreamBase(env), 10. stream_(stream) { 11. StreamBase::AttachToObject(object); 12. } LibuvStreamWrap\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u7684\u5185\u90e8\u6307\u9488\u6307\u5411\u81ea\u5df1\uff0c\u89c1HandleWrap\u3002 2 \u5199\u64cd\u4f5c 1. // \u5de5\u5177\u51fd\u6570\uff0c\u83b7\u53d6\u5f85\u5199\u6570\u636e\u5b57\u8282\u7684\u5927\u5c0f 2. void LibuvStreamWrap::GetWriteQueueSize( 3. const FunctionCallbackInfo<Value>& info) { 4. LibuvStreamWrap* wrap; 5. ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This()); 6. uint32_t write_queue_size = wrap->stream()->write_queue_size; 7. info.GetReturnValue().Set(write_queue_size); 8. } 9. 10. // \u8bbe\u7f6e\u975e\u963b\u585e 11. void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) { 12. LibuvStreamWrap* wrap; 13. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 14. bool enable = args[0]->IsTrue(); 15. args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable)); 16. } 17. // \u5b9a\u4e49\u4e00\u4e2a\u5173\u95ed\u7684\u8bf7\u6c42 18. typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>> LibuvShutdownWrap; 19. // \u5b9a\u4e49\u4e00\u4e2a\u5199\u8bf7\u6c42 20. typedef SimpleWriteWrap<ReqWrap<uv_write_t>> LibuvWriteWrap; 21. 22. ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) { 23. return new LibuvShutdownWrap(this, object); 24. } 25. 26. WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) { 27. return new LibuvWriteWrap(this, object); 28. } 29. 30. // \u53d1\u8d77\u5173\u95ed\u8bf7\u6c42\uff0c\u7531\u7236\u7c7b\u8c03\u7528\uff0creq_wrap\u662fC++\u5c42\u521b\u5efa\u7684\u5bf9\u8c61 31. int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) { 32. LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_); 33. return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown); 34. } 35. 36. // \u5173\u95ed\u8bf7\u6c42\u7ed3\u675f\u540e\u6267\u884c\u8bf7\u6c42\u7684\u901a\u7528\u56de\u8c03Done 37. void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) { 38. LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>( 39. LibuvShutdownWrap::from_req(req)); 40. HandleScope scope(req_wrap->env()->isolate()); 41. Context::Scope context_scope(req_wrap->env()->context()); 42. req_wrap->Done(status); 43. } 44. 45. int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) { 46. int err; 47. size_t written; 48. uv_buf_t* vbufs = *bufs; 49. size_t vcount = *count; 50. 51. err = uv_try_write(stream(), vbufs, vcount); 52. if (err == UV_ENOSYS || err == UV_EAGAIN) 53. return 0; 54. if (err < 0) 55. return err; 56. // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u66f4\u65b0\u6570\u636e 57. written = err; 58. for (; vcount > 0; vbufs++, vcount--) { 59. // Slice 60. if (vbufs[0].len > written) { 61. vbufs[0].base += written; 62. vbufs[0].len -= written; 63. written = 0; 64. break; 65. 66. // Discard 67. } else { 68. written -= vbufs[0].len; 69. } 70. } 71. 72. *bufs = vbufs; 73. *count = vcount; 74. 75. return 0; 76. } 77. 78. 79. int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap, 80. uv_buf_t* bufs, 81. size_t count, 82. uv_stream_t* send_handle) { 83. LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap); 84. return w->Dispatch(uv_write2, 85. stream(), 86. bufs, 87. count, 88. send_handle, 89. AfterUvWrite); 90. } 91. 92. 93. 94. void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) { 95. LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>( 96. LibuvWriteWrap::from_req(req)); 97. HandleScope scope(req_wrap->env()->isolate()); 98. Context::Scope context_scope(req_wrap->env()->context()); 99. req_wrap->Done(status); 100. } 3 \u8bfb\u64cd\u4f5c 1. // \u8c03\u7528Libuv\u5b9e\u73b0\u542f\u52a8\u8bfb\u903b\u8f91 2. int LibuvStreamWrap::ReadStart() { 3. return uv_read_start(stream(), [](uv_handle_t* handle, 4. size_t suggested_size, 5. uv_buf_t* buf) { 6. static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); 7. }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { 8. static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); 9. }); 10. } 11. 12. // \u5b9e\u73b0\u505c\u6b62\u8bfb\u903b\u8f91 13. int LibuvStreamWrap::ReadStop() { 14. return uv_read_stop(stream()); 15. } 16. 17. // \u9700\u8981\u5206\u914d\u5185\u5b58\u65f6\u7684\u56de\u8c03\uff0c\u7531Libuv\u56de\u8c03\uff0c\u5177\u4f53\u5206\u914d\u5185\u5b58\u903b\u8f91\u7531listener\u5b9e\u73b0 18. void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) { 19. HandleScope scope(env()->isolate()); 20. Context::Scope context_scope(env()->context()); 21. 22. *buf = EmitAlloc(suggested_size); 23. } 24. // \u5904\u7406\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 25. template <class WrapType> 26. static MaybeLocal<Object> AcceptHandle(Environment* env, 27. LibuvStreamWrap* parent) { 28. EscapableHandleScope scope(env->isolate()); 29. Local<Object> wrap_obj; 30. // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5176\u4e2d 31. if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj)) 32. return Local<Object>(); 33. // \u89e3\u51faC++\u5c42\u5bf9\u8c61 34. HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj); 35. CHECK_NOT_NULL(wrap); 36. // \u62ff\u5230C++\u5bf9\u8c61\u4e2d\u5c01\u88c5\u7684handle 37. uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); 38. // \u4ece\u670d\u52a1\u5668\u6d41\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230steam 39. if (uv_accept(parent->stream(), stream)) 40. ABORT(); 41. 42. return scope.Escape(wrap_obj); 43. } 44. 45. // \u5b9e\u73b0OnUvRead\uff0c\u6d41\u4e2d\u6709\u6570\u636e\u6216\u8bfb\u5230\u7ed3\u5c3e\u65f6\u7531Libuv\u56de\u8c03 46. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 47. HandleScope scope(env()->isolate()); 48. Context::Scope context_scope(env()->context()); 49. uv_handle_type type = UV_UNKNOWN_HANDLE; 50. // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b 51. if (is_named_pipe_ipc() && 52. uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) { 53. type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream())); 54. } 55. 56. // \u8bfb\u53d6\u6210\u529f 57. if (nread > 0) { 58. MaybeLocal<Object> pending_obj; 59. // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef 60. if (type == UV_TCP) { 61. pending_obj = AcceptHandle<TCPWrap>(env(), this); 62. } else if (type == UV_NAMED_PIPE) { 63. pending_obj = AcceptHandle<PipeWrap>(env(), this); 64. } else if (type == UV_UDP) { 65. pending_obj = AcceptHandle<UDPWrap>(env(), this); 66. } else { 67. CHECK_EQ(type, UV_UNKNOWN_HANDLE); 68. } 69. // \u6709\u9700\u8981\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u8bbe\u7f6e\u5230JS\u5c42\u5bf9\u8c61\u4e2d\uff0cJS\u5c42\u4f7f\u7528 70. if (!pending_obj.IsEmpty()) { 71. object() 72. ->Set(env()->context(), 73. env()->pending_handle_string(), 74. pending_obj.ToLocalChecked()) 75. .Check(); 76. } 77. } 78. // \u89e6\u53d1\u8bfb\u4e8b\u4ef6\uff0clistener\u5b9e\u73b0 79. EmitRead(nread, *buf); 80. } \u8bfb\u64cd\u4f5c\u4e0d\u4ec5\u652f\u6301\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\uff0c\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u4f1a\u65b0\u5efa\u4e00\u4e2a\u6d41\u5bf9\u8c61\u8868\u793a\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728JS\u5c42\u53ef\u4ee5\u4f7f\u7528\u3002","title":"6.8.3 LibuvStreamWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#684-connectionwrap","text":"ConnectionWrap\u662fLibuvStreamWrap\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86\u8fde\u63a5\u7684\u63a5\u53e3\u3002\u9002\u7528\u4e8e\u5e26\u6709\u8fde\u63a5\u5c5e\u6027\u7684\u6d41\uff0c\u6bd4\u5982Unix\u57df\u548cTCP\u3002 1. // WrapType\u662fC++\u5c42\u7684\u7c7b\uff0cUVType\u662fLibuv\u7684\u7c7b\u578b 2. template <typename WrapType, typename UVType> 3. class ConnectionWrap : public LibuvStreamWrap { 4. public: 5. static void OnConnection(uv_stream_t* handle, int status); 6. static void AfterConnect(uv_connect_t* req, int status); 7. 8. protected: 9. ConnectionWrap(Environment* env, 10. v8::Local<v8::Object> object, 11. ProviderType provider); 12. 13. UVType handle_; 14. }; 1 \u53d1\u8d77\u8fde\u63a5\u540e\u7684\u56de\u8c03 1. template <typename WrapType, typename UVType> 2. void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req, 3. int status) { 4. // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 5. std::unique_ptr<ConnectWrap> req_wrap = 6. (static_cast<ConnectWrap*>(req->data)); 7. WrapType* wrap = static_cast<WrapType*>(req->handle->data); 8. Environment* env = wrap->env(); 9. 10. HandleScope handle_scope(env->isolate()); 11. Context::Scope context_scope(env->context()); 12. 13. bool readable, writable; 14. // \u8fde\u63a5\u7ed3\u679c 15. if (status) { 16. readable = writable = false; 17. } else { 18. readable = uv_is_readable(req->handle) != 0; 19. writable = uv_is_writable(req->handle) != 0; 20. } 21. 22. Local<Value> argv[5] = { 23. Integer::New(env->isolate(), status), 24. wrap->object(), 25. req_wrap->object(), 26. Boolean::New(env->isolate(), readable), 27. Boolean::New(env->isolate(), writable) 28. }; 29. // \u56de\u8c03js 30. req_wrap->MakeCallback(env->oncomplete_string(), 31. arraysize(argv), 32. argv); 33. } 2 \u8fde\u63a5\u5230\u6765\u65f6\u56de\u8c03 1. // \u6709\u8fde\u63a5\u65f6\u89e6\u53d1\u7684\u56de\u8c03 2. template <typename WrapType, typename UVType> 3. void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle, 4. int status) { 5. // \u62ff\u5230Libuv\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61 6. WrapType* wrap_data = static_cast<WrapType*>(handle->data); 7. Environment* env = wrap_data->env(); 8. HandleScope handle_scope(env->isolate()); 9. Context::Scope context_scope(env->context()); 10. 11. // \u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61 12. Local<Value> client_handle; 13. 14. if (status == 0) { 15. // Instantiate the client javascript object and handle. 16. // \u65b0\u5efa\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u5bf9\u8c61 17. Local<Object> client_obj; 18. if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET) 19. .ToLocal(&client_obj)) 20. return; 21. 22. // Unwrap the client javascript object. 23. WrapType* wrap; 24. // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61client_obj\u6240\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61\u5b58\u5230wrap\u4e2d 25. ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj); 26. // \u62ff\u5230\u5bf9\u5e94\u7684handle 27. uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_); 28. 29. // \u4ecehandleaccpet\u5230\u7684fd\u4e2d\u62ff\u4e00\u4e2a\u4fdd\u5b58\u5230client\uff0cclient\u5c31\u53ef\u4ee5\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u4e86 30. if (uv_accept(handle, client)) 31. return; 32. client_handle = client_obj; 33. } else { 34. client_handle = Undefined(env->isolate()); 35. } 36. // \u56de\u8c03JS\uff0cclient_handle\u76f8\u5f53\u4e8e\u5728JS\u5c42\u6267\u884cnew TCP 37. Local<Value> argv[] = { 38. Integer::New(env->isolate(), status), 39. client_handle 40. }; 41. wrap_data->MakeCallback(env->onconnection_string(), 42. arraysize(argv), 43. argv); 44. } \u6211\u4eec\u770b\u4e00\u4e0bTCP\u7684Instantiate\u3002 1. MaybeLocal<Object> TCPWrap::Instantiate(Environment* env, 2. AsyncWrap* parent, 3. TCPWrap::SocketType type) { 4. EscapableHandleScope handle_scope(env->isolate()); 5. AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent); 6. 7. // \u62ff\u5230\u5bfc\u51fa\u5230JS\u5c42\u7684TCP\u6784\u9020\u51fd\u6570\uff0c\u7f13\u5b58\u5728env\u4e2d 8. Local<Function> constructor = env->tcp_constructor_template() 9. ->GetFunction(env->context()) 10. .ToLocalChecked(); 11. Local<Value> type_value = Int32::New(env->isolate(), type); 12. // \u76f8\u5f53\u4e8e\u6211\u4eec\u5728JS\u5c42\u8c03\u7528new TCP()\u65f6\u62ff\u5230\u7684\u5bf9\u8c61 13. return handle_scope.EscapeMaybe( 14. constructor->NewInstance(env->context(), 1, &type_value)); 15. }","title":"6.8.4 ConnectionWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#685-streamreq","text":"StreamReq\u8868\u793a\u64cd\u4f5c\u6d41\u7684\u4e00\u6b21\u8bf7\u6c42\u3002\u4e3b\u8981\u4fdd\u5b58\u4e86\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u7684\u901a\u7528\u903b\u8f91\u3002 1. // \u8bf7\u6c42Libuv\u7684\u57fa\u7c7b 2. class StreamReq { 3. public: 4. // JS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61\u7684internalField[1]\u4fdd\u5b58\u4e86StreamReq\u7c7b\u5bf9\u8c61 5. static constexpr int kStreamReqField = 1; 6. // stream\u4e3a\u6240\u64cd\u4f5c\u7684\u6d41\uff0creq_wrap_obj\u4e3aJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 7. explicit StreamReq(StreamBase* stream, 8. v8::Local<v8::Object> req_wrap_obj) : stream_(stream) { 9. // JS\u5c42\u5bf9\u8c61\u6307\u5411\u5f53\u524dStreamReq\u5bf9\u8c61 10. AttachToObject(req_wrap_obj); 11. } 12. // \u5b50\u7c7b\u5b9a\u4e49 13. virtual AsyncWrap* GetAsyncWrap() = 0; 14. // \u83b7\u53d6\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 15. v8::Local<v8::Object> object(); 16. // \u8bf7\u6c42\u7ed3\u675f\u540e\u7684\u56de\u8c03\uff0c\u4f1a\u6267\u884c\u5b50\u7c7b\u7684onDone\uff0conDone\u7531\u5b50\u7c7b\u5b9e\u73b0 17. void Done(int status, const char* error_str = nullptr); 18. // JS\u5c42\u5bf9\u8c61\u4e0d\u518d\u6267\u884cStreamReq\u5b9e\u4f8b 19. void Dispose(); 20. // \u83b7\u53d6\u6240\u64cd\u4f5c\u7684\u6d41 21. inline StreamBase* stream() const { return stream_; } 22. // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6StreamReq\u5bf9\u8c61 23. static StreamReq* FromObject(v8::Local<v8::Object> req_wrap_obj); 24. // \u8bf7\u6c42JS\u5c42\u5bf9\u8c61\u7684internalField\u6240\u6709\u6307\u5411 25. static inline void ResetObject(v8::Local<v8::Object> req_wrap_obj); 26. 27. protected: 28. // \u8bf7\u6c42\u7ed3\u675f\u540e\u56de\u8c03 29. virtual void OnDone(int status) = 0; 30. void AttachToObject(v8::Local<v8::Object> req_wrap_obj); 31. 32. private: 33. StreamBase* const stream_; 34. }; StreamReq\u6709\u4e00\u4e2a\u6210\u5458\u4e3astream_\uff0c\u8868\u793aStreamReq\u8bf7\u6c42\u4e2d\u64cd\u4f5c\u7684\u6d41\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 JS\u5c42\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548cStreamReq\u7684\u5173\u7cfb\u7ba1\u7406\u3002 1. inline void StreamReq::AttachToObject(v8::Local<v8::Object> req_wrap_obj) { 2. req_wrap_obj->SetAlignedPointerInInternalField(kStreamReqField, this); 3. } 4. 5. inline StreamReq* StreamReq::FromObject(v8::Local<v8::Object> req_wrap_obj) { 6. return static_cast<StreamReq*>( 7. req_wrap_obj->GetAlignedPointerFromInternalField(kStreamReqField)); 8. } 9. 10. inline void StreamReq::Dispose() { 11. object()->SetAlignedPointerInInternalField(kStreamReqField, nullptr); 12. delete this; 13. } 14. 15. inline void StreamReq::ResetObject(v8::Local<v8::Object> obj) { 16. obj->SetAlignedPointerInInternalField(0, nullptr); // BaseObject field. 17. obj->SetAlignedPointerInInternalField(StreamReq::kStreamReqField, nullptr); 18. } 2 \u83b7\u53d6\u539f\u59cbJS\u5c42\u8bf7\u6c42\u5bf9\u8c61 1. // \u83b7\u53d6\u548c\u8be5\u8bf7\u6c42\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 2. inline v8::Local<v8::Object> StreamReq::object() { 3. return GetAsyncWrap()->object(); 4. } 3 \u8bf7\u6c42\u7ed3\u675f\u56de\u8c03 1. inline void StreamReq::Done(int status, const char* error_str) { 2. AsyncWrap* async_wrap = GetAsyncWrap(); 3. Environment* env = async_wrap->env(); 4. if (error_str != nullptr) { 5. async_wrap->object()->Set(env->context(), 6. env->error_string(), 7. OneByteString(env->isolate(), 8. error_str)) 9. .Check(); 10. } 11. // \u6267\u884c\u5b50\u7c7b\u7684OnDone 12. OnDone(status); 13. } \u6d41\u64cd\u4f5c\u8bf7\u6c42\u7ed3\u675f\u540e\u4f1a\u7edf\u4e00\u6267\u884cDone\uff0cDone\u4f1a\u6267\u884c\u5b50\u7c7b\u5b9e\u73b0\u7684OnDone\u51fd\u6570\u3002","title":"6.8.5 StreamReq"},{"location":"chapter06-C%2B%2B%E5%B1%82/#686-shutdownwrap","text":"ShutdownWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5173\u95ed\u6d41\u8bf7\u6c42\u3002 1. class ShutdownWrap : public StreamReq { 2. public: 3. ShutdownWrap(StreamBase* stream, 4. v8::Local<v8::Object> req_wrap_obj) 5. : StreamReq(stream, req_wrap_obj) { } 6. 7. void OnDone(int status) override; 8. }; ShutdownWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5173\u95ed\u6d41\u7ed3\u675f\u540e\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1. /* 2. \u5173\u95ed\u7ed3\u675f\u65f6\u56de\u8c03\uff0c\u7531\u8bf7\u6c42\u7c7b\uff08ShutdownWrap\uff09\u8c03\u7528Libuv\uff0c 3. \u6240\u4ee5Libuv\u64cd\u4f5c\u5b8c\u6210\u540e\uff0c\u9996\u5148\u6267\u884c\u8bf7\u6c42\u7c7b\u7684\u56de\u8c03\uff0c\u8bf7\u6c42\u7c7b\u901a\u77e5\u6d41\uff0c\u6d41\u89e6\u53d1 4. \u5bf9\u5e94\u7684\u4e8b\u4ef6\uff0c\u8fdb\u4e00\u6b65\u901a\u77e5listener 5. */ 6. inline void ShutdownWrap::OnDone(int status) { 7. stream()->EmitAfterShutdown(this, status); 8. Dispose(); 9. }","title":"6.8.6 ShutdownWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#687-simpleshutdownwrap","text":"SimpleShutdownWrap\u662fShutdownWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002OtherBase\u53ef\u4ee5\u662fReqWrap\u6216\u8005AsyncWrap\u3002 1. template <typename OtherBase> 2. class SimpleShutdownWrap : public ShutdownWrap, public OtherBase { 3. public: 4. SimpleShutdownWrap(StreamBase* stream, 5. v8::Local<v8::Object> req_wrap_obj); 6. 7. AsyncWrap* GetAsyncWrap() override { return this; } 8. };","title":"6.8.7 SimpleShutdownWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#688-writewrap","text":"WriteWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5f80\u6d41\u5199\u5165\u6570\u636e\u7684\u8bf7\u6c42\u3002 1. class WriteWrap : public StreamReq { 2. public: 3. void SetAllocatedStorage(AllocatedBuffer&& storage); 4. 5. WriteWrap(StreamBase* stream, 6. v8::Local<v8::Object> req_wrap_obj) 7. : StreamReq(stream, req_wrap_obj) { } 8. 9. void OnDone(int status) override; 10. 11. private: 12. AllocatedBuffer storage_; 13. }; WriteWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5199\u7ed3\u675f\u65f6\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1. inline void WriteWrap::OnDone(int status) { 2. stream()->EmitAfterWrite(this, status); 3. Dispose(); 4. } \u8bf7\u6c42\u7ed3\u675f\u540e\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5\u6d41\u5199\u7ed3\u675f\u4e86\uff0c\u6d41\u4f1a\u901a\u77e5listener\uff0clistener\u4f1a\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5JS\u5c42\u3002","title":"6.8.8 WriteWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#689-simplewritewrap","text":"SimpleWriteWrap\u662fWriteWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002\u548cSimpleShutdownWrap\u7c7b\u578b\u3002 1. template <typename OtherBase> 2. class SimpleWriteWrap : public WriteWrap, public OtherBase { 3. public: 4. SimpleWriteWrap(StreamBase* stream, 5. v8::Local<v8::Object> req_wrap_obj); 6. 7. AsyncWrap* GetAsyncWrap() override { return this; } 8. };","title":"6.8.9 SimpleWriteWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#6810-streamlistener","text":"1. class StreamListener { 2. public: 3. virtual ~StreamListener(); 4. // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 5. virtual uv_buf_t OnStreamAlloc(size_t suggested_size) = 0; 6. // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u56de\u8c03\uff0c\u6d88\u8d39\u6570\u636e\u7684\u51fd\u6570 7. virtual void OnStreamRead(ssize_t nread, const uv_buf_t& buf) = 0; 8. // \u6d41\u9500\u6bc1\u65f6\u56de\u8c03 9. virtual void OnStreamDestroy() {} 10. // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 11. inline StreamResource* stream() { return stream_; } 12. 13. protected: 14. // \u6d41\u662f\u76d1\u542c\u8005\u662f\u4e00\u6761\u94fe\u8868\uff0c\u8be5\u51fd\u6570\u628a\u7ed3\u6784\u4f20\u9012\u7ed9\u4e0b\u4e00\u4e2a\u8282\u70b9 15. void PassReadErrorToPreviousListener(ssize_t nread); 16. // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 17. StreamResource* stream_ = nullptr; 18. // \u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u5f62\u6210\u94fe\u8868 19. StreamListener* previous_listener_ = nullptr; 20. friend class StreamResource; 21. }; StreamListener\u662f\u7c7b\u4f3c\u4e00\u4e2a\u8ba2\u9605\u8005\uff0c\u5b83\u4f1a\u5bf9\u6d41\u7684\u72b6\u6001\u611f\u5174\u8da3\uff0c\u6bd4\u5982\u6570\u636e\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u6d41\u5173\u95ed\u7b49\u3002\u4e00\u4e2a\u6d41\u53ef\u4ee5\u6ce8\u518c\u591a\u4e2alistener\uff0c\u591a\u4e2alistener\u5f62\u6210\u4e00\u4e2a\u94fe\u8868\u3002 1. // \u4ecelisten\u6240\u5c5e\u7684\u6d41\u7684listener\u961f\u5217\u4e2d\u5220\u9664\u81ea\u5df1 2. inline StreamListener::~StreamListener() { 3. if (stream_ != nullptr) 4. stream_->RemoveStreamListener(this); 5. } 6. // \u8bfb\u51fa\u9519\uff0c\u628a\u4fe1\u606f\u4f20\u9012\u7ed9\u524d\u4e00\u4e2alistener 7. inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) { 8. CHECK_NOT_NULL(previous_listener_); 9. previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0)); 10. } 11. // \u5b9e\u73b0\u6d41\u5173\u95ed\u65f6\u7684\u5904\u7406\u903b\u8f91 12. inline void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) { 13. previous_listener_->OnStreamAfterShutdown(w, status); 14. } 15. // \u5b9e\u73b0\u5199\u7ed3\u675f\u65f6\u7684\u5904\u7406\u903b\u8f91 16. inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) { 17. previous_listener_->OnStreamAfterWrite(w, status); 18. } StreamListener\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u5177\u4f53\u7684\u5b9e\u73b0\u5728\u5b50\u7c7b\u3002","title":"6.8.10 StreamListener"},{"location":"chapter06-C%2B%2B%E5%B1%82/#6811-reportwritestojsstreamlistener","text":"ReportWritesToJSStreamListener\u662fStreamListener\u7684\u5b50\u7c7b\u3002\u8986\u76d6\u4e86\u90e8\u5206\u63a5\u53e3\u548c\u62d3\u5c55\u4e86\u4e00\u4e9b\u529f\u80fd\u3002 1. class ReportWritesToJSStreamListener : public StreamListener { 2. public: 3. // \u5b9e\u73b0\u7236\u7c7b\u7684\u8fd9\u4e24\u4e2a\u63a5\u53e3 4. void OnStreamAfterWrite(WriteWrap* w, int status) override; 5. void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; 6. 7. private: 8. void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); 9. }; 1 OnStreamAfterReqFinished OnStreamAfterReqFinished\u662f\u8bf7\u6c42\u64cd\u4f5c\u6d41\u7ed3\u675f\u540e\u7684\u7edf\u4e00\u7684\u56de\u8c03\u3002 1. void ReportWritesToJSStreamListener::OnStreamAfterWrite( 2. WriteWrap* req_wrap, int status) { 3. OnStreamAfterReqFinished(req_wrap, status); 4. } 5. 6. void ReportWritesToJSStreamListener::OnStreamAfterShutdown( 7. ShutdownWrap* req_wrap, int status) { 8. OnStreamAfterReqFinished(req_wrap, status); 9. } \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0 1. void ReportWritesToJSStreamListener::OnStreamAfterReqFinished( 2. StreamReq* req_wrap, int status) { 3. // \u8bf7\u6c42\u6240\u64cd\u4f5c\u7684\u6d41 4. StreamBase* stream = static_cast<StreamBase*>(stream_); 5. Environment* env = stream->stream_env(); 6. AsyncWrap* async_wrap = req_wrap->GetAsyncWrap(); 7. HandleScope handle_scope(env->isolate()); 8. Context::Scope context_scope(env->context()); 9. // \u83b7\u53d6\u539f\u59cb\u7684JS\u5c42\u5bf9\u8c61 10. Local<Object> req_wrap_obj = async_wrap->object(); 11. 12. Local<Value> argv[] = { 13. Integer::New(env->isolate(), status), 14. stream->GetObject(), 15. Undefined(env->isolate()) 16. }; 17. 18. const char* msg = stream->Error(); 19. if (msg != nullptr) { 20. argv[2] = OneByteString(env->isolate(), msg); 21. stream->ClearError(); 22. } 23. // \u56de\u8c03JS\u5c42 24. if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust()) 25. async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv); 26. } OnStreamAfterReqFinished\u4f1a\u56de\u8c03JS\u5c42\u3002 6.8.12 EmitToJSStreamListener EmitToJSStreamListener\u662fReportWritesToJSStreamListener\u7684\u5b50\u7c7b 1. class EmitToJSStreamListener : public ReportWritesToJSStreamListener { 2. public: 3. uv_buf_t OnStreamAlloc(size_t suggested_size) override; 4. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; 5. }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1. // \u5206\u914d\u4e00\u5757\u5185\u5b58 2. uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) { 3. Environment* env = static_cast<StreamBase*>(stream_)->stream_env(); 4. return env->AllocateManaged(suggested_size).release(); 5. } 6. // \u8bfb\u53d6\u6570\u636e\u7ed3\u675f\u540e\u56de\u8c03 7. void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { 8. StreamBase* stream = static_cast<StreamBase*>(stream_); 9. Environment* env = stream->stream_env(); 10. HandleScope handle_scope(env->isolate()); 11. Context::Scope context_scope(env->context()); 12. AllocatedBuffer buf(env, buf_); 13. // \u8bfb\u53d6\u5931\u8d25 14. if (nread <= 0) { 15. if (nread < 0) 16. stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>()); 17. return; 18. } 19. 20. buf.Resize(nread); 21. // \u8bfb\u53d6\u6210\u529f\u56de\u8c03JS\u5c42 22. stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); 23. } \u6211\u4eec\u770b\u5230listener\u5904\u7406\u5b8c\u6570\u636e\u540e\u53c8\u4f1a\u56de\u8c03\u6d41\u7684\u63a5\u53e3\uff0c\u5177\u4f53\u7684\u903b\u8f91\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\uff08\u6d41\u9ed8\u8ba4\u7684listener\uff09\u3002 1. class EmitToJSStreamListener : public ReportWritesToJSStreamListener { 2. public: 3. uv_buf_t OnStreamAlloc(size_t suggested_size) override; 4. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; 5. }; EmitToJSStreamListener\u4f1a\u5b9e\u73b0OnStreamRead\u7b49\u65b9\u6cd5\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u521b\u5efa\u4e00\u4e2aC++\u5c42\u7684TCP\u5bf9\u8c61\u662f\u600e\u6837\u7684\u3002\u4e0b\u9762\u662fTCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\u3002 1. class TCPWrap : public ConnectionWrap<TCPWrap, uv_tcp_t>{} 2. // ConnectionWrap\u62d3\u5c55\u4e86\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u7684\u903b\u8f91 3. class ConnectionWrap : public LibuvStreamWrap{} 4. class LibuvStreamWrap : public HandleWrap, public StreamBase{} 5. class StreamBase : public StreamResource {} \u6211\u4eec\u770b\u5230TCP\u6d41\u662f\u7ee7\u627f\u4e8eStreamResource\u7684\u3002\u65b0\u5efa\u4e00\u4e2aTCP\u7684C++\u7684\u5bf9\u8c61\u65f6\uff08tcp_wrap.cc\uff09\uff0c\u4f1a\u4e0d\u65ad\u5f80\u4e0a\u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5176\u4e2d\u5728StreamBase\u4e2d\u6709\u4e00\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\u3002 1. inline StreamBase::StreamBase(Environment* env) : env_(env) { 2. PushStreamListener(&default_listener_); 3. } 4. 5. EmitToJSStreamListener default_listener_; StreamBase\u4f1a\u9ed8\u8ba4\u7ed9\u6d41\u6ce8\u518c\u4e00\u4e2alistener\u3002\u6211\u4eec\u770b\u4e0bEmitToJSStreamListener \u5177\u4f53\u7684\u5b9a\u4e49\u3002 1. class ReportWritesToJSStreamListener : public StreamListener { 2. public: 3. void OnStreamAfterWrite(WriteWrap* w, int status) override; 4. void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; 5. 6. private: 7. void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); 8. }; 9. 10. class EmitToJSStreamListener : public ReportWritesToJSStreamListener { 11. public: 12. uv_buf_t OnStreamAlloc(size_t suggested_size) override; 13. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; 14. }; EmitToJSStreamListener\u7ee7\u627fStreamListener \uff0c\u5b9a\u4e49\u4e86\u5206\u914d\u5185\u5b58\u548c\u8bfb\u53d6\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bPushStreamListener\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1. inline void StreamResource::PushStreamListener(StreamListener* listener) { 2. // \u5934\u63d2\u6cd5 3. listener->previous_listener_ = listener_; 4. listener->stream_ = this; 5. listener_ = listener; 6. } PushStreamListener\u5c31\u662f\u6784\u9020\u51fa\u4e00\u4e2alistener\u94fe\u8868\u7ed3\u6784\u3002\u7136\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u4e8e\u6d41\u6765\u8bf4\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u6574\u4e2a\u94fe\u8def\u3002\u9996\u5148\u662fJS\u5c42\u8c03\u7528readStart 1. function tryReadStart(socket) { 2. socket._handle.reading = true; 3. const err = socket._handle.readStart(); 4. if (err) 5. socket.destroy(errnoException(err, 'read')); 6. } 7. 8. // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 9. Socket.prototype._read = function(n) { 10. tryReadStart(this); 11. }; \u6211\u4eec\u770b\u770breadStart 1. int LibuvStreamWrap::ReadStart() { 2. return uv_read_start(stream(), [](uv_handle_t* handle, 3. size_t suggested_size, 4. uv_buf_t* buf) { 5. static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); 6. }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { 7. static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); 8. }); 9. } ReadStart\u8c03\u7528Libuv\u7684uv_read_start\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u4e14\u6ce8\u518c\u4e86\u4e24\u4e2a\u56de\u8c03\u51fd\u6570OnUvAlloc\u548cOnUvRead\u3002 1. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 2. EmitRead(nread, *buf); 3. } 4. 5. inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { 6. // bytes_read_\u8868\u793a\u5df2\u8bfb\u7684\u5b57\u8282\u6570 7. if (nread > 0) 8. bytes_read_ += static_cast<uint64_t>(nread); 9. listener_->OnStreamRead(nread, buf); 10. } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u6700\u540e\u4f1a\u8c03\u7528listener_\u7684OnStreamRead\u3002\u6211\u4eec\u770b\u770bTCP\u7684OnStreamRead 1. void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { 2. StreamBase* stream = static_cast<StreamBase*>(stream_); 3. Environment* env = stream->stream_env(); 4. HandleScope handle_scope(env->isolate()); 5. Context::Scope context_scope(env->context()); 6. AllocatedBuffer buf(env, buf_); 7. stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); 8. } \u7ee7\u7eed\u56de\u8c03CallJSOnreadMethod 1. MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, 2. Local<ArrayBuffer> ab, 3. size_t offset, 4. StreamBaseJSChecks checks) { 5. Environment* env = env_; 6. // ... 7. AsyncWrap* wrap = GetAsyncWrap(); 8. CHECK_NOT_NULL(wrap); 9. Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); 10. CHECK(onread->IsFunction()); 11. return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); 12. } CallJSOnreadMethod\u4f1a\u56de\u8c03JS\u5c42\u7684onread\u56de\u8c03\u51fd\u6570\u3002onread\u4f1a\u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u89e6\u53d1data\u4e8b\u4ef6\u3002","title":"6.8.11 ReportWritesToJSStreamListener"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/","text":"7.1 \u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5b9e\u73b0\u539f\u7406 \u00b6 \u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u9996\u5148\u4e86\u89e3\u4e00\u4e0b\u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5b9e\u73b0\u539f\u7406\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u5bf9\u5e94\u4e00\u4e2atask_struct\u7ed3\u6784\u4f53\uff08PCB\uff09\uff0cPCB\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8fdb\u7a0b\u6536\u5230\u7684\u4fe1\u53f7\uff08\u6bcf\u4e00\u4e2a\u6bd4\u7279\u4ee3\u8868\u4e00\u79cd\u4fe1\u53f7\uff09\u548c\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u8fd9\u4e2a\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u975e\u5e38\u76f8\u4f3c\uff0c\u6211\u4eec\u770b\u4e00\u4e0bPCB\u4e2d\u4fe1\u53f7\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002 1. struct task_struct { 2. // \u6536\u5230\u7684\u4fe1\u53f7 3. long signal; 4. // \u5904\u7406\u4fe1\u53f7\u8fc7\u7a0b\u4e2d\u5c4f\u853d\u7684\u4fe1\u606f 5. long blocked; 6. // \u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 7. struct sigaction sigaction[32]; 8. ... 9. }; 10. 11. struct sigaction { 12. // \u4fe1\u53f7\u5904\u7406\u51fd\u6570 13. void (*sa_handler)(int); 14. // \u5904\u7406\u4fe1\u53f7\u65f6\u5c4f\u853d\u54ea\u4e9b\u4fe1\u606f\uff0c\u548cPCB\u7684block\u5b57\u6bb5\u5bf9\u5e94 15. sigset_t sa_mask; 16. // \u4e00\u4e9b\u6807\u8bb0\uff0c\u6bd4\u5982\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7c7b\u4f3cevents\u6a21\u5757\u7684once 17. int sa_flags; 18. // \u6e05\u9664\u8c03\u7528\u6808\u4fe1\u606f\uff0cglibc\u4f7f\u7528 19. void (*sa_restorer)(void); 20. }; Linux\u4e0b\u652f\u6301\u591a\u79cd\u4fe1\u53f7\uff0c\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u5904\u7406\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u6ce8\u518c\u5904\u7406\u4fe1\u53f7\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6709\u4e9b\u4fe1\u53f7\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u9000\u51fa\uff0c\u8fd9\u662f\u6211\u4eec\u65e0\u6cd5\u63a7\u5236\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5728Linux\u4e0b\u4fe1\u53f7\u4f7f\u7528\u7684\u4f8b\u5b50\u3002 1. #include <stdio.h> 2. #include <unistd.h> 3. #include <stdlib.h> 4. #include <signal.h> 5. 6. void handler(int); 7. 8. int main() 9. { 10. signal(SIGINT, handler); 11. while(1); 12. return(0); 13. } 14. 15. void sighandler(int signum) 16. { 17. printf(\"\u6536\u5230\u4fe1\u53f7%d\", signum); 18. } \u6211\u4eec\u6ce8\u518c\u4e86\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7136\u540e\u8fdb\u5165while\u5faa\u73af\u4fdd\u8bc1\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u7ed9\u8fd9\u4e2a\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aSIGINT\u4fe1\u53f7\uff08ctrl+c\u6216\u8005kill -2 pid\uff09\u3002\u5219\u8fdb\u7a0b\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u7136\u540e\u8f93\u51fa\uff1a\u6536\u5230\u4fe1\u53f72\u3002\u4e86\u89e3\u4e86\u4fe1\u53f7\u7684\u57fa\u672c\u539f\u7406\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u7684\u8bbe\u8ba1\u548c\u5b9e\u73b0\u3002 7.2 Libuv\u4fe1\u53f7\u5904\u7406\u7684\u8bbe\u8ba1\u601d\u60f3 \u00b6 \u7531\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u73b0\u7684\u9650\u5236\uff0c\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4fe1\u53f7\uff0c\u5982\u679c\u6211\u4eec\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u591a\u6b21\uff0c\u540e\u9762\u7684\u5c31\u4f1a\u8986\u76d6\u524d\u9762\u8bbe\u7f6e\u7684\u503c\u3002\u60f3\u8981\u5b9e\u73b0\u4e00\u4e2a\u4fe1\u53f7\u88ab\u591a\u4e2a\u51fd\u6570\u5904\u7406\uff0c\u6211\u4eec\u53ea\u80fd\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u4e0a\u518d\u5c01\u88c5\u4e00\u5c42\uff0cLibuv\u6b63\u662f\u8fd9\u6837\u505a\u7684\u3002Libuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u5904\u7406\u7684\u5c01\u88c5\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u5f88\u76f8\u4f3c\u3002\u7528\u6237\u8c03\u7528Libuv\u7684\u63a5\u53e3\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0cLibuv\u518d\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7b49\u5f85\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u4f1a\u89e6\u53d1Libuv\u7684\u56de\u8c03\uff0cLibuv\u7684\u56de\u8c03\u4f1a\u901a\u8fc7\u7ba1\u9053\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6536\u5230\u7684\u4fe1\u53f7\u548c\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u6536\u5230\u6240\u6709\u4fe1\u53f7\u4ee5\u53ca\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u6574\u4f53\u67b6\u6784\u5982\u56fe7-1\u6240\u793a \u56fe7-1 \u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5206\u6790Libuv\u4e2d\u4fe1\u53f7\u5904\u7406\u7684\u5b9e\u73b0\u3002 7.3 \u901a\u4fe1\u673a\u5236\u7684\u5b9e\u73b0 \u00b6 \u5f53\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u9700\u8981\u901a\u77e5Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u4ece\u800c\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5b9e\u73b0\u51fd\u6570\u662fuv__signal_loop_once_init\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_loop_once_init\u7684\u903b\u8f91\u3002 1. static int uv__signal_loop_once_init(uv_loop_t* loop) { 2. /* 3. \u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u548c\u4e8b\u4ef6\u5faa\u73af\u901a\u4fe1\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\uff0c 4. \u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u6807\u8bb0 5. */ 6. uv__make_pipe(loop->signal_pipefd, UV__F_NONBLOCK); 7. /* 8. \u8bbe\u7f6e\u4fe1\u53f7IO\u89c2\u5bdf\u8005\u7684\u5904\u7406\u51fd\u6570\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c 9. Libuv\u5728Poll IO\u65f6\uff0c\u53d1\u73b0\u7ba1\u9053\u8bfb\u7aefloop->signal_pipefd[0]\u53ef\u8bfb\uff0c 10. \u5219\u6267\u884cuv__signal_event 11. */ 12. uv__io_init(&loop->signal_io_watcher, 13. uv__signal_event, 14. loop->signal_pipefd[0]); 15. /* 16. \u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb 17. */ 18. uv__io_start(loop, &loop->signal_io_watcher, POLLIN); 19. 20. return 0; 21. } uv__signal_loop_once_init\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\uff0c\u7528\u4e8e\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\u3002\u7136\u540e\u5f80Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u628a\u89c2\u5bdf\u8005\u52a0\u5230epoll\u4e2d\u3002IO\u89c2\u5bdf\u8005\u91cc\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aef\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26loop->signal_pipefd[0]\u548c\u56de\u8c03\u51fd\u6570uv__signal_event\u3002uv__signal_event\u662f\u6536\u5230\u4efb\u610f\u4fe1\u53f7\u65f6\u7684\u56de\u8c03\uff0c\u5b83\u4f1a\u7ee7\u7eed\u6839\u636e\u6536\u5230\u7684\u4fe1\u53f7\u8fdb\u884c\u903b\u8f91\u5206\u53d1\u3002\u6267\u884c\u5b8c\u7684\u67b6\u6784\u5982\u56fe7-2\u6240\u793a\u3002 \u56fe7-2 7.4 \u4fe1\u53f7\u7ed3\u6784\u4f53\u7684\u521d\u59cb\u5316 \u00b6 Libuv\u4e2d\u4fe1\u53f7\u4f7f\u7528uv_signal_t\u8868\u793a\u3002 1. int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) { 2. // \u7533\u8bf7\u548cLibuv\u7684\u901a\u4fe1\u7ba1\u9053\u5e76\u4e14\u6ce8\u518cIO\u89c2\u5bdf\u8005 3. uv__signal_loop_once_init(loop); 4. uv__handle_init(loop, (uv_handle_t*) handle, UV_SIGNAL); 5. handle->signum = 0; 6. handle->caught_signals = 0; 7. handle->dispatched_signals = 0; 8. 9. return 0; 10. } \u4e0a\u9762\u7684\u4ee3\u7801\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316uv_signal_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002 7.5 \u4fe1\u53f7\u5904\u7406\u7684\u6ce8\u518c \u00b6 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_signal_start\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91 1. static int uv__signal_start(uv_signal_t* handle, 2. uv_signal_cb signal_cb, 3. int signum, 4. int oneshot) { 5. sigset_t saved_sigmask; 6. int err; 7. uv_signal_t* first_handle; 8. // \u6ce8\u518c\u8fc7\u4e86\uff0c\u91cd\u65b0\u8bbe\u7f6e\u5904\u7406\u51fd\u6570\u5c31\u884c 9. if (signum == handle->signum) { 10. handle->signal_cb = signal_cb; 11. return 0; 12. } 13. // \u8fd9\u4e2ahandle\u4e4b\u524d\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u5176\u5b83\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u5148\u89e3\u9664 14. if (handle->signum != 0) { 15. uv__signal_stop(handle); 16. } 17. // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 18. uv__signal_block_and_lock(&saved_sigmask); 19. /* 20. \u67e5\u627e\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u7b2c\u4e00\u4e2ahandle\uff0c 21. \u4f18\u5148\u8fd4\u56de\u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT flag\u7684\uff0c 22. \u89c1compare\u51fd\u6570 23. */ 24. first_handle = uv__signal_first_handle(signum); 25. /* 26. 1 \u4e4b\u524d\u6ca1\u6709\u6ce8\u518c\u8fc7\u8be5\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u5219\u76f4\u63a5\u8bbe\u7f6e 27. 2 \u4e4b\u524d\u8bbe\u7f6e\u8fc7\uff0c\u4f46\u662f\u662fone shot\uff0c\u4f46\u662f\u73b0\u5728\u9700\u8981 28. \u8bbe\u7f6e\u7684\u89c4\u5219\u4e0d\u662fone shot\uff0c\u9700\u8981\u4fee\u6539\u3002\u5426\u5219\u7b2c 29. \u4e8c\u6b21\u4e0d\u4f1a\u4e0d\u4f1a\u89e6\u53d1\u3002\u56e0\u4e3a\u4e00\u4e2a\u4fe1\u53f7\u53ea\u80fd\u5bf9\u5e94\u4e00 30. \u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u6240\u4ee5\uff0c\u4ee5\u89c4\u5219\u5bbd\u7684\u4e3a\u51c6\uff0c\u5728\u56de\u8c03 31. \u91cc\u518d\u6839\u636eflags\u5224\u65ad\u662f\u4e0d\u662f\u771f\u7684\u9700\u8981\u6267\u884c 32. 3 \u5982\u679c\u6ce8\u518c\u8fc7\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u76f4\u63a5\u63d2\u5165\u7ea2\u9ed1\u6811\u5c31\u884c\u3002 33. */ 34. if ( 35. first_handle == NULL || 36. (!oneshot && (first_handle->flags & UV_SIGNAL_ONE_SHOT)) 37. ) { 38. // \u6ce8\u518c\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570 39. err = uv__signal_register_handler(signum, oneshot); 40. if (err) { 41. uv__signal_unlock_and_unblock(&saved_sigmask); 42. return err; 43. } 44. } 45. // \u8bb0\u5f55\u611f\u5174\u8da3\u7684\u4fe1\u53f7 46. handle->signum = signum; 47. // \u53ea\u5904\u7406\u8be5\u4fe1\u53f7\u4e00\u6b21 48. if (oneshot) 49. handle->flags |= UV_SIGNAL_ONE_SHOT; 50. // \u63d2\u5165\u7ea2\u9ed1\u6811 51. RB_INSERT(uv__signal_tree_s, &uv__signal_tree, handle); 52. uv__signal_unlock_and_unblock(&saved_sigmask); 53. // \u4fe1\u53f7\u89e6\u53d1\u65f6\u7684\u4e1a\u52a1\u5c42\u56de\u8c03 54. handle->signal_cb = signal_cb; 55. uv__handle_start(handle); 56. 57. return 0; 58. } \u4e0a\u9762\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5927\u81f4\u7684\u903b\u8f91\u5982\u4e0b. 1 \u5224\u65ad\u662f\u5426\u9700\u8981\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u3002\u4e3b\u8981\u662f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6765\u5904\u7406\u7684\uff0c\u4ee3\u7801\u5982\u4e0b 1. // \u7ed9\u5f53\u524d\u8fdb\u7a0b\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u4f1a\u8986\u76d6\u4e4b\u524d\u8bbe\u7f6e\u7684signum\u7684\u5904\u7406\u51fd\u6570 2. static int uv__signal_register_handler(int signum, int oneshot) { 3. struct sigaction sa; 4. 5. memset(&sa, 0, sizeof(sa)); 6. // \u5168\u7f6e\u4e00\uff0c\u8bf4\u660e\u6536\u5230signum\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u6682\u65f6\u5c4f\u853d\u5176\u5b83\u4fe1\u53f7 7. if (sigfillset(&sa.sa_mask)) 8. abort(); 9. // \u6240\u6709\u4fe1\u53f7\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406 10. sa.sa_handler = uv__signal_handler; 11. sa.sa_flags = SA_RESTART; 12. // \u8bbe\u7f6e\u4e86oneshot\uff0c\u8bf4\u660e\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7136\u540e\u88ab\u6062\u590d\u4e3a\u7cfb\u7edf\u7684\u9ed8\u8ba4\u5904\u7406\u51fd\u6570 13. if (oneshot) 14. sa.sa_flags |= SA_RESETHAND; 15. 16. // \u6ce8\u518c 17. if (sigaction(signum, &sa, NULL)) 18. return UV__ERR(errno); 19. 20. return 0; 21. } \u6211\u4eec\u770b\u5230\u6240\u6709\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u90fd\u662fuv__signal_handler\uff0c\u6211\u4eec\u4e00\u4f1a\u4f1a\u5206\u6790uv__signal_handler\u7684\u5b9e\u73b0\u3002 2\u8fdb\u7a0b\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u662f\u5728\u4e00\u68f5\u7ea2\u9ed1\u6811\u7ba1\u7406\u7684\uff0c\u6bcf\u6b21\u6ce8\u518c\u7684\u65f6\u5019\u4f1a\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\u3002Libuv\u7528\u9ed1\u7ea2\u6811\u7ef4\u62a4\u4fe1\u53f7\u7684\u4e0a\u4e0b\u6587\uff0c\u63d2\u5165\u7684\u89c4\u5219\u662f\u6839\u636e\u4fe1\u53f7\u7684\u5927\u5c0f\u548cflags\u7b49\u4fe1\u606f\u3002 RB_INSERT\u5b9e\u73b0\u4e86\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7ea2\u9ed1\u6811\u4e2d\u7684\u8282\u70b9\u662f\u7236\u8282\u70b9\u7684\u503c\u6bd4\u5de6\u5b69\u5b50\u5927\uff0c\u6bd4\u53f3\u5b69\u5b50\u5c0f\u7684\u3002\u6267\u884c\u5b8cRB_INSERT\u540e\u7684\u67b6\u6784\u5982\u56fe7-3\u6240\u793a\u3002 \u56fe7-3 \u6211\u4eec\u770b\u5230\uff0c\u5f53\u6211\u4eec\u6bcf\u6b21\u63d2\u5165\u4e0d\u540c\u7684\u4fe1\u53f7\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u5728\u64cd\u4f5c\u7cfb\u7edf\u548c\u7ea2\u9ed1\u6811\u4e2d\u4fee\u6539\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u5462\uff1f\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u65f6\uff0c\u5982\u679c\u5728\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u8fc7\uff0c\u5e76\u4e14\u5f53\u524d\u63d2\u5165\u7684\u4fe1\u53f7flags\u662fone shot\uff0c\u800c\u4e4b\u524d\u662f\u975eone shot\u65f6\uff0cLibuv\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u53bb\u4fee\u6539\u914d\u7f6e\u3002\u90a3\u4e48\u5bf9\u4e8e\u7ea2\u9ed1\u6811\u6765\u8bf4\uff0c\u63d2\u5165\u91cd\u590d\u4fe1\u53f7\u4f1a\u5982\u4f55\u5904\u7406\u5462\uff1f\u4ece\u521a\u624dRB_INSERT\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u6bcf\u6b21\u63d2\u5165\u7ea2\u9ed1\u6811\u65f6\uff0c\u7ea2\u9ed1\u6811\u4f1a\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u76f8\u540c\u503c\u7684\u8282\u70b9\uff0c\u5982\u679c\u662f\u7684\u8bdd\u76f4\u63a5\u8fd4\u56de\uff0c\u4e0d\u8fdb\u884c\u63d2\u5165\u3002\u8fd9\u4e48\u770b\u8d77\u6765\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u4f46\u5176\u5b9e\u662f\u53ef\u4ee5\u7684\uff0c\u91cd\u70b9\u5728\u6bd4\u8f83\u5927\u5c0f\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. static int uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2) { 2. int f1; 3. int f2; 4. 5. // \u8fd4\u56de\u4fe1\u53f7\u503c\u5927\u7684 6. if (w1->signum < w2->signum) return -1; 7. if (w1->signum > w2->signum) return 1; 8. 9. // \u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT\u7684\u5927 10. f1 = w1->flags & UV_SIGNAL_ONE_SHOT; 11. f2 = w2->flags & UV_SIGNAL_ONE_SHOT; 12. if (f1 < f2) return -1; 13. if (f1 > f2) return 1; 14. 15. // \u5730\u5740\u5927\u7684\u503c\u5c31\u5927 16. if (w1->loop < w2->loop) return -1; 17. if (w1->loop > w2->loop) return 1; 18. 19. if (w1 < w2) return -1; 20. if (w1 > w2) return 1; 21. 22. return 0; 23. } \u6211\u4eec\u770b\u5230Libuv\u6bd4\u8f83\u7684\u4e0d\u4ec5\u662f\u4fe1\u53f7\u7684\u5927\u5c0f\uff0c\u5728\u4fe1\u53f7\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\uff0cLibuv\u8fd8\u4f1a\u6bd4\u8f83\u5176\u5b83\u7684\u56e0\u5b50\uff0c\u9664\u975e\u4e24\u4e2auv_signal_t\u6307\u9488\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2auv_signal_t\u7ed3\u6784\u4f53\uff0c\u5426\u5219\u5b83\u4eec\u662f\u4e0d\u4f1a\u88ab\u8ba4\u4e3a\u91cd\u590d\u7684\uff0c\u6240\u4ee5\u7ea2\u9ed1\u6811\u4e2d\u4f1a\u5b58\u7740\u4fe1\u53f7\u4e00\u6837\u7684\u8282\u70b9\u3002\u5047\u8bbe\u6211\u4eec\u6309\u71671\uff08flags\u4e3aone shot\uff09\uff0c2\uff08flags\u4e3a\u975eone shot\uff09,3\uff08flags\u4e3aone shot\uff09\u7684\u987a\u5e8f\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u5e76\u4e14\u8282\u70b93\u6bd4\u8282\u70b91\u7684\u5730\u5740\u5927\u3002\u6240\u5f62\u6210\u7684\u7ed3\u6784\u5982\u56fe7-4\u6240\u793a\u3002 \u56fe7-4 7.6 \u4fe1\u53f7\u7684\u5904\u7406 \u00b6 \u6211\u4eec\u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u7ba1\u6ce8\u518c\u4ec0\u4e48\u4fe1\u53f7\uff0c\u5b83\u7684\u5904\u7406\u51fd\u6570\u90fd\u662f\u8fd9\u4e2auv__signal_handler\u51fd\u6570\u3002\u6211\u4eec\u81ea\u5df1\u7684\u4e1a\u52a1\u56de\u8c03\u51fd\u6570\uff0c\u662f\u4fdd\u5b58\u5728handle\u91cc\u7684\u3002\u800cLibuv\u7ef4\u62a4\u4e86\u4e00\u68f5\u7ea2\u9ed1\u6811\uff0c\u8bb0\u5f55\u4e86\u6bcf\u4e2ahandle\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u51fd\u6570\uff0c\u90a3\u4e48\u5f53\u4efb\u610f\u4fe1\u53f7\u5230\u6765\u7684\u65f6\u5019\u3002uv__signal_handler\u5c31\u4f1a\u88ab\u8c03\u7528\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_handler\u51fd\u6570\u3002 1. /* 2. \u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0csignum\u4e3a\u6536\u5230\u7684\u4fe1\u53f7\uff0c 3. \u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406\uff0c 4. \u7136\u540e\u901a\u8fc7\u7ba1\u9053\u901a\u77e5Libuv 5. */ 6. static void uv__signal_handler(int signum) { 7. uv__signal_msg_t msg; 8. uv_signal_t* handle; 9. int saved_errno; 10. // \u4fdd\u6301\u4e0a\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\u7684\u9519\u8bef\u7801 11. saved_errno = errno; 12. memset(&msg, 0, sizeof msg); 13. 14. if (uv__signal_lock()) { 15. errno = saved_errno; 16. return; 17. } 18. // \u627e\u5230\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709handle 19. for (handle = uv__signal_first_handle(signum); 20. handle != NULL && handle->signum == signum; 21. handle = RB_NEXT(uv__signal_tree_s, 22. &uv__signal_tree, 23. handle)) 24. { 25. int r; 26. // \u8bb0\u5f55\u4e0a\u4e0b\u6587 27. msg.signum = signum; 28. msg.handle = handle; 29. do { 30. // \u901a\u77e5Libuv\uff0c\u54ea\u4e9bhandle\u9700\u8981\u5904\u7406\u8be5\u4fe1\u53f7\uff0c 31. \u5728Poll IO\u9636\u6bb5\u5904\u7406 32. r = write(handle->loop->signal_pipefd[1], 33. &msg, 34. sizeof msg); 35. } while (r == -1 && errno == EINTR); 36. // \u8be5handle\u6536\u5230\u4fe1\u53f7\u7684\u6b21\u6570 37. if (r != -1) 38. handle->caught_signals++; 39. } 40. 41. uv__signal_unlock(); 42. errno = saved_errno; 43. } uv__signal_handler\u51fd\u6570\u4f1a\u8c03\u7528uv__signal_first_handle\u904d\u5386\u7ea2\u9ed1\u6811\uff0c\u627e\u5230\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u6240\u6709handle\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_first_handle\u7684\u5b9e\u73b0\u3002 1. static uv_signal_t* uv__signal_first_handle(int signum) { 2. uv_signal_t lookup; 3. uv_signal_t* handle; 4. 5. lookup.signum = signum; 6. lookup.flags = 0; 7. lookup.loop = NULL; 8. 9. handle = RB_NFIND(uv__signal_tree_s, 10. &uv__signal_tree, 11. &lookup); 12. 13. if (handle != NULL && handle->signum == signum) 14. return handle; 15. return NULL; 16. } uv__signal_first_handle\u51fd\u6570\u901a\u8fc7RB_NFIND\u5b9e\u73b0\u7ea2\u9ed1\u6811\u7684\u67e5\u627e\uff0cRB_NFIND\u662f\u4e00\u4e2a\u5b8f\u3002 1. #define RB_NFIND(name, x, y) name##_RB_NFIND(x, y) \u6211\u4eec\u770b\u770bname##_RB_NFIND\u5373uv__signal_tree_s_RB_NFIND\u7684\u5b9e\u73b0 1. static struct uv_signal_t * uv__signal_tree_s_RB_NFIND(struct uv__signal_tree_s *head, struct uv_signal_t *elm) 2. { 3. struct uv_signal_t *tmp = RB_ROOT(head); 4. struct uv_signal_t *res = NULL; 5. int comp; 6. while (tmp) { 7. comp = cmp(elm, tmp); 8. /* 9. elm\u5c0f\u4e8e\u5f53\u524d\u8282\u70b9\u5219\u5f80\u5de6\u5b50\u6811\u627e\uff0c\u5927\u4e8e\u5219\u5f80\u53f3\u5b50\u6811\u627e\uff0c 10. \u7b49\u4e8e\u5219\u8fd4\u56de 11. */ 12. if (comp < 0) { 13. // \u8bb0\u5f55\u7236\u8282\u70b9 14. res = tmp; 15. tmp = RB_LEFT(tmp, field); 16. } 17. else if (comp > 0) 18. tmp = RB_RIGHT(tmp, field); 19. else 20. return (tmp); 21. } 22. return (res); 23. } uv__signal_tree_s_RB_NFIND\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u7ea2\u9ed1\u6811\u7684\u7279\u70b9\u8fdb\u884c\u641c\u7d22\uff0c\u8fd9\u91cc\u7684\u91cd\u70b9\u662fcmp\u51fd\u6570\u3002\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7cmp\u7684\u903b\u8f91\u3002\u8fd9\u91cc\u4f1a\u9996\u5148\u67e5\u627e\u6ca1\u6709\u8bbe\u7f6eone shot\u6807\u8bb0\u7684handle\uff08\u56e0\u4e3a\u5b83\u7684\u503c\u5c0f\uff09\uff0c\u7136\u540e\u518d\u67e5\u627e\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u4e00\u65e6\u9047\u5230\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u5219\u8bf4\u660e\u540e\u9762\u88ab\u5339\u914d\u7684handle\u4e5f\u662f\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\u7684\u3002\u6bcf\u6b21\u627e\u5230\u4e00\u4e2ahandle\uff0c\u5c31\u4f1a\u5c01\u88c5\u4e00\u4e2amsg\u5199\u5165\u7ba1\u9053\uff08\u5373\u548cLibuv\u901a\u4fe1\u7684\u7ba1\u9053\uff09\u3002\u4fe1\u53f7\u7684\u5904\u7406\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u5728Libuv\u7684Poll IO\u9636\u6bb5\u624d\u505a\u771f\u6b63\u7684\u5904\u7406\u3002\u6211\u4eec\u77e5\u9053\u5728Poll IO\u9636\u6bb5\u3002epoll\u4f1a\u68c0\u6d4b\u5230\u7ba1\u9053loop->signal_pipefd[0]\u53ef\u8bfb\uff0c\u7136\u540e\u4f1a\u6267\u884cuv__signal_event\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u4ee3\u7801\u3002 1. // \u5982\u679c\u6536\u5230\u4fe1\u53f7,Libuv Poll IO\u9636\u6bb5,\u4f1a\u6267\u884c\u8be5\u51fd\u6570 2. static void uv__signal_event(uv_loop_t* loop, uv__io_t* w, 3. unsigned int events) { 4. uv__signal_msg_t* msg; 5. uv_signal_t* handle; 6. char buf[sizeof(uv__signal_msg_t) * 32]; 7. size_t bytes, end, i; 8. int r; 9. 10. bytes = 0; 11. end = 0; 12. // \u8ba1\u7b97\u51fa\u6570\u636e\u7684\u5927\u5c0f 13. do { 14. // \u8bfb\u51fa\u6240\u6709\u7684uv__signal_msg_t 15. r = read(loop->signal_pipefd[0], 16. buf + bytes, 17. sizeof(buf) - bytes); 18. if (r == -1 && errno == EINTR) 19. continue; 20. if (r == -1 && 21. (errno == EAGAIN || 22. errno == EWOULDBLOCK)) { 23. if (bytes > 0) 24. continue; 25. return; 26. } 27. if (r == -1) 28. abort(); 29. bytes += r; 30. /* 31. \u6839\u636e\u6536\u5230\u7684\u5b57\u8282\u6570\u7b97\u51fa\u6709\u591a\u5c11\u4e2auv__signal_msg_t\u7ed3\u6784\u4f53\uff0c 32. \u4ece\u800c\u7b97\u51fa\u7ed3\u675f\u4f4d\u7f6e 33. */ 34. end=(bytes/sizeof(uv__signal_msg_t))*sizeof(uv__signal_msg_t); 35. // \u5faa\u73af\u5904\u7406\u6bcf\u4e00\u4e2amsg 36. for (i = 0; i < end; i += sizeof(uv__signal_msg_t)) { 37. msg = (uv__signal_msg_t*) (buf + i); 38. // \u53d6\u51fa\u4e0a\u4e0b\u6587 39. handle = msg->handle; 40. // \u6536\u5230\u7684\u4fe1\u53f7\u548chandle\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u4e00\u81f4\uff0c\u6267\u884c\u56de\u8c03 41. if (msg->signum == handle->signum) { 42. handle->signal_cb(handle, handle->signum); 43. } 44. // \u5904\u7406\u4fe1\u53f7\u4e2a\u6570\uff0c\u548c\u6536\u5230\u7684\u4e2a\u6570\u5bf9\u5e94 45. handle->dispatched_signals++; 46. // \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6062\u590d\u7cfb\u7edf\u9ed8\u8ba4\u7684\u5904\u7406\u51fd\u6570 47. if (handle->flags & UV_SIGNAL_ONE_SHOT) 48. uv__signal_stop(handle); 49. /* 50. \u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\uff0c 51. \u89c1uv_close\u6216uv__signal_close 52. */ 53. if ((handle->flags & UV_HANDLE_CLOSING) && 54. (handle->caught_signals==handle->dispatched_signals)) 55. { 56. uv__make_close_pending((uv_handle_t*) handle); 57. } 58. } 59. bytes -= end; 60. if (bytes) { 61. memmove(buf, buf + end, bytes); 62. continue; 63. } 64. } while (end == sizeof buf); 65. } uv__signal_event\u51fd\u6570\u7684\u903b\u8f91\u5982\u4e0b 1 \u8bfb\u51fa\u7ba1\u9053\u91cc\u7684\u6570\u636e\uff0c\u8ba1\u7b97\u51famsg\u7684\u4e2a\u6570\u3002 2 \u904d\u5386\u6536\u5230\u7684\u6570\u636e\uff0c\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2amsg\u3002 3 \u4ecemsg\u4e2d\u53d6\u51fa\u4e0a\u4e0b\u6587\uff08handle\u548c\u4fe1\u53f7\uff09\uff0c\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 4 \u5982\u679chandle\u8bbe\u7f6e\u4e86one shot\u5219\u9700\u8981\u6267\u884cuv__signal_stop\uff08\u6211\u4eec\u63a5\u4e0b\u6765\u5206\u6790\uff09\u3002 5 \u5982\u679chandle\u8bbe\u7f6e\u4e86closing\u6807\u8bb0\uff0c\u5219\u5224\u65ad\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u662f\u5426\u5df2\u7ecf\u5904\u7406\u5b8c\u3002\u5373\u6536\u5230\u7684\u4e2a\u6570\u548c\u5904\u7406\u7684\u4e2a\u6570\u662f\u5426\u4e00\u81f4\u3002\u9700\u8981\u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\u3002 7.7 \u53d6\u6d88/\u5173\u95ed\u4fe1\u53f7\u5904\u7406 \u00b6 \u5f53\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\uff0c\u5728\u6536\u5230\u4fe1\u53f7\u5e76\u4e14\u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0cLibuv\u4f1a\u8c03\u7528uv__signal_stop\u5173\u95ed\u8be5handle\u5e76\u4e14\u4ece\u7ea2\u9ed1\u6811\u4e2d\u79fb\u9664\u8be5handle\u3002\u53e6\u5916\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u5730\u8c03\u7528uv_close\uff08\u4f1a\u8c03\u7528uv__signal_stop\uff09\u5173\u95ed\u6216\u53d6\u6d88\u4fe1\u53f7\u7684\u5904\u7406\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_stop\u7684\u5b9e\u73b0\u3002 1. static void uv__signal_stop(uv_signal_t* handle) { 2. uv_signal_t* removed_handle; 3. sigset_t saved_sigmask; 4. uv_signal_t* first_handle; 5. int rem_oneshot; 6. int first_oneshot; 7. int ret; 8. 9. /* If the watcher wasn't started, this is a no-op. */ 10. // \u6ca1\u6709\u6ce8\u518c\u8fc7\u4fe1\u53f7\uff0c\u5219\u4e0d\u9700\u8981\u5904\u7406 11. if (handle->signum == 0) 12. return; 13. // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 14. uv__signal_block_and_lock(&saved_sigmask); 15. // \u79fb\u51fa\u7ea2\u9ed1\u6811 16. removed_handle = RB_REMOVE(uv__signal_tree_s, &uv__signal_tree, handle); 17. // \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u8fd8\u6709\u5bf9\u5e94\u7684handle 18. first_handle = uv__signal_first_handle(handle->signum); 19. // \u4e3a\u7a7a\u8bf4\u660e\u6ca1\u6709handle\u4f1a\u5904\u7406\u8be5\u4fe1\u53f7\u4e86\uff0c\u89e3\u9664\u8be5\u4fe1\u53f7\u7684\u8bbe\u7f6e 20. if (first_handle == NULL) { 21. uv__signal_unregister_handler(handle->signum); 22. } else { 23. // \u88ab\u5904\u7406\u7684handle\u662f\u5426\u8bbe\u7f6e\u4e86one shot 24. rem_oneshot = handle->flags & UV_SIGNAL_ONE_SHOT; 25. /* 26. \u5269\u4e0b\u7684\u7b2c\u4e00\u4e2ahandle\u662f\u5426\u8bbe\u7f6e\u4e86one shot\uff0c 27. \u5982\u679c\u662f\u5219\u8bf4\u660e\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709\u5269\u4e0b\u7684handle\u90fd\u662fone shot 28. */ 29. first_oneshot = first_handle->flags & UV_SIGNAL_ONE_SHOT; 30. /* 31. \u88ab\u79fb\u9664\u7684handle\u6ca1\u6709\u8bbe\u7f6eoneshot\u4f46\u662f\u5f53\u524d\u7684\u7b2c\u4e00\u4e2ahandle\u8bbe\u7f6e\u4e86 32. one shot\uff0c\u5219\u9700\u8981\u4fee\u6539\u8be5\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u4e3aone shot\uff0c\u9632\u6b62\u6536\u5230\u591a\u6b21\u4fe1 33. \u53f7\uff0c\u6267\u884c\u591a\u6b21\u56de\u8c03 34. */ 35. if (first_oneshot && !rem_oneshot) { 36. ret = uv__signal_register_handler(handle->signum, 1); 37. assert(ret == 0); 38. } 39. } 40. 41. uv__signal_unlock_and_unblock(&saved_sigmask); 42. 43. handle->signum = 0; 44. uv__handle_stop(handle); 45. } 7.8 \u4fe1\u53f7\u5728Node.js\u4e2d\u7684\u4f7f\u7528 \u00b6 \u5206\u6790\u5b8cLibuv\u7684\u5b9e\u73b0\u540e\uff0c\u6211\u4eec\u770b\u770bNode.js\u4e0a\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u4fe1\u53f7\u7684\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u5173\u4e8e\u4fe1\u53f7\u6a21\u5757\u7684\u5b9e\u73b0\u3002 1. static void Initialize(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. Local<FunctionTemplate> constructor = env->NewFunctionTemplate(New); 7. constructor->InstanceTemplate()->SetInternalFieldCount(1); 8. // \u5bfc\u51fa\u7684\u7c7b\u540d 9. Local<String> signalString = 10. FIXED_ONE_BYTE_STRING(env->isolate(), \"Signal\"); 11. constructor->SetClassName(signalString); 12. constructor->Inherit(HandleWrap::GetConstructorTemplate(env)); 13. // \u7ed9Signal\u521b\u5efa\u7684\u5bf9\u8c61\u6ce8\u5165\u4e24\u4e2a\u51fd\u6570 14. env->SetProtoMethod(constructor, \"start\", Start); 15. env->SetProtoMethod(constructor, \"stop\", Stop); 16. 17. target->Set(env->context(), signalString, 18. constructor->GetFunction(env->context()).ToLocalChecked()).Check(); 19. } \u5f53\u6211\u4eec\u5728JS\u4e2dnew Signal\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u4f5c\u4e3a\u5165\u53c2\u6267\u884cNew\u51fd\u6570\u3002 1. static void New(const FunctionCallbackInfo<Value>& args) { 2. CHECK(args.IsConstructCall()); 3. Environment* env = Environment::GetCurrent(args); 4. new SignalWrap(env, args.This()); 5. } \u5f53\u6211\u4eec\u5728JS\u5c42\u64cd\u4f5cSignal\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cC++\u5c42\u5bf9\u5e94\u7684\u65b9\u6cd5\u3002\u4e3b\u8981\u7684\u65b9\u6cd5\u662f\u6ce8\u518c\u548c\u5220\u9664\u4fe1\u53f7\u3002 1. static void Start(const FunctionCallbackInfo<Value>& args) { 2. SignalWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 4. Environment* env = wrap->env(); 5. int signum; 6. if (!args[0]->Int32Value(env->context()).To(&signum)) return; 7. int err = uv_signal_start( 8. &wrap->handle_, 9. // \u4fe1\u53f7\u4ea7\u751f\u65f6\u6267\u884c\u7684\u56de\u8c03 10. [](uv_signal_t* handle, int signum) { 11. SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, 12. handle); 13. Environment* env = wrap->env(); 14. HandleScope handle_scope(env->isolate()); 15. Context::Scope context_scope(env->context()); 16. Local<Value> arg = Integer::New(env->isolate(), 17. signum); 18. // \u89e6\u53d1JS\u5c42onsignal\u51fd\u6570 19. wrap->MakeCallback(env->onsignal_string(), 1, &arg); 20. }, 21. signum); 22. 23. if (err == 0) { 24. CHECK(!wrap->active_); 25. wrap->active_ = true; 26. Mutex::ScopedLock lock(handled_signals_mutex); 27. handled_signals[signum]++; 28. } 29. 30. args.GetReturnValue().Set(err); 31. } 32. 33. static void Stop(const FunctionCallbackInfo<Value>& args) { 34. SignalWrap* wrap; 35. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 36. 37. if (wrap->active_) { 38. wrap->active_ = false; 39. DecreaseSignalHandlerCount(wrap->handle_.signum); 40. } 41. 42. int err = uv_signal_stop(&wrap->handle_); 43. args.GetReturnValue().Set(err); 44. } \u63a5\u7740\u6211\u4eec\u770b\u5728JS\u5c42\u5982\u4f55\u4f7f\u7528\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u5728is_main_thread.js\u4e2d\u6267\u884c\u4e86\u3002 1. process.on('newListener', startListeningIfSignal); 2. process.on('removeListener', stopListeningIfSignal) newListener\u548cremoveListener\u4e8b\u4ef6\u5728\u6ce8\u518c\u548c\u5220\u9664\u4e8b\u4ef6\u7684\u65f6\u5019\u90fd\u4f1a\u88ab\u89e6\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0 1. /* 2. { 3. SIGINT: 2, 4. ... 5. } 6. */ 7. const { signals } = internalBinding('constants').os; 8. 9. let Signal; 10. const signalWraps = new Map(); 11. 12. function isSignal(event) { 13. return typeof event === 'string' && signals[event] !== undefined; 14. } 15. 16. function startListeningIfSignal(type) { 17. if (isSignal(type) && !signalWraps.has(type)) { 18. if (Signal === undefined) 19. Signal = internalBinding('signal_wrap').Signal; 20. const wrap = new Signal(); 21. // \u4e0d\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 22. wrap.unref(); 23. // \u6302\u8f7d\u4fe1\u53f7\u5904\u7406\u51fd\u6570 24. wrap.onsignal = process.emit.bind(process, type, type); 25. // \u901a\u8fc7\u5b57\u7b26\u62ff\u5230\u6570\u5b57 26. const signum = signals[type]; 27. // \u6ce8\u518c\u4fe1\u53f7 28. const err = wrap.start(signum); 29. if (err) { 30. wrap.close(); 31. throw errnoException(err, 'uv_signal_start'); 32. } 33. // \u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\uff0c\u4e0d\u9700\u8981\u5f80\u5e95\u5c42\u518d\u6ce8\u518c\u4e86 34. signalWraps.set(type, wrap); 35. } 36. } startListeningIfSignal\u51fd\u6570\u7684\u903b\u8f91\u5206\u4e3a\u4e00\u4e0b\u51e0\u4e2a 1 \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u6ce8\u518c\u8fc7\u4e86\uff0c\u5982\u679c\u6ce8\u518c\u8fc7\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6ce8\u518c\u3002Libuv\u672c\u8eab\u652f\u6301\u5728\u540c\u4e00\u4e2a\u4fe1\u53f7\u4e0a\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0cNode.js\u7684JS\u5c42\u4e5f\u505a\u4e86\u8fd9\u4e2a\u5904\u7406\u3002 2 \u8c03\u7528unref\uff0c\u4fe1\u53f7\u7684\u6ce8\u518c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 3 \u6302\u8f7d\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\uff0c\u5f53\u4fe1\u53f7\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff08\u4e00\u4e2a\u6216\u591a\u4e2a\uff09\u3002 4 \u5f80\u5e95\u5c42\u6ce8\u518c\u4fe1\u53f7\u5e76\u8bbe\u7f6e\u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\u7684\u6807\u8bb0 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bstopListeningIfSignal\u3002 1. function stopListeningIfSignal(type) { 2. const wrap = signalWraps.get(type); 3. if (wrap !== undefined && process.listenerCount(type) === 0) { 4. wrap.close(); 5. signalWraps.delete(type); 6. } 7. } \u53ea\u6709\u5f53\u4fe1\u53f7\u88ab\u6ce8\u518c\u8fc7\u5e76\u4e14\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0\uff0c\u624d\u505a\u771f\u6b63\u7684\u5220\u9664\u3002","title":"07-\u4fe1\u53f7\u5904\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#71","text":"\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u9996\u5148\u4e86\u89e3\u4e00\u4e0b\u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5b9e\u73b0\u539f\u7406\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u5bf9\u5e94\u4e00\u4e2atask_struct\u7ed3\u6784\u4f53\uff08PCB\uff09\uff0cPCB\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8fdb\u7a0b\u6536\u5230\u7684\u4fe1\u53f7\uff08\u6bcf\u4e00\u4e2a\u6bd4\u7279\u4ee3\u8868\u4e00\u79cd\u4fe1\u53f7\uff09\u548c\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u8fd9\u4e2a\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u975e\u5e38\u76f8\u4f3c\uff0c\u6211\u4eec\u770b\u4e00\u4e0bPCB\u4e2d\u4fe1\u53f7\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002 1. struct task_struct { 2. // \u6536\u5230\u7684\u4fe1\u53f7 3. long signal; 4. // \u5904\u7406\u4fe1\u53f7\u8fc7\u7a0b\u4e2d\u5c4f\u853d\u7684\u4fe1\u606f 5. long blocked; 6. // \u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 7. struct sigaction sigaction[32]; 8. ... 9. }; 10. 11. struct sigaction { 12. // \u4fe1\u53f7\u5904\u7406\u51fd\u6570 13. void (*sa_handler)(int); 14. // \u5904\u7406\u4fe1\u53f7\u65f6\u5c4f\u853d\u54ea\u4e9b\u4fe1\u606f\uff0c\u548cPCB\u7684block\u5b57\u6bb5\u5bf9\u5e94 15. sigset_t sa_mask; 16. // \u4e00\u4e9b\u6807\u8bb0\uff0c\u6bd4\u5982\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7c7b\u4f3cevents\u6a21\u5757\u7684once 17. int sa_flags; 18. // \u6e05\u9664\u8c03\u7528\u6808\u4fe1\u606f\uff0cglibc\u4f7f\u7528 19. void (*sa_restorer)(void); 20. }; Linux\u4e0b\u652f\u6301\u591a\u79cd\u4fe1\u53f7\uff0c\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u5904\u7406\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u6ce8\u518c\u5904\u7406\u4fe1\u53f7\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6709\u4e9b\u4fe1\u53f7\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u9000\u51fa\uff0c\u8fd9\u662f\u6211\u4eec\u65e0\u6cd5\u63a7\u5236\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5728Linux\u4e0b\u4fe1\u53f7\u4f7f\u7528\u7684\u4f8b\u5b50\u3002 1. #include <stdio.h> 2. #include <unistd.h> 3. #include <stdlib.h> 4. #include <signal.h> 5. 6. void handler(int); 7. 8. int main() 9. { 10. signal(SIGINT, handler); 11. while(1); 12. return(0); 13. } 14. 15. void sighandler(int signum) 16. { 17. printf(\"\u6536\u5230\u4fe1\u53f7%d\", signum); 18. } \u6211\u4eec\u6ce8\u518c\u4e86\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7136\u540e\u8fdb\u5165while\u5faa\u73af\u4fdd\u8bc1\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u7ed9\u8fd9\u4e2a\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aSIGINT\u4fe1\u53f7\uff08ctrl+c\u6216\u8005kill -2 pid\uff09\u3002\u5219\u8fdb\u7a0b\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u7136\u540e\u8f93\u51fa\uff1a\u6536\u5230\u4fe1\u53f72\u3002\u4e86\u89e3\u4e86\u4fe1\u53f7\u7684\u57fa\u672c\u539f\u7406\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u7684\u8bbe\u8ba1\u548c\u5b9e\u73b0\u3002","title":"7.1 \u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5b9e\u73b0\u539f\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#72-libuv","text":"\u7531\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u73b0\u7684\u9650\u5236\uff0c\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4fe1\u53f7\uff0c\u5982\u679c\u6211\u4eec\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u591a\u6b21\uff0c\u540e\u9762\u7684\u5c31\u4f1a\u8986\u76d6\u524d\u9762\u8bbe\u7f6e\u7684\u503c\u3002\u60f3\u8981\u5b9e\u73b0\u4e00\u4e2a\u4fe1\u53f7\u88ab\u591a\u4e2a\u51fd\u6570\u5904\u7406\uff0c\u6211\u4eec\u53ea\u80fd\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u4e0a\u518d\u5c01\u88c5\u4e00\u5c42\uff0cLibuv\u6b63\u662f\u8fd9\u6837\u505a\u7684\u3002Libuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u5904\u7406\u7684\u5c01\u88c5\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u5f88\u76f8\u4f3c\u3002\u7528\u6237\u8c03\u7528Libuv\u7684\u63a5\u53e3\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0cLibuv\u518d\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7b49\u5f85\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u4f1a\u89e6\u53d1Libuv\u7684\u56de\u8c03\uff0cLibuv\u7684\u56de\u8c03\u4f1a\u901a\u8fc7\u7ba1\u9053\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6536\u5230\u7684\u4fe1\u53f7\u548c\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u6536\u5230\u6240\u6709\u4fe1\u53f7\u4ee5\u53ca\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u6574\u4f53\u67b6\u6784\u5982\u56fe7-1\u6240\u793a \u56fe7-1 \u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5206\u6790Libuv\u4e2d\u4fe1\u53f7\u5904\u7406\u7684\u5b9e\u73b0\u3002","title":"7.2 Libuv\u4fe1\u53f7\u5904\u7406\u7684\u8bbe\u8ba1\u601d\u60f3"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#73","text":"\u5f53\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u9700\u8981\u901a\u77e5Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u4ece\u800c\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5b9e\u73b0\u51fd\u6570\u662fuv__signal_loop_once_init\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_loop_once_init\u7684\u903b\u8f91\u3002 1. static int uv__signal_loop_once_init(uv_loop_t* loop) { 2. /* 3. \u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u548c\u4e8b\u4ef6\u5faa\u73af\u901a\u4fe1\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\uff0c 4. \u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u6807\u8bb0 5. */ 6. uv__make_pipe(loop->signal_pipefd, UV__F_NONBLOCK); 7. /* 8. \u8bbe\u7f6e\u4fe1\u53f7IO\u89c2\u5bdf\u8005\u7684\u5904\u7406\u51fd\u6570\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c 9. Libuv\u5728Poll IO\u65f6\uff0c\u53d1\u73b0\u7ba1\u9053\u8bfb\u7aefloop->signal_pipefd[0]\u53ef\u8bfb\uff0c 10. \u5219\u6267\u884cuv__signal_event 11. */ 12. uv__io_init(&loop->signal_io_watcher, 13. uv__signal_event, 14. loop->signal_pipefd[0]); 15. /* 16. \u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb 17. */ 18. uv__io_start(loop, &loop->signal_io_watcher, POLLIN); 19. 20. return 0; 21. } uv__signal_loop_once_init\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\uff0c\u7528\u4e8e\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\u3002\u7136\u540e\u5f80Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u628a\u89c2\u5bdf\u8005\u52a0\u5230epoll\u4e2d\u3002IO\u89c2\u5bdf\u8005\u91cc\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aef\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26loop->signal_pipefd[0]\u548c\u56de\u8c03\u51fd\u6570uv__signal_event\u3002uv__signal_event\u662f\u6536\u5230\u4efb\u610f\u4fe1\u53f7\u65f6\u7684\u56de\u8c03\uff0c\u5b83\u4f1a\u7ee7\u7eed\u6839\u636e\u6536\u5230\u7684\u4fe1\u53f7\u8fdb\u884c\u903b\u8f91\u5206\u53d1\u3002\u6267\u884c\u5b8c\u7684\u67b6\u6784\u5982\u56fe7-2\u6240\u793a\u3002 \u56fe7-2","title":"7.3 \u901a\u4fe1\u673a\u5236\u7684\u5b9e\u73b0"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#74","text":"Libuv\u4e2d\u4fe1\u53f7\u4f7f\u7528uv_signal_t\u8868\u793a\u3002 1. int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) { 2. // \u7533\u8bf7\u548cLibuv\u7684\u901a\u4fe1\u7ba1\u9053\u5e76\u4e14\u6ce8\u518cIO\u89c2\u5bdf\u8005 3. uv__signal_loop_once_init(loop); 4. uv__handle_init(loop, (uv_handle_t*) handle, UV_SIGNAL); 5. handle->signum = 0; 6. handle->caught_signals = 0; 7. handle->dispatched_signals = 0; 8. 9. return 0; 10. } \u4e0a\u9762\u7684\u4ee3\u7801\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316uv_signal_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002","title":"7.4 \u4fe1\u53f7\u7ed3\u6784\u4f53\u7684\u521d\u59cb\u5316"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#75","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_signal_start\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91 1. static int uv__signal_start(uv_signal_t* handle, 2. uv_signal_cb signal_cb, 3. int signum, 4. int oneshot) { 5. sigset_t saved_sigmask; 6. int err; 7. uv_signal_t* first_handle; 8. // \u6ce8\u518c\u8fc7\u4e86\uff0c\u91cd\u65b0\u8bbe\u7f6e\u5904\u7406\u51fd\u6570\u5c31\u884c 9. if (signum == handle->signum) { 10. handle->signal_cb = signal_cb; 11. return 0; 12. } 13. // \u8fd9\u4e2ahandle\u4e4b\u524d\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u5176\u5b83\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u5148\u89e3\u9664 14. if (handle->signum != 0) { 15. uv__signal_stop(handle); 16. } 17. // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 18. uv__signal_block_and_lock(&saved_sigmask); 19. /* 20. \u67e5\u627e\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u7b2c\u4e00\u4e2ahandle\uff0c 21. \u4f18\u5148\u8fd4\u56de\u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT flag\u7684\uff0c 22. \u89c1compare\u51fd\u6570 23. */ 24. first_handle = uv__signal_first_handle(signum); 25. /* 26. 1 \u4e4b\u524d\u6ca1\u6709\u6ce8\u518c\u8fc7\u8be5\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u5219\u76f4\u63a5\u8bbe\u7f6e 27. 2 \u4e4b\u524d\u8bbe\u7f6e\u8fc7\uff0c\u4f46\u662f\u662fone shot\uff0c\u4f46\u662f\u73b0\u5728\u9700\u8981 28. \u8bbe\u7f6e\u7684\u89c4\u5219\u4e0d\u662fone shot\uff0c\u9700\u8981\u4fee\u6539\u3002\u5426\u5219\u7b2c 29. \u4e8c\u6b21\u4e0d\u4f1a\u4e0d\u4f1a\u89e6\u53d1\u3002\u56e0\u4e3a\u4e00\u4e2a\u4fe1\u53f7\u53ea\u80fd\u5bf9\u5e94\u4e00 30. \u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u6240\u4ee5\uff0c\u4ee5\u89c4\u5219\u5bbd\u7684\u4e3a\u51c6\uff0c\u5728\u56de\u8c03 31. \u91cc\u518d\u6839\u636eflags\u5224\u65ad\u662f\u4e0d\u662f\u771f\u7684\u9700\u8981\u6267\u884c 32. 3 \u5982\u679c\u6ce8\u518c\u8fc7\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u76f4\u63a5\u63d2\u5165\u7ea2\u9ed1\u6811\u5c31\u884c\u3002 33. */ 34. if ( 35. first_handle == NULL || 36. (!oneshot && (first_handle->flags & UV_SIGNAL_ONE_SHOT)) 37. ) { 38. // \u6ce8\u518c\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570 39. err = uv__signal_register_handler(signum, oneshot); 40. if (err) { 41. uv__signal_unlock_and_unblock(&saved_sigmask); 42. return err; 43. } 44. } 45. // \u8bb0\u5f55\u611f\u5174\u8da3\u7684\u4fe1\u53f7 46. handle->signum = signum; 47. // \u53ea\u5904\u7406\u8be5\u4fe1\u53f7\u4e00\u6b21 48. if (oneshot) 49. handle->flags |= UV_SIGNAL_ONE_SHOT; 50. // \u63d2\u5165\u7ea2\u9ed1\u6811 51. RB_INSERT(uv__signal_tree_s, &uv__signal_tree, handle); 52. uv__signal_unlock_and_unblock(&saved_sigmask); 53. // \u4fe1\u53f7\u89e6\u53d1\u65f6\u7684\u4e1a\u52a1\u5c42\u56de\u8c03 54. handle->signal_cb = signal_cb; 55. uv__handle_start(handle); 56. 57. return 0; 58. } \u4e0a\u9762\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5927\u81f4\u7684\u903b\u8f91\u5982\u4e0b. 1 \u5224\u65ad\u662f\u5426\u9700\u8981\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u3002\u4e3b\u8981\u662f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6765\u5904\u7406\u7684\uff0c\u4ee3\u7801\u5982\u4e0b 1. // \u7ed9\u5f53\u524d\u8fdb\u7a0b\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u4f1a\u8986\u76d6\u4e4b\u524d\u8bbe\u7f6e\u7684signum\u7684\u5904\u7406\u51fd\u6570 2. static int uv__signal_register_handler(int signum, int oneshot) { 3. struct sigaction sa; 4. 5. memset(&sa, 0, sizeof(sa)); 6. // \u5168\u7f6e\u4e00\uff0c\u8bf4\u660e\u6536\u5230signum\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u6682\u65f6\u5c4f\u853d\u5176\u5b83\u4fe1\u53f7 7. if (sigfillset(&sa.sa_mask)) 8. abort(); 9. // \u6240\u6709\u4fe1\u53f7\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406 10. sa.sa_handler = uv__signal_handler; 11. sa.sa_flags = SA_RESTART; 12. // \u8bbe\u7f6e\u4e86oneshot\uff0c\u8bf4\u660e\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7136\u540e\u88ab\u6062\u590d\u4e3a\u7cfb\u7edf\u7684\u9ed8\u8ba4\u5904\u7406\u51fd\u6570 13. if (oneshot) 14. sa.sa_flags |= SA_RESETHAND; 15. 16. // \u6ce8\u518c 17. if (sigaction(signum, &sa, NULL)) 18. return UV__ERR(errno); 19. 20. return 0; 21. } \u6211\u4eec\u770b\u5230\u6240\u6709\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u90fd\u662fuv__signal_handler\uff0c\u6211\u4eec\u4e00\u4f1a\u4f1a\u5206\u6790uv__signal_handler\u7684\u5b9e\u73b0\u3002 2\u8fdb\u7a0b\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u662f\u5728\u4e00\u68f5\u7ea2\u9ed1\u6811\u7ba1\u7406\u7684\uff0c\u6bcf\u6b21\u6ce8\u518c\u7684\u65f6\u5019\u4f1a\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\u3002Libuv\u7528\u9ed1\u7ea2\u6811\u7ef4\u62a4\u4fe1\u53f7\u7684\u4e0a\u4e0b\u6587\uff0c\u63d2\u5165\u7684\u89c4\u5219\u662f\u6839\u636e\u4fe1\u53f7\u7684\u5927\u5c0f\u548cflags\u7b49\u4fe1\u606f\u3002 RB_INSERT\u5b9e\u73b0\u4e86\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7ea2\u9ed1\u6811\u4e2d\u7684\u8282\u70b9\u662f\u7236\u8282\u70b9\u7684\u503c\u6bd4\u5de6\u5b69\u5b50\u5927\uff0c\u6bd4\u53f3\u5b69\u5b50\u5c0f\u7684\u3002\u6267\u884c\u5b8cRB_INSERT\u540e\u7684\u67b6\u6784\u5982\u56fe7-3\u6240\u793a\u3002 \u56fe7-3 \u6211\u4eec\u770b\u5230\uff0c\u5f53\u6211\u4eec\u6bcf\u6b21\u63d2\u5165\u4e0d\u540c\u7684\u4fe1\u53f7\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u5728\u64cd\u4f5c\u7cfb\u7edf\u548c\u7ea2\u9ed1\u6811\u4e2d\u4fee\u6539\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u5462\uff1f\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u65f6\uff0c\u5982\u679c\u5728\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u8fc7\uff0c\u5e76\u4e14\u5f53\u524d\u63d2\u5165\u7684\u4fe1\u53f7flags\u662fone shot\uff0c\u800c\u4e4b\u524d\u662f\u975eone shot\u65f6\uff0cLibuv\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u53bb\u4fee\u6539\u914d\u7f6e\u3002\u90a3\u4e48\u5bf9\u4e8e\u7ea2\u9ed1\u6811\u6765\u8bf4\uff0c\u63d2\u5165\u91cd\u590d\u4fe1\u53f7\u4f1a\u5982\u4f55\u5904\u7406\u5462\uff1f\u4ece\u521a\u624dRB_INSERT\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u6bcf\u6b21\u63d2\u5165\u7ea2\u9ed1\u6811\u65f6\uff0c\u7ea2\u9ed1\u6811\u4f1a\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u76f8\u540c\u503c\u7684\u8282\u70b9\uff0c\u5982\u679c\u662f\u7684\u8bdd\u76f4\u63a5\u8fd4\u56de\uff0c\u4e0d\u8fdb\u884c\u63d2\u5165\u3002\u8fd9\u4e48\u770b\u8d77\u6765\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u4f46\u5176\u5b9e\u662f\u53ef\u4ee5\u7684\uff0c\u91cd\u70b9\u5728\u6bd4\u8f83\u5927\u5c0f\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. static int uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2) { 2. int f1; 3. int f2; 4. 5. // \u8fd4\u56de\u4fe1\u53f7\u503c\u5927\u7684 6. if (w1->signum < w2->signum) return -1; 7. if (w1->signum > w2->signum) return 1; 8. 9. // \u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT\u7684\u5927 10. f1 = w1->flags & UV_SIGNAL_ONE_SHOT; 11. f2 = w2->flags & UV_SIGNAL_ONE_SHOT; 12. if (f1 < f2) return -1; 13. if (f1 > f2) return 1; 14. 15. // \u5730\u5740\u5927\u7684\u503c\u5c31\u5927 16. if (w1->loop < w2->loop) return -1; 17. if (w1->loop > w2->loop) return 1; 18. 19. if (w1 < w2) return -1; 20. if (w1 > w2) return 1; 21. 22. return 0; 23. } \u6211\u4eec\u770b\u5230Libuv\u6bd4\u8f83\u7684\u4e0d\u4ec5\u662f\u4fe1\u53f7\u7684\u5927\u5c0f\uff0c\u5728\u4fe1\u53f7\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\uff0cLibuv\u8fd8\u4f1a\u6bd4\u8f83\u5176\u5b83\u7684\u56e0\u5b50\uff0c\u9664\u975e\u4e24\u4e2auv_signal_t\u6307\u9488\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2auv_signal_t\u7ed3\u6784\u4f53\uff0c\u5426\u5219\u5b83\u4eec\u662f\u4e0d\u4f1a\u88ab\u8ba4\u4e3a\u91cd\u590d\u7684\uff0c\u6240\u4ee5\u7ea2\u9ed1\u6811\u4e2d\u4f1a\u5b58\u7740\u4fe1\u53f7\u4e00\u6837\u7684\u8282\u70b9\u3002\u5047\u8bbe\u6211\u4eec\u6309\u71671\uff08flags\u4e3aone shot\uff09\uff0c2\uff08flags\u4e3a\u975eone shot\uff09,3\uff08flags\u4e3aone shot\uff09\u7684\u987a\u5e8f\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u5e76\u4e14\u8282\u70b93\u6bd4\u8282\u70b91\u7684\u5730\u5740\u5927\u3002\u6240\u5f62\u6210\u7684\u7ed3\u6784\u5982\u56fe7-4\u6240\u793a\u3002 \u56fe7-4","title":"7.5 \u4fe1\u53f7\u5904\u7406\u7684\u6ce8\u518c"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#76","text":"\u6211\u4eec\u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u7ba1\u6ce8\u518c\u4ec0\u4e48\u4fe1\u53f7\uff0c\u5b83\u7684\u5904\u7406\u51fd\u6570\u90fd\u662f\u8fd9\u4e2auv__signal_handler\u51fd\u6570\u3002\u6211\u4eec\u81ea\u5df1\u7684\u4e1a\u52a1\u56de\u8c03\u51fd\u6570\uff0c\u662f\u4fdd\u5b58\u5728handle\u91cc\u7684\u3002\u800cLibuv\u7ef4\u62a4\u4e86\u4e00\u68f5\u7ea2\u9ed1\u6811\uff0c\u8bb0\u5f55\u4e86\u6bcf\u4e2ahandle\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u51fd\u6570\uff0c\u90a3\u4e48\u5f53\u4efb\u610f\u4fe1\u53f7\u5230\u6765\u7684\u65f6\u5019\u3002uv__signal_handler\u5c31\u4f1a\u88ab\u8c03\u7528\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_handler\u51fd\u6570\u3002 1. /* 2. \u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0csignum\u4e3a\u6536\u5230\u7684\u4fe1\u53f7\uff0c 3. \u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406\uff0c 4. \u7136\u540e\u901a\u8fc7\u7ba1\u9053\u901a\u77e5Libuv 5. */ 6. static void uv__signal_handler(int signum) { 7. uv__signal_msg_t msg; 8. uv_signal_t* handle; 9. int saved_errno; 10. // \u4fdd\u6301\u4e0a\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\u7684\u9519\u8bef\u7801 11. saved_errno = errno; 12. memset(&msg, 0, sizeof msg); 13. 14. if (uv__signal_lock()) { 15. errno = saved_errno; 16. return; 17. } 18. // \u627e\u5230\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709handle 19. for (handle = uv__signal_first_handle(signum); 20. handle != NULL && handle->signum == signum; 21. handle = RB_NEXT(uv__signal_tree_s, 22. &uv__signal_tree, 23. handle)) 24. { 25. int r; 26. // \u8bb0\u5f55\u4e0a\u4e0b\u6587 27. msg.signum = signum; 28. msg.handle = handle; 29. do { 30. // \u901a\u77e5Libuv\uff0c\u54ea\u4e9bhandle\u9700\u8981\u5904\u7406\u8be5\u4fe1\u53f7\uff0c 31. \u5728Poll IO\u9636\u6bb5\u5904\u7406 32. r = write(handle->loop->signal_pipefd[1], 33. &msg, 34. sizeof msg); 35. } while (r == -1 && errno == EINTR); 36. // \u8be5handle\u6536\u5230\u4fe1\u53f7\u7684\u6b21\u6570 37. if (r != -1) 38. handle->caught_signals++; 39. } 40. 41. uv__signal_unlock(); 42. errno = saved_errno; 43. } uv__signal_handler\u51fd\u6570\u4f1a\u8c03\u7528uv__signal_first_handle\u904d\u5386\u7ea2\u9ed1\u6811\uff0c\u627e\u5230\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u6240\u6709handle\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_first_handle\u7684\u5b9e\u73b0\u3002 1. static uv_signal_t* uv__signal_first_handle(int signum) { 2. uv_signal_t lookup; 3. uv_signal_t* handle; 4. 5. lookup.signum = signum; 6. lookup.flags = 0; 7. lookup.loop = NULL; 8. 9. handle = RB_NFIND(uv__signal_tree_s, 10. &uv__signal_tree, 11. &lookup); 12. 13. if (handle != NULL && handle->signum == signum) 14. return handle; 15. return NULL; 16. } uv__signal_first_handle\u51fd\u6570\u901a\u8fc7RB_NFIND\u5b9e\u73b0\u7ea2\u9ed1\u6811\u7684\u67e5\u627e\uff0cRB_NFIND\u662f\u4e00\u4e2a\u5b8f\u3002 1. #define RB_NFIND(name, x, y) name##_RB_NFIND(x, y) \u6211\u4eec\u770b\u770bname##_RB_NFIND\u5373uv__signal_tree_s_RB_NFIND\u7684\u5b9e\u73b0 1. static struct uv_signal_t * uv__signal_tree_s_RB_NFIND(struct uv__signal_tree_s *head, struct uv_signal_t *elm) 2. { 3. struct uv_signal_t *tmp = RB_ROOT(head); 4. struct uv_signal_t *res = NULL; 5. int comp; 6. while (tmp) { 7. comp = cmp(elm, tmp); 8. /* 9. elm\u5c0f\u4e8e\u5f53\u524d\u8282\u70b9\u5219\u5f80\u5de6\u5b50\u6811\u627e\uff0c\u5927\u4e8e\u5219\u5f80\u53f3\u5b50\u6811\u627e\uff0c 10. \u7b49\u4e8e\u5219\u8fd4\u56de 11. */ 12. if (comp < 0) { 13. // \u8bb0\u5f55\u7236\u8282\u70b9 14. res = tmp; 15. tmp = RB_LEFT(tmp, field); 16. } 17. else if (comp > 0) 18. tmp = RB_RIGHT(tmp, field); 19. else 20. return (tmp); 21. } 22. return (res); 23. } uv__signal_tree_s_RB_NFIND\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u7ea2\u9ed1\u6811\u7684\u7279\u70b9\u8fdb\u884c\u641c\u7d22\uff0c\u8fd9\u91cc\u7684\u91cd\u70b9\u662fcmp\u51fd\u6570\u3002\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7cmp\u7684\u903b\u8f91\u3002\u8fd9\u91cc\u4f1a\u9996\u5148\u67e5\u627e\u6ca1\u6709\u8bbe\u7f6eone shot\u6807\u8bb0\u7684handle\uff08\u56e0\u4e3a\u5b83\u7684\u503c\u5c0f\uff09\uff0c\u7136\u540e\u518d\u67e5\u627e\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u4e00\u65e6\u9047\u5230\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u5219\u8bf4\u660e\u540e\u9762\u88ab\u5339\u914d\u7684handle\u4e5f\u662f\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\u7684\u3002\u6bcf\u6b21\u627e\u5230\u4e00\u4e2ahandle\uff0c\u5c31\u4f1a\u5c01\u88c5\u4e00\u4e2amsg\u5199\u5165\u7ba1\u9053\uff08\u5373\u548cLibuv\u901a\u4fe1\u7684\u7ba1\u9053\uff09\u3002\u4fe1\u53f7\u7684\u5904\u7406\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u5728Libuv\u7684Poll IO\u9636\u6bb5\u624d\u505a\u771f\u6b63\u7684\u5904\u7406\u3002\u6211\u4eec\u77e5\u9053\u5728Poll IO\u9636\u6bb5\u3002epoll\u4f1a\u68c0\u6d4b\u5230\u7ba1\u9053loop->signal_pipefd[0]\u53ef\u8bfb\uff0c\u7136\u540e\u4f1a\u6267\u884cuv__signal_event\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u4ee3\u7801\u3002 1. // \u5982\u679c\u6536\u5230\u4fe1\u53f7,Libuv Poll IO\u9636\u6bb5,\u4f1a\u6267\u884c\u8be5\u51fd\u6570 2. static void uv__signal_event(uv_loop_t* loop, uv__io_t* w, 3. unsigned int events) { 4. uv__signal_msg_t* msg; 5. uv_signal_t* handle; 6. char buf[sizeof(uv__signal_msg_t) * 32]; 7. size_t bytes, end, i; 8. int r; 9. 10. bytes = 0; 11. end = 0; 12. // \u8ba1\u7b97\u51fa\u6570\u636e\u7684\u5927\u5c0f 13. do { 14. // \u8bfb\u51fa\u6240\u6709\u7684uv__signal_msg_t 15. r = read(loop->signal_pipefd[0], 16. buf + bytes, 17. sizeof(buf) - bytes); 18. if (r == -1 && errno == EINTR) 19. continue; 20. if (r == -1 && 21. (errno == EAGAIN || 22. errno == EWOULDBLOCK)) { 23. if (bytes > 0) 24. continue; 25. return; 26. } 27. if (r == -1) 28. abort(); 29. bytes += r; 30. /* 31. \u6839\u636e\u6536\u5230\u7684\u5b57\u8282\u6570\u7b97\u51fa\u6709\u591a\u5c11\u4e2auv__signal_msg_t\u7ed3\u6784\u4f53\uff0c 32. \u4ece\u800c\u7b97\u51fa\u7ed3\u675f\u4f4d\u7f6e 33. */ 34. end=(bytes/sizeof(uv__signal_msg_t))*sizeof(uv__signal_msg_t); 35. // \u5faa\u73af\u5904\u7406\u6bcf\u4e00\u4e2amsg 36. for (i = 0; i < end; i += sizeof(uv__signal_msg_t)) { 37. msg = (uv__signal_msg_t*) (buf + i); 38. // \u53d6\u51fa\u4e0a\u4e0b\u6587 39. handle = msg->handle; 40. // \u6536\u5230\u7684\u4fe1\u53f7\u548chandle\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u4e00\u81f4\uff0c\u6267\u884c\u56de\u8c03 41. if (msg->signum == handle->signum) { 42. handle->signal_cb(handle, handle->signum); 43. } 44. // \u5904\u7406\u4fe1\u53f7\u4e2a\u6570\uff0c\u548c\u6536\u5230\u7684\u4e2a\u6570\u5bf9\u5e94 45. handle->dispatched_signals++; 46. // \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6062\u590d\u7cfb\u7edf\u9ed8\u8ba4\u7684\u5904\u7406\u51fd\u6570 47. if (handle->flags & UV_SIGNAL_ONE_SHOT) 48. uv__signal_stop(handle); 49. /* 50. \u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\uff0c 51. \u89c1uv_close\u6216uv__signal_close 52. */ 53. if ((handle->flags & UV_HANDLE_CLOSING) && 54. (handle->caught_signals==handle->dispatched_signals)) 55. { 56. uv__make_close_pending((uv_handle_t*) handle); 57. } 58. } 59. bytes -= end; 60. if (bytes) { 61. memmove(buf, buf + end, bytes); 62. continue; 63. } 64. } while (end == sizeof buf); 65. } uv__signal_event\u51fd\u6570\u7684\u903b\u8f91\u5982\u4e0b 1 \u8bfb\u51fa\u7ba1\u9053\u91cc\u7684\u6570\u636e\uff0c\u8ba1\u7b97\u51famsg\u7684\u4e2a\u6570\u3002 2 \u904d\u5386\u6536\u5230\u7684\u6570\u636e\uff0c\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2amsg\u3002 3 \u4ecemsg\u4e2d\u53d6\u51fa\u4e0a\u4e0b\u6587\uff08handle\u548c\u4fe1\u53f7\uff09\uff0c\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 4 \u5982\u679chandle\u8bbe\u7f6e\u4e86one shot\u5219\u9700\u8981\u6267\u884cuv__signal_stop\uff08\u6211\u4eec\u63a5\u4e0b\u6765\u5206\u6790\uff09\u3002 5 \u5982\u679chandle\u8bbe\u7f6e\u4e86closing\u6807\u8bb0\uff0c\u5219\u5224\u65ad\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u662f\u5426\u5df2\u7ecf\u5904\u7406\u5b8c\u3002\u5373\u6536\u5230\u7684\u4e2a\u6570\u548c\u5904\u7406\u7684\u4e2a\u6570\u662f\u5426\u4e00\u81f4\u3002\u9700\u8981\u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\u3002","title":"7.6 \u4fe1\u53f7\u7684\u5904\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#77","text":"\u5f53\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\uff0c\u5728\u6536\u5230\u4fe1\u53f7\u5e76\u4e14\u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0cLibuv\u4f1a\u8c03\u7528uv__signal_stop\u5173\u95ed\u8be5handle\u5e76\u4e14\u4ece\u7ea2\u9ed1\u6811\u4e2d\u79fb\u9664\u8be5handle\u3002\u53e6\u5916\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u5730\u8c03\u7528uv_close\uff08\u4f1a\u8c03\u7528uv__signal_stop\uff09\u5173\u95ed\u6216\u53d6\u6d88\u4fe1\u53f7\u7684\u5904\u7406\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_stop\u7684\u5b9e\u73b0\u3002 1. static void uv__signal_stop(uv_signal_t* handle) { 2. uv_signal_t* removed_handle; 3. sigset_t saved_sigmask; 4. uv_signal_t* first_handle; 5. int rem_oneshot; 6. int first_oneshot; 7. int ret; 8. 9. /* If the watcher wasn't started, this is a no-op. */ 10. // \u6ca1\u6709\u6ce8\u518c\u8fc7\u4fe1\u53f7\uff0c\u5219\u4e0d\u9700\u8981\u5904\u7406 11. if (handle->signum == 0) 12. return; 13. // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 14. uv__signal_block_and_lock(&saved_sigmask); 15. // \u79fb\u51fa\u7ea2\u9ed1\u6811 16. removed_handle = RB_REMOVE(uv__signal_tree_s, &uv__signal_tree, handle); 17. // \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u8fd8\u6709\u5bf9\u5e94\u7684handle 18. first_handle = uv__signal_first_handle(handle->signum); 19. // \u4e3a\u7a7a\u8bf4\u660e\u6ca1\u6709handle\u4f1a\u5904\u7406\u8be5\u4fe1\u53f7\u4e86\uff0c\u89e3\u9664\u8be5\u4fe1\u53f7\u7684\u8bbe\u7f6e 20. if (first_handle == NULL) { 21. uv__signal_unregister_handler(handle->signum); 22. } else { 23. // \u88ab\u5904\u7406\u7684handle\u662f\u5426\u8bbe\u7f6e\u4e86one shot 24. rem_oneshot = handle->flags & UV_SIGNAL_ONE_SHOT; 25. /* 26. \u5269\u4e0b\u7684\u7b2c\u4e00\u4e2ahandle\u662f\u5426\u8bbe\u7f6e\u4e86one shot\uff0c 27. \u5982\u679c\u662f\u5219\u8bf4\u660e\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709\u5269\u4e0b\u7684handle\u90fd\u662fone shot 28. */ 29. first_oneshot = first_handle->flags & UV_SIGNAL_ONE_SHOT; 30. /* 31. \u88ab\u79fb\u9664\u7684handle\u6ca1\u6709\u8bbe\u7f6eoneshot\u4f46\u662f\u5f53\u524d\u7684\u7b2c\u4e00\u4e2ahandle\u8bbe\u7f6e\u4e86 32. one shot\uff0c\u5219\u9700\u8981\u4fee\u6539\u8be5\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u4e3aone shot\uff0c\u9632\u6b62\u6536\u5230\u591a\u6b21\u4fe1 33. \u53f7\uff0c\u6267\u884c\u591a\u6b21\u56de\u8c03 34. */ 35. if (first_oneshot && !rem_oneshot) { 36. ret = uv__signal_register_handler(handle->signum, 1); 37. assert(ret == 0); 38. } 39. } 40. 41. uv__signal_unlock_and_unblock(&saved_sigmask); 42. 43. handle->signum = 0; 44. uv__handle_stop(handle); 45. }","title":"7.7 \u53d6\u6d88/\u5173\u95ed\u4fe1\u53f7\u5904\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#78-nodejs","text":"\u5206\u6790\u5b8cLibuv\u7684\u5b9e\u73b0\u540e\uff0c\u6211\u4eec\u770b\u770bNode.js\u4e0a\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u4fe1\u53f7\u7684\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u5173\u4e8e\u4fe1\u53f7\u6a21\u5757\u7684\u5b9e\u73b0\u3002 1. static void Initialize(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. Local<FunctionTemplate> constructor = env->NewFunctionTemplate(New); 7. constructor->InstanceTemplate()->SetInternalFieldCount(1); 8. // \u5bfc\u51fa\u7684\u7c7b\u540d 9. Local<String> signalString = 10. FIXED_ONE_BYTE_STRING(env->isolate(), \"Signal\"); 11. constructor->SetClassName(signalString); 12. constructor->Inherit(HandleWrap::GetConstructorTemplate(env)); 13. // \u7ed9Signal\u521b\u5efa\u7684\u5bf9\u8c61\u6ce8\u5165\u4e24\u4e2a\u51fd\u6570 14. env->SetProtoMethod(constructor, \"start\", Start); 15. env->SetProtoMethod(constructor, \"stop\", Stop); 16. 17. target->Set(env->context(), signalString, 18. constructor->GetFunction(env->context()).ToLocalChecked()).Check(); 19. } \u5f53\u6211\u4eec\u5728JS\u4e2dnew Signal\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u4f5c\u4e3a\u5165\u53c2\u6267\u884cNew\u51fd\u6570\u3002 1. static void New(const FunctionCallbackInfo<Value>& args) { 2. CHECK(args.IsConstructCall()); 3. Environment* env = Environment::GetCurrent(args); 4. new SignalWrap(env, args.This()); 5. } \u5f53\u6211\u4eec\u5728JS\u5c42\u64cd\u4f5cSignal\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cC++\u5c42\u5bf9\u5e94\u7684\u65b9\u6cd5\u3002\u4e3b\u8981\u7684\u65b9\u6cd5\u662f\u6ce8\u518c\u548c\u5220\u9664\u4fe1\u53f7\u3002 1. static void Start(const FunctionCallbackInfo<Value>& args) { 2. SignalWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 4. Environment* env = wrap->env(); 5. int signum; 6. if (!args[0]->Int32Value(env->context()).To(&signum)) return; 7. int err = uv_signal_start( 8. &wrap->handle_, 9. // \u4fe1\u53f7\u4ea7\u751f\u65f6\u6267\u884c\u7684\u56de\u8c03 10. [](uv_signal_t* handle, int signum) { 11. SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, 12. handle); 13. Environment* env = wrap->env(); 14. HandleScope handle_scope(env->isolate()); 15. Context::Scope context_scope(env->context()); 16. Local<Value> arg = Integer::New(env->isolate(), 17. signum); 18. // \u89e6\u53d1JS\u5c42onsignal\u51fd\u6570 19. wrap->MakeCallback(env->onsignal_string(), 1, &arg); 20. }, 21. signum); 22. 23. if (err == 0) { 24. CHECK(!wrap->active_); 25. wrap->active_ = true; 26. Mutex::ScopedLock lock(handled_signals_mutex); 27. handled_signals[signum]++; 28. } 29. 30. args.GetReturnValue().Set(err); 31. } 32. 33. static void Stop(const FunctionCallbackInfo<Value>& args) { 34. SignalWrap* wrap; 35. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 36. 37. if (wrap->active_) { 38. wrap->active_ = false; 39. DecreaseSignalHandlerCount(wrap->handle_.signum); 40. } 41. 42. int err = uv_signal_stop(&wrap->handle_); 43. args.GetReturnValue().Set(err); 44. } \u63a5\u7740\u6211\u4eec\u770b\u5728JS\u5c42\u5982\u4f55\u4f7f\u7528\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u5728is_main_thread.js\u4e2d\u6267\u884c\u4e86\u3002 1. process.on('newListener', startListeningIfSignal); 2. process.on('removeListener', stopListeningIfSignal) newListener\u548cremoveListener\u4e8b\u4ef6\u5728\u6ce8\u518c\u548c\u5220\u9664\u4e8b\u4ef6\u7684\u65f6\u5019\u90fd\u4f1a\u88ab\u89e6\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0 1. /* 2. { 3. SIGINT: 2, 4. ... 5. } 6. */ 7. const { signals } = internalBinding('constants').os; 8. 9. let Signal; 10. const signalWraps = new Map(); 11. 12. function isSignal(event) { 13. return typeof event === 'string' && signals[event] !== undefined; 14. } 15. 16. function startListeningIfSignal(type) { 17. if (isSignal(type) && !signalWraps.has(type)) { 18. if (Signal === undefined) 19. Signal = internalBinding('signal_wrap').Signal; 20. const wrap = new Signal(); 21. // \u4e0d\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 22. wrap.unref(); 23. // \u6302\u8f7d\u4fe1\u53f7\u5904\u7406\u51fd\u6570 24. wrap.onsignal = process.emit.bind(process, type, type); 25. // \u901a\u8fc7\u5b57\u7b26\u62ff\u5230\u6570\u5b57 26. const signum = signals[type]; 27. // \u6ce8\u518c\u4fe1\u53f7 28. const err = wrap.start(signum); 29. if (err) { 30. wrap.close(); 31. throw errnoException(err, 'uv_signal_start'); 32. } 33. // \u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\uff0c\u4e0d\u9700\u8981\u5f80\u5e95\u5c42\u518d\u6ce8\u518c\u4e86 34. signalWraps.set(type, wrap); 35. } 36. } startListeningIfSignal\u51fd\u6570\u7684\u903b\u8f91\u5206\u4e3a\u4e00\u4e0b\u51e0\u4e2a 1 \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u6ce8\u518c\u8fc7\u4e86\uff0c\u5982\u679c\u6ce8\u518c\u8fc7\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6ce8\u518c\u3002Libuv\u672c\u8eab\u652f\u6301\u5728\u540c\u4e00\u4e2a\u4fe1\u53f7\u4e0a\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0cNode.js\u7684JS\u5c42\u4e5f\u505a\u4e86\u8fd9\u4e2a\u5904\u7406\u3002 2 \u8c03\u7528unref\uff0c\u4fe1\u53f7\u7684\u6ce8\u518c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 3 \u6302\u8f7d\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\uff0c\u5f53\u4fe1\u53f7\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff08\u4e00\u4e2a\u6216\u591a\u4e2a\uff09\u3002 4 \u5f80\u5e95\u5c42\u6ce8\u518c\u4fe1\u53f7\u5e76\u8bbe\u7f6e\u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\u7684\u6807\u8bb0 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bstopListeningIfSignal\u3002 1. function stopListeningIfSignal(type) { 2. const wrap = signalWraps.get(type); 3. if (wrap !== undefined && process.listenerCount(type) === 0) { 4. wrap.close(); 5. signalWraps.delete(type); 6. } 7. } \u53ea\u6709\u5f53\u4fe1\u53f7\u88ab\u6ce8\u518c\u8fc7\u5e76\u4e14\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0\uff0c\u624d\u505a\u771f\u6b63\u7684\u5220\u9664\u3002","title":"7.8 \u4fe1\u53f7\u5728Node.js\u4e2d\u7684\u4f7f\u7528"},{"location":"chapter08-DNS/","text":"Node.js\u7684DNS\u6a21\u5757\u4f7f\u7528\u4e86cares\u5e93\u548cLibuv\u7684\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u3002cares\u662f\u4e00\u4e2a\u5f02\u6b65DNS\u89e3\u6790\u5e93\uff0c\u5b83\u81ea\u5df1\u5b9e\u73b0\u4e86DNS\u534f\u8bae\u7684\u5c01\u5305\u548c\u89e3\u6790\uff0c\u914d\u5408Libuv\u4e8b\u4ef6\u9a71\u52a8\u673a\u5236\uff0c\u5728Node.js\u4e2d\u5b9e\u73b0\u5f02\u6b65\u7684DNS\u89e3\u6790\u3002\u53e6\u5916\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u6216\u8005\u57df\u540d\u67e5\u8be2IP\u662f\u76f4\u63a5\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u963b\u585e\u5f0f\u7684API\uff0c\u6240\u4ee5Node.js\u662f\u901a\u8fc7Libuv\u7684\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u5f02\u6b65\u67e5\u8be2\u3002\u9664\u4e86\u63d0\u4f9b\u76f4\u63a5\u7684DNS\u67e5\u8be2\u5916\uff0cNode.js\u8fd8\u63d0\u4f9b\u4e86\u8bbe\u7f6eDNS\u670d\u52a1\u5668\u3001\u65b0\u5efa\u4e00\u4e2aDNS\u89e3\u6790\u5b9e\u4f8b\uff08Resolver\uff09\u7b49\u529f\u80fd\u3002\u8fd9\u4e9b\u529f\u80fd\u662f\u4f7f\u7528cares\u5b9e\u73b0\u7684\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790DNS\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 8.1 \u901a\u8fc7\u57df\u540d\u627eIP \u00b6 \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u67e5\u8be2\u4e00\u4e2a\u57df\u540d\u5bf9\u4e8e\u7684IP\u7684\u4fe1\u606f 1. dns.lookup('www.a.com', function(err, address, family) { 2. console.log(address); 3. }); DNS\u529f\u80fd\u7684JS\u5c42\u5b9e\u73b0\u5728dns.js\u4e2d 1. const req = new GetAddrInfoReqWrap(); 2. req.callback = callback; 3. req.family = family; 4. req.hostname = hostname; 5. req.oncomplete = all ? onlookupall : onlookup; 6. 7. const err = cares.getaddrinfo( 8. req, toASCII(hostname), family, hints, verbatim 9. ); Node.js\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u53c2\u6570\u540e\uff0c\u8c03\u7528cares_wrap.cc\u7684getaddrinfo\u65b9\u6cd5\uff0c\u5728care_wrap.cc\u7684\u521d\u59cb\u5316\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\uff0c getaddrinfo\u51fd\u6570\u5bf9\u5e94\u7684\u51fd\u6570\u662fGetAddrInfo\u3002 1. void Initialize(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context) { 4. Environment* env = Environment::GetCurrent(context); 5. env->SetMethod(target, \"getaddrinfo\", GetAddrInfo); 6. ... 7. } GetAddrInfo\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1. auto req_wrap = new GetAddrInfoReqWrap(env, req_wrap_obj, args[4]->IsTrue()); 2. 3. struct addrinfo hints; 4. memset(&hints, 0, sizeof(struct addrinfo)); 5. hints.ai_family = family; 6. hints.ai_socktype = SOCK_STREAM; 7. hints.ai_flags = flags; 8. 9. int err = uv_getaddrinfo(env->event_loop(), 10. req_wrap->req(), 11. AfterGetAddrInfo, 12. *hostname, 13. nullptr, 14. &hints); GetAddrInfo\u662f\u5bf9uv_getaddrinfo\u7684\u5c01\u88c5\uff0c\u56de\u8c03\u51fd\u6570\u662fAfterGetAddrInfo 1. int uv_getaddrinfo(uv_loop_t* loop, 2. // \u4e0a\u5c42\u4f20\u8fdb\u6765\u7684req 3. uv_getaddrinfo_t* req, 4. // \u89e3\u6790\u5b8c\u540e\u7684\u4e0a\u5c42\u56de\u8c03 5. uv_getaddrinfo_cb cb, 6. // \u9700\u8981\u89e3\u6790\u7684\u540d\u5b57 7. const char* hostname, 8. /* 9. \u67e5\u8be2\u7684\u8fc7\u6ee4\u6761\u4ef6\uff1a\u670d\u52a1\u540d\u3002\u6bd4\u5982 10. http smtp\u3002\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u7aef\u53e3\u3002 11. \u89c1\u4e0b\u9762\u6ce8\u91ca 12. */ 13. const char* service, 14. // \u5176\u5b83\u67e5\u8be2\u8fc7\u6ee4\u6761\u4ef6 15. const struct addrinfo* hints) { 16. 17. size_t hostname_len; 18. size_t service_len; 19. size_t hints_len; 20. size_t len; 21. char* buf; 22. 23. hostname_len = hostname ? strlen(hostname) + 1 : 0; 24. service_len = service ? strlen(service) + 1 : 0; 25. hints_len = hints ? sizeof(*hints) : 0; 26. buf = uv__malloc(hostname_len + service_len + hints_len); 27. uv__req_init(loop, req, UV_GETADDRINFO); 28. req->loop = loop; 29. // \u8bbe\u7f6e\u8bf7\u6c42\u7684\u56de\u8c03 30. req->cb = cb; 31. req->addrinfo = NULL; 32. req->hints = NULL; 33. req->service = NULL; 34. req->hostname = NULL; 35. req->retcode = 0; 36. len = 0; 37. 38. if (hints) { 39. req->hints = memcpy(buf + len, hints, sizeof(*hints)); 40. len += sizeof(*hints); 41. } 42. 43. if (service) { 44. req->service = memcpy(buf + len, service, service_len); 45. len += service_len; 46. } 47. 48. if (hostname) 49. req->hostname = memcpy(buf + len, hostname, hostname_len); 50. // \u4f20\u4e86cb\u5219\u662f\u5f02\u6b65 51. if (cb) { 52. uv__work_submit(loop, 53. &req->work_req, 54. UV__WORK_SLOW_IO, 55. uv__getaddrinfo_work, 56. uv__getaddrinfo_done); 57. return 0; 58. } else { 59. // \u963b\u585e\u5f0f\u67e5\u8be2\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03 60. uv__getaddrinfo_work(&req->work_req); 61. uv__getaddrinfo_done(&req->work_req, 0); 62. return req->retcode; 63. } 64. } \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u51fd\u6570\u9996\u5148\u662f\u5bf9\u4e00\u4e2arequest\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u7136\u540e\u6839\u636e\u662f\u5426\u4f20\u4e86\u56de\u8c03\uff0c\u51b3\u5b9a\u8d70\u5f02\u6b65\u8fd8\u662f\u540c\u6b65\u7684\u6a21\u5f0f\u3002\u540c\u6b65\u7684\u65b9\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u76f4\u63a5\u963b\u585eLibuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u76f4\u5230\u89e3\u6790\u5b8c\u6210\u3002\u5982\u679c\u662f\u5f02\u6b65\uff0c\u5219\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u6162IO\u7684\u4efb\u52a1\u3002\u5176\u4e2d\u5de5\u4f5c\u51fd\u6570\u662fuv__getaddrinfo_work\u3002\u56de\u8c03\u662fuv__getaddrinfo_done\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1. // \u89e3\u6790\u7684\u5de5\u4f5c\u51fd\u6570 2. static void uv__getaddrinfo_work(struct uv__work* w) { 3. uv_getaddrinfo_t* req; 4. int err; 5. // \u6839\u636e\u7ed3\u6784\u4f53\u7684\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 6. req = container_of(w, uv_getaddrinfo_t, work_req); 7. // \u963b\u585e\u5728\u8fd9 8. err = getaddrinfo(req->hostname, 9. req->service, 10. req->hints, 11. &req->addrinfo); 12. req->retcode = uv__getaddrinfo_translate_error(err); 13. } uv__getaddrinfo_work\u51fd\u6570\u4e3b\u8981\u662f\u8c03\u7528\u4e86\u7cfb\u7edf\u63d0\u4f9b\u7684getaddrinfo\u53bb\u505a\u89e3\u6790\u3002\u8be5\u51fd\u6570\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u963b\u585e\u3002\u7ed3\u679c\u8fd4\u56de\u540e\uff0c\u6267\u884cuv__getaddrinfo_done\u3002 1. static void uv__getaddrinfo_done(struct uv__work* w, int status) { 2. uv_getaddrinfo_t* req; 3. 4. req = container_of(w, uv_getaddrinfo_t, work_req); 5. uv__req_unregister(req->loop, req); 6. // \u91ca\u653e\u521d\u59cb\u5316\u65f6\u7533\u8bf7\u7684\u5185\u5b58 7. if (req->hints) 8. uv__free(req->hints); 9. else if (req->service) 10. uv__free(req->service); 11. else if (req->hostname) 12. uv__free(req->hostname); 13. else 14. assert(0); 15. 16. req->hints = NULL; 17. req->service = NULL; 18. req->hostname = NULL; 19. // \u89e3\u6790\u8bf7\u6c42\u88ab\u7528\u6237\u53d6\u6d88\u4e86 20. if (status == UV_ECANCELED) { 21. assert(req->retcode == 0); 22. req->retcode = UV_EAI_CANCELED; 23. } 24. // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 25. if (req->cb) 26. req->cb(req, req->retcode, req->addrinfo); 27. 28. } uv__getaddrinfo_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002 8.2 cares \u00b6 \u9664\u4e86\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u548c\u57df\u540d\u67e5\u8be2IP\u5916\uff0c\u5176\u4f59\u7684DNS\u529f\u80fd\u90fd\u7531cares\u5b9e\u73b0\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u7684\u57fa\u672c\u7528\u6cd5\u3002 8.2.1 cares\u4f7f\u7528\u548c\u539f\u7406 \u00b6 1. // channel\u662fcares\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 2. ares_channel channel; 3. struct ares_options options; 4. // \u521d\u59cb\u5316channel 5. status = ares_init_options(&channel, &options, optmask); 6. // \u628a argv\u7684\u6570\u636e\u5b58\u5230addr 7. ares_inet_pton(AF_INET, *argv, &addr4); 8. // \u628aaddr\u6570\u636e\u5b58\u5230channel\u5e76\u53d1\u8d77DNS\u67e5\u8be2 9. ares_gethostbyaddr(channel, 10. &addr4, 11. sizeof(addr4), 12. AF_INET, 13. callback,*argv); 14. for (;;) 15. { 16. int res; 17. FD_ZERO(&read_fds); 18. FD_ZERO(&write_fds); 19. // \u628achannel\u5bf9\u5e94\u7684fd\u5b58\u5230read_fd\u548cwrite_fds 20. nfds = ares_fds(channel, &read_fds, &write_fds); 21. if (nfds == 0) 22. break; 23. // \u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 24. tvp = ares_timeout(channel, NULL, &tv); 25. // \u963b\u585e\u5728select\uff0c\u7b49\u5f85DNS\u56de\u5305 26. res = select(nfds, &read_fds, &write_fds, NULL, tvp); 27. if (-1 == res) 28. break; 29. // \u5904\u7406DNS\u76f8\u5e94 30. ares_process(channel, &read_fds, &write_fds); 31. } \u4e0a\u9762\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u578b\uff0c\u9996\u5148\u521d\u59cb\u5316\u4e00\u4e9b\u4fe1\u606f\uff0c\u7136\u540e\u53d1\u8d77\u4e00\u4e2a\u975e\u963b\u585e\u7684\u8bf7\u6c42\uff0c\u63a5\u7740\u963b\u585e\u5728\u591a\u8def\u590d\u7528API\uff0c\u8be5API\u8fd4\u56de\u540e\uff0c\u6267\u884c\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u56de\u8c03\u3002 8.2.2 cares_wrap.cc\u7684\u901a\u7528\u903b\u8f91 \u00b6 \u5728Node.js\u4e2d\uff0cNode.js\u548ccares\u7684\u6574\u4f53\u4ea4\u4e92\u5982\u56fe8-1\u6240\u793a\u3002 \u56fe8-1. \u6211\u4eec\u901a\u8fc7cares_wrap.cc\u5206\u6790\u5176\u4e2d\u7684\u539f\u7406\u3002\u6211\u4eec\u4eceDNS\u6a21\u5757\u63d0\u4f9b\u7684resolveCname\u51fd\u6570\u5f00\u59cb\u3002resolveCname\u51fd\u6570\u7531\u4ee5\u4e0b\u4ee3\u7801\u5bfc\u51fa\uff08dns.js\uff09\u3002 bindDefaultResolver(module.exports, getDefaultResolver()) \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\uff08dns/utils.js\uff09\u3002 1. class Resolver { 2. constructor() { 3. this._handle = new ChannelWrap(); 4. } 5. // ... 6. } 7. 8. let defaultResolver = new Resolver(); 9. 10. function getDefaultResolver() { 11. return defaultResolver; 12. } 13. 14. function resolver(bindingName) { 15. function query(name, /* options, */ callback) { 16. let options; 17. const req = new QueryReqWrap(); 18. req.bindingName = bindingName; 19. req.callback = callback; 20. req.hostname = name; 21. req.oncomplete = onresolve; 22. req.ttl = !!(options && options.ttl); 23. const err = this._handle[bindingName](req, toASCII(name)); 24. if (err) throw dnsException(err, bindingName, name); 25. return req; 26. } 27. ObjectDefineProperty(query, 'name', { value: bindingName }); 28. return query; 29. } 30. // \u7ed9\u539f\u578b\u94fe\u6ce8\u5165\u4e00\u4e2a\u65b0\u7684\u5c5e\u6027\uff0cdefaultResolver\u4e2d\u4e5f\u751f\u6548 31. Resolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname'); getDefaultResolver\u5bfc\u51fa\u7684\u662f\u4e00\u4e2aResolve\u5bf9\u8c61\uff0c\u91cc\u9762\u6709resolveCname\u7b49\u4e00\u7cfb\u5217\u65b9\u6cd5\u3002\u63a5\u7740\u770b\u4e00\u4e0bbindDefaultResolver\uff0c\u6211\u4eec\u4e00\u4f1a\u518d\u770bChannelWrap\u3002 1. const resolverKeys = [ 2. 'resolveCname ', 3. // \u2026 4. ] 5. function bindDefaultResolver(target, source) { 6. resolverKeys.forEach((key) => { 7. target[key] = source[key].bind(defaultResolver); 8. }); 9. } \u770b\u8d77\u6765\u5f88\u7ed5\uff0c\u5176\u5b9e\u5c31\u662f\u628aResolve\u5bf9\u8c61\u7684\u65b9\u6cd5\u5bfc\u51fa\u5230DNS\u6a21\u5757\u3002\u8fd9\u6837\u7528\u6237\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002\u6211\u4eec\u770b\u5230resolveCname\u662f\u7531resolver\u51fd\u6570\u751f\u6210\u7684\uff0cresolver\u51fd\u6570\u5bf9cares\u7cfb\u5217\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\uff0c\u6700\u7ec8\u8c03\u7528\u7684\u662fthis._handle.queryCname\u51fd\u6570\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2ahandle\uff08ChannelWrap\u7c7b\u5bf9\u8c61\uff09\u7684\u5b9e\u73b0\uff08cares_wrap.cc\uff09\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bcares_wrap.cc\u6a21\u5757\u5bfc\u51fa\u7684API\u3002 1. Local<FunctionTemplate> channel_wrap = env->NewFunctionTemplate(ChannelWrap::New); 2. channel_wrap->InstanceTemplate()->SetInternalFieldCount(1); 3. channel_wrap->Inherit(AsyncWrap::GetConstructorTemplate(env)); 4. // Query\u662fC++\u51fd\u6570\u6a21\u677f 5. env->SetProtoMethod(channel_wrap, 6. \"queryCname\", 7. Query<QueryCnameWrap>); 8. // ... 9. Local<String> channelWrapString = FIXED_ONE_BYTE_STRING(env->isolate(), \"ChannelWrap\"); 10. channel_wrap->SetClassName(channelWrapString); 11. target->Set(env->context(), 12. channelWrapString,channel_wrap->GetFunction(context).ToLocalChecked()).Check(); handle\u5bf9\u5e94\u7684\u5c31\u662f\u4ee5\u4e0a\u4ee3\u7801\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew ChannelWrap\u7684\u65f6\u5019\u3002 \u6700\u7ec8\u4f1a\u8c03\u7528C++\u5c42\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u6267\u884cChannelWrap::New\u3002 1. void ChannelWrap::New(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. new ChannelWrap(env, args.This()); 4. } \u6211\u4eec\u770b\u4e00\u4e0b\u7c7bChannelWrap\u7684\u5b9a\u4e49\u3002 1. class ChannelWrap : public AsyncWrap { 2. public: 3. // ... 4. 5. private: 6. // \u8d85\u65f6\u7ba1\u7406 7. uv_timer_t* timer_handle_; 8. // cares\u6570\u636e\u7c7b\u578b 9. ares_channel channel_; 10. // \u6807\u8bb0\u67e5\u8be2\u7ed3\u679c 11. bool query_last_ok_; 12. // \u4f7f\u7528\u7684DNS\u670d\u52a1\u5668 13. bool is_servers_default_; 14. // \u662f\u5426\u5df2\u7ecf\u521d\u59cb\u5316cares\u5e93 15. bool library_inited_; 16. // \u6b63\u5728\u53d1\u8d77\u7684\u67e5\u8be2\u4e2a\u6570 17. int active_query_count_; 18. // \u53d1\u8d77\u67e5\u8be2\u7684\u4efb\u52a1\u961f\u5217 19. node_ares_task_list task_list_; 20. }; \u63a5\u7740\u6211\u4eec\u770b\u770bChannelWrap\u6784\u9020\u51fd\u6570\u7684\u4ee3\u7801\u3002 1. ChannelWrap::ChannelWrap(...) { 2. Setup(); 3. } ChannelWrap\u91cc\u76f4\u63a5\u8c03\u7528\u4e86Setup 1. void ChannelWrap::Setup() { 2. struct ares_options options; 3. memset(&options, 0, sizeof(options)); 4. options.flags = ARES_FLAG_NOCHECKRESP; 5. /* 6. caresd socket\u72b6\u6001\uff08\u8bfb\u5199\uff09\u53d1\u751f\u53d8\u66f4\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\uff0c 7. \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fsock_state_cb_data 8. */ 9. options.sock_state_cb = ares_sockstate_cb; 10. options.sock_state_cb_data = this; 11. 12. // \u8fd8\u6ca1\u521d\u59cb\u5316\u5219\u521d\u59cb\u5316 13. if (!library_inited_) { 14. Mutex::ScopedLock lock(ares_library_mutex); 15. // \u521d\u59cb\u5316cares\u5e93 16. ares_library_init(ARES_LIB_INIT_ALL); 17. } 18. // \u8bbe\u7f6e\u4f7f\u7528cares\u7684\u914d\u7f6e 19. ares_init_options(&channel_, 20. &options, 21. ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB); 22. library_inited_ = true; 23. } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5728\u8fd9\u91cc\u521d\u59cb\u5316cares\u76f8\u5173\u7684\u903b\u8f91\u3002\u5176\u4e2d\u6700\u91cd\u8981\u7684\u5c31\u662f\u8bbe\u7f6e\u4e86cares socket\u72b6\u6001\u53d8\u66f4\u65f6\u6267\u884c\u7684\u56de\u8c03ares_sockstate_cb\uff08\u6bd4\u5982socket\u9700\u8981\u8bfb\u53d6\u6570\u636e\u6216\u8005\u5199\u5165\u6570\u636e\uff09\u3002\u524d\u9762\u7684cares\u4f7f\u7528\u4f8b\u5b50\u4e2d\u8bb2\u5230\u4e86cares\u548c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u7684\u914d\u5408\u4f7f\u7528\uff0c\u90a3\u4e48cares\u548cLibuv\u662f\u5982\u4f55\u914d\u5408\u7684\u5462\uff1fcares\u63d0\u4f9b\u4e86\u4e00\u79cd\u673a\u5236\uff0c\u5c31\u662fsocket\u72b6\u6001\u53d8\u66f4\u65f6\u901a\u77e5\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u3002DNS\u89e3\u6790\u672c\u8d28\u4e0a\u4e5f\u662f\u7f51\u7edcIO\uff0c\u6240\u4ee5\u53d1\u8d77\u4e00\u4e2aDNS\u67e5\u8be2\u4e5f\u5c31\u662f\u5bf9\u5e94\u4e00\u4e2asocket\u3002DNS\u67e5\u8be2\u662f\u7531cares\u53d1\u8d77\u7684\uff0c\u8fd9\u5c31\u610f\u5473\u7740socket\u662f\u5728cares\u4e2d\u7ef4\u62a4\u7684\uff0c\u90a3Libuv\u600e\u4e48\u77e5\u9053\u5462\uff1f\u6b63\u662fcares\u63d0\u4f9b\u7684\u901a\u77e5\u673a\u5236\uff0c\u4f7f\u5f97Libuv\u77e5\u9053\u53d1\u8d77DNS\u67e5\u8be2\u5bf9\u5e94\u7684socket\uff0c\u4ece\u800c\u6ce8\u518c\u5230Libuv\u4e2d\uff0c\u7b49\u5230\u4e8b\u4ef6\u89e6\u53d1\u540e\uff0c\u518d\u901a\u77e5cares\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u53d1\u8d77\u4e00\u4e2acname\u67e5\u8be2\u5f00\u59cb\u5206\u6790\u3002\u9996\u5148\u56de\u987e\u4e00\u4e0bcares_wrap\u6a21\u5757\u5bfc\u51fa\u7684cname\u67e5\u8be2\u51fd\u6570\uff0c env->SetProtoMethod(channel_wrap, \"queryCname\", Query );Query\u662fC++\u6a21\u677f\u51fd\u6570\uff0cQueryCnameWrap\u662fC++\u7c7b 1. template <class Wrap> 2. static void Query(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. ChannelWrap* channel; 5. // Holder\u4e2d\u4fdd\u5b58\u4e86ChannelWrap\u5bf9\u8c61\uff0c\u89e3\u5305\u51fa\u6765 6. ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder()); 7. Local<Object> req_wrap_obj = args[0].As<Object>(); 8. Local<String> string = args[1].As<String>(); 9. /* 10. \u6839\u636e\u53c2\u6570\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8fd9\u91cc\u662fQueryCnameWrap\uff0c 11. \u5e76\u4e14\u4fdd\u5b58\u5bf9\u5e94\u7684ChannelWrap\u5bf9\u8c61\u548c\u64cd\u4f5c\u76f8\u5173\u7684\u5bf9\u8c61 12. */ 13. Wrap* wrap = new Wrap(channel, req_wrap_obj); 14. 15. node::Utf8Value name(env->isolate(), string); 16. // \u53d1\u8d77\u8bf7\u6c42\u6570\u52a0\u4e00 17. channel->ModifyActivityQueryCount(1); 18. // \u8c03\u7528Send\u51fd\u6570\u53d1\u8d77\u67e5\u8be2 19. int err = wrap->Send(*name); 20. if (err) { 21. channel->ModifyActivityQueryCount(-1); 22. delete wrap; 23. } 24. 25. args.GetReturnValue().Set(err); 26. } Query\u53ea\u5b9e\u73b0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u903b\u8f91\uff0c\u7136\u540e\u8c03\u7528Send\u51fd\u6570\uff0c\u5177\u4f53\u7684Send\u51fd\u6570\u903b\u8f91\u7531\u5404\u4e2a\u5177\u4f53\u7684\u7c7b\u5b9e\u73b0\u3002 8.2.3 \u5177\u4f53\u5b9e\u73b0 \u00b6 \u6211\u4eec\u770b\u4e00\u4e0bQueryCnameWrap\u7c7b\u3002 1. class QueryCnameWrap: public QueryWrap { 2. public: 3. QueryCnameWrap(ChannelWrap* channel, 4. Local<Object> req_wrap_obj) 5. : QueryWrap(channel, req_wrap_obj, \"resolveCname\") { 6. } 7. 8. int Send(const char* name) override { 9. AresQuery(name, ns_c_in, ns_t_cname); 10. return 0; 11. } 12. 13. protected: 14. void Parse(unsigned char* buf, int len) override { 15. HandleScope handle_scope(env()->isolate()); 16. Context::Scope context_scope(env()->context()); 17. 18. Local<Array> ret = Array::New(env()->isolate()); 19. int type = ns_t_cname; 20. int status = ParseGeneralReply(env(), buf, len, &type, ret); 21. if (status != ARES_SUCCESS) { 22. ParseError(status); 23. return; 24. } 25. 26. this->CallOnComplete(ret); 27. } 28. }; \u6211\u4eec\u770b\u5230QueryCnameWrap\u7c7b\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u4e3b\u8981\u5b9a\u4e49Send\u548cParse\u7684\u5b9e\u73b0\uff0c\u6700\u7ec8\u8fd8\u662f\u4f1a\u8c03\u7528\u57fa\u7c7b\u5bf9\u5e94\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u7c7bQueryWrap\u4e2dAresQuery\u7684\u5b9e\u73b0\u3002 1. void AresQuery(const char* name, 2. int dnsclass, 3. int type) { 4. ares_query(channel_->cares_channel(), 5. name, 6. dnsclass, 7. type, 8. Callback, 9. static_cast<void*>(this)); 10. } AresQuery\u51fd\u6570\u63d0\u4f9b\u7edf\u4e00\u53d1\u9001\u67e5\u8be2\u64cd\u4f5c\u3002\u67e5\u8be2\u5b8c\u6210\u540e\u6267\u884cCallback\u56de\u8c03\u3002\u63a5\u4e0b\u6765\u5c31\u6d89\u53ca\u5230cares\u548cNode.js\u7684\u5177\u4f53\u4ea4\u4e92\u4e86\u3002Node.js\u628a\u4e00\u4e2a\u4efb\u52a1\u4ea4\u7ed9cares\u540e\uff0ccares\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u63a5\u7740cares\u4f1a\u901a\u8fc7Node.js\u8bbe\u7f6e\u7684\u56de\u8c03ares_sockstate_cb\u901a\u77e5Node.js\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_query\u7684\u5173\u952e\u903b\u8f91\u3002 1. void ares_query(ares_channel channel, const char *name, int dnsclass, 2. int type, ares_callback callback, void *arg) 3. { 4. struct qquery *qquery; 5. unsigned char *qbuf; 6. int qlen, rd, status; 7. 8. qquery = ares_malloc(sizeof(struct qquery)); 9. // \u4fdd\u5b58Node.js\u7684\u56de\u8c03\uff0c\u67e5\u8be2\u5b8c\u6210\u65f6\u56de\u8c03 10. qquery->callback = callback; 11. qquery->arg = arg; 12. ares_send(channel, qbuf, qlen, qcallback, qquery); 13. } 14. 15. static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen) 16. { 17. struct qquery *qquery = (struct qquery *) arg; 18. unsigned int ancount; 19. int rcode; 20. 21. if (status != ARES_SUCCESS) 22. qquery->callback(qquery->arg, status, timeouts, abuf, alen); 23. else 24. { 25. // ... 26. // \u6267\u884cNode.js\u56de\u8c03 27. qquery->callback(qquery->arg, 28. status, 29. timeouts, 30. abuf, 31. alen); 32. } 33. ares_free(qquery); 34. } 35. ares_query\u4fdd\u5b58\u4e86Node.js\u7684\u56de\u8c03\uff0c\u5e76\u4e14\u8bbe\u7f6e\u56de\u8c03qcallback\uff0c\u67e5\u8be2\u6210\u529f\u540e\u4f1a\u56de\u8c03qcallback\uff0cqcallback\u518d\u56de\u8c03Node.js\u3002\u63a5\u7740\u6267\u884cares_send\uff0cares_send\u4f1a\u8c03\u7528ares__send_query\u3002 1. void ares__send_query(ares_channel channel, 2. struct query *query, 3. struct timeval *now) 4. { 5. struct server_state *server = &channel->servers[query->server]; 6. if (server->udp_socket == ARES_SOCKET_BAD) 7. { 8. // \u7533\u8bf7\u4e00\u4e2asocket 9. if (open_udp_socket(channel, server) == -1) 10. { 11. skip_server(channel, query, query->server); 12. next_server(channel, query, now); 13. return; 14. } 15. } 16. // \u53d1\u9001DNS\u67e5\u8be2 17. if (socket_write(channel, server->udp_socket, query->qbuf, query->qlen) == -1) 18. { 19. skip_server(channel, query, query->server); 20. next_server(channel, query, now); 21. return; 22. } 23. } ares__send_query\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\u3002\u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u53ef\u4ee5\u76f4\u63a5\u53d1\u9001\u3002\u6211\u4eec\u770b\u4e00\u4e0bopen_udp_socket\u3002 1. static int open_udp_socket(ares_channel channel, struct server_state *server) 2. { 3. ares_socket_t s; 4. ares_socklen_t salen; 5. union { 6. struct sockaddr_in sa4; 7. struct sockaddr_in6 sa6; 8. } saddr; 9. struct sockaddr *sa; 10. 11. // \u7533\u8bf7\u4e00\u4e2asocket 12. s = open_socket(channel, server->addr.family, SOCK_DGRAM, 0); 13. // \u7ed1\u5b9a\u670d\u52a1\u5668\u5730\u5740 14. connect_socket(channel, s, sa, salen) 15. 16. // \u901a\u77e5Node.js\uff0c1,0\u8868\u793a\u5bf9socket\u7684\u8bfb\u4e8b\u4ef6\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u53d1\u9001\u4e86\u8bf7\u6c42\uff0c\u7b49\u5f85\u54cd\u5e94 17. SOCK_STATE_CALLBACK(channel, s, 1, 0); 18. // \u4fdd\u5b58socket 19. server->udp_socket = s; 20. return 0; 21. } 22. 23. #define SOCK_STATE_CALLBACK(c, s, r, w) \\ 24. do { \\ 25. if ((c)->sock_state_cb) \\ 26. (c)->sock_state_cb((c)->sock_state_cb_data, (s), (r), (w)); \\ 27. } WHILE_FALSE 28. ares__send_query\u51fd\u6570\u505a\u4e86\u4e09\u4ef6\u4e8b 1 \u7533\u8bf7\u4e86socket\uff0c 2 \u901a\u77e5Node.js 3 \u53d1\u9001\u4e86DNS\u67e5\u8be2\u8bf7\u6c42 \u8fd9\u65f6\u5019\u6d41\u7a0b\u8d70\u5230\u4e86Node.js\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u56de\u8c03Node.js\u7684\u65f6\u5019\uff0cNode.js\u600e\u4e48\u5904\u7406\u7684 1. struct node_ares_task : public MemoryRetainer { 2. ChannelWrap* channel; 3. // \u5173\u8054\u7684socket 4. ares_socket_t sock; 5. // IO\u89c2\u5bdf\u8005\u548c\u56de\u8c03 6. uv_poll_t poll_watcher; 7. }; 8. 9. void ares_sockstate_cb(void* data, 10. ares_socket_t sock, 11. int read, 12. int write) { 13. ChannelWrap* channel = static_cast<ChannelWrap*>(data); 14. node_ares_task* task; 15. // \u4efb\u52a1 16. node_ares_task lookup_task; 17. lookup_task.sock = sock; 18. // \u8be5\u4efb\u52a1\u662f\u5426\u5df2\u7ecf\u5b58\u5728 19. auto it = channel->task_list()->find(&lookup_task); 20. 21. task = (it == channel->task_list()->end()) ? nullptr : *it; 22. 23. if (read || write) { 24. if (!task) { 25. // \u5f00\u542f\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u901a\u77e5cares 26. channel->StartTimer(); 27. // \u521b\u5efa\u4e00\u4e2a\u4efb\u52a1 28. task = ares_task_create(channel, sock); 29. // \u4fdd\u5b58\u5230\u4efb\u52a1\u5217\u8868 30. channel->task_list()->insert(task); 31. } 32. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230epoll\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u6839\u636ecares\u4f20\u7684\u8fdb\u884c\u8bbe\u7f6e\uff0c\u6709\u4e8b\u4ef6\u89e6\u53d1\u540e\u6267\u884c\u56de\u8c03ares_poll_cb 33. uv_poll_start(&task->poll_watcher, 34. (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0), 35. ares_poll_cb); 36. 37. } else { 38. // socket\u5173\u95ed\u4e86\uff0c\u5220\u9664\u4efb\u52a1 39. channel->task_list()->erase(it); 40. // \u5173\u95ed\u8be5\u4efb\u52a1\u5bf9\u5e94\u89c2\u5bdf\u8005io\uff0c\u7136\u540e\u5220\u9664\u5220\u9664\u8be5\u4efb\u52a1 41. channel->env()->CloseHandle(&task->poll_watcher, ares_poll_close_cb); 42. // \u6ca1\u6709\u4efb\u52a1\u4e86\uff0c\u5173\u95ed\u5b9a\u65f6\u5668 43. if (channel->task_list()->empty()) { 44. channel->CloseTimer(); 45. } 46. } 47. } \u6bcf\u4e00\u4e2aDNS\u67e5\u8be2\u7684\u4efb\u52a1\uff0c\u5728Node.js\u4e2d\u7528node_ares_task \u7ba1\u7406\u3002\u5b83\u5c01\u88c5\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684channel\u3001\u67e5\u8be2\u8bf7\u6c42\u5bf9\u5e94\u7684socket\u548cuv_poll_t\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_task_create 1. node_ares_task* ares_task_create(ChannelWrap* channel, ares_socket_t sock) { 2. auto task = new node_ares_task(); 3. 4. task->channel = channel; 5. task->sock = sock; 6. // \u521d\u59cb\u5316uv_poll_t\uff0c\u4fdd\u5b58\u6587\u4ef6\u63cf\u8ff0\u7b26sock\u5230uv_poll_t 7. if (uv_poll_init_socket(channel->env()->event_loop(),&task->poll_watcher, sock) < 0) { 8. delete task; 9. return nullptr; 10. } 11. 12. return task; 13. } \u9996\u5148\u521b\u5efa\u4e00\u4e2anode_ares_task\u5bf9\u8c61\u3002\u7136\u540e\u521d\u59cb\u5316uv_poll_t\u5e76\u4e14\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230uv_poll_t\u3002uv_poll_t\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de\u8c03\u3001IO\u89c2\u5bdf\u8005\u7684\u5c01\u88c5\u3002\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cuv_poll_t\u4fdd\u5b58\u7684\u56de\u8c03\u3002\u6211\u4eec\u7ee7\u7eed\u56de\u5230ares_sockstate_cb\uff0c\u5f53cares\u901a\u77e5Node.js socket\u72b6\u6001\u53d8\u66f4\u7684\u65f6\u5019\uff0cNode.js\u5c31\u4f1a\u4fee\u6539epoll\u8282\u70b9\u7684\u914d\u7f6e\uff08\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff09\u3002\u5f53\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cares_poll_cb\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u3002 1. void ares_poll_cb(uv_poll_t* watcher, int status, int events) { 2. node_ares_task* task = ContainerOf(&node_ares_task::poll_watcher, watcher); 3. ChannelWrap* channel = task->channel; 4. 5. // \u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u91cd\u7f6e\u8d85\u65f6\u65f6\u95f4 6. uv_timer_again(channel->timer_handle()); 7. 8. // \u901a\u77e5cares\u5904\u7406\u54cd\u5e94 9. ares_process_fd(channel->cares_channel(), 10. events & UV_READABLE ? task->sock : ARES_SOCKET_BAD, 11. events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD); 12. } \u5f53socket\u4e0a\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0cNode.js\u8c03ares_process_fd\u5904\u7406\u3002\u771f\u6b63\u7684\u5904\u7406\u51fd\u6570\u662fprocessfds\u3002 1. static void processfds(ares_channel channel, 2. fd_set *read_fds, ares_socket_t read_fd, 3. fd_set *write_fds, ares_socket_t write_fd) 4. { 5. struct timeval now = ares__tvnow(); 6. 7. write_tcp_data(channel, write_fds, write_fd, &now); 8. read_tcp_data(channel, read_fds, read_fd, &now); 9. read_udp_packets(channel, read_fds, read_fd, &now); 10. process_timeouts(channel, &now); 11. process_broken_connections(channel, &now); 12. } processfds\u662f\u7edf\u4e00\u7684\u5904\u7406\u51fd\u6570\uff0c\u5728\u5404\u81ea\u51fd\u6570\u5185\u4f1a\u505a\u76f8\u5e94\u7684\u5224\u65ad\u548c\u5904\u7406\u3002\u6211\u4eec\u8fd9\u91cc\u662f\u6536\u5230\u4e86UDP\u54cd\u5e94\u3002\u5219\u4f1a\u6267\u884cread_udp_packets 1. static void read_udp_packets(ares_channel channel, fd_set *read_fds, 2. ares_socket_t read_fd, struct timeval *now){ 3. // \u8bfb\u53d6\u54cd\u5e94 4. count = socket_recvfrom(channel, server->udp_socket, (void *)buf, sizeof(buf), 0, &from.sa, &fromlen); 5. // \u5904\u7406\u54cd\u5e94\uff0c\u6700\u7ec8\u8c03\u7528query->callback\u56de\u8c03Node.js 6. process_answer(channel, buf, (int)count, i, 0, now); 7. } Cares\u8bfb\u53d6\u54cd\u5e94\u7136\u540e\u89e3\u6790\u54cd\u5e94\uff0c\u6700\u540e\u56de\u8c03Node.js\u3002Node.js\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u662fCallback 1. static void Callback(void* arg, int status, int timeouts, 2. unsigned char* answer_buf, int answer_len) { 3. QueryWrap* wrap = FromCallbackPointer(arg); 4. unsigned char* buf_copy = nullptr; 5. if (status == ARES_SUCCESS) { 6. buf_copy = node::Malloc<unsigned char>(answer_len); 7. memcpy(buf_copy, answer_buf, answer_len); 8. } 9. 10. wrap->response_data_ = std::make_unique<ResponseData>(); 11. ResponseData* data = wrap->response_data_.get(); 12. data->status = status; 13. data->is_host = false; 14. data->buf = MallocedBuffer<unsigned char>(buf_copy, answer_len); 15. // \u6267\u884cQueueResponseCallback 16. wrap->QueueResponseCallback(status); 17. } 18. 19. void QueueResponseCallback(int status) { 20. BaseObjectPtr<QueryWrap> strong_ref{this}; 21. // \u4ea7\u751f\u4e00\u4e2anative immediate\u4efb\u52a1\uff0c\u5728check\u9636\u6bb5\u6267\u884c 22. env()->SetImmediate([this, strong_ref](Environment*) { 23. // check\u9636\u6bb5\u6267\u884c 24. AfterResponse(); 25. // Delete once strong_ref goes out of scope. 26. Detach(); 27. }); 28. 29. channel_->set_query_last_ok(status != ARES_ECONNREFUSED); 30. channel_->ModifyActivityQueryCount(-1); 31. } 32. 33. void AfterResponse() { 34. const int status = response_data_->status; 35. // \u8c03\u7528\u5bf9\u5e94\u7684\u5b50\u7c7b\u7684Parse 36. if (status != ARES_SUCCESS) { 37. ParseError(status); 38. } else if (!response_data_->is_host) { 39. Parse(response_data_->buf.data, response_data_->buf.size); 40. } else { 41. Parse(response_data_->host.get()); 42. } 43. } \u4efb\u52a1\u5b8c\u6210\u540e\uff0cNode.js\u4f1a\u5728check\u9636\u6bb5\uff08Node.js v10\u662f\u4f7f\u7528async handle\u901a\u77e5Libuv\uff09\u52a0\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540echeck\u9636\u6bb5\u7684\u65f6\u5019\u6267\u884c\u5bf9\u5e94\u5b50\u7c7b\u7684Parse\u51fd\u6570\uff0c\u8fd9\u91cc\u4ee5QueryCnameWrap\u7684Parse\u4e3a\u4f8b\u3002 1. void Parse(unsigned char* buf, int len) override { 2. HandleScope handle_scope(env()->isolate()); 3. Context::Scope context_scope(env()->context()); 4. 5. Local<Array> ret = Array::New(env()->isolate()); 6. int type = ns_t_cname; 7. int status = ParseGeneralReply(env(), buf, len, &type, ret); 8. if (status != ARES_SUCCESS) { 9. ParseError(status); 10. return; 11. } 12. 13. this->CallOnComplete(ret); 14. } \u6536\u5230DNS\u56de\u590d\u540e\uff0c\u8c03\u7528ParseGeneralReply\u89e3\u6790\u56de\u5305\uff0c\u7136\u540e\u6267\u884cJS\u5c42DNS\u6a21\u5757\u7684\u56de\u8c03\u3002\u4ece\u800c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 1. void CallOnComplete(Local<Value> answer, 2. Local<Value> extra = Local<Value>()) { 3. HandleScope handle_scope(env()->isolate()); 4. Context::Scope context_scope(env()->context()); 5. Local<Value> argv[] = { 6. Integer::New(env()->isolate(), 0), 7. answer, 8. extra 9. }; 10. const int argc = arraysize(argv) - extra.IsEmpty(); 11. MakeCallback(env()->oncomplete_string(), argc, argv); 12. }","title":"08-DNS"},{"location":"chapter08-DNS/#81-ip","text":"\u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u67e5\u8be2\u4e00\u4e2a\u57df\u540d\u5bf9\u4e8e\u7684IP\u7684\u4fe1\u606f 1. dns.lookup('www.a.com', function(err, address, family) { 2. console.log(address); 3. }); DNS\u529f\u80fd\u7684JS\u5c42\u5b9e\u73b0\u5728dns.js\u4e2d 1. const req = new GetAddrInfoReqWrap(); 2. req.callback = callback; 3. req.family = family; 4. req.hostname = hostname; 5. req.oncomplete = all ? onlookupall : onlookup; 6. 7. const err = cares.getaddrinfo( 8. req, toASCII(hostname), family, hints, verbatim 9. ); Node.js\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u53c2\u6570\u540e\uff0c\u8c03\u7528cares_wrap.cc\u7684getaddrinfo\u65b9\u6cd5\uff0c\u5728care_wrap.cc\u7684\u521d\u59cb\u5316\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\uff0c getaddrinfo\u51fd\u6570\u5bf9\u5e94\u7684\u51fd\u6570\u662fGetAddrInfo\u3002 1. void Initialize(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context) { 4. Environment* env = Environment::GetCurrent(context); 5. env->SetMethod(target, \"getaddrinfo\", GetAddrInfo); 6. ... 7. } GetAddrInfo\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1. auto req_wrap = new GetAddrInfoReqWrap(env, req_wrap_obj, args[4]->IsTrue()); 2. 3. struct addrinfo hints; 4. memset(&hints, 0, sizeof(struct addrinfo)); 5. hints.ai_family = family; 6. hints.ai_socktype = SOCK_STREAM; 7. hints.ai_flags = flags; 8. 9. int err = uv_getaddrinfo(env->event_loop(), 10. req_wrap->req(), 11. AfterGetAddrInfo, 12. *hostname, 13. nullptr, 14. &hints); GetAddrInfo\u662f\u5bf9uv_getaddrinfo\u7684\u5c01\u88c5\uff0c\u56de\u8c03\u51fd\u6570\u662fAfterGetAddrInfo 1. int uv_getaddrinfo(uv_loop_t* loop, 2. // \u4e0a\u5c42\u4f20\u8fdb\u6765\u7684req 3. uv_getaddrinfo_t* req, 4. // \u89e3\u6790\u5b8c\u540e\u7684\u4e0a\u5c42\u56de\u8c03 5. uv_getaddrinfo_cb cb, 6. // \u9700\u8981\u89e3\u6790\u7684\u540d\u5b57 7. const char* hostname, 8. /* 9. \u67e5\u8be2\u7684\u8fc7\u6ee4\u6761\u4ef6\uff1a\u670d\u52a1\u540d\u3002\u6bd4\u5982 10. http smtp\u3002\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u7aef\u53e3\u3002 11. \u89c1\u4e0b\u9762\u6ce8\u91ca 12. */ 13. const char* service, 14. // \u5176\u5b83\u67e5\u8be2\u8fc7\u6ee4\u6761\u4ef6 15. const struct addrinfo* hints) { 16. 17. size_t hostname_len; 18. size_t service_len; 19. size_t hints_len; 20. size_t len; 21. char* buf; 22. 23. hostname_len = hostname ? strlen(hostname) + 1 : 0; 24. service_len = service ? strlen(service) + 1 : 0; 25. hints_len = hints ? sizeof(*hints) : 0; 26. buf = uv__malloc(hostname_len + service_len + hints_len); 27. uv__req_init(loop, req, UV_GETADDRINFO); 28. req->loop = loop; 29. // \u8bbe\u7f6e\u8bf7\u6c42\u7684\u56de\u8c03 30. req->cb = cb; 31. req->addrinfo = NULL; 32. req->hints = NULL; 33. req->service = NULL; 34. req->hostname = NULL; 35. req->retcode = 0; 36. len = 0; 37. 38. if (hints) { 39. req->hints = memcpy(buf + len, hints, sizeof(*hints)); 40. len += sizeof(*hints); 41. } 42. 43. if (service) { 44. req->service = memcpy(buf + len, service, service_len); 45. len += service_len; 46. } 47. 48. if (hostname) 49. req->hostname = memcpy(buf + len, hostname, hostname_len); 50. // \u4f20\u4e86cb\u5219\u662f\u5f02\u6b65 51. if (cb) { 52. uv__work_submit(loop, 53. &req->work_req, 54. UV__WORK_SLOW_IO, 55. uv__getaddrinfo_work, 56. uv__getaddrinfo_done); 57. return 0; 58. } else { 59. // \u963b\u585e\u5f0f\u67e5\u8be2\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03 60. uv__getaddrinfo_work(&req->work_req); 61. uv__getaddrinfo_done(&req->work_req, 0); 62. return req->retcode; 63. } 64. } \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u51fd\u6570\u9996\u5148\u662f\u5bf9\u4e00\u4e2arequest\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u7136\u540e\u6839\u636e\u662f\u5426\u4f20\u4e86\u56de\u8c03\uff0c\u51b3\u5b9a\u8d70\u5f02\u6b65\u8fd8\u662f\u540c\u6b65\u7684\u6a21\u5f0f\u3002\u540c\u6b65\u7684\u65b9\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u76f4\u63a5\u963b\u585eLibuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u76f4\u5230\u89e3\u6790\u5b8c\u6210\u3002\u5982\u679c\u662f\u5f02\u6b65\uff0c\u5219\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u6162IO\u7684\u4efb\u52a1\u3002\u5176\u4e2d\u5de5\u4f5c\u51fd\u6570\u662fuv__getaddrinfo_work\u3002\u56de\u8c03\u662fuv__getaddrinfo_done\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1. // \u89e3\u6790\u7684\u5de5\u4f5c\u51fd\u6570 2. static void uv__getaddrinfo_work(struct uv__work* w) { 3. uv_getaddrinfo_t* req; 4. int err; 5. // \u6839\u636e\u7ed3\u6784\u4f53\u7684\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 6. req = container_of(w, uv_getaddrinfo_t, work_req); 7. // \u963b\u585e\u5728\u8fd9 8. err = getaddrinfo(req->hostname, 9. req->service, 10. req->hints, 11. &req->addrinfo); 12. req->retcode = uv__getaddrinfo_translate_error(err); 13. } uv__getaddrinfo_work\u51fd\u6570\u4e3b\u8981\u662f\u8c03\u7528\u4e86\u7cfb\u7edf\u63d0\u4f9b\u7684getaddrinfo\u53bb\u505a\u89e3\u6790\u3002\u8be5\u51fd\u6570\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u963b\u585e\u3002\u7ed3\u679c\u8fd4\u56de\u540e\uff0c\u6267\u884cuv__getaddrinfo_done\u3002 1. static void uv__getaddrinfo_done(struct uv__work* w, int status) { 2. uv_getaddrinfo_t* req; 3. 4. req = container_of(w, uv_getaddrinfo_t, work_req); 5. uv__req_unregister(req->loop, req); 6. // \u91ca\u653e\u521d\u59cb\u5316\u65f6\u7533\u8bf7\u7684\u5185\u5b58 7. if (req->hints) 8. uv__free(req->hints); 9. else if (req->service) 10. uv__free(req->service); 11. else if (req->hostname) 12. uv__free(req->hostname); 13. else 14. assert(0); 15. 16. req->hints = NULL; 17. req->service = NULL; 18. req->hostname = NULL; 19. // \u89e3\u6790\u8bf7\u6c42\u88ab\u7528\u6237\u53d6\u6d88\u4e86 20. if (status == UV_ECANCELED) { 21. assert(req->retcode == 0); 22. req->retcode = UV_EAI_CANCELED; 23. } 24. // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 25. if (req->cb) 26. req->cb(req, req->retcode, req->addrinfo); 27. 28. } uv__getaddrinfo_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002","title":"8.1 \u901a\u8fc7\u57df\u540d\u627eIP"},{"location":"chapter08-DNS/#82-cares","text":"\u9664\u4e86\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u548c\u57df\u540d\u67e5\u8be2IP\u5916\uff0c\u5176\u4f59\u7684DNS\u529f\u80fd\u90fd\u7531cares\u5b9e\u73b0\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u7684\u57fa\u672c\u7528\u6cd5\u3002","title":"8.2 cares"},{"location":"chapter08-DNS/#821-cares","text":"1. // channel\u662fcares\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 2. ares_channel channel; 3. struct ares_options options; 4. // \u521d\u59cb\u5316channel 5. status = ares_init_options(&channel, &options, optmask); 6. // \u628a argv\u7684\u6570\u636e\u5b58\u5230addr 7. ares_inet_pton(AF_INET, *argv, &addr4); 8. // \u628aaddr\u6570\u636e\u5b58\u5230channel\u5e76\u53d1\u8d77DNS\u67e5\u8be2 9. ares_gethostbyaddr(channel, 10. &addr4, 11. sizeof(addr4), 12. AF_INET, 13. callback,*argv); 14. for (;;) 15. { 16. int res; 17. FD_ZERO(&read_fds); 18. FD_ZERO(&write_fds); 19. // \u628achannel\u5bf9\u5e94\u7684fd\u5b58\u5230read_fd\u548cwrite_fds 20. nfds = ares_fds(channel, &read_fds, &write_fds); 21. if (nfds == 0) 22. break; 23. // \u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 24. tvp = ares_timeout(channel, NULL, &tv); 25. // \u963b\u585e\u5728select\uff0c\u7b49\u5f85DNS\u56de\u5305 26. res = select(nfds, &read_fds, &write_fds, NULL, tvp); 27. if (-1 == res) 28. break; 29. // \u5904\u7406DNS\u76f8\u5e94 30. ares_process(channel, &read_fds, &write_fds); 31. } \u4e0a\u9762\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u578b\uff0c\u9996\u5148\u521d\u59cb\u5316\u4e00\u4e9b\u4fe1\u606f\uff0c\u7136\u540e\u53d1\u8d77\u4e00\u4e2a\u975e\u963b\u585e\u7684\u8bf7\u6c42\uff0c\u63a5\u7740\u963b\u585e\u5728\u591a\u8def\u590d\u7528API\uff0c\u8be5API\u8fd4\u56de\u540e\uff0c\u6267\u884c\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u56de\u8c03\u3002","title":"8.2.1 cares\u4f7f\u7528\u548c\u539f\u7406"},{"location":"chapter08-DNS/#822-cares_wrapcc","text":"\u5728Node.js\u4e2d\uff0cNode.js\u548ccares\u7684\u6574\u4f53\u4ea4\u4e92\u5982\u56fe8-1\u6240\u793a\u3002 \u56fe8-1. \u6211\u4eec\u901a\u8fc7cares_wrap.cc\u5206\u6790\u5176\u4e2d\u7684\u539f\u7406\u3002\u6211\u4eec\u4eceDNS\u6a21\u5757\u63d0\u4f9b\u7684resolveCname\u51fd\u6570\u5f00\u59cb\u3002resolveCname\u51fd\u6570\u7531\u4ee5\u4e0b\u4ee3\u7801\u5bfc\u51fa\uff08dns.js\uff09\u3002 bindDefaultResolver(module.exports, getDefaultResolver()) \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\uff08dns/utils.js\uff09\u3002 1. class Resolver { 2. constructor() { 3. this._handle = new ChannelWrap(); 4. } 5. // ... 6. } 7. 8. let defaultResolver = new Resolver(); 9. 10. function getDefaultResolver() { 11. return defaultResolver; 12. } 13. 14. function resolver(bindingName) { 15. function query(name, /* options, */ callback) { 16. let options; 17. const req = new QueryReqWrap(); 18. req.bindingName = bindingName; 19. req.callback = callback; 20. req.hostname = name; 21. req.oncomplete = onresolve; 22. req.ttl = !!(options && options.ttl); 23. const err = this._handle[bindingName](req, toASCII(name)); 24. if (err) throw dnsException(err, bindingName, name); 25. return req; 26. } 27. ObjectDefineProperty(query, 'name', { value: bindingName }); 28. return query; 29. } 30. // \u7ed9\u539f\u578b\u94fe\u6ce8\u5165\u4e00\u4e2a\u65b0\u7684\u5c5e\u6027\uff0cdefaultResolver\u4e2d\u4e5f\u751f\u6548 31. Resolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname'); getDefaultResolver\u5bfc\u51fa\u7684\u662f\u4e00\u4e2aResolve\u5bf9\u8c61\uff0c\u91cc\u9762\u6709resolveCname\u7b49\u4e00\u7cfb\u5217\u65b9\u6cd5\u3002\u63a5\u7740\u770b\u4e00\u4e0bbindDefaultResolver\uff0c\u6211\u4eec\u4e00\u4f1a\u518d\u770bChannelWrap\u3002 1. const resolverKeys = [ 2. 'resolveCname ', 3. // \u2026 4. ] 5. function bindDefaultResolver(target, source) { 6. resolverKeys.forEach((key) => { 7. target[key] = source[key].bind(defaultResolver); 8. }); 9. } \u770b\u8d77\u6765\u5f88\u7ed5\uff0c\u5176\u5b9e\u5c31\u662f\u628aResolve\u5bf9\u8c61\u7684\u65b9\u6cd5\u5bfc\u51fa\u5230DNS\u6a21\u5757\u3002\u8fd9\u6837\u7528\u6237\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002\u6211\u4eec\u770b\u5230resolveCname\u662f\u7531resolver\u51fd\u6570\u751f\u6210\u7684\uff0cresolver\u51fd\u6570\u5bf9cares\u7cfb\u5217\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\uff0c\u6700\u7ec8\u8c03\u7528\u7684\u662fthis._handle.queryCname\u51fd\u6570\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2ahandle\uff08ChannelWrap\u7c7b\u5bf9\u8c61\uff09\u7684\u5b9e\u73b0\uff08cares_wrap.cc\uff09\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bcares_wrap.cc\u6a21\u5757\u5bfc\u51fa\u7684API\u3002 1. Local<FunctionTemplate> channel_wrap = env->NewFunctionTemplate(ChannelWrap::New); 2. channel_wrap->InstanceTemplate()->SetInternalFieldCount(1); 3. channel_wrap->Inherit(AsyncWrap::GetConstructorTemplate(env)); 4. // Query\u662fC++\u51fd\u6570\u6a21\u677f 5. env->SetProtoMethod(channel_wrap, 6. \"queryCname\", 7. Query<QueryCnameWrap>); 8. // ... 9. Local<String> channelWrapString = FIXED_ONE_BYTE_STRING(env->isolate(), \"ChannelWrap\"); 10. channel_wrap->SetClassName(channelWrapString); 11. target->Set(env->context(), 12. channelWrapString,channel_wrap->GetFunction(context).ToLocalChecked()).Check(); handle\u5bf9\u5e94\u7684\u5c31\u662f\u4ee5\u4e0a\u4ee3\u7801\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew ChannelWrap\u7684\u65f6\u5019\u3002 \u6700\u7ec8\u4f1a\u8c03\u7528C++\u5c42\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u6267\u884cChannelWrap::New\u3002 1. void ChannelWrap::New(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. new ChannelWrap(env, args.This()); 4. } \u6211\u4eec\u770b\u4e00\u4e0b\u7c7bChannelWrap\u7684\u5b9a\u4e49\u3002 1. class ChannelWrap : public AsyncWrap { 2. public: 3. // ... 4. 5. private: 6. // \u8d85\u65f6\u7ba1\u7406 7. uv_timer_t* timer_handle_; 8. // cares\u6570\u636e\u7c7b\u578b 9. ares_channel channel_; 10. // \u6807\u8bb0\u67e5\u8be2\u7ed3\u679c 11. bool query_last_ok_; 12. // \u4f7f\u7528\u7684DNS\u670d\u52a1\u5668 13. bool is_servers_default_; 14. // \u662f\u5426\u5df2\u7ecf\u521d\u59cb\u5316cares\u5e93 15. bool library_inited_; 16. // \u6b63\u5728\u53d1\u8d77\u7684\u67e5\u8be2\u4e2a\u6570 17. int active_query_count_; 18. // \u53d1\u8d77\u67e5\u8be2\u7684\u4efb\u52a1\u961f\u5217 19. node_ares_task_list task_list_; 20. }; \u63a5\u7740\u6211\u4eec\u770b\u770bChannelWrap\u6784\u9020\u51fd\u6570\u7684\u4ee3\u7801\u3002 1. ChannelWrap::ChannelWrap(...) { 2. Setup(); 3. } ChannelWrap\u91cc\u76f4\u63a5\u8c03\u7528\u4e86Setup 1. void ChannelWrap::Setup() { 2. struct ares_options options; 3. memset(&options, 0, sizeof(options)); 4. options.flags = ARES_FLAG_NOCHECKRESP; 5. /* 6. caresd socket\u72b6\u6001\uff08\u8bfb\u5199\uff09\u53d1\u751f\u53d8\u66f4\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\uff0c 7. \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fsock_state_cb_data 8. */ 9. options.sock_state_cb = ares_sockstate_cb; 10. options.sock_state_cb_data = this; 11. 12. // \u8fd8\u6ca1\u521d\u59cb\u5316\u5219\u521d\u59cb\u5316 13. if (!library_inited_) { 14. Mutex::ScopedLock lock(ares_library_mutex); 15. // \u521d\u59cb\u5316cares\u5e93 16. ares_library_init(ARES_LIB_INIT_ALL); 17. } 18. // \u8bbe\u7f6e\u4f7f\u7528cares\u7684\u914d\u7f6e 19. ares_init_options(&channel_, 20. &options, 21. ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB); 22. library_inited_ = true; 23. } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5728\u8fd9\u91cc\u521d\u59cb\u5316cares\u76f8\u5173\u7684\u903b\u8f91\u3002\u5176\u4e2d\u6700\u91cd\u8981\u7684\u5c31\u662f\u8bbe\u7f6e\u4e86cares socket\u72b6\u6001\u53d8\u66f4\u65f6\u6267\u884c\u7684\u56de\u8c03ares_sockstate_cb\uff08\u6bd4\u5982socket\u9700\u8981\u8bfb\u53d6\u6570\u636e\u6216\u8005\u5199\u5165\u6570\u636e\uff09\u3002\u524d\u9762\u7684cares\u4f7f\u7528\u4f8b\u5b50\u4e2d\u8bb2\u5230\u4e86cares\u548c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u7684\u914d\u5408\u4f7f\u7528\uff0c\u90a3\u4e48cares\u548cLibuv\u662f\u5982\u4f55\u914d\u5408\u7684\u5462\uff1fcares\u63d0\u4f9b\u4e86\u4e00\u79cd\u673a\u5236\uff0c\u5c31\u662fsocket\u72b6\u6001\u53d8\u66f4\u65f6\u901a\u77e5\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u3002DNS\u89e3\u6790\u672c\u8d28\u4e0a\u4e5f\u662f\u7f51\u7edcIO\uff0c\u6240\u4ee5\u53d1\u8d77\u4e00\u4e2aDNS\u67e5\u8be2\u4e5f\u5c31\u662f\u5bf9\u5e94\u4e00\u4e2asocket\u3002DNS\u67e5\u8be2\u662f\u7531cares\u53d1\u8d77\u7684\uff0c\u8fd9\u5c31\u610f\u5473\u7740socket\u662f\u5728cares\u4e2d\u7ef4\u62a4\u7684\uff0c\u90a3Libuv\u600e\u4e48\u77e5\u9053\u5462\uff1f\u6b63\u662fcares\u63d0\u4f9b\u7684\u901a\u77e5\u673a\u5236\uff0c\u4f7f\u5f97Libuv\u77e5\u9053\u53d1\u8d77DNS\u67e5\u8be2\u5bf9\u5e94\u7684socket\uff0c\u4ece\u800c\u6ce8\u518c\u5230Libuv\u4e2d\uff0c\u7b49\u5230\u4e8b\u4ef6\u89e6\u53d1\u540e\uff0c\u518d\u901a\u77e5cares\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u53d1\u8d77\u4e00\u4e2acname\u67e5\u8be2\u5f00\u59cb\u5206\u6790\u3002\u9996\u5148\u56de\u987e\u4e00\u4e0bcares_wrap\u6a21\u5757\u5bfc\u51fa\u7684cname\u67e5\u8be2\u51fd\u6570\uff0c env->SetProtoMethod(channel_wrap, \"queryCname\", Query );Query\u662fC++\u6a21\u677f\u51fd\u6570\uff0cQueryCnameWrap\u662fC++\u7c7b 1. template <class Wrap> 2. static void Query(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. ChannelWrap* channel; 5. // Holder\u4e2d\u4fdd\u5b58\u4e86ChannelWrap\u5bf9\u8c61\uff0c\u89e3\u5305\u51fa\u6765 6. ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder()); 7. Local<Object> req_wrap_obj = args[0].As<Object>(); 8. Local<String> string = args[1].As<String>(); 9. /* 10. \u6839\u636e\u53c2\u6570\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8fd9\u91cc\u662fQueryCnameWrap\uff0c 11. \u5e76\u4e14\u4fdd\u5b58\u5bf9\u5e94\u7684ChannelWrap\u5bf9\u8c61\u548c\u64cd\u4f5c\u76f8\u5173\u7684\u5bf9\u8c61 12. */ 13. Wrap* wrap = new Wrap(channel, req_wrap_obj); 14. 15. node::Utf8Value name(env->isolate(), string); 16. // \u53d1\u8d77\u8bf7\u6c42\u6570\u52a0\u4e00 17. channel->ModifyActivityQueryCount(1); 18. // \u8c03\u7528Send\u51fd\u6570\u53d1\u8d77\u67e5\u8be2 19. int err = wrap->Send(*name); 20. if (err) { 21. channel->ModifyActivityQueryCount(-1); 22. delete wrap; 23. } 24. 25. args.GetReturnValue().Set(err); 26. } Query\u53ea\u5b9e\u73b0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u903b\u8f91\uff0c\u7136\u540e\u8c03\u7528Send\u51fd\u6570\uff0c\u5177\u4f53\u7684Send\u51fd\u6570\u903b\u8f91\u7531\u5404\u4e2a\u5177\u4f53\u7684\u7c7b\u5b9e\u73b0\u3002","title":"8.2.2 cares_wrap.cc\u7684\u901a\u7528\u903b\u8f91"},{"location":"chapter08-DNS/#823","text":"\u6211\u4eec\u770b\u4e00\u4e0bQueryCnameWrap\u7c7b\u3002 1. class QueryCnameWrap: public QueryWrap { 2. public: 3. QueryCnameWrap(ChannelWrap* channel, 4. Local<Object> req_wrap_obj) 5. : QueryWrap(channel, req_wrap_obj, \"resolveCname\") { 6. } 7. 8. int Send(const char* name) override { 9. AresQuery(name, ns_c_in, ns_t_cname); 10. return 0; 11. } 12. 13. protected: 14. void Parse(unsigned char* buf, int len) override { 15. HandleScope handle_scope(env()->isolate()); 16. Context::Scope context_scope(env()->context()); 17. 18. Local<Array> ret = Array::New(env()->isolate()); 19. int type = ns_t_cname; 20. int status = ParseGeneralReply(env(), buf, len, &type, ret); 21. if (status != ARES_SUCCESS) { 22. ParseError(status); 23. return; 24. } 25. 26. this->CallOnComplete(ret); 27. } 28. }; \u6211\u4eec\u770b\u5230QueryCnameWrap\u7c7b\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u4e3b\u8981\u5b9a\u4e49Send\u548cParse\u7684\u5b9e\u73b0\uff0c\u6700\u7ec8\u8fd8\u662f\u4f1a\u8c03\u7528\u57fa\u7c7b\u5bf9\u5e94\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u7c7bQueryWrap\u4e2dAresQuery\u7684\u5b9e\u73b0\u3002 1. void AresQuery(const char* name, 2. int dnsclass, 3. int type) { 4. ares_query(channel_->cares_channel(), 5. name, 6. dnsclass, 7. type, 8. Callback, 9. static_cast<void*>(this)); 10. } AresQuery\u51fd\u6570\u63d0\u4f9b\u7edf\u4e00\u53d1\u9001\u67e5\u8be2\u64cd\u4f5c\u3002\u67e5\u8be2\u5b8c\u6210\u540e\u6267\u884cCallback\u56de\u8c03\u3002\u63a5\u4e0b\u6765\u5c31\u6d89\u53ca\u5230cares\u548cNode.js\u7684\u5177\u4f53\u4ea4\u4e92\u4e86\u3002Node.js\u628a\u4e00\u4e2a\u4efb\u52a1\u4ea4\u7ed9cares\u540e\uff0ccares\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u63a5\u7740cares\u4f1a\u901a\u8fc7Node.js\u8bbe\u7f6e\u7684\u56de\u8c03ares_sockstate_cb\u901a\u77e5Node.js\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_query\u7684\u5173\u952e\u903b\u8f91\u3002 1. void ares_query(ares_channel channel, const char *name, int dnsclass, 2. int type, ares_callback callback, void *arg) 3. { 4. struct qquery *qquery; 5. unsigned char *qbuf; 6. int qlen, rd, status; 7. 8. qquery = ares_malloc(sizeof(struct qquery)); 9. // \u4fdd\u5b58Node.js\u7684\u56de\u8c03\uff0c\u67e5\u8be2\u5b8c\u6210\u65f6\u56de\u8c03 10. qquery->callback = callback; 11. qquery->arg = arg; 12. ares_send(channel, qbuf, qlen, qcallback, qquery); 13. } 14. 15. static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen) 16. { 17. struct qquery *qquery = (struct qquery *) arg; 18. unsigned int ancount; 19. int rcode; 20. 21. if (status != ARES_SUCCESS) 22. qquery->callback(qquery->arg, status, timeouts, abuf, alen); 23. else 24. { 25. // ... 26. // \u6267\u884cNode.js\u56de\u8c03 27. qquery->callback(qquery->arg, 28. status, 29. timeouts, 30. abuf, 31. alen); 32. } 33. ares_free(qquery); 34. } 35. ares_query\u4fdd\u5b58\u4e86Node.js\u7684\u56de\u8c03\uff0c\u5e76\u4e14\u8bbe\u7f6e\u56de\u8c03qcallback\uff0c\u67e5\u8be2\u6210\u529f\u540e\u4f1a\u56de\u8c03qcallback\uff0cqcallback\u518d\u56de\u8c03Node.js\u3002\u63a5\u7740\u6267\u884cares_send\uff0cares_send\u4f1a\u8c03\u7528ares__send_query\u3002 1. void ares__send_query(ares_channel channel, 2. struct query *query, 3. struct timeval *now) 4. { 5. struct server_state *server = &channel->servers[query->server]; 6. if (server->udp_socket == ARES_SOCKET_BAD) 7. { 8. // \u7533\u8bf7\u4e00\u4e2asocket 9. if (open_udp_socket(channel, server) == -1) 10. { 11. skip_server(channel, query, query->server); 12. next_server(channel, query, now); 13. return; 14. } 15. } 16. // \u53d1\u9001DNS\u67e5\u8be2 17. if (socket_write(channel, server->udp_socket, query->qbuf, query->qlen) == -1) 18. { 19. skip_server(channel, query, query->server); 20. next_server(channel, query, now); 21. return; 22. } 23. } ares__send_query\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\u3002\u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u53ef\u4ee5\u76f4\u63a5\u53d1\u9001\u3002\u6211\u4eec\u770b\u4e00\u4e0bopen_udp_socket\u3002 1. static int open_udp_socket(ares_channel channel, struct server_state *server) 2. { 3. ares_socket_t s; 4. ares_socklen_t salen; 5. union { 6. struct sockaddr_in sa4; 7. struct sockaddr_in6 sa6; 8. } saddr; 9. struct sockaddr *sa; 10. 11. // \u7533\u8bf7\u4e00\u4e2asocket 12. s = open_socket(channel, server->addr.family, SOCK_DGRAM, 0); 13. // \u7ed1\u5b9a\u670d\u52a1\u5668\u5730\u5740 14. connect_socket(channel, s, sa, salen) 15. 16. // \u901a\u77e5Node.js\uff0c1,0\u8868\u793a\u5bf9socket\u7684\u8bfb\u4e8b\u4ef6\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u53d1\u9001\u4e86\u8bf7\u6c42\uff0c\u7b49\u5f85\u54cd\u5e94 17. SOCK_STATE_CALLBACK(channel, s, 1, 0); 18. // \u4fdd\u5b58socket 19. server->udp_socket = s; 20. return 0; 21. } 22. 23. #define SOCK_STATE_CALLBACK(c, s, r, w) \\ 24. do { \\ 25. if ((c)->sock_state_cb) \\ 26. (c)->sock_state_cb((c)->sock_state_cb_data, (s), (r), (w)); \\ 27. } WHILE_FALSE 28. ares__send_query\u51fd\u6570\u505a\u4e86\u4e09\u4ef6\u4e8b 1 \u7533\u8bf7\u4e86socket\uff0c 2 \u901a\u77e5Node.js 3 \u53d1\u9001\u4e86DNS\u67e5\u8be2\u8bf7\u6c42 \u8fd9\u65f6\u5019\u6d41\u7a0b\u8d70\u5230\u4e86Node.js\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u56de\u8c03Node.js\u7684\u65f6\u5019\uff0cNode.js\u600e\u4e48\u5904\u7406\u7684 1. struct node_ares_task : public MemoryRetainer { 2. ChannelWrap* channel; 3. // \u5173\u8054\u7684socket 4. ares_socket_t sock; 5. // IO\u89c2\u5bdf\u8005\u548c\u56de\u8c03 6. uv_poll_t poll_watcher; 7. }; 8. 9. void ares_sockstate_cb(void* data, 10. ares_socket_t sock, 11. int read, 12. int write) { 13. ChannelWrap* channel = static_cast<ChannelWrap*>(data); 14. node_ares_task* task; 15. // \u4efb\u52a1 16. node_ares_task lookup_task; 17. lookup_task.sock = sock; 18. // \u8be5\u4efb\u52a1\u662f\u5426\u5df2\u7ecf\u5b58\u5728 19. auto it = channel->task_list()->find(&lookup_task); 20. 21. task = (it == channel->task_list()->end()) ? nullptr : *it; 22. 23. if (read || write) { 24. if (!task) { 25. // \u5f00\u542f\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u901a\u77e5cares 26. channel->StartTimer(); 27. // \u521b\u5efa\u4e00\u4e2a\u4efb\u52a1 28. task = ares_task_create(channel, sock); 29. // \u4fdd\u5b58\u5230\u4efb\u52a1\u5217\u8868 30. channel->task_list()->insert(task); 31. } 32. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230epoll\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u6839\u636ecares\u4f20\u7684\u8fdb\u884c\u8bbe\u7f6e\uff0c\u6709\u4e8b\u4ef6\u89e6\u53d1\u540e\u6267\u884c\u56de\u8c03ares_poll_cb 33. uv_poll_start(&task->poll_watcher, 34. (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0), 35. ares_poll_cb); 36. 37. } else { 38. // socket\u5173\u95ed\u4e86\uff0c\u5220\u9664\u4efb\u52a1 39. channel->task_list()->erase(it); 40. // \u5173\u95ed\u8be5\u4efb\u52a1\u5bf9\u5e94\u89c2\u5bdf\u8005io\uff0c\u7136\u540e\u5220\u9664\u5220\u9664\u8be5\u4efb\u52a1 41. channel->env()->CloseHandle(&task->poll_watcher, ares_poll_close_cb); 42. // \u6ca1\u6709\u4efb\u52a1\u4e86\uff0c\u5173\u95ed\u5b9a\u65f6\u5668 43. if (channel->task_list()->empty()) { 44. channel->CloseTimer(); 45. } 46. } 47. } \u6bcf\u4e00\u4e2aDNS\u67e5\u8be2\u7684\u4efb\u52a1\uff0c\u5728Node.js\u4e2d\u7528node_ares_task \u7ba1\u7406\u3002\u5b83\u5c01\u88c5\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684channel\u3001\u67e5\u8be2\u8bf7\u6c42\u5bf9\u5e94\u7684socket\u548cuv_poll_t\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_task_create 1. node_ares_task* ares_task_create(ChannelWrap* channel, ares_socket_t sock) { 2. auto task = new node_ares_task(); 3. 4. task->channel = channel; 5. task->sock = sock; 6. // \u521d\u59cb\u5316uv_poll_t\uff0c\u4fdd\u5b58\u6587\u4ef6\u63cf\u8ff0\u7b26sock\u5230uv_poll_t 7. if (uv_poll_init_socket(channel->env()->event_loop(),&task->poll_watcher, sock) < 0) { 8. delete task; 9. return nullptr; 10. } 11. 12. return task; 13. } \u9996\u5148\u521b\u5efa\u4e00\u4e2anode_ares_task\u5bf9\u8c61\u3002\u7136\u540e\u521d\u59cb\u5316uv_poll_t\u5e76\u4e14\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230uv_poll_t\u3002uv_poll_t\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de\u8c03\u3001IO\u89c2\u5bdf\u8005\u7684\u5c01\u88c5\u3002\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cuv_poll_t\u4fdd\u5b58\u7684\u56de\u8c03\u3002\u6211\u4eec\u7ee7\u7eed\u56de\u5230ares_sockstate_cb\uff0c\u5f53cares\u901a\u77e5Node.js socket\u72b6\u6001\u53d8\u66f4\u7684\u65f6\u5019\uff0cNode.js\u5c31\u4f1a\u4fee\u6539epoll\u8282\u70b9\u7684\u914d\u7f6e\uff08\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff09\u3002\u5f53\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cares_poll_cb\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u3002 1. void ares_poll_cb(uv_poll_t* watcher, int status, int events) { 2. node_ares_task* task = ContainerOf(&node_ares_task::poll_watcher, watcher); 3. ChannelWrap* channel = task->channel; 4. 5. // \u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u91cd\u7f6e\u8d85\u65f6\u65f6\u95f4 6. uv_timer_again(channel->timer_handle()); 7. 8. // \u901a\u77e5cares\u5904\u7406\u54cd\u5e94 9. ares_process_fd(channel->cares_channel(), 10. events & UV_READABLE ? task->sock : ARES_SOCKET_BAD, 11. events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD); 12. } \u5f53socket\u4e0a\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0cNode.js\u8c03ares_process_fd\u5904\u7406\u3002\u771f\u6b63\u7684\u5904\u7406\u51fd\u6570\u662fprocessfds\u3002 1. static void processfds(ares_channel channel, 2. fd_set *read_fds, ares_socket_t read_fd, 3. fd_set *write_fds, ares_socket_t write_fd) 4. { 5. struct timeval now = ares__tvnow(); 6. 7. write_tcp_data(channel, write_fds, write_fd, &now); 8. read_tcp_data(channel, read_fds, read_fd, &now); 9. read_udp_packets(channel, read_fds, read_fd, &now); 10. process_timeouts(channel, &now); 11. process_broken_connections(channel, &now); 12. } processfds\u662f\u7edf\u4e00\u7684\u5904\u7406\u51fd\u6570\uff0c\u5728\u5404\u81ea\u51fd\u6570\u5185\u4f1a\u505a\u76f8\u5e94\u7684\u5224\u65ad\u548c\u5904\u7406\u3002\u6211\u4eec\u8fd9\u91cc\u662f\u6536\u5230\u4e86UDP\u54cd\u5e94\u3002\u5219\u4f1a\u6267\u884cread_udp_packets 1. static void read_udp_packets(ares_channel channel, fd_set *read_fds, 2. ares_socket_t read_fd, struct timeval *now){ 3. // \u8bfb\u53d6\u54cd\u5e94 4. count = socket_recvfrom(channel, server->udp_socket, (void *)buf, sizeof(buf), 0, &from.sa, &fromlen); 5. // \u5904\u7406\u54cd\u5e94\uff0c\u6700\u7ec8\u8c03\u7528query->callback\u56de\u8c03Node.js 6. process_answer(channel, buf, (int)count, i, 0, now); 7. } Cares\u8bfb\u53d6\u54cd\u5e94\u7136\u540e\u89e3\u6790\u54cd\u5e94\uff0c\u6700\u540e\u56de\u8c03Node.js\u3002Node.js\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u662fCallback 1. static void Callback(void* arg, int status, int timeouts, 2. unsigned char* answer_buf, int answer_len) { 3. QueryWrap* wrap = FromCallbackPointer(arg); 4. unsigned char* buf_copy = nullptr; 5. if (status == ARES_SUCCESS) { 6. buf_copy = node::Malloc<unsigned char>(answer_len); 7. memcpy(buf_copy, answer_buf, answer_len); 8. } 9. 10. wrap->response_data_ = std::make_unique<ResponseData>(); 11. ResponseData* data = wrap->response_data_.get(); 12. data->status = status; 13. data->is_host = false; 14. data->buf = MallocedBuffer<unsigned char>(buf_copy, answer_len); 15. // \u6267\u884cQueueResponseCallback 16. wrap->QueueResponseCallback(status); 17. } 18. 19. void QueueResponseCallback(int status) { 20. BaseObjectPtr<QueryWrap> strong_ref{this}; 21. // \u4ea7\u751f\u4e00\u4e2anative immediate\u4efb\u52a1\uff0c\u5728check\u9636\u6bb5\u6267\u884c 22. env()->SetImmediate([this, strong_ref](Environment*) { 23. // check\u9636\u6bb5\u6267\u884c 24. AfterResponse(); 25. // Delete once strong_ref goes out of scope. 26. Detach(); 27. }); 28. 29. channel_->set_query_last_ok(status != ARES_ECONNREFUSED); 30. channel_->ModifyActivityQueryCount(-1); 31. } 32. 33. void AfterResponse() { 34. const int status = response_data_->status; 35. // \u8c03\u7528\u5bf9\u5e94\u7684\u5b50\u7c7b\u7684Parse 36. if (status != ARES_SUCCESS) { 37. ParseError(status); 38. } else if (!response_data_->is_host) { 39. Parse(response_data_->buf.data, response_data_->buf.size); 40. } else { 41. Parse(response_data_->host.get()); 42. } 43. } \u4efb\u52a1\u5b8c\u6210\u540e\uff0cNode.js\u4f1a\u5728check\u9636\u6bb5\uff08Node.js v10\u662f\u4f7f\u7528async handle\u901a\u77e5Libuv\uff09\u52a0\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540echeck\u9636\u6bb5\u7684\u65f6\u5019\u6267\u884c\u5bf9\u5e94\u5b50\u7c7b\u7684Parse\u51fd\u6570\uff0c\u8fd9\u91cc\u4ee5QueryCnameWrap\u7684Parse\u4e3a\u4f8b\u3002 1. void Parse(unsigned char* buf, int len) override { 2. HandleScope handle_scope(env()->isolate()); 3. Context::Scope context_scope(env()->context()); 4. 5. Local<Array> ret = Array::New(env()->isolate()); 6. int type = ns_t_cname; 7. int status = ParseGeneralReply(env(), buf, len, &type, ret); 8. if (status != ARES_SUCCESS) { 9. ParseError(status); 10. return; 11. } 12. 13. this->CallOnComplete(ret); 14. } \u6536\u5230DNS\u56de\u590d\u540e\uff0c\u8c03\u7528ParseGeneralReply\u89e3\u6790\u56de\u5305\uff0c\u7136\u540e\u6267\u884cJS\u5c42DNS\u6a21\u5757\u7684\u56de\u8c03\u3002\u4ece\u800c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 1. void CallOnComplete(Local<Value> answer, 2. Local<Value> extra = Local<Value>()) { 3. HandleScope handle_scope(env()->isolate()); 4. Context::Scope context_scope(env()->context()); 5. Local<Value> argv[] = { 6. Integer::New(env()->isolate(), 0), 7. answer, 8. extra 9. }; 10. const int argc = arraysize(argv) - extra.IsEmpty(); 11. MakeCallback(env()->oncomplete_string(), argc, argv); 12. }","title":"8.2.3 \u5177\u4f53\u5b9e\u73b0"},{"location":"chapter09-Unix%E5%9F%9F/","text":"Unix\u57df\u4e00\u79cd\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0cUnix\u57df\u4e0d\u4ec5\u652f\u6301\u6ca1\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\u95f4\u8fdb\u884c\u901a\u4fe1\uff0c\u800c\u4e14\u652f\u6301\u8fdb\u7a0b\u95f4\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002Unix\u57df\u662fNode.js\u4e2d\u6838\u5fc3\u7684\u529f\u80fd\uff0c\u5b83\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5e95\u5c42\u57fa\u7840\uff0cchild_process\u548ccluster\u6a21\u5757\u90fd\u4f9d\u8d56Unix\u57df\u7684\u80fd\u529b\u3002\u4ece\u5b9e\u73b0\u548c\u4f7f\u7528\u4e0a\u6765\u770b\uff0cUnix\u57df\u7c7b\u4f3cTCP\uff0c\u4f46\u662f\u56e0\u4e3a\u5b83\u662f\u57fa\u4e8e\u540c\u4e3b\u673a\u8fdb\u7a0b\u7684\uff0c\u4e0d\u50cfTCP\u9700\u8981\u9762\u4e34\u590d\u6742\u7684\u7f51\u7edc\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e5f\u6ca1\u6709TCP\u90a3\u4e48\u590d\u6742\u3002Unix\u57df\u548c\u4f20\u7edf\u7684socket\u901a\u4fe1\u4e00\u6837\uff0c\u9075\u5faa\u7f51\u7edc\u7f16\u7a0b\u7684\u90a3\u4e00\u5957\u6d41\u7a0b\uff0c\u7531\u4e8e\u5728\u540c\u4e3b\u673a\u5185\uff0c\u5c31\u4e0d\u5fc5\u8981\u4f7f\u7528IP\u548c\u7aef\u53e3\u7684\u65b9\u5f0f\u3002Node.js\u4e2d\uff0cUnix\u57df\u91c7\u7528\u7684\u662f\u4e00\u4e2a\u6587\u4ef6\u4f5c\u4e3a\u6807\u8bb0\u3002\u5927\u81f4\u539f\u7406\u5982\u4e0b\u3002 1 \u670d\u52a1\u5668\u9996\u5148\u62ff\u5230\u4e00\u4e2asocket\u3002 2 \u670d\u52a1\u5668bind\u4e00\u4e2a\u6587\u4ef6\uff0c\u7c7b\u4f3cbind\u4e00\u4e2aIP\u548c\u7aef\u53e3\u4e00\u6837\uff0c\u5bf9\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u6765\u8bf4\uff0c\u5c31\u662f\u65b0\u5efa\u4e00\u4e2a\u6587\u4ef6\uff08\u4e0d\u4e00\u5b9a\u662f\u5728\u786c\u76d8\u4e2d\u521b\u5efa\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u62bd\u8c61\u8def\u5f84\u540d\uff09\uff0c\u7136\u540e\u628a\u6587\u4ef6\u8def\u5f84\u4fe1\u606f\u5b58\u5728socket\u4e2d\u3002 3 \u8c03\u7528listen\u4fee\u6539socket\u72b6\u6001\u4e3a\u76d1\u542c\u72b6\u6001\u3002 4 \u5ba2\u6237\u7aef\u901a\u8fc7\u540c\u6837\u7684\u6587\u4ef6\u8def\u5f84\u8c03\u7528connect\u53bb\u8fde\u63a5\u670d\u52a1\u5668\u3002\u8fd9\u65f6\u5019\u7528\u4e8e\u8868\u793a\u5ba2\u6237\u7aef\u7684\u7ed3\u6784\u4f53\u63d2\u5165\u670d\u52a1\u5668\u7684\u8fde\u63a5\u961f\u5217\uff0c\u7b49\u5f85\u5904\u7406\u3002 5 \u670d\u52a1\u5668\u8c03\u7528accept\u6458\u53d6\u961f\u5217\u7684\u8282\u70b9\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u901a\u4fe1socket\u548c\u5ba2\u6237\u7aef\u8fdb\u884c\u901a\u4fe1\u3002 Unix\u57df\u901a\u4fe1\u672c\u8d28\u8fd8\u662f\u57fa\u4e8e\u5185\u5b58\u4e4b\u95f4\u7684\u901a\u4fe1\uff0c\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u90fd\u7ef4\u62a4\u4e00\u5757\u5185\u5b58\uff0c\u8fd9\u5757\u5185\u5b58\u5206\u4e3a\u8bfb\u7f13\u51b2\u533a\u548c\u5199\u7f13\u51b2\u533a\u3002\u4ece\u800c\u5b9e\u73b0\u5168\u53cc\u5de5\u901a\u4fe1\uff0c\u800cUnix\u57df\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u53ea\u4e0d\u8fc7\u662f\u4e3a\u4e86\u8ba9\u5ba2\u6237\u7aef\u8fdb\u7a0b\u53ef\u4ee5\u627e\u5230\u670d\u52a1\u7aef\u8fdb\u7a0b\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u4e92\u76f8\u5f80\u5bf9\u65b9\u7ef4\u62a4\u7684\u5185\u5b58\u91cc\u5199\u6570\u636e\uff0c\u4ece\u800c\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 9.1 Unix\u57df\u5728Libuv\u4e2d\u7684\u4f7f\u7528 \u00b6 \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\u5728Libuv\u4e2d\u5173\u4e8eUnix\u57df\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\u3002 9.1.1 \u521d\u59cb\u5316 \u00b6 Unix\u57df\u4f7f\u7528uv_pipe_t\u7ed3\u6784\u4f53\u8868\u793a\uff0c\u4f7f\u7528\u4e4b\u524d\u9996\u5148\u9700\u8981\u521d\u59cb\u5316uv_pipe_t\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u903b\u8f91\u3002 1. int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) { 2. uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE); 3. handle->shutdown_req = NULL; 4. handle->connect_req = NULL; 5. handle->pipe_fname = NULL; 6. handle->ipc = ipc; 7. return 0; 8. } uv_pipe_init\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u521d\u59cb\u5316uv_pipe_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002uv_pipe_t\u7ee7\u627f\u4e8estream\uff0cuv__stream_init\u5c31\u662f\u521d\u59cb\u5316stream\uff08\u7236\u7c7b\uff09\u7684\u5b57\u6bb5\u3002uv_pipe_t\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5ipc\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u4e86\u662f\u5426\u5141\u8bb8\u5728\u8be5Unix\u57df\u901a\u4fe1\u4e2d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 9.1.2 \u7ed1\u5b9aUnix\u57df\u8def\u5f84 \u00b6 \u5f00\u5934\u8bf4\u8fc7\uff0cUnix\u57df\u7684\u5b9e\u73b0\u7c7b\u4f3cTCP\u7684\u5b9e\u73b0\u3002\u9075\u5faa\u7f51\u7edcsocket\u7f16\u7a0b\u90a3\u4e00\u5957\u6d41\u7a0b\u3002\u670d\u52a1\u7aef\u4f7f\u7528bind\uff0clisten\u7b49\u51fd\u6570\u542f\u52a8\u670d\u52a1\u3002 1. // name\u662funix\u8def\u5f84\u540d\u79f0 2. int uv_pipe_bind(uv_pipe_t* handle, const char* name) { 3. struct sockaddr_un saddr; 4. const char* pipe_fname; 5. int sockfd; 6. int err; 7. pipe_fname = NULL; 8. pipe_fname = uv__strdup(name); 9. name = NULL; 10. // \u6d41\u5f0fUnix\u57df\u5957\u63a5\u5b57 11. sockfd = uv__socket(AF_UNIX, SOCK_STREAM, 0); 12. memset(&saddr, 0, sizeof saddr); 13. strncpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path) - 1); 14. saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\0'; 15. saddr.sun_family = AF_UNIX; 16. // \u7ed1\u5b9a\u5230\u8def\u5f84\uff0cTCP\u662f\u7ed1\u5b9a\u5230IP\u548c\u7aef\u53e3 17. if (bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr)) { 18. // ... 19. } 20. 21. // \u8bbe\u7f6e\u7ed1\u5b9a\u6210\u529f\u6807\u8bb0 22. handle->flags |= UV_HANDLE_BOUND; 23. // Unix\u57df\u7684\u8def\u5f84 24. handle->pipe_fname = pipe_fname; 25. // \u4fdd\u5b58socket\u5bf9\u5e94\u7684fd 26. handle->io_watcher.fd = sockfd; 27. return 0; 28. } uv_pipe_bind\u51fd\u6570\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684bind\u51fd\u6570\u628aUnix\u57df\u8def\u5f84\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6700\u540e\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u6807\u8bb0\uff0c\u5e76\u4e14\u4fdd\u5b58Unix\u57df\u7684\u8def\u5f84\u548csocket\u5bf9\u5e94\u7684fd\u5230handle\u4e2d\uff0c\u540e\u7eed\u9700\u8981\u4f7f\u7528\u3002\u6211\u4eec\u770b\u5230Node.js\u4e2dUnix\u57df\u7684\u7c7b\u578b\u662fSOCK_STREAM\u3002Unix\u57df\u652f\u6301\u4e24\u79cd\u6570\u636e\u6a21\u5f0f\u3002 1 \u6d41\u5f0f\uff08 SOCK_STREAM\uff09\uff0c\u7c7b\u4f3cTCP\uff0c\u6570\u636e\u4e3a\u5b57\u8282\u6d41\uff0c\u9700\u8981\u5e94\u7528\u5c42\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 2 \u6570\u636e\u62a5\u6a21\u5f0f\uff08 SOCK_DGRAM \uff09\uff0c\u7c7b\u4f3cUDP\uff0c\u4e0d\u9700\u8981\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 \u901a\u8fc7Unix\u57df\u867d\u7136\u53ef\u4ee5\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\uff0c\u4f46\u662f\u6211\u4eec\u62ff\u5230\u7684\u6570\u636e\u53ef\u80fd\u662f\"\u4e71\u7684\"\uff0c\u8fd9\u662f\u4e3a\u4ec0\u4e48\u5462\uff1f\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u670d\u52a1\u5668\u5904\u7406\uff0c\u5982\u679c\u662f\u57fa\u4e8e\u8fd9\u79cd\u573a\u666f\uff0c\u90a3\u4e48\u6570\u636e\u5c31\u4e0d\u4f1a\u662f\u4e71\u7684\u3002\u56e0\u4e3a\u6bcf\u6b21\u5c31\u662f\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u6570\u636e\u5355\u4f4d\u3002\u4f46\u662f\u5982\u679c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u670d\u52a1\u5668\u8fd8\u6ca1\u6765\u5f97\u53ca\u5904\u7406\uff0c\u5ba2\u6237\u7aef\u53c8\u53d1\u9001\u4e86\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u518d\u5904\u7406\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u56e0\u4e3a\u4e24\u4e2a\u5b57\u8282\u6df7\u4e00\u8d77\u4e86\u3002\u5c31\u597d\u6bd4\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u5148\u540e\u53d1\u9001\u4e24\u4e2aHTTP\u8bf7\u6c42\u4e00\u6837\uff0c\u5982\u679c\u670d\u52a1\u5668\u6ca1\u6709\u529e\u6cd5\u5224\u65ad\u4e24\u4e2a\u8bf7\u6c42\u7684\u6570\u636e\u8fb9\u754c\uff0c\u90a3\u4e48\u5904\u7406\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u5e76\u4e14\u5b9e\u73b0\u5c01\u5305\u89e3\u5305\u7684\u903b\u8f91\uff0c\u624d\u80fd\u771f\u6b63\u5b8c\u6210\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 9.1.3 \u542f\u52a8\u670d\u52a1 \u00b6 \u7ed1\u5b9a\u4e86\u8def\u5f84\u540e\uff0c\u5c31\u53ef\u4ee5\u8c03\u7528listen\u51fd\u6570\u4f7f\u5f97socket\u5904\u4e8e\u76d1\u542c\u72b6\u6001\u3002 1. int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) { 2. // uv__stream_fd(handle)\u5f97\u5230bind\u51fd\u6570\u4e2d\u83b7\u53d6\u7684socket 3. if (listen(uv__stream_fd(handle), backlog)) 4. return UV__ERR(errno); 5. // \u4fdd\u5b58\u56de\u8c03\uff0c\u6709\u8fdb\u7a0b\u8c03\u7528connect\u7684\u65f6\u5019\u65f6\u89e6\u53d1\uff0c\u7531uv__server_io\u51fd\u6570\u89e6\u53d1 6. handle->connection_cb = cb; 7. // IO\u89c2\u5bdf\u8005\u7684\u56de\u8c03 8. handle->io_watcher.cb = uv__server_io; 9. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230Libuv\uff0c\u7b49\u5f85\u8fde\u63a5\uff0c\u5373\u8bfb\u4e8b\u4ef6\u5230\u6765 10. uv__io_start(handle->loop, &handle->io_watcher, POLLIN); 11. return 0; 12. } uv_pipe_listen\u6267\u884c\u64cd\u4f5c\u7cfb\u7edf\u7684listen\u51fd\u6570\u4f7f\u5f97socket\u6210\u4e3a\u76d1\u542c\u578b\u7684\u5957\u63a5\u5b57\u3002\u7136\u540e\u628asocket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u56de\u8c03\u5c01\u88c5\u6210IO\u89c2\u5bdf\u8005\u3002\u6ce8\u518c\u5230Libuv\u4e2d\u3002\u7b49\u5230\u6709\u8bfb\u4e8b\u4ef6\u5230\u6765\uff08\u6709\u8fde\u63a5\u5230\u6765\uff09\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u51fd\u6570\uff0c\u6458\u4e0b\u5bf9\u5e94\u7684\u5ba2\u6237\u7aef\u8282\u70b9\u3002\u6700\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002 9.1.4 \u53d1\u8d77\u8fde\u63a5 \u00b6 \u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u542f\u52a8\u4e86\u4e00\u4e2aUnix\u57df\u670d\u52a1\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u770b\u5ba2\u6237\u7aef\u7684\u903b\u8f91\u3002 1. void uv_pipe_connect(uv_connect_t* req, 2. uv_pipe_t* handle, 3. const char* name, 4. uv_connect_cb cb) { 5. struct sockaddr_un saddr; 6. int new_sock; 7. int err; 8. int r; 9. // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u4e86\uff0c\u6ca1\u6709\u7684\u8bdd\u9700\u8981\u7533\u8bf7\u4e00\u4e2a\uff0c\u89c1\u4e0b\u9762 10. new_sock = (uv__stream_fd(handle) == -1); 11. // \u5ba2\u6237\u7aef\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684socket fd 12. if (new_sock) { 13. handle->io_watcher.fd= uv__socket(AF_UNIX, 14. SOCK_STREAM, 15. 0); 16. } 17. // \u9700\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u4fe1\u606f\u3002\u4e3b\u8981\u662fUnix\u57df\u8def\u5f84\u4fe1\u606f 18. memset(&saddr, 0, sizeof saddr); 19. strncpy(saddr.sun_path, name, sizeof(saddr.sun_path) - 1); 20. saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\0'; 21. saddr.sun_family = AF_UNIX; 22. // \u975e\u963b\u585e\u5f0f\u8fde\u63a5\u670d\u52a1\u5668\uff0cUnix\u57df\u8def\u5f84\u662fname 23. do { 24. r = connect(uv__stream_fd(handle), 25. (struct sockaddr*)&saddr, sizeof saddr); 26. } 27. while (r == -1 && errno == EINTR); 28. // \u5ffd\u7565\u9519\u8bef\u5904\u7406\u903b\u8f91 29. err = 0; 30. // \u8bbe\u7f6esocket\u7684\u53ef\u8bfb\u5199\u5c5e\u6027 31. if (new_sock) { 32. err = uv__stream_open((uv_stream_t*)handle, 33. uv__stream_fd(handle), 34. UV_HANDLE_READABLE | UV_HANDLE_WRITABLE); 35. } 36. // \u628aIO\u89c2\u5bdf\u8005\u6ce8\u518c\u5230Libuv\uff0c\u7b49\u5230\u8fde\u63a5\u6210\u529f\u6216\u8005\u53ef\u4ee5\u53d1\u9001\u8bf7\u6c42 37. if (err == 0) 38. uv__io_start(handle->loop, 39. &handle->io_watcher, 40. POLLIN | POLLOUT); 41. 42. out: 43. // \u8bb0\u5f55\u9519\u8bef\u7801\uff0c\u5982\u679c\u6709\u7684\u8bdd 44. handle->delayed_error = err; 45. // \u4fdd\u5b58\u8c03\u7528\u8005\u4fe1\u606f 46. handle->connect_req = req; 47. uv__req_init(handle->loop, req, UV_CONNECT); 48. req->handle = (uv_stream_t*)handle; 49. req->cb = cb; 50. QUEUE_INIT(&req->queue); 51. /* 52. \u5982\u679c\u8fde\u63a5\u51fa\u9519\uff0c\u5728pending\u9636\u6bb5\u4f1a\u6267\u884cuv__stream_io\uff0c 53. \u4ece\u800c\u6267\u884creq\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u9519\u8bef\u7801\u662fdelayed_error 54. */ 55. if (err) 56. uv__io_feed(handle->loop, &handle->io_watcher); 57. } uv_pipe_connect\u51fd\u6570\u9996\u5148\u4ee5\u975e\u963b\u585e\u7684\u65b9\u5f0f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u51fd\u6570\uff0c\u8c03\u7528connect\u540e\u64cd\u4f5c\u7cfb\u7edf\u628a\u5ba2\u6237\u7aef\u5bf9\u5e94\u7684socket\u76f4\u63a5\u63d2\u5165\u670d\u52a1\u5668socket\u7684\u5f85\u5904\u7406socket\u961f\u5217\u4e2d\uff0c\u7b49\u5f85\u670d\u52a1\u5668\u5904\u7406\u3002\u8fd9\u65f6\u5019socket\u662f\u5904\u4e8e\u8fde\u63a5\u4e2d\u7684\u72b6\u6001\uff0c\u5f53\u670d\u52a1\u5668\u8c03\u7528accept\u51fd\u6570\u5904\u7406\u8fde\u63a5\u65f6\uff0c\u4f1a\u4fee\u6539\u8fde\u63a5\u72b6\u6001\u4e3a\u5df2\u8fde\u63a5\uff08\u8fd9\u548cTCP\u4e0d\u4e00\u6837\uff0cTCP\u662f\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\u5c31\u4f1a\u4fee\u6539\u4e3a\u8fde\u63a5\u72b6\u6001\uff0c\u800c\u4e0d\u662faccept\u7684\u65f6\u5019\uff09\uff0c\u5e76\u4e14\u4f1a\u89e6\u53d1\u5ba2\u6237\u7aefsocket\u7684\u53ef\u5199\u4e8b\u4ef6\u3002\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u5c31\u4f1a\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03\uff08uv__stream_io\uff09\uff0c\u4ece\u800c\u6267\u884cC++\u548cJS\u7684\u56de\u8c03\u3002 9.1.5 \u5173\u95edUnix\u57df \u00b6 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_close\u5173\u95ed\u4e00\u4e2aUnix\u57dfhandle\u3002uv_close\u4e2d\u4f1a\u8c03\u7528uv__pipe_close\u3002 1. void uv__pipe_close(uv_pipe_t* handle) { 2. // \u5982\u679c\u662fUnix\u57df\u670d\u52a1\u5668\u5219\u9700\u8981\u5220\u9664Unix\u57df\u8def\u5f84\u5e76\u5220\u9664\u6307\u5411\u7684\u5806\u5185\u5b58 3. if (handle->pipe_fname) { 4. unlink(handle->pipe_fname); 5. uv__free((void*)handle->pipe_fname); 6. handle->pipe_fname = NULL; 7. } 8. // \u5173\u95ed\u6d41\u76f8\u5173\u7684\u5185\u5bb9 9. uv__stream_close((uv_stream_t*)handle); 10. } \u5173\u95edUnix\u57dfhandle\u65f6\uff0cLibuv\u4f1a\u81ea\u52a8\u5220\u9664Unix\u57df\u8def\u5f84\u5bf9\u5e94\u7684\u6587\u4ef6\u3002\u4f46\u662f\u5982\u679c\u8fdb\u7a0b\u5f02\u5e38\u9000\u51fa\u65f6\uff0c\u8be5\u6587\u4ef6\u53ef\u80fd\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u4e0b\u6b21\u76d1\u542c\u7684\u65f6\u5019\u62a5\u9519listen EADDRINUSE\uff0c\u6240\u4ee5\u5b89\u5168\u8d77\u89c1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8fdb\u7a0b\u9000\u51fa\u6216\u8005\u76d1\u542c\u4e4b\u524d\u5224\u65ad\u8be5\u6587\u4ef6\u662f\u5426\u5b58\u5728\uff0c\u5b58\u5728\u7684\u8bdd\u5219\u5220\u9664\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5982\u679c\u4e24\u4e2a\u4e0d\u76f8\u5173\u7684\u8fdb\u7a0b\u4f7f\u7528\u4e86\u540c\u4e00\u4e2a\u6587\u4ef6\u5219\u4f1a\u5bfc\u81f4\u8bef\u5220\uff0c\u6240\u4ee5Unix\u57df\u5bf9\u5e94\u7684\u6587\u4ef6\uff0c\u6211\u4eec\u9700\u8981\u5c0f\u5fc3\u5904\u7406\uff0c\u6700\u597d\u80fd\u4fdd\u8bc1\u552f\u4e00\u6027\u3002 Unix\u57df\u5927\u81f4\u7684\u6d41\u7a0b\u548c\u7f51\u7edc\u7f16\u7a0b\u4e00\u6837\u3002\u5206\u4e3a\u670d\u52a1\u7aef\u548c\u5ba2\u6237\u7aef\u4e24\u9762\u3002Libuv\u5728\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u7684\u57fa\u7840\u4e0a\u3002\u548cLibuv\u7684\u5f02\u6b65\u975e\u963b\u585e\u7ed3\u5408\u3002\u5728Libuv\u4e2d\u4e3a\u8fdb\u7a0b\u95f4\u63d0\u4f9b\u4e86\u4e00\u79cd\u901a\u4fe1\u65b9\u5f0f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u7684\u3002 9.2 Unix\u57df\u5728Node.js\u4e2d\u7684\u4f7f\u7528 \u00b6 9.2.1 Unix\u57df\u670d\u52a1\u5668 \u00b6 \u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 1. const server = net.createServer((client) => { 2. // \u5904\u7406client 3. }); 4. server.listen('/tmp/test.sock', () => { 5. console.log(`bind uinx domain success`); 6. }); \u6211\u4eec\u4ecelisten\u51fd\u6570\u5f00\u59cb\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1. Server.prototype.listen = function(...args) { 2. const normalized = normalizeArgs(args); 3. let options = normalized[0]; 4. const cb = normalized[1]; 5. // \u8c03\u7528\u5e95\u5c42\u7684listen\u51fd\u6570\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 6. if (cb !== null) { 7. this.once('listening', cb); 8. } 9. if (options.path && isPipeName(options.path)) { 10. const pipeName = this._pipeName = options.path; 11. backlog = options.backlog || backlogFromArgs; 12. listenIncluster(this, pipeName, -1, -1, backlog, undefined, 13. options.exclusive); 14. /* 15. Unix\u57df\u4f7f\u7528\u6587\u4ef6\u5b9e\u73b0\u7684\uff0c\u5ba2\u6237\u7aef\u9700\u8981\u8bbf\u95ee\u8be5\u6587\u4ef6\u7684\u6743\u9650\u624d\u80fd\u901a\u4fe1\uff0c 16. \u8fd9\u91cc\u505a\u6743\u9650\u63a7\u5236 17. */ 18. let mode = 0; 19. if (options.readableAll === true) 20. mode |= PipeConstants.UV_READABLE; 21. if (options.writableAll === true) 22. mode |= PipeConstants.UV_WRITABLE; 23. if (mode !== 0) { 24. // \u4fee\u6539\u6587\u4ef6\u7684\u8bbf\u95ee\u5c5e\u6027 25. const err = this._handle.fchmod(mode); 26. if (err) { 27. this._handle.close(); 28. this._handle = null; 29. throw errnoException(err, 'uv_pipe_chmod'); 30. } 31. } 32. return this; 33. } 34. } \u8fd9\u6bb5\u4ee3\u7801\u4e2d\u6700\u4e3b\u8981\u7684\u662flistenIncluster\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1. function listenIncluster(server, address, port, addressType, 2. backlog, fd, exclusive, flags) { 3. exclusive = !!exclusive; 4. if (cluster === undefined) cluster = require('cluster'); 5. if (cluster.isMaster || exclusive) { 6. server._listen2(address, port, addressType, backlog, fd, flags); 7. return; 8. } 9. } \u76f4\u63a5\u8c03\u7528_listen2\uff08isMaster\u53ea\u6709\u5728cluster.fork\u521b\u5efa\u7684\u8fdb\u7a0b\u4e2d\u624d\u662ffalse\uff0c\u5176\u4f59\u60c5\u51b5\u90fd\u662ftrue\uff0c\u5305\u62ecchild_process\u6a21\u5757\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\uff09\u3002\u6211\u4eec\u7ee7\u7eed\u770blisten\u51fd\u6570\u3002 1. Server.prototype._listen2 = setupListenHandle; 2. 3. function setupListenHandle(address, 4. port, 5. addressType, 6. backlog, 7. fd, 8. flags) { 9. this._handle = createServerHandle(address, 10. port, 11. addressType, 12. fd, 13. flags); 14. // \u6709\u5b8c\u6210\u8fde\u63a5\u5b8c\u6210\u65f6\u89e6\u53d1 15. this._handle.onconnection = onconnection; 16. const err = this._handle.listen(backlog || 511); 17. if (err) { 18. // \u89e6\u53d1error\u4e8b\u4ef6 19. } 20. // \u4e0b\u4e00\u4e2atick\u89e6\u53d1listen\u56de\u8c03 21. defaultTriggerAsyncIdScope(this[async_id_symbol], 22. process.nextTick, 23. emitListeningNT, 24. this); 25. } \u9996\u5148\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u6267\u884clisten\u51fd\u6570\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateServerHandle\u3002 26. function createServerHandle(address, 27. port, 28. addressType, 29. fd, 30. flags) { 31. let handle = new Pipe(PipeConstants.SERVER); 32. handle.bind(address, port); 33. return handle; 34. } \u521b\u5efa\u4e86\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528\u5b83\u7684bind\u548clisten\u51fd\u6570\uff0c\u6211\u4eec\u770bnew Pipe\u7684\u903b\u8f91\uff0c\u4ecepipe_wrap.cc\u7684\u5bfc\u51fa\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u8fd9\u65f6\u5019\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\uff0c\u5e76\u4e14\u628a\u65b0\u5efa\u7684C++\u5bf9\u8c61\u7b49\u4fe1\u606f\u4f5c\u4e3a\u5165\u53c2\u3002 1. void PipeWrap::New(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. // \u7c7b\u578b 4. int type_value = args[0].As<Int32>()->Value(); 5. PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value); 6. // \u662f\u5426\u662f\u7528\u4e8eIPC 7. bool ipc; 8. ProviderType provider; 9. switch (type) { 10. case SOCKET: 11. provider = PROVIDER_PIPEWRAP; 12. ipc = false; 13. break; 14. case SERVER: 15. provider = PROVIDER_PIPESERVERWRAP; 16. ipc = false; 17. break; 18. case IPC: 19. provider = PROVIDER_PIPEWRAP; 20. ipc = true; 21. break; 22. default: 23. UNREACHABLE(); 24. } 25. 26. new PipeWrap(env, args.This(), provider, ipc); 27. } New\u51fd\u6570\u5904\u7406\u4e86\u53c2\u6570\uff0c\u7136\u540e\u6267\u884c\u4e86new PipeWrap\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002 1. PipeWrap::PipeWrap(Environment* env, 2. Local<Object> object, 3. ProviderType provider, 4. bool ipc) 5. : ConnectionWrap(env, object, provider) { 6. int r = uv_pipe_init(env->event_loop(), &handle_, ipc); 7. } new Pipe\u6267\u884c\u5b8c\u540e\uff0c\u5c31\u4f1a\u901a\u8fc7\u8be5C++\u5bf9\u8c61\u8c03\u7528Libuv\u7684bind\u548clisten\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\uff0c\u5c31\u4e0d\u518d\u5c55\u5f00\u5206\u6790\u3002 9.2.2 Unix\u57df\u5ba2\u6237\u7aef \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bUnix\u57df\u4f5c\u4e3a\u5ba2\u6237\u7aef\u4f7f\u7528\u65f6\u7684\u8fc7\u7a0b\u3002 1. Socket.prototype.connect = function(...args) { 2. const path = options.path; 3. // Unix\u57df\u8def\u5f84 4. var pipe = !!path; 5. if (!this._handle) { 6. // \u521b\u5efa\u4e00\u4e2aC++\u5c42handle\uff0c\u5373pipe_wrap.cc\u5bfc\u51fa\u7684Pipe\u7c7b 7. this._handle = pipe ? 8. new Pipe(PipeConstants.SOCKET) : 9. new TCP(TCPConstants.SOCKET); 10. // \u6302\u8f7donread\u65b9\u6cd5\u5230this\u4e2d 11. initSocketHandle(this); 12. } 13. 14. if (cb !== null) { 15. this.once('connect', cb); 16. } 17. // \u6267\u884cinternalConnect 18. defaultTriggerAsyncIdScope( 19. this[async_id_symbol], internalConnect, this, path 20. ); 21. return this; 22. }; \u9996\u5148\u65b0\u5efa\u4e00\u4e2ahandle\uff0c\u503c\u662fnew Pipe\u3002\u63a5\u7740\u6267\u884c\u4e86internalConnect\uff0cinternalConnect\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1. const req = new PipeConnectWrap(); 2. // address\u4e3aUnix\u57df\u8def\u5f84 3. req.address = address; 4. req.oncomplete = afterConnect; 5. // \u8c03\u7528C++\u5c42connect 6. err = self._handle.connect(req, address, afterConnect); \u6211\u4eec\u770bC++\u5c42\u7684connect\u51fd\u6570\uff0c 1. void PipeWrap::Connect(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. PipeWrap* wrap; 5. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 6. // PipeConnectWrap\u5bf9\u8c61 7. Local<Object> req_wrap_obj = args[0].As<Object>(); 8. // Unix\u57df\u8def\u5f84 9. node::Utf8Value name(env->isolate(), args[1]); 10. /* 11. \u65b0\u5efa\u4e00\u4e2aConnectWrap\u5bf9\u8c61\uff0cConnectWrap\u662f\u5bf9handle\u8fdb\u884c\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 12. \u7684\u5c01\u88c5\uff0c\u5185\u90e8\u7ef4\u62a4\u4e00\u4e2auv_connect_t\u7ed3\u6784\u4f53\uff0c req_wrap_obj\u7684\u4e00\u4e2a\u5b57\u6bb5 13. \u6307\u5411ConnectWrap\u5bf9\u8c61\uff0c\u7528\u4e8e\u4fdd\u5b58\u5bf9\u5e94\u7684\u8bf7\u6c42\u4e0a\u4e0b\u6587 14. */ 15. ConnectWrap* req_wrap = 16. new ConnectWrap(env, 17. req_wrap_obj, 18. AsyncWrap::PROVIDER_PIPECONNECTWRAP); 19. // \u8c03\u7528Libuv\u7684connect\u51fd\u6570 20. uv_pipe_connect(req_wrap->req(), 21. &wrap->handle_, 22. *name, 23. AfterConnect); 24. // req_wrap->req_.data = req_wrap;\u5173\u8054\u8d77\u6765 25. req_wrap->Dispatched(); 26. // uv_pipe_connect() doesn't return errors. 27. args.GetReturnValue().Set(0); 28. } uv_pipe_connect\u51fd\u6570\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fuv_connect_t\u7ed3\u6784\u4f53\uff08request\uff09\uff0c\u7b2c\u4e8c\u4e2a\u662f\u4e00\u4e2auv_pipe_t\u7ed3\u6784\u4f53\uff08handle\uff09\uff0chandle\u662f\u5bf9Unix\u57df\u5ba2\u6237\u7aef\u7684\u5c01\u88c5\uff0crequest\u662f\u8bf7\u6c42\u7684\u5c01\u88c5\uff0c\u5b83\u8868\u793a\u57fa\u4e8ehandle\u53d1\u8d77\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42\u3002\u8fde\u63a5\u6210\u529f\u540e\u4f1a\u6267\u884cAfterConnect\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u8fde\u63a5\u6210\u529f\u65f6\uff0c\u9996\u5148\u4f1a\u6267\u884c\u56de\u8c03Libuv\u7684uv__stream_io\uff0c\u7136\u540e\u6267\u884cC++\u5c42\u7684AfterConnect\u3002 1. // \u4e3b\u52a8\u53d1\u8d77\u8fde\u63a5\uff0c\u6210\u529f/\u5931\u8d25\u540e\u7684\u56de\u8c03 2. template <typename WrapType,typename UVType> = PipeWrap, uv_pipe_t 3. void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req 4. ,int status) { 5. // \u5728Connect\u51fd\u6570\u91cc\u5173\u8054\u8d77\u6765\u7684 6. ConnectWrap* req_wrap = static_cast<ConnectWrap*>(req->data); 7. // \u5728uv_pipe_connect\u4e2d\u5b8c\u6210\u5173\u8054\u7684 8. WrapType* wrap = static_cast<WrapType*>(req->handle->data); 9. Environment* env = wrap->env(); 10. 11. HandleScope handle_scope(env->isolate()); 12. Context::Scope context_scope(env->context()); 13. 14. bool readable, writable; 15. // \u662f\u5426\u8fde\u63a5\u6210\u529f 16. if (status) { 17. readable = writable = 0; 18. } else { 19. readable = uv_is_readable(req->handle) != 0; 20. writable = uv_is_writable(req->handle) != 0; 21. } 22. 23. Local<Value> argv[5] = { 24. Integer::New(env->isolate(), status), 25. wrap->object(), 26. req_wrap->object(), 27. Boolean::New(env->isolate(), readable), 28. Boolean::New(env->isolate(), writable) 29. }; 30. // \u6267\u884cJS\u5c42\u7684oncomplete\u56de\u8c03 31. req_wrap->MakeCallback(env->oncomplete_string(), 32. arraysize(argv), 33. argv); 34. 35. delete req_wrap; 36. } \u6211\u4eec\u518d\u56de\u5230JS\u5c42\u7684afterConnect 1. function afterConnect(status, handle, req, readable, writable) { 2. var self = handle.owner; 3. handle = self._handle; 4. if (status === 0) { 5. self.readable = readable; 6. self.writable = writable; 7. self._unrefTimer(); 8. // \u89e6\u53d1connect\u4e8b\u4ef6 9. self.emit('connect'); 10. // \u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u5904\u4e8e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 11. if (readable && !self.isPaused()) 12. self.read(0); 13. } 14. } \u81f3\u6b64\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u5bf9\u670d\u52a1\u5668\u7684\u8fde\u63a5\u5c31\u5b8c\u6210\u4e86\u3002\u540e\u7eed\u5c31\u53ef\u4ee5\u8fdb\u884c\u901a\u4fe1\u3002","title":"09-Unix\u57df"},{"location":"chapter09-Unix%E5%9F%9F/#91-unixlibuv","text":"\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\u5728Libuv\u4e2d\u5173\u4e8eUnix\u57df\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\u3002","title":"9.1 Unix\u57df\u5728Libuv\u4e2d\u7684\u4f7f\u7528"},{"location":"chapter09-Unix%E5%9F%9F/#911","text":"Unix\u57df\u4f7f\u7528uv_pipe_t\u7ed3\u6784\u4f53\u8868\u793a\uff0c\u4f7f\u7528\u4e4b\u524d\u9996\u5148\u9700\u8981\u521d\u59cb\u5316uv_pipe_t\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u903b\u8f91\u3002 1. int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) { 2. uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE); 3. handle->shutdown_req = NULL; 4. handle->connect_req = NULL; 5. handle->pipe_fname = NULL; 6. handle->ipc = ipc; 7. return 0; 8. } uv_pipe_init\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u521d\u59cb\u5316uv_pipe_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002uv_pipe_t\u7ee7\u627f\u4e8estream\uff0cuv__stream_init\u5c31\u662f\u521d\u59cb\u5316stream\uff08\u7236\u7c7b\uff09\u7684\u5b57\u6bb5\u3002uv_pipe_t\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5ipc\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u4e86\u662f\u5426\u5141\u8bb8\u5728\u8be5Unix\u57df\u901a\u4fe1\u4e2d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"9.1.1 \u521d\u59cb\u5316"},{"location":"chapter09-Unix%E5%9F%9F/#912-unix","text":"\u5f00\u5934\u8bf4\u8fc7\uff0cUnix\u57df\u7684\u5b9e\u73b0\u7c7b\u4f3cTCP\u7684\u5b9e\u73b0\u3002\u9075\u5faa\u7f51\u7edcsocket\u7f16\u7a0b\u90a3\u4e00\u5957\u6d41\u7a0b\u3002\u670d\u52a1\u7aef\u4f7f\u7528bind\uff0clisten\u7b49\u51fd\u6570\u542f\u52a8\u670d\u52a1\u3002 1. // name\u662funix\u8def\u5f84\u540d\u79f0 2. int uv_pipe_bind(uv_pipe_t* handle, const char* name) { 3. struct sockaddr_un saddr; 4. const char* pipe_fname; 5. int sockfd; 6. int err; 7. pipe_fname = NULL; 8. pipe_fname = uv__strdup(name); 9. name = NULL; 10. // \u6d41\u5f0fUnix\u57df\u5957\u63a5\u5b57 11. sockfd = uv__socket(AF_UNIX, SOCK_STREAM, 0); 12. memset(&saddr, 0, sizeof saddr); 13. strncpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path) - 1); 14. saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\0'; 15. saddr.sun_family = AF_UNIX; 16. // \u7ed1\u5b9a\u5230\u8def\u5f84\uff0cTCP\u662f\u7ed1\u5b9a\u5230IP\u548c\u7aef\u53e3 17. if (bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr)) { 18. // ... 19. } 20. 21. // \u8bbe\u7f6e\u7ed1\u5b9a\u6210\u529f\u6807\u8bb0 22. handle->flags |= UV_HANDLE_BOUND; 23. // Unix\u57df\u7684\u8def\u5f84 24. handle->pipe_fname = pipe_fname; 25. // \u4fdd\u5b58socket\u5bf9\u5e94\u7684fd 26. handle->io_watcher.fd = sockfd; 27. return 0; 28. } uv_pipe_bind\u51fd\u6570\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684bind\u51fd\u6570\u628aUnix\u57df\u8def\u5f84\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6700\u540e\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u6807\u8bb0\uff0c\u5e76\u4e14\u4fdd\u5b58Unix\u57df\u7684\u8def\u5f84\u548csocket\u5bf9\u5e94\u7684fd\u5230handle\u4e2d\uff0c\u540e\u7eed\u9700\u8981\u4f7f\u7528\u3002\u6211\u4eec\u770b\u5230Node.js\u4e2dUnix\u57df\u7684\u7c7b\u578b\u662fSOCK_STREAM\u3002Unix\u57df\u652f\u6301\u4e24\u79cd\u6570\u636e\u6a21\u5f0f\u3002 1 \u6d41\u5f0f\uff08 SOCK_STREAM\uff09\uff0c\u7c7b\u4f3cTCP\uff0c\u6570\u636e\u4e3a\u5b57\u8282\u6d41\uff0c\u9700\u8981\u5e94\u7528\u5c42\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 2 \u6570\u636e\u62a5\u6a21\u5f0f\uff08 SOCK_DGRAM \uff09\uff0c\u7c7b\u4f3cUDP\uff0c\u4e0d\u9700\u8981\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 \u901a\u8fc7Unix\u57df\u867d\u7136\u53ef\u4ee5\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\uff0c\u4f46\u662f\u6211\u4eec\u62ff\u5230\u7684\u6570\u636e\u53ef\u80fd\u662f\"\u4e71\u7684\"\uff0c\u8fd9\u662f\u4e3a\u4ec0\u4e48\u5462\uff1f\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u670d\u52a1\u5668\u5904\u7406\uff0c\u5982\u679c\u662f\u57fa\u4e8e\u8fd9\u79cd\u573a\u666f\uff0c\u90a3\u4e48\u6570\u636e\u5c31\u4e0d\u4f1a\u662f\u4e71\u7684\u3002\u56e0\u4e3a\u6bcf\u6b21\u5c31\u662f\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u6570\u636e\u5355\u4f4d\u3002\u4f46\u662f\u5982\u679c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u670d\u52a1\u5668\u8fd8\u6ca1\u6765\u5f97\u53ca\u5904\u7406\uff0c\u5ba2\u6237\u7aef\u53c8\u53d1\u9001\u4e86\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u518d\u5904\u7406\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u56e0\u4e3a\u4e24\u4e2a\u5b57\u8282\u6df7\u4e00\u8d77\u4e86\u3002\u5c31\u597d\u6bd4\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u5148\u540e\u53d1\u9001\u4e24\u4e2aHTTP\u8bf7\u6c42\u4e00\u6837\uff0c\u5982\u679c\u670d\u52a1\u5668\u6ca1\u6709\u529e\u6cd5\u5224\u65ad\u4e24\u4e2a\u8bf7\u6c42\u7684\u6570\u636e\u8fb9\u754c\uff0c\u90a3\u4e48\u5904\u7406\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u5e76\u4e14\u5b9e\u73b0\u5c01\u5305\u89e3\u5305\u7684\u903b\u8f91\uff0c\u624d\u80fd\u771f\u6b63\u5b8c\u6210\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002","title":"9.1.2 \u7ed1\u5b9aUnix\u57df\u8def\u5f84"},{"location":"chapter09-Unix%E5%9F%9F/#913","text":"\u7ed1\u5b9a\u4e86\u8def\u5f84\u540e\uff0c\u5c31\u53ef\u4ee5\u8c03\u7528listen\u51fd\u6570\u4f7f\u5f97socket\u5904\u4e8e\u76d1\u542c\u72b6\u6001\u3002 1. int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) { 2. // uv__stream_fd(handle)\u5f97\u5230bind\u51fd\u6570\u4e2d\u83b7\u53d6\u7684socket 3. if (listen(uv__stream_fd(handle), backlog)) 4. return UV__ERR(errno); 5. // \u4fdd\u5b58\u56de\u8c03\uff0c\u6709\u8fdb\u7a0b\u8c03\u7528connect\u7684\u65f6\u5019\u65f6\u89e6\u53d1\uff0c\u7531uv__server_io\u51fd\u6570\u89e6\u53d1 6. handle->connection_cb = cb; 7. // IO\u89c2\u5bdf\u8005\u7684\u56de\u8c03 8. handle->io_watcher.cb = uv__server_io; 9. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230Libuv\uff0c\u7b49\u5f85\u8fde\u63a5\uff0c\u5373\u8bfb\u4e8b\u4ef6\u5230\u6765 10. uv__io_start(handle->loop, &handle->io_watcher, POLLIN); 11. return 0; 12. } uv_pipe_listen\u6267\u884c\u64cd\u4f5c\u7cfb\u7edf\u7684listen\u51fd\u6570\u4f7f\u5f97socket\u6210\u4e3a\u76d1\u542c\u578b\u7684\u5957\u63a5\u5b57\u3002\u7136\u540e\u628asocket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u56de\u8c03\u5c01\u88c5\u6210IO\u89c2\u5bdf\u8005\u3002\u6ce8\u518c\u5230Libuv\u4e2d\u3002\u7b49\u5230\u6709\u8bfb\u4e8b\u4ef6\u5230\u6765\uff08\u6709\u8fde\u63a5\u5230\u6765\uff09\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u51fd\u6570\uff0c\u6458\u4e0b\u5bf9\u5e94\u7684\u5ba2\u6237\u7aef\u8282\u70b9\u3002\u6700\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002","title":"9.1.3 \u542f\u52a8\u670d\u52a1"},{"location":"chapter09-Unix%E5%9F%9F/#914","text":"\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u542f\u52a8\u4e86\u4e00\u4e2aUnix\u57df\u670d\u52a1\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u770b\u5ba2\u6237\u7aef\u7684\u903b\u8f91\u3002 1. void uv_pipe_connect(uv_connect_t* req, 2. uv_pipe_t* handle, 3. const char* name, 4. uv_connect_cb cb) { 5. struct sockaddr_un saddr; 6. int new_sock; 7. int err; 8. int r; 9. // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u4e86\uff0c\u6ca1\u6709\u7684\u8bdd\u9700\u8981\u7533\u8bf7\u4e00\u4e2a\uff0c\u89c1\u4e0b\u9762 10. new_sock = (uv__stream_fd(handle) == -1); 11. // \u5ba2\u6237\u7aef\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684socket fd 12. if (new_sock) { 13. handle->io_watcher.fd= uv__socket(AF_UNIX, 14. SOCK_STREAM, 15. 0); 16. } 17. // \u9700\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u4fe1\u606f\u3002\u4e3b\u8981\u662fUnix\u57df\u8def\u5f84\u4fe1\u606f 18. memset(&saddr, 0, sizeof saddr); 19. strncpy(saddr.sun_path, name, sizeof(saddr.sun_path) - 1); 20. saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\0'; 21. saddr.sun_family = AF_UNIX; 22. // \u975e\u963b\u585e\u5f0f\u8fde\u63a5\u670d\u52a1\u5668\uff0cUnix\u57df\u8def\u5f84\u662fname 23. do { 24. r = connect(uv__stream_fd(handle), 25. (struct sockaddr*)&saddr, sizeof saddr); 26. } 27. while (r == -1 && errno == EINTR); 28. // \u5ffd\u7565\u9519\u8bef\u5904\u7406\u903b\u8f91 29. err = 0; 30. // \u8bbe\u7f6esocket\u7684\u53ef\u8bfb\u5199\u5c5e\u6027 31. if (new_sock) { 32. err = uv__stream_open((uv_stream_t*)handle, 33. uv__stream_fd(handle), 34. UV_HANDLE_READABLE | UV_HANDLE_WRITABLE); 35. } 36. // \u628aIO\u89c2\u5bdf\u8005\u6ce8\u518c\u5230Libuv\uff0c\u7b49\u5230\u8fde\u63a5\u6210\u529f\u6216\u8005\u53ef\u4ee5\u53d1\u9001\u8bf7\u6c42 37. if (err == 0) 38. uv__io_start(handle->loop, 39. &handle->io_watcher, 40. POLLIN | POLLOUT); 41. 42. out: 43. // \u8bb0\u5f55\u9519\u8bef\u7801\uff0c\u5982\u679c\u6709\u7684\u8bdd 44. handle->delayed_error = err; 45. // \u4fdd\u5b58\u8c03\u7528\u8005\u4fe1\u606f 46. handle->connect_req = req; 47. uv__req_init(handle->loop, req, UV_CONNECT); 48. req->handle = (uv_stream_t*)handle; 49. req->cb = cb; 50. QUEUE_INIT(&req->queue); 51. /* 52. \u5982\u679c\u8fde\u63a5\u51fa\u9519\uff0c\u5728pending\u9636\u6bb5\u4f1a\u6267\u884cuv__stream_io\uff0c 53. \u4ece\u800c\u6267\u884creq\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u9519\u8bef\u7801\u662fdelayed_error 54. */ 55. if (err) 56. uv__io_feed(handle->loop, &handle->io_watcher); 57. } uv_pipe_connect\u51fd\u6570\u9996\u5148\u4ee5\u975e\u963b\u585e\u7684\u65b9\u5f0f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u51fd\u6570\uff0c\u8c03\u7528connect\u540e\u64cd\u4f5c\u7cfb\u7edf\u628a\u5ba2\u6237\u7aef\u5bf9\u5e94\u7684socket\u76f4\u63a5\u63d2\u5165\u670d\u52a1\u5668socket\u7684\u5f85\u5904\u7406socket\u961f\u5217\u4e2d\uff0c\u7b49\u5f85\u670d\u52a1\u5668\u5904\u7406\u3002\u8fd9\u65f6\u5019socket\u662f\u5904\u4e8e\u8fde\u63a5\u4e2d\u7684\u72b6\u6001\uff0c\u5f53\u670d\u52a1\u5668\u8c03\u7528accept\u51fd\u6570\u5904\u7406\u8fde\u63a5\u65f6\uff0c\u4f1a\u4fee\u6539\u8fde\u63a5\u72b6\u6001\u4e3a\u5df2\u8fde\u63a5\uff08\u8fd9\u548cTCP\u4e0d\u4e00\u6837\uff0cTCP\u662f\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\u5c31\u4f1a\u4fee\u6539\u4e3a\u8fde\u63a5\u72b6\u6001\uff0c\u800c\u4e0d\u662faccept\u7684\u65f6\u5019\uff09\uff0c\u5e76\u4e14\u4f1a\u89e6\u53d1\u5ba2\u6237\u7aefsocket\u7684\u53ef\u5199\u4e8b\u4ef6\u3002\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u5c31\u4f1a\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03\uff08uv__stream_io\uff09\uff0c\u4ece\u800c\u6267\u884cC++\u548cJS\u7684\u56de\u8c03\u3002","title":"9.1.4 \u53d1\u8d77\u8fde\u63a5"},{"location":"chapter09-Unix%E5%9F%9F/#915-unix","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_close\u5173\u95ed\u4e00\u4e2aUnix\u57dfhandle\u3002uv_close\u4e2d\u4f1a\u8c03\u7528uv__pipe_close\u3002 1. void uv__pipe_close(uv_pipe_t* handle) { 2. // \u5982\u679c\u662fUnix\u57df\u670d\u52a1\u5668\u5219\u9700\u8981\u5220\u9664Unix\u57df\u8def\u5f84\u5e76\u5220\u9664\u6307\u5411\u7684\u5806\u5185\u5b58 3. if (handle->pipe_fname) { 4. unlink(handle->pipe_fname); 5. uv__free((void*)handle->pipe_fname); 6. handle->pipe_fname = NULL; 7. } 8. // \u5173\u95ed\u6d41\u76f8\u5173\u7684\u5185\u5bb9 9. uv__stream_close((uv_stream_t*)handle); 10. } \u5173\u95edUnix\u57dfhandle\u65f6\uff0cLibuv\u4f1a\u81ea\u52a8\u5220\u9664Unix\u57df\u8def\u5f84\u5bf9\u5e94\u7684\u6587\u4ef6\u3002\u4f46\u662f\u5982\u679c\u8fdb\u7a0b\u5f02\u5e38\u9000\u51fa\u65f6\uff0c\u8be5\u6587\u4ef6\u53ef\u80fd\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u4e0b\u6b21\u76d1\u542c\u7684\u65f6\u5019\u62a5\u9519listen EADDRINUSE\uff0c\u6240\u4ee5\u5b89\u5168\u8d77\u89c1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8fdb\u7a0b\u9000\u51fa\u6216\u8005\u76d1\u542c\u4e4b\u524d\u5224\u65ad\u8be5\u6587\u4ef6\u662f\u5426\u5b58\u5728\uff0c\u5b58\u5728\u7684\u8bdd\u5219\u5220\u9664\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5982\u679c\u4e24\u4e2a\u4e0d\u76f8\u5173\u7684\u8fdb\u7a0b\u4f7f\u7528\u4e86\u540c\u4e00\u4e2a\u6587\u4ef6\u5219\u4f1a\u5bfc\u81f4\u8bef\u5220\uff0c\u6240\u4ee5Unix\u57df\u5bf9\u5e94\u7684\u6587\u4ef6\uff0c\u6211\u4eec\u9700\u8981\u5c0f\u5fc3\u5904\u7406\uff0c\u6700\u597d\u80fd\u4fdd\u8bc1\u552f\u4e00\u6027\u3002 Unix\u57df\u5927\u81f4\u7684\u6d41\u7a0b\u548c\u7f51\u7edc\u7f16\u7a0b\u4e00\u6837\u3002\u5206\u4e3a\u670d\u52a1\u7aef\u548c\u5ba2\u6237\u7aef\u4e24\u9762\u3002Libuv\u5728\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u7684\u57fa\u7840\u4e0a\u3002\u548cLibuv\u7684\u5f02\u6b65\u975e\u963b\u585e\u7ed3\u5408\u3002\u5728Libuv\u4e2d\u4e3a\u8fdb\u7a0b\u95f4\u63d0\u4f9b\u4e86\u4e00\u79cd\u901a\u4fe1\u65b9\u5f0f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u7684\u3002","title":"9.1.5 \u5173\u95edUnix\u57df"},{"location":"chapter09-Unix%E5%9F%9F/#92-unixnodejs","text":"","title":"9.2 Unix\u57df\u5728Node.js\u4e2d\u7684\u4f7f\u7528"},{"location":"chapter09-Unix%E5%9F%9F/#921-unix","text":"\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 1. const server = net.createServer((client) => { 2. // \u5904\u7406client 3. }); 4. server.listen('/tmp/test.sock', () => { 5. console.log(`bind uinx domain success`); 6. }); \u6211\u4eec\u4ecelisten\u51fd\u6570\u5f00\u59cb\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1. Server.prototype.listen = function(...args) { 2. const normalized = normalizeArgs(args); 3. let options = normalized[0]; 4. const cb = normalized[1]; 5. // \u8c03\u7528\u5e95\u5c42\u7684listen\u51fd\u6570\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 6. if (cb !== null) { 7. this.once('listening', cb); 8. } 9. if (options.path && isPipeName(options.path)) { 10. const pipeName = this._pipeName = options.path; 11. backlog = options.backlog || backlogFromArgs; 12. listenIncluster(this, pipeName, -1, -1, backlog, undefined, 13. options.exclusive); 14. /* 15. Unix\u57df\u4f7f\u7528\u6587\u4ef6\u5b9e\u73b0\u7684\uff0c\u5ba2\u6237\u7aef\u9700\u8981\u8bbf\u95ee\u8be5\u6587\u4ef6\u7684\u6743\u9650\u624d\u80fd\u901a\u4fe1\uff0c 16. \u8fd9\u91cc\u505a\u6743\u9650\u63a7\u5236 17. */ 18. let mode = 0; 19. if (options.readableAll === true) 20. mode |= PipeConstants.UV_READABLE; 21. if (options.writableAll === true) 22. mode |= PipeConstants.UV_WRITABLE; 23. if (mode !== 0) { 24. // \u4fee\u6539\u6587\u4ef6\u7684\u8bbf\u95ee\u5c5e\u6027 25. const err = this._handle.fchmod(mode); 26. if (err) { 27. this._handle.close(); 28. this._handle = null; 29. throw errnoException(err, 'uv_pipe_chmod'); 30. } 31. } 32. return this; 33. } 34. } \u8fd9\u6bb5\u4ee3\u7801\u4e2d\u6700\u4e3b\u8981\u7684\u662flistenIncluster\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1. function listenIncluster(server, address, port, addressType, 2. backlog, fd, exclusive, flags) { 3. exclusive = !!exclusive; 4. if (cluster === undefined) cluster = require('cluster'); 5. if (cluster.isMaster || exclusive) { 6. server._listen2(address, port, addressType, backlog, fd, flags); 7. return; 8. } 9. } \u76f4\u63a5\u8c03\u7528_listen2\uff08isMaster\u53ea\u6709\u5728cluster.fork\u521b\u5efa\u7684\u8fdb\u7a0b\u4e2d\u624d\u662ffalse\uff0c\u5176\u4f59\u60c5\u51b5\u90fd\u662ftrue\uff0c\u5305\u62ecchild_process\u6a21\u5757\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\uff09\u3002\u6211\u4eec\u7ee7\u7eed\u770blisten\u51fd\u6570\u3002 1. Server.prototype._listen2 = setupListenHandle; 2. 3. function setupListenHandle(address, 4. port, 5. addressType, 6. backlog, 7. fd, 8. flags) { 9. this._handle = createServerHandle(address, 10. port, 11. addressType, 12. fd, 13. flags); 14. // \u6709\u5b8c\u6210\u8fde\u63a5\u5b8c\u6210\u65f6\u89e6\u53d1 15. this._handle.onconnection = onconnection; 16. const err = this._handle.listen(backlog || 511); 17. if (err) { 18. // \u89e6\u53d1error\u4e8b\u4ef6 19. } 20. // \u4e0b\u4e00\u4e2atick\u89e6\u53d1listen\u56de\u8c03 21. defaultTriggerAsyncIdScope(this[async_id_symbol], 22. process.nextTick, 23. emitListeningNT, 24. this); 25. } \u9996\u5148\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u6267\u884clisten\u51fd\u6570\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateServerHandle\u3002 26. function createServerHandle(address, 27. port, 28. addressType, 29. fd, 30. flags) { 31. let handle = new Pipe(PipeConstants.SERVER); 32. handle.bind(address, port); 33. return handle; 34. } \u521b\u5efa\u4e86\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528\u5b83\u7684bind\u548clisten\u51fd\u6570\uff0c\u6211\u4eec\u770bnew Pipe\u7684\u903b\u8f91\uff0c\u4ecepipe_wrap.cc\u7684\u5bfc\u51fa\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u8fd9\u65f6\u5019\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\uff0c\u5e76\u4e14\u628a\u65b0\u5efa\u7684C++\u5bf9\u8c61\u7b49\u4fe1\u606f\u4f5c\u4e3a\u5165\u53c2\u3002 1. void PipeWrap::New(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. // \u7c7b\u578b 4. int type_value = args[0].As<Int32>()->Value(); 5. PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value); 6. // \u662f\u5426\u662f\u7528\u4e8eIPC 7. bool ipc; 8. ProviderType provider; 9. switch (type) { 10. case SOCKET: 11. provider = PROVIDER_PIPEWRAP; 12. ipc = false; 13. break; 14. case SERVER: 15. provider = PROVIDER_PIPESERVERWRAP; 16. ipc = false; 17. break; 18. case IPC: 19. provider = PROVIDER_PIPEWRAP; 20. ipc = true; 21. break; 22. default: 23. UNREACHABLE(); 24. } 25. 26. new PipeWrap(env, args.This(), provider, ipc); 27. } New\u51fd\u6570\u5904\u7406\u4e86\u53c2\u6570\uff0c\u7136\u540e\u6267\u884c\u4e86new PipeWrap\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002 1. PipeWrap::PipeWrap(Environment* env, 2. Local<Object> object, 3. ProviderType provider, 4. bool ipc) 5. : ConnectionWrap(env, object, provider) { 6. int r = uv_pipe_init(env->event_loop(), &handle_, ipc); 7. } new Pipe\u6267\u884c\u5b8c\u540e\uff0c\u5c31\u4f1a\u901a\u8fc7\u8be5C++\u5bf9\u8c61\u8c03\u7528Libuv\u7684bind\u548clisten\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\uff0c\u5c31\u4e0d\u518d\u5c55\u5f00\u5206\u6790\u3002","title":"9.2.1 Unix\u57df\u670d\u52a1\u5668"},{"location":"chapter09-Unix%E5%9F%9F/#922-unix","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bUnix\u57df\u4f5c\u4e3a\u5ba2\u6237\u7aef\u4f7f\u7528\u65f6\u7684\u8fc7\u7a0b\u3002 1. Socket.prototype.connect = function(...args) { 2. const path = options.path; 3. // Unix\u57df\u8def\u5f84 4. var pipe = !!path; 5. if (!this._handle) { 6. // \u521b\u5efa\u4e00\u4e2aC++\u5c42handle\uff0c\u5373pipe_wrap.cc\u5bfc\u51fa\u7684Pipe\u7c7b 7. this._handle = pipe ? 8. new Pipe(PipeConstants.SOCKET) : 9. new TCP(TCPConstants.SOCKET); 10. // \u6302\u8f7donread\u65b9\u6cd5\u5230this\u4e2d 11. initSocketHandle(this); 12. } 13. 14. if (cb !== null) { 15. this.once('connect', cb); 16. } 17. // \u6267\u884cinternalConnect 18. defaultTriggerAsyncIdScope( 19. this[async_id_symbol], internalConnect, this, path 20. ); 21. return this; 22. }; \u9996\u5148\u65b0\u5efa\u4e00\u4e2ahandle\uff0c\u503c\u662fnew Pipe\u3002\u63a5\u7740\u6267\u884c\u4e86internalConnect\uff0cinternalConnect\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1. const req = new PipeConnectWrap(); 2. // address\u4e3aUnix\u57df\u8def\u5f84 3. req.address = address; 4. req.oncomplete = afterConnect; 5. // \u8c03\u7528C++\u5c42connect 6. err = self._handle.connect(req, address, afterConnect); \u6211\u4eec\u770bC++\u5c42\u7684connect\u51fd\u6570\uff0c 1. void PipeWrap::Connect(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. PipeWrap* wrap; 5. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 6. // PipeConnectWrap\u5bf9\u8c61 7. Local<Object> req_wrap_obj = args[0].As<Object>(); 8. // Unix\u57df\u8def\u5f84 9. node::Utf8Value name(env->isolate(), args[1]); 10. /* 11. \u65b0\u5efa\u4e00\u4e2aConnectWrap\u5bf9\u8c61\uff0cConnectWrap\u662f\u5bf9handle\u8fdb\u884c\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 12. \u7684\u5c01\u88c5\uff0c\u5185\u90e8\u7ef4\u62a4\u4e00\u4e2auv_connect_t\u7ed3\u6784\u4f53\uff0c req_wrap_obj\u7684\u4e00\u4e2a\u5b57\u6bb5 13. \u6307\u5411ConnectWrap\u5bf9\u8c61\uff0c\u7528\u4e8e\u4fdd\u5b58\u5bf9\u5e94\u7684\u8bf7\u6c42\u4e0a\u4e0b\u6587 14. */ 15. ConnectWrap* req_wrap = 16. new ConnectWrap(env, 17. req_wrap_obj, 18. AsyncWrap::PROVIDER_PIPECONNECTWRAP); 19. // \u8c03\u7528Libuv\u7684connect\u51fd\u6570 20. uv_pipe_connect(req_wrap->req(), 21. &wrap->handle_, 22. *name, 23. AfterConnect); 24. // req_wrap->req_.data = req_wrap;\u5173\u8054\u8d77\u6765 25. req_wrap->Dispatched(); 26. // uv_pipe_connect() doesn't return errors. 27. args.GetReturnValue().Set(0); 28. } uv_pipe_connect\u51fd\u6570\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fuv_connect_t\u7ed3\u6784\u4f53\uff08request\uff09\uff0c\u7b2c\u4e8c\u4e2a\u662f\u4e00\u4e2auv_pipe_t\u7ed3\u6784\u4f53\uff08handle\uff09\uff0chandle\u662f\u5bf9Unix\u57df\u5ba2\u6237\u7aef\u7684\u5c01\u88c5\uff0crequest\u662f\u8bf7\u6c42\u7684\u5c01\u88c5\uff0c\u5b83\u8868\u793a\u57fa\u4e8ehandle\u53d1\u8d77\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42\u3002\u8fde\u63a5\u6210\u529f\u540e\u4f1a\u6267\u884cAfterConnect\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u8fde\u63a5\u6210\u529f\u65f6\uff0c\u9996\u5148\u4f1a\u6267\u884c\u56de\u8c03Libuv\u7684uv__stream_io\uff0c\u7136\u540e\u6267\u884cC++\u5c42\u7684AfterConnect\u3002 1. // \u4e3b\u52a8\u53d1\u8d77\u8fde\u63a5\uff0c\u6210\u529f/\u5931\u8d25\u540e\u7684\u56de\u8c03 2. template <typename WrapType,typename UVType> = PipeWrap, uv_pipe_t 3. void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req 4. ,int status) { 5. // \u5728Connect\u51fd\u6570\u91cc\u5173\u8054\u8d77\u6765\u7684 6. ConnectWrap* req_wrap = static_cast<ConnectWrap*>(req->data); 7. // \u5728uv_pipe_connect\u4e2d\u5b8c\u6210\u5173\u8054\u7684 8. WrapType* wrap = static_cast<WrapType*>(req->handle->data); 9. Environment* env = wrap->env(); 10. 11. HandleScope handle_scope(env->isolate()); 12. Context::Scope context_scope(env->context()); 13. 14. bool readable, writable; 15. // \u662f\u5426\u8fde\u63a5\u6210\u529f 16. if (status) { 17. readable = writable = 0; 18. } else { 19. readable = uv_is_readable(req->handle) != 0; 20. writable = uv_is_writable(req->handle) != 0; 21. } 22. 23. Local<Value> argv[5] = { 24. Integer::New(env->isolate(), status), 25. wrap->object(), 26. req_wrap->object(), 27. Boolean::New(env->isolate(), readable), 28. Boolean::New(env->isolate(), writable) 29. }; 30. // \u6267\u884cJS\u5c42\u7684oncomplete\u56de\u8c03 31. req_wrap->MakeCallback(env->oncomplete_string(), 32. arraysize(argv), 33. argv); 34. 35. delete req_wrap; 36. } \u6211\u4eec\u518d\u56de\u5230JS\u5c42\u7684afterConnect 1. function afterConnect(status, handle, req, readable, writable) { 2. var self = handle.owner; 3. handle = self._handle; 4. if (status === 0) { 5. self.readable = readable; 6. self.writable = writable; 7. self._unrefTimer(); 8. // \u89e6\u53d1connect\u4e8b\u4ef6 9. self.emit('connect'); 10. // \u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u5904\u4e8e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 11. if (readable && !self.isPaused()) 12. self.read(0); 13. } 14. } \u81f3\u6b64\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u5bf9\u670d\u52a1\u5668\u7684\u8fde\u63a5\u5c31\u5b8c\u6210\u4e86\u3002\u540e\u7eed\u5c31\u53ef\u4ee5\u8fdb\u884c\u901a\u4fe1\u3002","title":"9.2.2 Unix\u57df\u5ba2\u6237\u7aef"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/","text":"Node.js V14\u5bf9\u5b9a\u65f6\u5668\u6a21\u5757\u8fdb\u884c\u4e86\u91cd\u6784\uff0c\u4e4b\u524d\u7248\u672c\u7684\u5b9e\u73b0\u662f\u7528\u4e00\u4e2amap\uff0c\u4ee5\u8d85\u65f6\u65f6\u95f4\u4e3a\u952e\uff0c\u6bcf\u4e2a\u952e\u5bf9\u5e94\u4e00\u4e2a\u961f\u5217\u3002\u5373\u6709\u540c\u6837\u8d85\u65f6\u65f6\u95f4\u7684\u8282\u70b9\u5728\u540c\u4e00\u4e2a\u961f\u5217\u3002\u6bcf\u4e2a\u961f\u5217\u5bf9\u5e94\u4e00\u4e2a\u5e95\u5c42\u7684\u4e00\u4e2a\u8282\u70b9\uff08\u4e8c\u53c9\u5806\u91cc\u7684\u8282\u70b9\uff09\uff0cNode.js\u5728\u4e8b\u4ef6\u5faa\u73af\u7684timer\u9636\u6bb5\u4f1a\u4ece\u4e8c\u53c9\u5806\u91cc\u627e\u51fa\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\uff0c\u56de\u8c03\u91cc\u4f1a\u904d\u5386\u961f\u5217\uff0c\u5224\u65ad\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\u300214\u91cd\u6784\u540e\uff0c\u53ea\u4f7f\u7528\u4e86\u4e00\u4e2a\u4e8c\u53c9\u5806\u7684\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\uff0c\u9996\u5148\u770b\u4e0b\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u6574\u4f53\u5173\u7cfb\u56fe\uff0c\u5982\u56fe10-1\u6240\u793a\u3002 \u56fe10-1 \u4e0b\u9762\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u51e0\u4e2a\u91cd\u8981\u7684\u6570\u636e\u7ed3\u6784\u3002 10.1 Libuv\u7684\u5b9e\u73b0 \u00b6 Libuv\u4e2d\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u4e86\u5b9a\u65f6\u5668\u3002\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002 10.1.1 Libuv\u4e2d\u7ef4\u62a4\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784 \u00b6 1. // \u53d6\u51faloop\u4e2d\u7684\u8ba1\u65f6\u5668\u5806\u6307\u9488 2. static struct heap *timer_heap(const uv_loop_t* loop) { 3. return (struct heap*) &loop->timer_heap; 4. } 10.1.2 \u6bd4\u8f83\u51fd\u6570 \u00b6 \u56e0\u4e3aLibuv\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u5b9a\u65f6\u5668\uff0c\u8fd9\u5c31\u6d89\u53ca\u5230\u8282\u70b9\u63d2\u5165\u5806\u7684\u65f6\u5019\u7684\u89c4\u5219\u3002 5. static int timer_less_than(const struct heap_node* ha, 6. const struct heap_node* hb) { 7. const uv_timer_t* a; 8. const uv_timer_t* b; 9. // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 10. a = container_of(ha, uv_timer_t, heap_node); 11. b = container_of(hb, uv_timer_t, heap_node); 12. // \u6bd4\u8f83\u4e24\u4e2a\u7ed3\u6784\u4f53\u4e2d\u7684\u8d85\u65f6\u65f6\u95f4 13. if (a->timeout < b->timeout) 14. return 1; 15. if (b->timeout < a->timeout) 16. return 0; 17. // \u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u8bdd\uff0c\u770b\u8c01\u5148\u521b\u5efa 18. if (a->start_id < b->start_id) 19. return 1; 20. if (b->start_id < a->start_id) 21. return 0; 22. 23. return 0; 24. } 10.1.3 \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53 \u00b6 \u5982\u679c\u9700\u8981\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u9996\u5148\u8981\u5bf9\u5b9a\u65f6\u5668\u7684\u7ed3\u6784\u4f53\u8fdb\u884c\u521d\u59cb\u5316\u3002 1. // \u521d\u59cb\u5316uv_timer_t\u7ed3\u6784\u4f53 2. int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) { 3. uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER); 4. handle->timer_cb = NULL; 5. handle->repeat = 0; 6. return 0; 7. } 10.1.4 \u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668 \u00b6 1. // \u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668 2. int uv_timer_start(uv_timer_t* handle, 3. uv_timer_cb cb, 4. uint64_t timeout, 5. uint64_t repeat) { 6. uint64_t clamped_timeout; 7. 8. if (cb == NULL) 9. return UV_EINVAL; 10. // \u91cd\u65b0\u6267\u884cstart\u7684\u65f6\u5019\u5148\u628a\u4e4b\u524d\u7684\u505c\u6389 11. if (uv__is_active(handle)) 12. uv_timer_stop(handle); 13. // \u8d85\u65f6\u65f6\u95f4\uff0c\u4e3a\u7edd\u5bf9\u503c 14. clamped_timeout = handle->loop->time + timeout; 15. if (clamped_timeout < timeout) 16. clamped_timeout = (uint64_t) -1; 17. // \u521d\u59cb\u5316\u56de\u8c03\uff0c\u8d85\u65f6\u65f6\u95f4\uff0c\u662f\u5426\u91cd\u590d\u8ba1\u65f6\uff0c\u8d4b\u4e88\u4e00\u4e2a\u72ec\u7acb\u65e0\u4e8c\u7684id 18. handle->timer_cb = cb; 19. handle->timeout = clamped_timeout; 20. handle->repeat = repeat; 21. // \u7528\u4e8e\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u65f6\u5019\uff0c\u6bd4\u8f83\u5b9a\u65f6\u5668\u5728\u4e8c\u53c9\u5806\u7684\u4f4d\u7f6e\uff0c\u89c1cmp\u51fd\u6570 22. handle->start_id = handle->loop->timer_counter++; 23. // \u63d2\u5165\u6700\u5c0f\u5806 24. heap_insert(timer_heap(handle->loop), 25. (struct heap_node*) &handle->heap_node, 26. timer_less_than); 27. // \u6fc0\u6d3b\u8be5handle 28. uv__handle_start(handle); 29. 30. return 0; 31. } 10.1.5 \u505c\u6b62\u4e00\u4e2a\u5b9a\u65f6\u5668 \u00b6 1. // \u505c\u6b62\u4e00\u4e2a\u8ba1\u65f6\u5668 2. int uv_timer_stop(uv_timer_t* handle) { 3. if (!uv__is_active(handle)) 4. return 0; 5. // \u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9 6. heap_remove(timer_heap(handle->loop), 7. (struct heap_node*) &handle->heap_node, 8. timer_less_than); 9. // \u6e05\u9664\u6fc0\u6d3b\u72b6\u6001\u548chandle\u7684active\u6570\u51cf\u4e00 10. uv__handle_stop(handle); 11. 12. return 0; 13. } 10.1.6 \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668 \u00b6 \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\u7c7b\u4f3c\u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5b83\u9996\u5148\u9700\u8981\u628a\u4e4b\u524d\u7684\u5b9a\u65f6\u5668\u4ece\u4e8c\u53c9\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806\u3002 1. // \u91cd\u65b0\u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668\uff0c\u9700\u8981\u8bbe\u7f6erepeat\u6807\u8bb0 2. int uv_timer_again(uv_timer_t* handle) { 3. if (handle->timer_cb == NULL) 4. return UV_EINVAL; 5. // \u5982\u679c\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\u8bf4\u660e\u8ba1\u65f6\u5668\u662f\u9700\u8981\u91cd\u590d\u89e6\u53d1\u7684 6. if (handle->repeat) { 7. // \u5148\u628a\u65e7\u7684\u8282\u70b9\u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u518d\u91cd\u65b0\u5f00\u542f\u4e00\u4e2a\u8ba1\u65f6\u5668 8. uv_timer_stop(handle); 9. uv_timer_start(handle, 10. handle->timer_cb, 11. handle->repeat, 12. handle->repeat); 13. } 14. 15. return 0; 16. } 10.1.7 \u8ba1\u7b97\u4e8c\u53c9\u5806\u4e2d\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c \u00b6 \u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c\uff0c\u4e3b\u8981\u7528\u4e8e\u5224\u65adPoll IO\u8282\u70b9\u662f\u963b\u585e\u7684\u6700\u957f\u65f6\u95f4\u3002 1. // \u8ba1\u7b97\u6700\u5c0f\u5806\u4e2d\u6700\u5c0f\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4 2. int uv__next_timeout(const uv_loop_t* loop) { 3. const struct heap_node* heap_node; 4. const uv_timer_t* handle; 5. uint64_t diff; 6. // \u53d6\u51fa\u5806\u7684\u6839\u8282\u70b9\uff0c\u5373\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u7684 7. heap_node = heap_min(timer_heap(loop)); 8. if (heap_node == NULL) 9. return -1; /* block indefinitely */ 10. 11. handle = container_of(heap_node, uv_timer_t, heap_node); 12. // \u5982\u679c\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4\u5c0f\u4e8e\u5f53\u524d\u65f6\u95f4\uff0c\u5219\u8fd4\u56de0\uff0c\u8bf4\u660e\u5df2\u7ecf\u8d85\u65f6 13. if (handle->timeout <= loop->time) 14. return 0; 15. // \u5426\u5219\u8ba1\u7b97\u8fd8\u6709\u591a\u4e45\u8d85\u65f6\uff0c\u8fd4\u56de\u7ed9epoll\uff0cepoll\u7684timeout\u4e0d\u80fd\u5927\u4e8ediff 16. diff = handle->timeout - loop->time; 17. if (diff > INT_MAX) 18. diff = INT_MAX; 19. 20. return diff; 21. } 10.1.8 \u5904\u7406\u5b9a\u65f6\u5668 \u00b6 \u5904\u7406\u8d85\u65f6\u5b9a\u65f6\u5668\u5c31\u662f\u904d\u5386\u4e8c\u53c9\u5806\uff0c\u5224\u65ad\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\u3002 1. // \u627e\u51fa\u5df2\u7ecf\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03 2. void uv__run_timers(uv_loop_t* loop) { 3. struct heap_node* heap_node; 4. uv_timer_t* handle; 5. 6. for (;;) { 7. heap_node = heap_min(timer_heap(loop)); 8. if (heap_node == NULL) 9. break; 10. 11. handle = container_of(heap_node, uv_timer_t, heap_node); 12. // \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u5927\u4e8e\u5f53\u524d\u65f6\u95f4\u5219\u8fd4\u56de\uff0c\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u6ca1\u6709\u8d85\u65f6 13. if (handle->timeout > loop->time) 14. break; 15. // \u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9\uff0c\u91cd\u65b0\u63d2\u5165\u6700\u5c0f\u5806\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86repeat\u7684\u8bdd 16. uv_timer_stop(handle); 17. uv_timer_again(handle); 18. // \u6267\u884c\u8d85\u65f6\u56de\u8c03 19. handle->timer_cb(handle); 20. } 21. } 10.2 \u6838\u5fc3\u6570\u636e\u7ed3\u6784 \u00b6 10.2.1 TimersList \u00b6 \u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u5b9a\u65f6\u5668\u4f1a\u88ab\u653e\u5230\u540c\u4e00\u4e2a\u961f\u5217\uff0c\u6bd4\u5982\u5f53\u524d\u6267\u884csetTimeout(()=>{}, 10000})\u548c5\u79d2\u540e\u6267\u884csetTimeout(()=>{}, 10000})\uff0c\u8fd9\u4e24\u4e2a\u4efb\u52a1\u5c31\u4f1a\u5728\u540c\u4e00\u4e2aList\u4e2d\uff0c\u8fd9\u4e2a\u961f\u5217\u7531TimersList\u6765\u7ba1\u7406\u3002\u5bf9\u5e94\u56fe1\u4e2d\u7684List\u90a3\u4e2a\u961f\u5217\u3002 1. function TimersList(expiry, msecs) { 2. // \u7528\u4e8e\u94fe\u8868 3. this._idleNext = this; 4. this._idlePrev = this; 5. this.expiry = expiry; 6. this.id = timerListId++; 7. this.msecs = msecs; 8. // \u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e 9. this.priorityQueuePosition = null; 10. } expiry\u8bb0\u5f55\u7684\u662f\u94fe\u8868\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u7684\u7edd\u5bf9\u65f6\u95f4\u3002\u6bcf\u6b21\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u65f6\u4f1a\u52a8\u6001\u66f4\u65b0\uff0cmsecs\u662f\u8d85\u65f6\u65f6\u95f4\u7684\u76f8\u5bf9\u503c\uff08\u76f8\u5bf9\u63d2\u5165\u65f6\u7684\u5f53\u524d\u65f6\u95f4\uff09\u3002\u7528\u4e8e\u8ba1\u7b97\u8be5\u94fe\u8868\u4e2d\u7684\u8282\u70b9\u662f\u5426\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u7528\u5904\u3002 10.2.2 \u4f18\u5148\u961f\u5217 \u00b6 1. const timerListQueue = new PriorityQueue(compareTimersLists, setPosition) Node.js\u7528\u4f18\u5148\u961f\u5217\u5bf9\u6240\u6709TimersList\u94fe\u8868\u8fdb\u884c\u7ba1\u7406\uff0c\u4f18\u5148\u961f\u5217\u672c\u8d28\u662f\u4e00\u4e2a\u4e8c\u53c9\u5806\uff08\u5c0f\u6839\u5806\uff09\uff0c\u6bcf\u4e2aTimersList\u94fe\u8868\u5728\u4e8c\u53c9\u5806\u91cc\u5bf9\u5e94\u4e00\u4e2a\u8282\u70b9\u3002\u6839\u636eTimersList\u7684\u7ed3\u6784\uff0c\u6211\u4eec\u77e5\u9053\u6bcf\u4e2a\u94fe\u8868\u90fd\u4fdd\u5b58\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4\u3002\u4e8c\u53c9\u5806\u4ee5\u8be5\u65f6\u95f4\u4e3a\u4f9d\u636e\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684list\u5bf9\u5e94\u4e8c\u53c9\u5806\u4e2d\u7684\u6839\u8282\u70b9\u3002\u6839\u8282\u70b9\u7684\u5230\u671f\u65f6\u95f4\u5c31\u662f\u6574\u4e2aNode.js\u5b9a\u65f6\u5668\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0cNode.js\u628aLibuv\u4e2d\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\u8bbe\u7f6e\u4e3a\u8be5\u503c\uff0c\u5728\u4e8b\u4ef6\u5faa\u73af\u7684\u5b9a\u65f6\u5668\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u5b9a\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u4e0d\u65ad\u904d\u5386\u4f18\u5148\u961f\u5217\uff0c\u5224\u65ad\u5f53\u524d\u8282\u70b9\u662f\u5426\u8d85\u65f6\uff0c\u5982\u679c\u8d85\u65f6\u4e86\uff0c\u5c31\u9700\u8981\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u8d85\u65f6\uff0c\u8bf4\u660e\u6574\u4e2a\u4e8c\u53c9\u5806\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u65f6\u3002\u7136\u540e\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u8282\u70b9\u65b0\u7684\u5230\u671f\u65f6\u95f4\u3002 \u53e6\u5916\uff0cNode.js\u4e2d\u7528\u4e00\u4e2amap\u4fdd\u5b58\u4e86\u8d85\u65f6\u65f6\u95f4\u5230TimersList\u94fe\u8868\u7684\u6620\u5c04\u5173\u7cfb\u3002 \u8fd9\u6837\u5c31\u53ef\u4ee5\u6839\u636e\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u5feb\u901f\u627e\u5230\u5bf9\u5e94\u7684\u5217\u8868\uff0c\u5229\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002\u4e86\u89e3\u5b8c\u5b9a\u65f6\u5668\u6574\u4f53\u7684\u7ec4\u7ec7\u548c\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u8fdb\u5165\u771f\u6b63\u7684\u6e90\u7801\u5206\u6790\u4e86\u3002 10.3 \u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570 \u00b6 Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u3002 setupTimers(processImmediate, processTimers); setupTimers\u5bf9\u5e94\u7684C++\u51fd\u6570\u662f 1. void SetupTimers(const FunctionCallbackInfo<Value>& args) { 2. auto env = Environment::GetCurrent(args); 3. env->set_immediate_callback_function(args[0].As<Function>()); 4. env->set_timers_callback_function(args[1].As<Function>()); 5. } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570\uff0cprocessImmediate\u662f\u5904\u7406setImmediate\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u7684\u3002\u5f53\u6709\u8282\u70b9\u8d85\u65f6\u65f6\uff0cNode.js\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u5904\u7406\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u540e\u7eed\u4f1a\u770b\u5230\u8be5\u51fd\u6570\u7684\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002 10.4 \u8bbe\u7f6e\u5b9a\u65f6\u5668 \u00b6 1. function setTimeout(callback, after, arg1, arg2, arg3) { 2. // \u5ffd\u7565\u5904\u7406\u53c2\u6570args\u903b\u8f91 3. // \u65b0\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61 4. const timeout = new Timeout(callback, 5. after, 6. args, 7. false, 8. true); 9. insert(timeout, timeout._idleTimeout); 10. return timeout; 11. } setTimeout\u4e3b\u8981\u5305\u542b\u4e24\u4e2a\u64cd\u4f5c\uff0cnew Timeout\u548cinsert\u3002\u6211\u4eec\u9010\u4e2a\u5206\u6790\u4e00\u4e0b\u3002 1 setTimeout 1. function Timeout(callback, after, args, isRepeat, isRefed) { 2. after *= 1; // Coalesce to number or NaN 3. // \u5173\u4e8esetTimeout\u7684\u8d85\u65f6\u65f6\u95f4\u4e3a0\u7684\u95ee\u9898\u5728\u8fd9\u91cc\u53ef\u4ee5\u63ed\u5f00\u8ff7\u96fe 4. if (!(after >= 1 && after <= TIMEOUT_MAX)) { 5. after = 1; 6. } 7. // \u8d85\u65f6\u65f6\u95f4\u76f8\u5bf9\u503c 8. this._idleTimeout = after; 9. // \u524d\u540e\u6307\u9488\uff0c\u7528\u4e8e\u94fe\u8868 10. this._idlePrev = this; 11. this._idleNext = this; 12. // \u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4 13. this._idleStart = null; 14. // \u8d85\u65f6\u56de\u8c03 15. this._onTimeout = callback; 16. // \u6267\u884c\u56de\u8c03\u65f6\u4f20\u5165\u7684\u53c2\u6570 17. this._timerArgs = args; 18. // \u662f\u5426\u5b9a\u671f\u89e6\u53d1\u8d85\u65f6\uff0c\u7528\u4e8esetInterval 19. this._repeat = isRepeat ? after : null; 20. this._destroyed = false; 21. // this._idleStart = now(); 22. // \u6fc0\u6d3b\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff08\u4e8c\u53c9\u5806\u7684\u8282\u70b9\uff09\uff0c\u8bf4\u660e\u6709\u5b9a\u65f6\u8282\u70b9\u9700\u8981\u5904\u7406 23. if (isRefed) 24. incRefCount(); 25. // \u8bb0\u5f55\u72b6\u6001 26. this[kRefed] = isRefed; 27. } Timeout\u4e3b\u8981\u662f\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\u8bb0\u5f55\u4e00\u4e9b\u5b9a\u65f6\u5668\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\uff08\u7528\u4e8e\u652f\u6301setInterval\uff0c\u91cd\u65b0\u63d2\u5165\u961f\u5217\u65f6\u627e\u5230\u6240\u5c5e\u961f\u5217\uff09\u3001\u5f00\u59cb\u65f6\u95f4\uff08\u7528\u4e8e\u8ba1\u7b97\u5b9a\u65f6\u5668\u662f\u5426\u8d85\u65f6\uff09\u7b49\u4e0a\u4e0b\u6587\u4fe1\u606f\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u952e\u7684\u903b\u8f91\u662fisRefed\u7684\u503c\u3002Node.js\u652f\u6301ref\u548cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff08setTimeout \u548csetUnrefTimeout\uff09\uff0cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u5373\u5f53\u53ea\u6709unref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u4e8b\u4ef6\u5faa\u73af\u4f1a\u7ed3\u675f\u3002\u5f53isRefed\u4e3atrue\u65f6\u4f1a\u6267\u884cincRefCount(); 1. function incRefCount() { 2. if (refCount++ === 0) 3. toggleTimerRef(true); 4. } 5. 6. void ToggleTimerRef(const FunctionCallbackInfo<Value>& args) { 7. Environment::GetCurrent(args)->ToggleTimerRef(args[0]->IsTrue()); 8. } 9. 10. void Environment::ToggleTimerRef(bool ref) { 11. if (started_cleanup_) return; 12. // \u6253\u4e0aref\u6807\u8bb0\uff0c 13. if (ref) { 14. uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle())); 15. } else { 16. uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle())); 17. } 18. } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u4f1a\u8c03\u7528Libuv\u7684uv_ref\u6216uv_unref\u4fee\u6539\u5b9a\u65f6\u5668\u76f8\u5173handle\u7684\u72b6\u6001\uff0c\u56e0\u4e3aNode.js\u53ea\u4f1a\u5728Libuv\u4e2d\u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668handle\u5e76\u4e14\u662f\u5e38\u9a7b\u7684\uff0c\u5982\u679cJS\u5c42\u5f53\u524d\u6ca1\u6709\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5219\u9700\u8981\u4fee\u6539\u5b9a\u65f6\u5668handle\u7684\u72b6\u6001\u4e3aunref\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002refCount\u503c\u4fbf\u662f\u8bb0\u5f55JS\u5c42ref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u4e2a\u6570\u7684\u3002\u6240\u4ee5\u5f53\u6211\u4eec\u7b2c\u4e00\u6b21\u6267\u884csetTimeout\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u6fc0\u6d3bLibuv\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0binsert\u3002 1. let nextExpiry = Infinity; 2. function insert(item, msecs, start = getLibuvNow()) { 3. msecs = MathTrunc(msecs); 4. // \u8bb0\u5f55\u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4\uff0c\u89c1Timeout\u51fd\u6570\u7684\u5b9a\u4e49 5. item._idleStart = start; 6. // \u8be5\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5bf9\u5e94\u7684\u94fe\u8868 7. let list = timerListMap[msecs]; 8. // \u8fd8\u6ca1\u6709 9. if (list === undefined) { 10. // \u7b97\u51fa\u7edd\u5bf9\u8d85\u65f6\u65f6\u95f4\uff0c\u7b2c\u4e00\u4e2a\u8282\u70b9\u662f\u8be5\u94fe\u8868\u4e2d\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9 11. const expiry = start + msecs; 12. // \u65b0\u5efa\u4e00\u4e2a\u94fe\u8868 13. timerListMap[msecs] = list = new TimersList(expiry, msecs); 14. // \u63d2\u5165\u4f18\u5148\u961f\u5217 15. timerListQueue.insert(list); 16. /* 17. nextExpiry\u8bb0\u5f55\u6240\u6709\u8d85\u65f6\u8282\u70b9\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\uff0c 18. \u5982\u679c\u6709\u66f4\u5feb\u5230\u671f\u7684\uff0c\u5219\u4fee\u6539\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4 19. */ 20. if (nextExpiry > expiry) { 21. // \u4fee\u6539\u5e95\u5c42\u8d85\u65f6\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 22. scheduleTimer(msecs); 23. nextExpiry = expiry; 24. } 25. } 26. // \u628a\u5f53\u524d\u8282\u70b9\u52a0\u5230\u94fe\u8868\u91cc 27. L.append(list, item); 28. } Insert\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u5982\u679c\u8be5\u8d85\u65f6\u65f6\u95f4\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u5219\u65b0\u5efa\u4e00\u4e2a\u94fe\u8868\uff0c\u6bcf\u4e2a\u94fe\u8868\u90fd\u4f1a\u8bb0\u5f55\u8be5\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u503c\uff0c\u5373\u7b2c\u4e00\u4e2a\u63d2\u5165\u7684\u503c\u3002\u7136\u540e\u628a\u94fe\u8868\u63d2\u5165\u4f18\u5148\u961f\u5217\uff0c\u4f18\u5148\u961f\u5217\u4f1a\u6839\u636e\u8be5\u94fe\u8868\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7684\u503c\uff0c\u628a\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u8c03\u6574\u5230\u76f8\u5e94\u7684\u4f4d\u7f6e\u3002 2 \u5982\u679c\u5f53\u524d\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u6bd4\u4e4b\u524d\u6240\u6709\u7684\u5b9a\u65f6\u5668\u90fd\u5feb\u5230\u671f\uff0c\u5219\u9700\u8981\u4fee\u6539\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff0c\u4f7f\u5f97\u66f4\u5feb\u89e6\u53d1\u8d85\u65f6\u3002 3 \u628a\u5f53\u524d\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u63d2\u5165\u5bf9\u5e94\u7684\u94fe\u8868\u5c3e\u90e8\u3002\u5373\u8be5\u94fe\u8868\u4e2d\u6700\u4e45\u8d85\u65f6\u7684\u8282\u70b9\u3002 \u5047\u8bbe\u6211\u4eec\u57280s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u4e0b\u9762\u662f\u63d2\u5165\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\u7684\u7ed3\u6784\u56fe\u5982\u56fe10-2\u6240\u793a\u3002 \u56fe10-2 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u591a\u4e2a\u8282\u70b9\u7684\u60c5\u51b5\u3002\u5047\u8bbe0s\u7684\u65f6\u5019\u63d2\u5165\u4e24\u4e2a\u8282\u70b910s\u8fc7\u671f\u548c11s\u8fc7\u671f\u3002\u5982\u56fe10-3\u6240\u793a\u3002 \u56fe10-3 \u7136\u540e\u57281s\u7684\u65f6\u5019\uff0c\u63d2\u5165\u4e00\u4e2a\u65b0\u768411s\u8fc7\u671f\u7684\u8282\u70b9\uff0c9s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u65b0\u768410s\u8fc7\u671f\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe10-4\u6240\u793a\u3002 \u56fe10-4 \u6211\u4eec\u770b\u5230\u4f18\u5148\u961f\u5217\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u94fe\u8868\uff0c\u7236\u8282\u70b9\u5bf9\u5e94\u7684\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u6bd4\u5b50\u8282\u70b9\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5148\u8d85\u65f6\u7684\uff0c\u4f46\u662f\u94fe\u8868\u4e2d\u540e\u7eed\u8282\u70b9\u7684\u8d85\u65f6\u5c31\u4e0d\u4e00\u5b9a\u3002\u6bd4\u5982\u5b50\u8282\u70b91s\u5f00\u59cb\u7684\u8282\u70b9\u5c31\u6bd4\u7236\u8282\u70b99s\u5f00\u59cb\u7684\u8282\u70b9\u5148\u8d85\u65f6\u3002\u56e0\u4e3a\u540c\u4e00\u961f\u5217\uff0c\u53ea\u662f\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\uff0c\u800c\u8fd8\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u56e0\u7d20\u662f\u5f00\u59cb\u7684\u65f6\u95f4\u3002\u867d\u7136\u67d0\u8282\u70b9\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u957f\uff0c\u4f46\u662f\u5982\u679c\u5b83\u6bd4\u53e6\u4e00\u4e2a\u8282\u70b9\u5f00\u59cb\u7684\u65e9\uff0c\u90a3\u4e48\u5c31\u6709\u53ef\u80fd\u6bd4\u5b83\u5148\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u662f\u600e\u4e48\u5b9e\u73b0\u7684\u3002 10.5 \u5904\u7406\u5b9a\u65f6\u5668 \u00b6 \u524d\u9762\u6211\u4eec\u8bb2\u5230\u4e86\u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570\u548c\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u4f46\u662f\u5728\u54ea\u91cc\u89e6\u53d1\u8fd9\u4e2a\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u5462\uff1f\u7b54\u6848\u5728scheduleTimer\u51fd\u6570\u3002Node.js\u7684\u5b9e\u73b0\u4e2d\uff0c\u6240\u6709JS\u5c42\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u5bf9\u5e94Libuv\u7684\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\uff0cNode.js\u7ef4\u62a4\u4e86JS\u5c42\u6240\u6709\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u6700\u5c0f\u503c\u3002\u5728\u7b2c\u4e00\u4e2a\u8bbe\u7f6e\u5b9a\u65f6\u5668\u6216\u8005\u8bbe\u7f6e\u4e00\u4e2a\u65b0\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u5982\u679c\u65b0\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u6bd4\u5f53\u524d\u7684\u6700\u5c0f\u503c\u5c0f\uff0c\u5219\u4f1a\u901a\u8fc7scheduleTimer\u4fee\u6539\u8d85\u65f6\u65f6\u95f4\u3002\u8d85\u65f6\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002scheduleTimer\u51fd\u6570\u662f\u5bf9C++\u51fd\u6570\u7684\u5c01\u88c5\u3002 1. void ScheduleTimer(const FunctionCallbackInfo<Value>& args) { 2. auto env = Environment::GetCurrent(args); 3. env->ScheduleTimer(args[0]->IntegerValue(env->context()).FromJust()); 4. } 5. 6. void Environment::ScheduleTimer(int64_t duration_ms) { 7. if (started_cleanup_) return; 8. uv_timer_start(timer_handle(), RunTimers, duration_ms, 0); 9. } uv_timer_start\u5c31\u662f\u5f00\u542f\u5e95\u5c42\u8ba1\u65f6\uff0c\u5373\u5f80Libuv\u7684\u4e8c\u53c9\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff08\u5982\u679c\u8be5handle\u5df2\u7ecf\u5b58\u5728\u4e8c\u53c9\u5806\uff0c\u5219\u5148\u5220\u9664\uff09\u3002\u8d85\u65f6\u65f6\u95f4\u662fduration_ms\uff0c\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0c\u8d85\u65f6\u56de\u8c03\u662fRunTimers\uff0c\u5728timer\u9636\u6bb5\u4f1a\u5224\u65ad\u662f\u5426\u8fc7\u671f\u3002\u662f\u7684\u8bdd\u6267\u884cRunTimers\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bRunTimers\u51fd\u6570\u7684\u4e3b\u8981\u4ee3\u7801\u3002 1. Local<Function> cb = env->timers_callback_function(); 2. ret = cb->Call(env->context(), process, 1, &arg); RunTimers\u4f1a\u6267\u884ctimers_callback_function\u3002timers_callback_function\u662f\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684processTimers\u51fd\u6570\u3002\u73b0\u5728\u6211\u4eec\u77e5\u9053\u4e86Node.js\u662f\u5982\u4f55\u8bbe\u7f6e\u8d85\u65f6\u7684\u5904\u7406\u51fd\u6570\uff0c\u4e5f\u77e5\u9053\u4e86\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u90a3\u6211\u4eec\u5c31\u6765\u770b\u4e00\u4e0b\u56de\u8c03\u65f6\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002 1. void Environment::RunTimers(uv_timer_t* handle) { 2. Local<Function> cb = env->timers_callback_function(); 3. MaybeLocal<Value> ret; 4. Local<Value> arg = env->GetNow(); 5. 6. do { 7. // \u6267\u884cjs\u56de\u8c03processTimers\u51fd\u6570 8. ret = cb->Call(env->context(), process, 1, &arg); 9. } while (ret.IsEmpty() && env->can_call_into_js()); 10. 11. // \u5982\u679c\u8fd8\u6709\u672a\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219ret\u4e3a\u7b2c\u4e00\u4e2a\u672a\u8d85\u65f6\u7684\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 12. int64_t expiry_ms = ret.ToLocalChecked()->IntegerValue(env->context()).FromJust(); 13. uv_handle_t* h = reinterpret_cast<uv_handle_t*>(handle); 14. 15. /* 16. 1 \u7b49\u4e8e0\u8bf4\u660e\u6240\u6709\u8282\u70b9\u90fd\u6267\u884c\u5b8c\u4e86\uff0c\u4f46\u662f\u5b9a\u65f6\u5668\u8282\u70b9\u8fd8\u662f\u5728Libuv\u4e2d\uff0c 17. \u4e0d\u8fc7\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c\u5373\u4e0d\u4f1a\u5f71\u54cdLibuv\u9000\u51fa\uff0c\u56e0\u4e3a\u5f53\u524d\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u4e86\uff08handle\uff09\uff0c 18. 2 \u4e0d\u7b49\u4e8e0\u8bf4\u660e\u6ca1\u6709\u8fd8\u8981\u8282\u70b9\u9700\u8981\u5904\u7406\uff0c\u8fd9\u79cd\u60c5\u51b5\u53c8\u5206\u4e3a\u4e24\u79cd 19. 1 \u8fd8\u6709\u6fc0\u6d3b\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u5373\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 20. 2 \u5b9a\u65f6\u5668\u90fd\u662f\u975e\u6fc0\u6d3b\u72b6\u6001\u7684\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 21. \u5177\u4f53\u89c1Timeout\u7684unref\u548cref\u65b9\u6cd5 22. */ 23. if (expiry_ms != 0) { 24. // \u7b97\u51fa\u4e0b\u6b21\u8d85\u65f6\u7684\u76f8\u5bf9\u503c 25. int64_t duration_ms = 26. llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base()); 27. // \u91cd\u65b0\u628ahandle\u63d2\u5165Libuv\u7684\u4e8c\u53c9\u5806 28. env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1); 29. /* 30. \u89c1internal/timer.js\u7684processTimers 31. 1 \u5927\u4e8e0\u8bf4\u660e\u8fd8\u6709\u8282\u70b9\u6ca1\u8d85\u65f6\uff0c\u5e76\u4e14\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c 32. \u9700\u8981\u4fdd\u6301\u5b9a\u65f6\u5668\u7684\u6fc0\u6d3b\u72b6\u6001\uff08\u5982\u679c\u4e4b\u524d\u662f\u6fc0\u6d3b\u72b6\u6001\u5219\u4e0d\u5f71\u54cd\uff09\uff0c 33. 2 \u5c0f\u4e8e0\u8bf4\u660e\u5b9a\u65f6\u5668\u4e0d\u5f71\u54cdLibuv\u7684\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\uff0c\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001 34. */ 35. if (expiry_ms > 0) 36. uv_ref(h); 37. else 38. uv_unref(h); 39. } else { 40. uv_unref(h); 41. } 42. } \u8be5\u51fd\u6570\u4e3b\u8981\u662f\u6267\u884c\u56de\u8c03\uff0c\u7136\u540e\u5982\u679c\u8fd8\u6709\u6ca1\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u3002\u770b\u770bJS\u5c42\u9762\u3002 1. function processTimers(now) { 2. nextExpiry = Infinity; 3. let list; 4. let ranAtLeastOneList = false; 5. // \u53d6\u51fa\u4f18\u5148\u961f\u5217\u7684\u6839\u8282\u70b9\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9 6. while (list = timerListQueue.peek()) { 7. // \u8fd8\u6ca1\u8fc7\u671f\uff0c\u5219\u53d6\u5f97\u4e0b\u6b21\u5230\u671f\u7684\u65f6\u95f4\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 8. if (list.expiry > now) { 9. nextExpiry = list.expiry; 10. // \u8fd4\u56de\u4e0b\u4e00\u6b21\u8fc7\u671f\u7684\u65f6\u95f4\uff0c\u8d1f\u7684\u8bf4\u660e\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 11. return refCount > 0 ? nextExpiry : -nextExpiry; 12. } 13. 14. // \u5904\u7406\u8d85\u65f6\u8282\u70b9 15. listOnTimeout(list, now); 16. } 17. // \u6240\u6709\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86 18. return 0; 19. } 20. 21. function listOnTimeout(list, now) { 22. const msecs = list.msecs; 23. let ranAtLeastOneTimer = false; 24. let timer; 25. // \u904d\u5386\u5177\u6709\u7edf\u4e00\u76f8\u5bf9\u8fc7\u671f\u65f6\u95f4\u7684\u961f\u5217 26. while (timer = L.peek(list)) { 27. // \u7b97\u51fa\u5df2\u7ecf\u8fc7\u53bb\u7684\u65f6\u95f4 28. const diff = now - timer._idleStart; 29. // \u8fc7\u671f\u7684\u65f6\u95f4\u6bd4\u8d85\u65f6\u65f6\u95f4\u5c0f\uff0c\u8fd8\u6ca1\u8fc7\u671f 30. if (diff < msecs) { 31. /* 32. \u6574\u4e2a\u94fe\u8868\u8282\u70b9\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7b49\u4e8e\u5f53\u524d 33. \u8fd8\u6ca1\u8fc7\u671f\u8282\u70b9\u7684\u503c\uff0c\u94fe\u8868\u662f\u6709\u5e8f\u7684 34. */ 35. list.expiry = MathMax(timer._idleStart + msecs, 36. now + 1); 37. // \u66f4\u65b0id\uff0c\u7528\u4e8e\u51b3\u5b9a\u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e 38. list.id = timerListId++; 39. /* 40. \u8c03\u6574\u8fc7\u671f\u65f6\u95f4\u540e\uff0c\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u662f\u4f18\u5148\u961f\u5217 41. \u91cc\u7684\u6839\u8282\u70b9\u4e86\uff0c\u53ef\u80fd\u6709\u5b83\u66f4\u5feb\u5230\u671f\uff0c\u5373\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282 42. \u70b9\u53ef\u80fd\u9700\u8981\u5f80\u4e0b\u6c89 43. */ 44. timerListQueue.percolateDown(1); 45. return; 46. } 47. 48. // \u51c6\u5907\u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03\uff0c\u5220\u9664\u8fd9\u4e2a\u8282\u70b9 49. L.remove(timer); 50. 51. let start; 52. if (timer._repeat) 53. start = getLibuvNow(); 54. try { 55. const args = timer._timerArgs; 56. // \u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03 57. if (args === undefined) 58. timer._onTimeout(); 59. else 60. timer._onTimeout(...args); 61. } finally { 62. /* 63. \u8bbe\u7f6e\u4e86\u91cd\u590d\u6267\u884c\u56de\u8c03\uff0c\u5373\u6765\u81easetInterval\u3002 64. \u5219\u9700\u8981\u91cd\u65b0\u52a0\u5165\u94fe\u8868\u3002 65. */ 66. if (timer._repeat && 67. timer._idleTimeout !== -1) { 68. // \u66f4\u65b0\u8d85\u65f6\u65f6\u95f4\uff0c\u4e00\u6837\u7684\u65f6\u95f4\u95f4\u9694 69. timer._idleTimeout = timer._repeat; 70. // \u91cd\u65b0\u63d2\u5165\u94fe\u8868 71. insert(timer, timer._idleTimeout, start); 72. } else if (!timer._idleNext && 73. !timer._idlePrev && 74. !timer._destroyed) { 75. timer._destroyed = true; 76. // \u662fref\u7c7b\u578b\uff0c\u5219\u51cf\u53bb\u4e00\u4e2a\uff0c\u9632\u6b62\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 77. if (timer[kRefed]) 78. refCount--; 79. } 80. // \u4e3a\u7a7a\u5219\u5220\u9664 81. if (list === timerListMap[msecs]) { 82. delete timerListMap[msecs]; 83. // \u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9\uff0c\u5e76\u8c03\u6574\u961f\u5217\u7ed3\u6784 84. timerListQueue.shift(); 85. } 86. } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u662f\u904d\u5386\u4f18\u5148\u961f\u5217 1 \u5982\u679c\u5f53\u524d\u8282\u70b9\u8d85\u65f6\uff0c\u5219\u904d\u5386\u5b83\u5bf9\u5e94\u7684\u94fe\u8868\u3002\u904d\u5386\u94fe\u8868\u7684\u65f6\u5019\u5982\u679c\u9047\u5230\u8d85\u65f6\u7684\u8282\u70b9\u5219\u6267\u884c\u3002\u5982\u679c\u9047\u5230\u6ca1\u6709\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\uff0c\u56e0\u4e3a\u94fe\u8868\u662f\u6709\u5e8f\u7684\uff0c\u63a5\u7740\u91cd\u65b0\u8ba1\u7b97\u51fa\u6700\u5feb\u8d85\u65f6\u65f6\u95f4\uff0c\u4fee\u6539\u94fe\u8868\u7684expiry\u5b57\u6bb5\u3002\u8c03\u6574\u5728\u4f18\u5148\u961f\u5217\u7684\u4f4d\u7f6e\u3002\u56e0\u4e3a\u4fee\u6539\u540e\u7684expiry\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4f4d\u7f6e\u53d1\u751f\u53d8\u5316\u3002\u5982\u679c\u94fe\u8868\u7684\u8282\u70b9\u5168\u90e8\u90fd\u8d85\u65f6\u4e86\uff0c\u5219\u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u91cd\u65b0\u8c03\u6574\u4f18\u5148\u961f\u5217\u7684\u8282\u70b9\u3002 2 \u5982\u679c\u5f53\u524d\u8282\u70b9\u6ca1\u6709\u8d85\u65f6\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\u3002\u56e0\u4e3a\u5f53\u524d\u8282\u70b9\u662f\u4f18\u5148\u961f\u5217\u4e2d\u6700\u5feb\u5230\u671f\uff08\u6700\u5c0f\u7684\uff09\u7684\u8282\u70b9\u3002\u63a5\u7740\u8bbe\u7f6eLibuv\u7684\u5b9a\u65f6\u5668\u65f6\u95f4\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u3002\u7b49\u5f85\u4e0b\u4e00\u6b21\u8d85\u65f6\u5904\u7406\u3002 10.6 ref\u548cunref \u00b6 setTimeout\u8fd4\u56de\u7684\u662f\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8be5\u63d0\u4f9b\u4e86ref\u548cunref\u63a5\u53e3\uff0c\u521a\u624d\u63d0\u5230\u4e86\u5173\u4e8e\u5b9a\u65f6\u5668\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u539f\u7406\u3002\u521a\u624d\u8bf4\u5230Node.js\u5b9a\u65f6\u5668\u6a21\u5757\u5728Libuv\u4e2d\u53ea\u5bf9\u5e94\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u521d\u59cb\u5316\u4e86\u8be5\u8282\u70b9\u3002 1. void Environment::InitializeLibuv(bool start_profiler_idle_notifier) { 2. // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 3. CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle())); 4. // \u7f6eunref\u72b6\u6001 5. uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle())); 6. } \u6211\u4eec\u770b\u5230\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u9ed8\u8ba4\u662funref\u72b6\u6001\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u56e0\u4e3a\u521d\u59cb\u5316\u65f6JS\u5c42\u6ca1\u6709\u5b9a\u65f6\u8282\u70b9\u3002\u53ef\u4ee5\u901a\u8fc7Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u4fee\u6539\u8be5\u72b6\u6001\u3002Node.js\u652f\u6301ref\u72b6\u6001\u7684Timeout\uff08setTimeout\uff09\u548cunref\u72b6\u6001\u7684Timeout\uff08setUnrefTimeout\uff09\u3002 1. function Timeout(callback, after, args, isRepeat, isRefed) { 2. if (isRefed) 3. incRefCount(); 4. this[kRefed] = isRefed; 5. } \u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u63a7\u5236ref\u8fd8\u662funref\u7684\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679cisRefed\u4e3atrue\u7684\u65f6\u5019\u7684\u903b\u8f91 1. function incRefCount() { 2. if (refCount++ === 0) 3. toggleTimerRef(true); 4. } refCount\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f1\uff0c\u6240\u4ee5\u5728\u65b0\u52a0\u7b2c\u4e00\u4e2aTimeout\u7684\u65f6\u5019\uff0cif\u6210\u7acb\u3002\u6211\u4eec\u63a5\u7740\u770btoggleTimerRef\uff0c\u8be5\u51fd\u6570\u5bf9\u5e94\u7684\u4ee3\u7801\u5982\u4e0b 1. void Environment::ToggleTimerRef(bool ref) { 2. // \u6253\u4e0aref\u6807\u8bb0\uff0c 3. if (ref) { 4. uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle())); 5. } else { 6. uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle())); 7. } 8. } \u8be5\u51fd\u6570\u6b63\u662f\u7ed9\u5b9a\u65f6\u5668\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u72b6\u6001\u7684\u3002setTimeout\u7684\u65f6\u5019\uff0cisRefed\u7684\u503c\u662ftrue\u7684\uff0cNode.js\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u4e2a\u51fd\u6570setUnrefTimeout\u3002 1. function setUnrefTimeout(callback, after) { 2. const timer = new Timeout(callback, after, undefined, false, false); 3. insert(timer, timer._idleTimeout); 4. return timer; 5. } \u8be5\u51fd\u6570\u548csetTimeout\u6700\u4e3b\u8981\u7684\u533a\u522b\u662fnew Timeout\u7684\u65f6\u5019\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u662ffalse\uff08isRefed\u53d8\u91cf\u7684\u503c\uff09\uff0c\u6240\u4ee5setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u662f\u4e0d\u4f1a\u5f71\u54cdLibuv\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u3002\u53e6\u5916\u9664\u4e86Node.js\u76f4\u63a5\u63d0\u4f9b\u7684api\u540e\u3002\u6211\u4eec\u8fd8\u53ef\u4ee5\u901a\u8fc7Timeout\u5bf9\u8c61\u63d0\u4f9b\u7684ref\u548cunref\u624b\u52a8\u63a7\u5236\u8fd9\u4e2a\u72b6\u6001\u3002 \u73b0\u5728\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u5177\u4f53\u6765\u770b\u4e00\u4e0b\u3002 1. const timeout = setTimeout(() => { 2. console.log(1) 3. }, 10000); 4. timeout.unref(); 5. // timeout.ref(); \u52a0\u8fd9\u4e00\u53e5\u4f1a\u8f93\u51fa1 \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c1\u662f\u4e0d\u4f1a\u8f93\u51fa\uff0c\u9664\u975e\u628a\u6ce8\u91ca\u53bb\u6389\u3002Unref\u548cref\u662f\u76f8\u53cd\u7684\u53c2\u6570\uff0c\u5373\u628a\u5b9a\u65f6\u5668\u6a21\u5757\u5bf9\u5e94\u7684Libuv handle\u6539\u6210unref\u72b6\u6001\u3002","title":"10-\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#101-libuv","text":"Libuv\u4e2d\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u4e86\u5b9a\u65f6\u5668\u3002\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002","title":"10.1 Libuv\u7684\u5b9e\u73b0"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1011-libuv","text":"1. // \u53d6\u51faloop\u4e2d\u7684\u8ba1\u65f6\u5668\u5806\u6307\u9488 2. static struct heap *timer_heap(const uv_loop_t* loop) { 3. return (struct heap*) &loop->timer_heap; 4. }","title":"10.1.1 Libuv\u4e2d\u7ef4\u62a4\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1012","text":"\u56e0\u4e3aLibuv\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u5b9a\u65f6\u5668\uff0c\u8fd9\u5c31\u6d89\u53ca\u5230\u8282\u70b9\u63d2\u5165\u5806\u7684\u65f6\u5019\u7684\u89c4\u5219\u3002 5. static int timer_less_than(const struct heap_node* ha, 6. const struct heap_node* hb) { 7. const uv_timer_t* a; 8. const uv_timer_t* b; 9. // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 10. a = container_of(ha, uv_timer_t, heap_node); 11. b = container_of(hb, uv_timer_t, heap_node); 12. // \u6bd4\u8f83\u4e24\u4e2a\u7ed3\u6784\u4f53\u4e2d\u7684\u8d85\u65f6\u65f6\u95f4 13. if (a->timeout < b->timeout) 14. return 1; 15. if (b->timeout < a->timeout) 16. return 0; 17. // \u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u8bdd\uff0c\u770b\u8c01\u5148\u521b\u5efa 18. if (a->start_id < b->start_id) 19. return 1; 20. if (b->start_id < a->start_id) 21. return 0; 22. 23. return 0; 24. }","title":"10.1.2 \u6bd4\u8f83\u51fd\u6570"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1013","text":"\u5982\u679c\u9700\u8981\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u9996\u5148\u8981\u5bf9\u5b9a\u65f6\u5668\u7684\u7ed3\u6784\u4f53\u8fdb\u884c\u521d\u59cb\u5316\u3002 1. // \u521d\u59cb\u5316uv_timer_t\u7ed3\u6784\u4f53 2. int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) { 3. uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER); 4. handle->timer_cb = NULL; 5. handle->repeat = 0; 6. return 0; 7. }","title":"10.1.3 \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1014","text":"1. // \u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668 2. int uv_timer_start(uv_timer_t* handle, 3. uv_timer_cb cb, 4. uint64_t timeout, 5. uint64_t repeat) { 6. uint64_t clamped_timeout; 7. 8. if (cb == NULL) 9. return UV_EINVAL; 10. // \u91cd\u65b0\u6267\u884cstart\u7684\u65f6\u5019\u5148\u628a\u4e4b\u524d\u7684\u505c\u6389 11. if (uv__is_active(handle)) 12. uv_timer_stop(handle); 13. // \u8d85\u65f6\u65f6\u95f4\uff0c\u4e3a\u7edd\u5bf9\u503c 14. clamped_timeout = handle->loop->time + timeout; 15. if (clamped_timeout < timeout) 16. clamped_timeout = (uint64_t) -1; 17. // \u521d\u59cb\u5316\u56de\u8c03\uff0c\u8d85\u65f6\u65f6\u95f4\uff0c\u662f\u5426\u91cd\u590d\u8ba1\u65f6\uff0c\u8d4b\u4e88\u4e00\u4e2a\u72ec\u7acb\u65e0\u4e8c\u7684id 18. handle->timer_cb = cb; 19. handle->timeout = clamped_timeout; 20. handle->repeat = repeat; 21. // \u7528\u4e8e\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u65f6\u5019\uff0c\u6bd4\u8f83\u5b9a\u65f6\u5668\u5728\u4e8c\u53c9\u5806\u7684\u4f4d\u7f6e\uff0c\u89c1cmp\u51fd\u6570 22. handle->start_id = handle->loop->timer_counter++; 23. // \u63d2\u5165\u6700\u5c0f\u5806 24. heap_insert(timer_heap(handle->loop), 25. (struct heap_node*) &handle->heap_node, 26. timer_less_than); 27. // \u6fc0\u6d3b\u8be5handle 28. uv__handle_start(handle); 29. 30. return 0; 31. }","title":"10.1.4 \u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1015","text":"1. // \u505c\u6b62\u4e00\u4e2a\u8ba1\u65f6\u5668 2. int uv_timer_stop(uv_timer_t* handle) { 3. if (!uv__is_active(handle)) 4. return 0; 5. // \u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9 6. heap_remove(timer_heap(handle->loop), 7. (struct heap_node*) &handle->heap_node, 8. timer_less_than); 9. // \u6e05\u9664\u6fc0\u6d3b\u72b6\u6001\u548chandle\u7684active\u6570\u51cf\u4e00 10. uv__handle_stop(handle); 11. 12. return 0; 13. }","title":"10.1.5 \u505c\u6b62\u4e00\u4e2a\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1016","text":"\u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\u7c7b\u4f3c\u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5b83\u9996\u5148\u9700\u8981\u628a\u4e4b\u524d\u7684\u5b9a\u65f6\u5668\u4ece\u4e8c\u53c9\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806\u3002 1. // \u91cd\u65b0\u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668\uff0c\u9700\u8981\u8bbe\u7f6erepeat\u6807\u8bb0 2. int uv_timer_again(uv_timer_t* handle) { 3. if (handle->timer_cb == NULL) 4. return UV_EINVAL; 5. // \u5982\u679c\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\u8bf4\u660e\u8ba1\u65f6\u5668\u662f\u9700\u8981\u91cd\u590d\u89e6\u53d1\u7684 6. if (handle->repeat) { 7. // \u5148\u628a\u65e7\u7684\u8282\u70b9\u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u518d\u91cd\u65b0\u5f00\u542f\u4e00\u4e2a\u8ba1\u65f6\u5668 8. uv_timer_stop(handle); 9. uv_timer_start(handle, 10. handle->timer_cb, 11. handle->repeat, 12. handle->repeat); 13. } 14. 15. return 0; 16. }","title":"10.1.6 \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1017","text":"\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c\uff0c\u4e3b\u8981\u7528\u4e8e\u5224\u65adPoll IO\u8282\u70b9\u662f\u963b\u585e\u7684\u6700\u957f\u65f6\u95f4\u3002 1. // \u8ba1\u7b97\u6700\u5c0f\u5806\u4e2d\u6700\u5c0f\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4 2. int uv__next_timeout(const uv_loop_t* loop) { 3. const struct heap_node* heap_node; 4. const uv_timer_t* handle; 5. uint64_t diff; 6. // \u53d6\u51fa\u5806\u7684\u6839\u8282\u70b9\uff0c\u5373\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u7684 7. heap_node = heap_min(timer_heap(loop)); 8. if (heap_node == NULL) 9. return -1; /* block indefinitely */ 10. 11. handle = container_of(heap_node, uv_timer_t, heap_node); 12. // \u5982\u679c\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4\u5c0f\u4e8e\u5f53\u524d\u65f6\u95f4\uff0c\u5219\u8fd4\u56de0\uff0c\u8bf4\u660e\u5df2\u7ecf\u8d85\u65f6 13. if (handle->timeout <= loop->time) 14. return 0; 15. // \u5426\u5219\u8ba1\u7b97\u8fd8\u6709\u591a\u4e45\u8d85\u65f6\uff0c\u8fd4\u56de\u7ed9epoll\uff0cepoll\u7684timeout\u4e0d\u80fd\u5927\u4e8ediff 16. diff = handle->timeout - loop->time; 17. if (diff > INT_MAX) 18. diff = INT_MAX; 19. 20. return diff; 21. }","title":"10.1.7 \u8ba1\u7b97\u4e8c\u53c9\u5806\u4e2d\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1018","text":"\u5904\u7406\u8d85\u65f6\u5b9a\u65f6\u5668\u5c31\u662f\u904d\u5386\u4e8c\u53c9\u5806\uff0c\u5224\u65ad\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\u3002 1. // \u627e\u51fa\u5df2\u7ecf\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03 2. void uv__run_timers(uv_loop_t* loop) { 3. struct heap_node* heap_node; 4. uv_timer_t* handle; 5. 6. for (;;) { 7. heap_node = heap_min(timer_heap(loop)); 8. if (heap_node == NULL) 9. break; 10. 11. handle = container_of(heap_node, uv_timer_t, heap_node); 12. // \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u5927\u4e8e\u5f53\u524d\u65f6\u95f4\u5219\u8fd4\u56de\uff0c\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u6ca1\u6709\u8d85\u65f6 13. if (handle->timeout > loop->time) 14. break; 15. // \u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9\uff0c\u91cd\u65b0\u63d2\u5165\u6700\u5c0f\u5806\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86repeat\u7684\u8bdd 16. uv_timer_stop(handle); 17. uv_timer_again(handle); 18. // \u6267\u884c\u8d85\u65f6\u56de\u8c03 19. handle->timer_cb(handle); 20. } 21. }","title":"10.1.8 \u5904\u7406\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#102","text":"","title":"10.2 \u6838\u5fc3\u6570\u636e\u7ed3\u6784"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1021-timerslist","text":"\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u5b9a\u65f6\u5668\u4f1a\u88ab\u653e\u5230\u540c\u4e00\u4e2a\u961f\u5217\uff0c\u6bd4\u5982\u5f53\u524d\u6267\u884csetTimeout(()=>{}, 10000})\u548c5\u79d2\u540e\u6267\u884csetTimeout(()=>{}, 10000})\uff0c\u8fd9\u4e24\u4e2a\u4efb\u52a1\u5c31\u4f1a\u5728\u540c\u4e00\u4e2aList\u4e2d\uff0c\u8fd9\u4e2a\u961f\u5217\u7531TimersList\u6765\u7ba1\u7406\u3002\u5bf9\u5e94\u56fe1\u4e2d\u7684List\u90a3\u4e2a\u961f\u5217\u3002 1. function TimersList(expiry, msecs) { 2. // \u7528\u4e8e\u94fe\u8868 3. this._idleNext = this; 4. this._idlePrev = this; 5. this.expiry = expiry; 6. this.id = timerListId++; 7. this.msecs = msecs; 8. // \u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e 9. this.priorityQueuePosition = null; 10. } expiry\u8bb0\u5f55\u7684\u662f\u94fe\u8868\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u7684\u7edd\u5bf9\u65f6\u95f4\u3002\u6bcf\u6b21\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u65f6\u4f1a\u52a8\u6001\u66f4\u65b0\uff0cmsecs\u662f\u8d85\u65f6\u65f6\u95f4\u7684\u76f8\u5bf9\u503c\uff08\u76f8\u5bf9\u63d2\u5165\u65f6\u7684\u5f53\u524d\u65f6\u95f4\uff09\u3002\u7528\u4e8e\u8ba1\u7b97\u8be5\u94fe\u8868\u4e2d\u7684\u8282\u70b9\u662f\u5426\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u7528\u5904\u3002","title":"10.2.1 TimersList"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1022","text":"1. const timerListQueue = new PriorityQueue(compareTimersLists, setPosition) Node.js\u7528\u4f18\u5148\u961f\u5217\u5bf9\u6240\u6709TimersList\u94fe\u8868\u8fdb\u884c\u7ba1\u7406\uff0c\u4f18\u5148\u961f\u5217\u672c\u8d28\u662f\u4e00\u4e2a\u4e8c\u53c9\u5806\uff08\u5c0f\u6839\u5806\uff09\uff0c\u6bcf\u4e2aTimersList\u94fe\u8868\u5728\u4e8c\u53c9\u5806\u91cc\u5bf9\u5e94\u4e00\u4e2a\u8282\u70b9\u3002\u6839\u636eTimersList\u7684\u7ed3\u6784\uff0c\u6211\u4eec\u77e5\u9053\u6bcf\u4e2a\u94fe\u8868\u90fd\u4fdd\u5b58\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4\u3002\u4e8c\u53c9\u5806\u4ee5\u8be5\u65f6\u95f4\u4e3a\u4f9d\u636e\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684list\u5bf9\u5e94\u4e8c\u53c9\u5806\u4e2d\u7684\u6839\u8282\u70b9\u3002\u6839\u8282\u70b9\u7684\u5230\u671f\u65f6\u95f4\u5c31\u662f\u6574\u4e2aNode.js\u5b9a\u65f6\u5668\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0cNode.js\u628aLibuv\u4e2d\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\u8bbe\u7f6e\u4e3a\u8be5\u503c\uff0c\u5728\u4e8b\u4ef6\u5faa\u73af\u7684\u5b9a\u65f6\u5668\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u5b9a\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u4e0d\u65ad\u904d\u5386\u4f18\u5148\u961f\u5217\uff0c\u5224\u65ad\u5f53\u524d\u8282\u70b9\u662f\u5426\u8d85\u65f6\uff0c\u5982\u679c\u8d85\u65f6\u4e86\uff0c\u5c31\u9700\u8981\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u8d85\u65f6\uff0c\u8bf4\u660e\u6574\u4e2a\u4e8c\u53c9\u5806\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u65f6\u3002\u7136\u540e\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u8282\u70b9\u65b0\u7684\u5230\u671f\u65f6\u95f4\u3002 \u53e6\u5916\uff0cNode.js\u4e2d\u7528\u4e00\u4e2amap\u4fdd\u5b58\u4e86\u8d85\u65f6\u65f6\u95f4\u5230TimersList\u94fe\u8868\u7684\u6620\u5c04\u5173\u7cfb\u3002 \u8fd9\u6837\u5c31\u53ef\u4ee5\u6839\u636e\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u5feb\u901f\u627e\u5230\u5bf9\u5e94\u7684\u5217\u8868\uff0c\u5229\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002\u4e86\u89e3\u5b8c\u5b9a\u65f6\u5668\u6574\u4f53\u7684\u7ec4\u7ec7\u548c\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u8fdb\u5165\u771f\u6b63\u7684\u6e90\u7801\u5206\u6790\u4e86\u3002","title":"10.2.2 \u4f18\u5148\u961f\u5217"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#103","text":"Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u3002 setupTimers(processImmediate, processTimers); setupTimers\u5bf9\u5e94\u7684C++\u51fd\u6570\u662f 1. void SetupTimers(const FunctionCallbackInfo<Value>& args) { 2. auto env = Environment::GetCurrent(args); 3. env->set_immediate_callback_function(args[0].As<Function>()); 4. env->set_timers_callback_function(args[1].As<Function>()); 5. } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570\uff0cprocessImmediate\u662f\u5904\u7406setImmediate\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u7684\u3002\u5f53\u6709\u8282\u70b9\u8d85\u65f6\u65f6\uff0cNode.js\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u5904\u7406\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u540e\u7eed\u4f1a\u770b\u5230\u8be5\u51fd\u6570\u7684\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002","title":"10.3 \u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#104","text":"1. function setTimeout(callback, after, arg1, arg2, arg3) { 2. // \u5ffd\u7565\u5904\u7406\u53c2\u6570args\u903b\u8f91 3. // \u65b0\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61 4. const timeout = new Timeout(callback, 5. after, 6. args, 7. false, 8. true); 9. insert(timeout, timeout._idleTimeout); 10. return timeout; 11. } setTimeout\u4e3b\u8981\u5305\u542b\u4e24\u4e2a\u64cd\u4f5c\uff0cnew Timeout\u548cinsert\u3002\u6211\u4eec\u9010\u4e2a\u5206\u6790\u4e00\u4e0b\u3002 1 setTimeout 1. function Timeout(callback, after, args, isRepeat, isRefed) { 2. after *= 1; // Coalesce to number or NaN 3. // \u5173\u4e8esetTimeout\u7684\u8d85\u65f6\u65f6\u95f4\u4e3a0\u7684\u95ee\u9898\u5728\u8fd9\u91cc\u53ef\u4ee5\u63ed\u5f00\u8ff7\u96fe 4. if (!(after >= 1 && after <= TIMEOUT_MAX)) { 5. after = 1; 6. } 7. // \u8d85\u65f6\u65f6\u95f4\u76f8\u5bf9\u503c 8. this._idleTimeout = after; 9. // \u524d\u540e\u6307\u9488\uff0c\u7528\u4e8e\u94fe\u8868 10. this._idlePrev = this; 11. this._idleNext = this; 12. // \u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4 13. this._idleStart = null; 14. // \u8d85\u65f6\u56de\u8c03 15. this._onTimeout = callback; 16. // \u6267\u884c\u56de\u8c03\u65f6\u4f20\u5165\u7684\u53c2\u6570 17. this._timerArgs = args; 18. // \u662f\u5426\u5b9a\u671f\u89e6\u53d1\u8d85\u65f6\uff0c\u7528\u4e8esetInterval 19. this._repeat = isRepeat ? after : null; 20. this._destroyed = false; 21. // this._idleStart = now(); 22. // \u6fc0\u6d3b\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff08\u4e8c\u53c9\u5806\u7684\u8282\u70b9\uff09\uff0c\u8bf4\u660e\u6709\u5b9a\u65f6\u8282\u70b9\u9700\u8981\u5904\u7406 23. if (isRefed) 24. incRefCount(); 25. // \u8bb0\u5f55\u72b6\u6001 26. this[kRefed] = isRefed; 27. } Timeout\u4e3b\u8981\u662f\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\u8bb0\u5f55\u4e00\u4e9b\u5b9a\u65f6\u5668\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\uff08\u7528\u4e8e\u652f\u6301setInterval\uff0c\u91cd\u65b0\u63d2\u5165\u961f\u5217\u65f6\u627e\u5230\u6240\u5c5e\u961f\u5217\uff09\u3001\u5f00\u59cb\u65f6\u95f4\uff08\u7528\u4e8e\u8ba1\u7b97\u5b9a\u65f6\u5668\u662f\u5426\u8d85\u65f6\uff09\u7b49\u4e0a\u4e0b\u6587\u4fe1\u606f\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u952e\u7684\u903b\u8f91\u662fisRefed\u7684\u503c\u3002Node.js\u652f\u6301ref\u548cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff08setTimeout \u548csetUnrefTimeout\uff09\uff0cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u5373\u5f53\u53ea\u6709unref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u4e8b\u4ef6\u5faa\u73af\u4f1a\u7ed3\u675f\u3002\u5f53isRefed\u4e3atrue\u65f6\u4f1a\u6267\u884cincRefCount(); 1. function incRefCount() { 2. if (refCount++ === 0) 3. toggleTimerRef(true); 4. } 5. 6. void ToggleTimerRef(const FunctionCallbackInfo<Value>& args) { 7. Environment::GetCurrent(args)->ToggleTimerRef(args[0]->IsTrue()); 8. } 9. 10. void Environment::ToggleTimerRef(bool ref) { 11. if (started_cleanup_) return; 12. // \u6253\u4e0aref\u6807\u8bb0\uff0c 13. if (ref) { 14. uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle())); 15. } else { 16. uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle())); 17. } 18. } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u4f1a\u8c03\u7528Libuv\u7684uv_ref\u6216uv_unref\u4fee\u6539\u5b9a\u65f6\u5668\u76f8\u5173handle\u7684\u72b6\u6001\uff0c\u56e0\u4e3aNode.js\u53ea\u4f1a\u5728Libuv\u4e2d\u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668handle\u5e76\u4e14\u662f\u5e38\u9a7b\u7684\uff0c\u5982\u679cJS\u5c42\u5f53\u524d\u6ca1\u6709\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5219\u9700\u8981\u4fee\u6539\u5b9a\u65f6\u5668handle\u7684\u72b6\u6001\u4e3aunref\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002refCount\u503c\u4fbf\u662f\u8bb0\u5f55JS\u5c42ref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u4e2a\u6570\u7684\u3002\u6240\u4ee5\u5f53\u6211\u4eec\u7b2c\u4e00\u6b21\u6267\u884csetTimeout\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u6fc0\u6d3bLibuv\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0binsert\u3002 1. let nextExpiry = Infinity; 2. function insert(item, msecs, start = getLibuvNow()) { 3. msecs = MathTrunc(msecs); 4. // \u8bb0\u5f55\u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4\uff0c\u89c1Timeout\u51fd\u6570\u7684\u5b9a\u4e49 5. item._idleStart = start; 6. // \u8be5\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5bf9\u5e94\u7684\u94fe\u8868 7. let list = timerListMap[msecs]; 8. // \u8fd8\u6ca1\u6709 9. if (list === undefined) { 10. // \u7b97\u51fa\u7edd\u5bf9\u8d85\u65f6\u65f6\u95f4\uff0c\u7b2c\u4e00\u4e2a\u8282\u70b9\u662f\u8be5\u94fe\u8868\u4e2d\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9 11. const expiry = start + msecs; 12. // \u65b0\u5efa\u4e00\u4e2a\u94fe\u8868 13. timerListMap[msecs] = list = new TimersList(expiry, msecs); 14. // \u63d2\u5165\u4f18\u5148\u961f\u5217 15. timerListQueue.insert(list); 16. /* 17. nextExpiry\u8bb0\u5f55\u6240\u6709\u8d85\u65f6\u8282\u70b9\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\uff0c 18. \u5982\u679c\u6709\u66f4\u5feb\u5230\u671f\u7684\uff0c\u5219\u4fee\u6539\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4 19. */ 20. if (nextExpiry > expiry) { 21. // \u4fee\u6539\u5e95\u5c42\u8d85\u65f6\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 22. scheduleTimer(msecs); 23. nextExpiry = expiry; 24. } 25. } 26. // \u628a\u5f53\u524d\u8282\u70b9\u52a0\u5230\u94fe\u8868\u91cc 27. L.append(list, item); 28. } Insert\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u5982\u679c\u8be5\u8d85\u65f6\u65f6\u95f4\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u5219\u65b0\u5efa\u4e00\u4e2a\u94fe\u8868\uff0c\u6bcf\u4e2a\u94fe\u8868\u90fd\u4f1a\u8bb0\u5f55\u8be5\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u503c\uff0c\u5373\u7b2c\u4e00\u4e2a\u63d2\u5165\u7684\u503c\u3002\u7136\u540e\u628a\u94fe\u8868\u63d2\u5165\u4f18\u5148\u961f\u5217\uff0c\u4f18\u5148\u961f\u5217\u4f1a\u6839\u636e\u8be5\u94fe\u8868\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7684\u503c\uff0c\u628a\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u8c03\u6574\u5230\u76f8\u5e94\u7684\u4f4d\u7f6e\u3002 2 \u5982\u679c\u5f53\u524d\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u6bd4\u4e4b\u524d\u6240\u6709\u7684\u5b9a\u65f6\u5668\u90fd\u5feb\u5230\u671f\uff0c\u5219\u9700\u8981\u4fee\u6539\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff0c\u4f7f\u5f97\u66f4\u5feb\u89e6\u53d1\u8d85\u65f6\u3002 3 \u628a\u5f53\u524d\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u63d2\u5165\u5bf9\u5e94\u7684\u94fe\u8868\u5c3e\u90e8\u3002\u5373\u8be5\u94fe\u8868\u4e2d\u6700\u4e45\u8d85\u65f6\u7684\u8282\u70b9\u3002 \u5047\u8bbe\u6211\u4eec\u57280s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u4e0b\u9762\u662f\u63d2\u5165\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\u7684\u7ed3\u6784\u56fe\u5982\u56fe10-2\u6240\u793a\u3002 \u56fe10-2 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u591a\u4e2a\u8282\u70b9\u7684\u60c5\u51b5\u3002\u5047\u8bbe0s\u7684\u65f6\u5019\u63d2\u5165\u4e24\u4e2a\u8282\u70b910s\u8fc7\u671f\u548c11s\u8fc7\u671f\u3002\u5982\u56fe10-3\u6240\u793a\u3002 \u56fe10-3 \u7136\u540e\u57281s\u7684\u65f6\u5019\uff0c\u63d2\u5165\u4e00\u4e2a\u65b0\u768411s\u8fc7\u671f\u7684\u8282\u70b9\uff0c9s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u65b0\u768410s\u8fc7\u671f\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe10-4\u6240\u793a\u3002 \u56fe10-4 \u6211\u4eec\u770b\u5230\u4f18\u5148\u961f\u5217\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u94fe\u8868\uff0c\u7236\u8282\u70b9\u5bf9\u5e94\u7684\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u6bd4\u5b50\u8282\u70b9\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5148\u8d85\u65f6\u7684\uff0c\u4f46\u662f\u94fe\u8868\u4e2d\u540e\u7eed\u8282\u70b9\u7684\u8d85\u65f6\u5c31\u4e0d\u4e00\u5b9a\u3002\u6bd4\u5982\u5b50\u8282\u70b91s\u5f00\u59cb\u7684\u8282\u70b9\u5c31\u6bd4\u7236\u8282\u70b99s\u5f00\u59cb\u7684\u8282\u70b9\u5148\u8d85\u65f6\u3002\u56e0\u4e3a\u540c\u4e00\u961f\u5217\uff0c\u53ea\u662f\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\uff0c\u800c\u8fd8\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u56e0\u7d20\u662f\u5f00\u59cb\u7684\u65f6\u95f4\u3002\u867d\u7136\u67d0\u8282\u70b9\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u957f\uff0c\u4f46\u662f\u5982\u679c\u5b83\u6bd4\u53e6\u4e00\u4e2a\u8282\u70b9\u5f00\u59cb\u7684\u65e9\uff0c\u90a3\u4e48\u5c31\u6709\u53ef\u80fd\u6bd4\u5b83\u5148\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u662f\u600e\u4e48\u5b9e\u73b0\u7684\u3002","title":"10.4 \u8bbe\u7f6e\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#105","text":"\u524d\u9762\u6211\u4eec\u8bb2\u5230\u4e86\u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570\u548c\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u4f46\u662f\u5728\u54ea\u91cc\u89e6\u53d1\u8fd9\u4e2a\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u5462\uff1f\u7b54\u6848\u5728scheduleTimer\u51fd\u6570\u3002Node.js\u7684\u5b9e\u73b0\u4e2d\uff0c\u6240\u6709JS\u5c42\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u5bf9\u5e94Libuv\u7684\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\uff0cNode.js\u7ef4\u62a4\u4e86JS\u5c42\u6240\u6709\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u6700\u5c0f\u503c\u3002\u5728\u7b2c\u4e00\u4e2a\u8bbe\u7f6e\u5b9a\u65f6\u5668\u6216\u8005\u8bbe\u7f6e\u4e00\u4e2a\u65b0\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u5982\u679c\u65b0\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u6bd4\u5f53\u524d\u7684\u6700\u5c0f\u503c\u5c0f\uff0c\u5219\u4f1a\u901a\u8fc7scheduleTimer\u4fee\u6539\u8d85\u65f6\u65f6\u95f4\u3002\u8d85\u65f6\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002scheduleTimer\u51fd\u6570\u662f\u5bf9C++\u51fd\u6570\u7684\u5c01\u88c5\u3002 1. void ScheduleTimer(const FunctionCallbackInfo<Value>& args) { 2. auto env = Environment::GetCurrent(args); 3. env->ScheduleTimer(args[0]->IntegerValue(env->context()).FromJust()); 4. } 5. 6. void Environment::ScheduleTimer(int64_t duration_ms) { 7. if (started_cleanup_) return; 8. uv_timer_start(timer_handle(), RunTimers, duration_ms, 0); 9. } uv_timer_start\u5c31\u662f\u5f00\u542f\u5e95\u5c42\u8ba1\u65f6\uff0c\u5373\u5f80Libuv\u7684\u4e8c\u53c9\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff08\u5982\u679c\u8be5handle\u5df2\u7ecf\u5b58\u5728\u4e8c\u53c9\u5806\uff0c\u5219\u5148\u5220\u9664\uff09\u3002\u8d85\u65f6\u65f6\u95f4\u662fduration_ms\uff0c\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0c\u8d85\u65f6\u56de\u8c03\u662fRunTimers\uff0c\u5728timer\u9636\u6bb5\u4f1a\u5224\u65ad\u662f\u5426\u8fc7\u671f\u3002\u662f\u7684\u8bdd\u6267\u884cRunTimers\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bRunTimers\u51fd\u6570\u7684\u4e3b\u8981\u4ee3\u7801\u3002 1. Local<Function> cb = env->timers_callback_function(); 2. ret = cb->Call(env->context(), process, 1, &arg); RunTimers\u4f1a\u6267\u884ctimers_callback_function\u3002timers_callback_function\u662f\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684processTimers\u51fd\u6570\u3002\u73b0\u5728\u6211\u4eec\u77e5\u9053\u4e86Node.js\u662f\u5982\u4f55\u8bbe\u7f6e\u8d85\u65f6\u7684\u5904\u7406\u51fd\u6570\uff0c\u4e5f\u77e5\u9053\u4e86\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u90a3\u6211\u4eec\u5c31\u6765\u770b\u4e00\u4e0b\u56de\u8c03\u65f6\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002 1. void Environment::RunTimers(uv_timer_t* handle) { 2. Local<Function> cb = env->timers_callback_function(); 3. MaybeLocal<Value> ret; 4. Local<Value> arg = env->GetNow(); 5. 6. do { 7. // \u6267\u884cjs\u56de\u8c03processTimers\u51fd\u6570 8. ret = cb->Call(env->context(), process, 1, &arg); 9. } while (ret.IsEmpty() && env->can_call_into_js()); 10. 11. // \u5982\u679c\u8fd8\u6709\u672a\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219ret\u4e3a\u7b2c\u4e00\u4e2a\u672a\u8d85\u65f6\u7684\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 12. int64_t expiry_ms = ret.ToLocalChecked()->IntegerValue(env->context()).FromJust(); 13. uv_handle_t* h = reinterpret_cast<uv_handle_t*>(handle); 14. 15. /* 16. 1 \u7b49\u4e8e0\u8bf4\u660e\u6240\u6709\u8282\u70b9\u90fd\u6267\u884c\u5b8c\u4e86\uff0c\u4f46\u662f\u5b9a\u65f6\u5668\u8282\u70b9\u8fd8\u662f\u5728Libuv\u4e2d\uff0c 17. \u4e0d\u8fc7\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c\u5373\u4e0d\u4f1a\u5f71\u54cdLibuv\u9000\u51fa\uff0c\u56e0\u4e3a\u5f53\u524d\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u4e86\uff08handle\uff09\uff0c 18. 2 \u4e0d\u7b49\u4e8e0\u8bf4\u660e\u6ca1\u6709\u8fd8\u8981\u8282\u70b9\u9700\u8981\u5904\u7406\uff0c\u8fd9\u79cd\u60c5\u51b5\u53c8\u5206\u4e3a\u4e24\u79cd 19. 1 \u8fd8\u6709\u6fc0\u6d3b\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u5373\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 20. 2 \u5b9a\u65f6\u5668\u90fd\u662f\u975e\u6fc0\u6d3b\u72b6\u6001\u7684\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 21. \u5177\u4f53\u89c1Timeout\u7684unref\u548cref\u65b9\u6cd5 22. */ 23. if (expiry_ms != 0) { 24. // \u7b97\u51fa\u4e0b\u6b21\u8d85\u65f6\u7684\u76f8\u5bf9\u503c 25. int64_t duration_ms = 26. llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base()); 27. // \u91cd\u65b0\u628ahandle\u63d2\u5165Libuv\u7684\u4e8c\u53c9\u5806 28. env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1); 29. /* 30. \u89c1internal/timer.js\u7684processTimers 31. 1 \u5927\u4e8e0\u8bf4\u660e\u8fd8\u6709\u8282\u70b9\u6ca1\u8d85\u65f6\uff0c\u5e76\u4e14\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c 32. \u9700\u8981\u4fdd\u6301\u5b9a\u65f6\u5668\u7684\u6fc0\u6d3b\u72b6\u6001\uff08\u5982\u679c\u4e4b\u524d\u662f\u6fc0\u6d3b\u72b6\u6001\u5219\u4e0d\u5f71\u54cd\uff09\uff0c 33. 2 \u5c0f\u4e8e0\u8bf4\u660e\u5b9a\u65f6\u5668\u4e0d\u5f71\u54cdLibuv\u7684\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\uff0c\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001 34. */ 35. if (expiry_ms > 0) 36. uv_ref(h); 37. else 38. uv_unref(h); 39. } else { 40. uv_unref(h); 41. } 42. } \u8be5\u51fd\u6570\u4e3b\u8981\u662f\u6267\u884c\u56de\u8c03\uff0c\u7136\u540e\u5982\u679c\u8fd8\u6709\u6ca1\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u3002\u770b\u770bJS\u5c42\u9762\u3002 1. function processTimers(now) { 2. nextExpiry = Infinity; 3. let list; 4. let ranAtLeastOneList = false; 5. // \u53d6\u51fa\u4f18\u5148\u961f\u5217\u7684\u6839\u8282\u70b9\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9 6. while (list = timerListQueue.peek()) { 7. // \u8fd8\u6ca1\u8fc7\u671f\uff0c\u5219\u53d6\u5f97\u4e0b\u6b21\u5230\u671f\u7684\u65f6\u95f4\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 8. if (list.expiry > now) { 9. nextExpiry = list.expiry; 10. // \u8fd4\u56de\u4e0b\u4e00\u6b21\u8fc7\u671f\u7684\u65f6\u95f4\uff0c\u8d1f\u7684\u8bf4\u660e\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 11. return refCount > 0 ? nextExpiry : -nextExpiry; 12. } 13. 14. // \u5904\u7406\u8d85\u65f6\u8282\u70b9 15. listOnTimeout(list, now); 16. } 17. // \u6240\u6709\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86 18. return 0; 19. } 20. 21. function listOnTimeout(list, now) { 22. const msecs = list.msecs; 23. let ranAtLeastOneTimer = false; 24. let timer; 25. // \u904d\u5386\u5177\u6709\u7edf\u4e00\u76f8\u5bf9\u8fc7\u671f\u65f6\u95f4\u7684\u961f\u5217 26. while (timer = L.peek(list)) { 27. // \u7b97\u51fa\u5df2\u7ecf\u8fc7\u53bb\u7684\u65f6\u95f4 28. const diff = now - timer._idleStart; 29. // \u8fc7\u671f\u7684\u65f6\u95f4\u6bd4\u8d85\u65f6\u65f6\u95f4\u5c0f\uff0c\u8fd8\u6ca1\u8fc7\u671f 30. if (diff < msecs) { 31. /* 32. \u6574\u4e2a\u94fe\u8868\u8282\u70b9\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7b49\u4e8e\u5f53\u524d 33. \u8fd8\u6ca1\u8fc7\u671f\u8282\u70b9\u7684\u503c\uff0c\u94fe\u8868\u662f\u6709\u5e8f\u7684 34. */ 35. list.expiry = MathMax(timer._idleStart + msecs, 36. now + 1); 37. // \u66f4\u65b0id\uff0c\u7528\u4e8e\u51b3\u5b9a\u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e 38. list.id = timerListId++; 39. /* 40. \u8c03\u6574\u8fc7\u671f\u65f6\u95f4\u540e\uff0c\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u662f\u4f18\u5148\u961f\u5217 41. \u91cc\u7684\u6839\u8282\u70b9\u4e86\uff0c\u53ef\u80fd\u6709\u5b83\u66f4\u5feb\u5230\u671f\uff0c\u5373\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282 42. \u70b9\u53ef\u80fd\u9700\u8981\u5f80\u4e0b\u6c89 43. */ 44. timerListQueue.percolateDown(1); 45. return; 46. } 47. 48. // \u51c6\u5907\u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03\uff0c\u5220\u9664\u8fd9\u4e2a\u8282\u70b9 49. L.remove(timer); 50. 51. let start; 52. if (timer._repeat) 53. start = getLibuvNow(); 54. try { 55. const args = timer._timerArgs; 56. // \u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03 57. if (args === undefined) 58. timer._onTimeout(); 59. else 60. timer._onTimeout(...args); 61. } finally { 62. /* 63. \u8bbe\u7f6e\u4e86\u91cd\u590d\u6267\u884c\u56de\u8c03\uff0c\u5373\u6765\u81easetInterval\u3002 64. \u5219\u9700\u8981\u91cd\u65b0\u52a0\u5165\u94fe\u8868\u3002 65. */ 66. if (timer._repeat && 67. timer._idleTimeout !== -1) { 68. // \u66f4\u65b0\u8d85\u65f6\u65f6\u95f4\uff0c\u4e00\u6837\u7684\u65f6\u95f4\u95f4\u9694 69. timer._idleTimeout = timer._repeat; 70. // \u91cd\u65b0\u63d2\u5165\u94fe\u8868 71. insert(timer, timer._idleTimeout, start); 72. } else if (!timer._idleNext && 73. !timer._idlePrev && 74. !timer._destroyed) { 75. timer._destroyed = true; 76. // \u662fref\u7c7b\u578b\uff0c\u5219\u51cf\u53bb\u4e00\u4e2a\uff0c\u9632\u6b62\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 77. if (timer[kRefed]) 78. refCount--; 79. } 80. // \u4e3a\u7a7a\u5219\u5220\u9664 81. if (list === timerListMap[msecs]) { 82. delete timerListMap[msecs]; 83. // \u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9\uff0c\u5e76\u8c03\u6574\u961f\u5217\u7ed3\u6784 84. timerListQueue.shift(); 85. } 86. } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u662f\u904d\u5386\u4f18\u5148\u961f\u5217 1 \u5982\u679c\u5f53\u524d\u8282\u70b9\u8d85\u65f6\uff0c\u5219\u904d\u5386\u5b83\u5bf9\u5e94\u7684\u94fe\u8868\u3002\u904d\u5386\u94fe\u8868\u7684\u65f6\u5019\u5982\u679c\u9047\u5230\u8d85\u65f6\u7684\u8282\u70b9\u5219\u6267\u884c\u3002\u5982\u679c\u9047\u5230\u6ca1\u6709\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\uff0c\u56e0\u4e3a\u94fe\u8868\u662f\u6709\u5e8f\u7684\uff0c\u63a5\u7740\u91cd\u65b0\u8ba1\u7b97\u51fa\u6700\u5feb\u8d85\u65f6\u65f6\u95f4\uff0c\u4fee\u6539\u94fe\u8868\u7684expiry\u5b57\u6bb5\u3002\u8c03\u6574\u5728\u4f18\u5148\u961f\u5217\u7684\u4f4d\u7f6e\u3002\u56e0\u4e3a\u4fee\u6539\u540e\u7684expiry\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4f4d\u7f6e\u53d1\u751f\u53d8\u5316\u3002\u5982\u679c\u94fe\u8868\u7684\u8282\u70b9\u5168\u90e8\u90fd\u8d85\u65f6\u4e86\uff0c\u5219\u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u91cd\u65b0\u8c03\u6574\u4f18\u5148\u961f\u5217\u7684\u8282\u70b9\u3002 2 \u5982\u679c\u5f53\u524d\u8282\u70b9\u6ca1\u6709\u8d85\u65f6\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\u3002\u56e0\u4e3a\u5f53\u524d\u8282\u70b9\u662f\u4f18\u5148\u961f\u5217\u4e2d\u6700\u5feb\u5230\u671f\uff08\u6700\u5c0f\u7684\uff09\u7684\u8282\u70b9\u3002\u63a5\u7740\u8bbe\u7f6eLibuv\u7684\u5b9a\u65f6\u5668\u65f6\u95f4\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u3002\u7b49\u5f85\u4e0b\u4e00\u6b21\u8d85\u65f6\u5904\u7406\u3002","title":"10.5 \u5904\u7406\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#106-refunref","text":"setTimeout\u8fd4\u56de\u7684\u662f\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8be5\u63d0\u4f9b\u4e86ref\u548cunref\u63a5\u53e3\uff0c\u521a\u624d\u63d0\u5230\u4e86\u5173\u4e8e\u5b9a\u65f6\u5668\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u539f\u7406\u3002\u521a\u624d\u8bf4\u5230Node.js\u5b9a\u65f6\u5668\u6a21\u5757\u5728Libuv\u4e2d\u53ea\u5bf9\u5e94\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u521d\u59cb\u5316\u4e86\u8be5\u8282\u70b9\u3002 1. void Environment::InitializeLibuv(bool start_profiler_idle_notifier) { 2. // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 3. CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle())); 4. // \u7f6eunref\u72b6\u6001 5. uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle())); 6. } \u6211\u4eec\u770b\u5230\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u9ed8\u8ba4\u662funref\u72b6\u6001\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u56e0\u4e3a\u521d\u59cb\u5316\u65f6JS\u5c42\u6ca1\u6709\u5b9a\u65f6\u8282\u70b9\u3002\u53ef\u4ee5\u901a\u8fc7Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u4fee\u6539\u8be5\u72b6\u6001\u3002Node.js\u652f\u6301ref\u72b6\u6001\u7684Timeout\uff08setTimeout\uff09\u548cunref\u72b6\u6001\u7684Timeout\uff08setUnrefTimeout\uff09\u3002 1. function Timeout(callback, after, args, isRepeat, isRefed) { 2. if (isRefed) 3. incRefCount(); 4. this[kRefed] = isRefed; 5. } \u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u63a7\u5236ref\u8fd8\u662funref\u7684\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679cisRefed\u4e3atrue\u7684\u65f6\u5019\u7684\u903b\u8f91 1. function incRefCount() { 2. if (refCount++ === 0) 3. toggleTimerRef(true); 4. } refCount\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f1\uff0c\u6240\u4ee5\u5728\u65b0\u52a0\u7b2c\u4e00\u4e2aTimeout\u7684\u65f6\u5019\uff0cif\u6210\u7acb\u3002\u6211\u4eec\u63a5\u7740\u770btoggleTimerRef\uff0c\u8be5\u51fd\u6570\u5bf9\u5e94\u7684\u4ee3\u7801\u5982\u4e0b 1. void Environment::ToggleTimerRef(bool ref) { 2. // \u6253\u4e0aref\u6807\u8bb0\uff0c 3. if (ref) { 4. uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle())); 5. } else { 6. uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle())); 7. } 8. } \u8be5\u51fd\u6570\u6b63\u662f\u7ed9\u5b9a\u65f6\u5668\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u72b6\u6001\u7684\u3002setTimeout\u7684\u65f6\u5019\uff0cisRefed\u7684\u503c\u662ftrue\u7684\uff0cNode.js\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u4e2a\u51fd\u6570setUnrefTimeout\u3002 1. function setUnrefTimeout(callback, after) { 2. const timer = new Timeout(callback, after, undefined, false, false); 3. insert(timer, timer._idleTimeout); 4. return timer; 5. } \u8be5\u51fd\u6570\u548csetTimeout\u6700\u4e3b\u8981\u7684\u533a\u522b\u662fnew Timeout\u7684\u65f6\u5019\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u662ffalse\uff08isRefed\u53d8\u91cf\u7684\u503c\uff09\uff0c\u6240\u4ee5setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u662f\u4e0d\u4f1a\u5f71\u54cdLibuv\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u3002\u53e6\u5916\u9664\u4e86Node.js\u76f4\u63a5\u63d0\u4f9b\u7684api\u540e\u3002\u6211\u4eec\u8fd8\u53ef\u4ee5\u901a\u8fc7Timeout\u5bf9\u8c61\u63d0\u4f9b\u7684ref\u548cunref\u624b\u52a8\u63a7\u5236\u8fd9\u4e2a\u72b6\u6001\u3002 \u73b0\u5728\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u5177\u4f53\u6765\u770b\u4e00\u4e0b\u3002 1. const timeout = setTimeout(() => { 2. console.log(1) 3. }, 10000); 4. timeout.unref(); 5. // timeout.ref(); \u52a0\u8fd9\u4e00\u53e5\u4f1a\u8f93\u51fa1 \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c1\u662f\u4e0d\u4f1a\u8f93\u51fa\uff0c\u9664\u975e\u628a\u6ce8\u91ca\u53bb\u6389\u3002Unref\u548cref\u662f\u76f8\u53cd\u7684\u53c2\u6570\uff0c\u5373\u628a\u5b9a\u65f6\u5668\u6a21\u5757\u5bf9\u5e94\u7684Libuv handle\u6539\u6210unref\u72b6\u6001\u3002","title":"10.6 ref\u548cunref"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/","text":"setImmediate\u5bf9\u5e94Libuv\u7684check\u9636\u6bb5\u3002\u6240\u63d0\u4ea4\u7684\u4efb\u52a1\u4f1a\u5728Libuv\u4e8b\u4ef6\u5faa\u73af\u7684check\u9636\u6bb5\u88ab\u6267\u884c\uff0ccheck\u9636\u6bb5\u7684\u4efb\u52a1\u4f1a\u5728\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u88ab\u6267\u884c\uff0c\u4f46\u662fsetImmediate\u63d0\u4ea4\u7684\u4efb\u52a1\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u4e0b\u9762\u6211\u4eec\u4f1a\u770b\u5230Node.js\u662f\u600e\u4e48\u5904\u7406\u7684\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 11.1 setImmediate \u00b6 11.1.1\u8bbe\u7f6e\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570 \u00b6 \u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e86\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570 1. // runNextTicks\u7528\u4e8e\u5904\u7406nextTick\u4ea7\u751f\u7684\u4efb\u52a1\uff0c\u8fd9\u91cc\u4e0d\u5173\u6ce8 2. const { processImmediate, processTimers } = getTimerCallbacks(runNextTicks); 3. setupTimers(processImmediate, processTimers); \u6211\u4eec\u5148\u770b\u770b\u4e00\u4e0bsetupTimers\uff08timer.cc\uff09\u7684\u903b\u8f91\u3002 1. void SetupTimers(const FunctionCallbackInfo<Value>& args) { 2. auto env = Environment::GetCurrent(args); 3. env->set_immediate_callback_function(args[0].As<Function>()); 4. env->set_timers_callback_function(args[1].As<Function>()); 5. } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570processImmediate, processTimers\uff0cprocessImmediate\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u4efb\u52a1\u7684\uff0c\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002 11.1.2 \u6ce8\u518ccheck\u9636\u6bb5\u7684\u56de\u8c03 \u00b6 \u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u540c\u65f6\u521d\u59cb\u5316\u4e86immediate\u4efb\u52a1\u76f8\u5173\u7684\u6570\u636e\u7ed3\u6784\u548c\u903b\u8f91\u3002 1. void Environment::InitializeLibuv(bool start_profiler_idle_notifier) { 2. // \u521d\u59cb\u5316immediate\u76f8\u5173\u7684handle 3. uv_check_init(event_loop(), immediate_check_handle()); 4. // \u4fee\u6539\u72b6\u6001\u4e3aunref\uff0c\u907f\u514d\u6ca1\u6709\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 5. uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle())); 6. // \u6fc0\u6d3bhandle\uff0c\u8bbe\u7f6e\u56de\u8c03 7. uv_check_start(immediate_check_handle(), CheckImmediate); 8. // \u5728idle\u9636\u6bb5\u4e5f\u63d2\u5165\u4e00\u4e2a\u76f8\u5173\u7684\u8282\u70b9 9. uv_idle_init(event_loop(), immediate_idle_handle()); 10. } Node.js\u9ed8\u8ba4\u4f1a\u5f80check\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u4e3aCheckImmediate\uff0c\u4f46\u662f\u521d\u59cb\u5316\u72b6\u6001\u662funref\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6ca1\u6709immediate\u4efb\u52a1\u7684\u8bdd\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u6211\u4eec\u770b\u4e00\u4e0bCheckImmediate\u51fd\u6570 1. void Environment::CheckImmediate(uv_check_t* handle) { 2. // \u7701\u7565\u90e8\u5206\u4ee3\u7801 3. // \u6ca1\u6709Immediate\u8282\u70b9\u9700\u8981\u5904\u7406 4. if (env->immediate_info()->count() == 0 || 5. !env->can_call_into_js()) 6. return; 7. do { 8. // \u6267\u884cJS\u5c42\u56de\u8c03immediate_callback_function 9. MakeCallback(env->isolate(), 10. env->process_object(), 11. env->immediate_callback_function(), 12. 0, 13. nullptr, 14. {0, 0}).ToLocalChecked(); 15. } while (env->immediate_info()->has_outstanding() && 16. env->can_call_into_js()); 17. /* 18. \u6240\u6709immediate\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86\uff0c\u7f6eidle\u9636\u6bb5\u5bf9\u5e94\u8282\u70b9\u4e3a\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c 19. \u5141\u8bb8Poll IO\u9636\u6bb5\u963b\u585e\u548c\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 20. */ 21. if (env->immediate_info()->ref_count() == 0) 22. env->ToggleImmediateRef(false); 23. } \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u65f6\uff0cCheckImmediate\u90fd\u4f1a\u88ab\u6267\u884c\uff0c\u4f46\u662f\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\u5219\u76f4\u63a5\u8fd4\u56de\u3002\u5982\u679c\u6709\u4efb\u52a1\uff0cCheckImmediate\u51fd\u6570\u6267\u884cimmediate_callback_function\u51fd\u6570\uff0c\u8fd9\u6b63\u662fNode.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u51fd\u6570processImmediate\u3002\u770b\u5b8c\u521d\u59cb\u5316\u548c\u5904\u7406immediate\u4efb\u52a1\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4ea7\u751f\u4e00\u4e2aimmediate\u4efb\u52a1\u3002 11.1.3 setImmediate\u751f\u6210\u4efb\u52a1 \u00b6 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setImmediate\u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u3002 1. function setImmediate(callback, arg1, arg2, arg3) { 2. let i, args; 3. switch (arguments.length) { 4. case 1: 5. break; 6. case 2: 7. args = [arg1]; 8. break; 9. case 3: 10. args = [arg1, arg2]; 11. break; 12. default: 13. args = [arg1, arg2, arg3]; 14. for (i = 4; i < arguments.length; i++) { 15. args[i - 1] = arguments[i]; 16. } 17. break; 18. } 19. 20. return new Immediate(callback, args); 21. } setImmediate\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e00\u4e2aImmediate\u3002\u6211\u4eec\u770b\u4e00\u4e0bImmediate\u7684\u7c7b\u3002 1. const Immediate = class Immediate { 2. constructor(callback, args) { 3. this._idleNext = null; 4. this._idlePrev = null; 5. this._onImmediate = callback; 6. this._argv = args; 7. this._destroyed = false; 8. this[kRefed] = false; 9. this.ref(); 10. // Immediate\u94fe\u8868\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u5305\u62ecref\u548cunref\u72b6\u6001 11. immediateInfo[kCount]++; 12. // \u52a0\u5165\u94fe\u8868\u4e2d 13. immediateQueue.append(this); 14. } 15. // \u6253\u4e0aref\u6807\u8bb0\uff0c\u5f80Libuv\u7684idle\u94fe\u8868\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u72b6\u6001\u7684\u8282\u70b9\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd 16. ref() { 17. if (this[kRefed] === false) { 18. this[kRefed] = true; 19. if (immediateInfo[kRefCount]++ === 0) 20. toggleImmediateRef(true); 21. } 22. return this; 23. } 24. // \u548c\u4e0a\u9762\u76f8\u53cd 25. unref() { 26. if (this[kRefed] === true) { 27. this[kRefed] = false; 28. if (--immediateInfo[kRefCount] === 0) 29. toggleImmediateRef(false); 30. } 31. return this; 32. } 33. 34. hasRef() { 35. return !!this[kRefed]; 36. } 37. }; Immediate\u7c7b\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u4e8b\u60c5\u3002 1 \u751f\u6210\u4e00\u4e2a\u8282\u70b9\u63d2\u5165\u5230\u94fe\u8868\u3002 1. const immediateQueue = new ImmediateList(); 2. 3. // \u53cc\u5411\u975e\u5faa\u73af\u7684\u94fe\u8868 4. function ImmediateList() { 5. this.head = null; 6. this.tail = null; 7. } 8. ImmediateList.prototype.append = function(item) { 9. // \u5c3e\u6307\u9488\u975e\u7a7a\uff0c\u8bf4\u660e\u94fe\u8868\u975e\u7a7a\uff0c\u76f4\u63a5\u8ffd\u52a0\u5728\u5c3e\u8282\u70b9\u540e\u9762 10. if (this.tail !== null) { 11. this.tail._idleNext = item; 12. item._idlePrev = this.tail; 13. } else { 14. // \u5c3e\u6307\u9488\u662f\u7a7a\u8bf4\u660e\u94fe\u8868\u662f\u7a7a\u7684\uff0c\u5934\u5c3e\u6307\u9488\u90fd\u6307\u5411item 15. this.head = item; 16. } 17. this.tail = item; 18. }; 19. 20. ImmediateList.prototype.remove = function(item) { 21. // \u5982\u679citem\u5728\u4e2d\u95f4\u5219\u81ea\u5df1\u5168\u8eab\u800c\u9000\uff0c\u524d\u540e\u4e24\u4e2a\u8282\u70b9\u8fde\u4e0a 22. if (item._idleNext !== null) { 23. item._idleNext._idlePrev = item._idlePrev; 24. } 25. 26. if (item._idlePrev !== null) { 27. item._idlePrev._idleNext = item._idleNext; 28. } 29. // \u662f\u5934\u6307\u9488\uff0c\u5219\u9700\u8981\u66f4\u65b0\u5934\u6307\u9488\u6307\u5411item\u7684\u4e0b\u4e00\u4e2a\uff0c\u56e0\u4e3aitem\u88ab\u5220\u9664\u4e86\uff0c\u5c3e\u6307\u9488\u540c\u7406 30. if (item === this.head) 31. this.head = item._idleNext; 32. if (item === this.tail) 33. this.tail = item._idlePrev; 34. // \u91cd\u7f6e\u524d\u540e\u6307\u9488 35. item._idleNext = null; 36. item._idlePrev = null; 37. }; 2 \u5982\u679c\u8fd8\u6ca1\u6709\u5f80Libuv\u7684idle\u94fe\u8868\u91cc\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u8282\u70b9\u7684\u8bdd\uff0c\u5219\u63d2\u5165\u4e00\u4e2a\u3002\u4ece\u4e4b\u524d\u7684\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053\uff0cNode.js\u5728check\u9636\u6bb5\u63d2\u5165\u4e86\u4e00\u4e2aunref\u8282\u70b9\uff0c\u5728\u6bcf\u6b21check\u9636\u6bb5\u90fd\u4f1a\u6267\u884c\u8be5\u8282\u70b9\u7684\u56de\u8c03\uff0c\u90a3\u4e48\u8fd9\u4e2aidle\u8282\u70b9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u7b54\u6848\u5728uv_backend_timeout\u51fd\u6570\u4e2d\uff0cuv_backend_timeout\u5b9a\u4e49\u4e86Poll IO\u963b\u585e\u7684\u65f6\u957f\uff0c\u5982\u679c\u6709ref\u72b6\u6001\u7684idle\u8282\u70b9\u5219Poll IO\u9636\u6bb5\u4e0d\u4f1a\u963b\u585e\uff08\u4f46\u662f\u4e0d\u4f1a\u5224\u65ad\u662f\u5426\u6709check\u8282\u70b9\uff09\u3002\u6240\u4ee5\u5f53\u6709immediate\u4efb\u52a1\u65f6\uff0cNode.js\u4f1a\u628a\u8fd9\u4e2aidle\u63d2\u5165idle\u9636\u6bb5\u4e2d\uff0c\u8868\u793a\u6709\u4efb\u52a1\u5904\u7406\uff0c\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\u3002\u6ca1\u6709immediate\u4efb\u52a1\u65f6\uff0c\u5219\u79fb\u9664idle\u8282\u70b9\u3002\u603b\u7684\u6765\u8bf4\uff0cidle\u8282\u70b9\u7684\u610f\u4e49\u662f\u6807\u8bb0\u662f\u5426\u6709immediate\u4efb\u52a1\u9700\u8981\u5904\u7406\uff0c\u6709\u7684\u8bdd\u5c31\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\uff0c\u5e76\u4e14\u4e0d\u80fd\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 1. void ToggleImmediateRef(const FunctionCallbackInfo<Value>& args) { 2. Environment::GetCurrent(args)->ToggleImmediateRef(args[0]->IsTrue()) 3. } 4. 5. void Environment::ToggleImmediateRef(bool ref) { 6. if (started_cleanup_) return; 7. // \u6539\u53d8handle\u7684\u72b6\u6001\uff08\u6fc0\u6d3b\u6216\u4e0d\u6fc0\u6d3b\uff09\uff0c\u9632\u6b62\u5728Poll IO\u9636\u6bb5\u963b\u585e 8. if (ref) { 9. uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ }); 10. } else { 11. // \u4e0d\u963b\u585ePoll IO\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 12. uv_idle_stop(immediate_idle_handle()); 13. } 14. } \u8fd9\u662fsetImmediate\u51fd\u6570\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u548c\u5b9a\u65f6\u5668\u4e00\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528immediate\u4efb\u52a1\u7684ref\u548cunref\u51fd\u6570\uff0c\u63a7\u5236\u5b83\u5bf9\u4e8b\u4ef6\u5faa\u73af\u7684\u5f71\u54cd\u3002 11.1.4 \u5904\u7406setImmediate\u4ea7\u751f\u7684\u4efb\u52a1 \u00b6 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5728check\u9636\u6bb5\u65f6\uff0c\u662f\u5982\u4f55\u5904\u7406immediate\u4efb\u52a1\u7684\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053processImmediate\u51fd\u6570\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570\uff0c\u6765\u81eagetTimerCallbacks\uff08internal/timer.js\uff09\u3002 1. function processImmediate() { 2. /* 3. \u4e0a\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\u5982\u679c\u7531\u672a\u6355\u83b7\u7684\u5f02\u5e38\uff0c 4. \u5219outstandingQueue\u4fdd\u5b58\u4e86\u672a\u6267\u884c\u7684\u8282\u70b9\uff0c\u4e0b\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\uff0c 5. \u4f18\u5148\u6267\u884coutstandingQueue\u961f\u5217\u7684\u8282\u70b9 6. */ 7. const queue = outstandingQueue.head !== null ? 8. outstandingQueue : immediateQueue; 9. let immediate = queue.head; 10. /* 11. \u5728\u6267\u884cimmediateQueue\u961f\u5217\u7684\u8bdd\uff0c\u5148\u7f6e\u7a7a\u961f\u5217\uff0c\u907f\u514d\u6267\u884c\u56de\u8c03 12. \u7684\u65f6\u5019\u4e00\u76f4\u5f80\u961f\u5217\u52a0\u8282\u70b9\uff0c\u6b7b\u5faa\u73af\u3002 \u6240\u4ee5\u65b0\u52a0\u7684\u63a5\u53e3\u4f1a\u63d2\u5165\u65b0\u7684\u961f\u5217\uff0c 13. \u4e0d\u4f1a\u5728\u672c\u6b21\u88ab\u6267\u884c\u3002\u5e76\u6253\u4e00\u4e2a\u6807\u8bb0,\u5168\u90e8immediateQueue\u8282\u70b9\u90fd\u88ab\u6267 14. \u884c\u5219\u6e05\u7a7a\uff0c\u5426\u5219\u4f1a\u518d\u6267\u884cprocessImmediate\u4e00\u6b21\uff0c\u89c1Environment::CheckImmediate 15. */ 16. if (queue !== outstandingQueue) { 17. queue.head = queue.tail = null; 18. immediateInfo[kHasOutstanding] = 1; 19. } 20. 21. let prevImmediate; 22. let ranAtLeastOneImmediate = false; 23. while (immediate !== null) { 24. // \u6267\u884c\u5fae\u4efb\u52a1 25. if (ranAtLeastOneImmediate) 26. runNextTicks(); 27. else 28. ranAtLeastOneImmediate = true; 29. 30. // \u5fae\u4efb\u52a1\u628a\u8be5\u8282\u70b9\u5220\u9664\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u6307\u5411\u5b83\u7684\u56de\u8c03\u4e86\uff0c\u7ee7\u7eed\u4e0b\u4e00\u4e2a 31. if (immediate._destroyed) { 32. outstandingQueue.head = immediate = prevImmediate._idleNext; 33. continue; 34. } 35. 36. immediate._destroyed = true; 37. // \u6267\u884c\u5b8c\u8981\u4fee\u6539\u4e2a\u6570 38. immediateInfo[kCount]--; 39. if (immediate[kRefed]) 40. immediateInfo[kRefCount]--; 41. immediate[kRefed] = null; 42. // \u89c1\u4e0a\u9762if (immediate._destroyed)\u7684\u6ce8\u91ca 43. prevImmediate = immediate; 44. // \u6267\u884c\u56de\u8c03\uff0c\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9 45. try { 46. const argv = immediate._argv; 47. if (!argv) 48. immediate._onImmediate(); 49. else 50. immediate._onImmediate(...argv); 51. } finally { 52. immediate._onImmediate = null; 53. outstandingQueue.head = immediate = immediate._idleNext; 54. } 55. } 56. // \u5f53\u524d\u6267\u884c\u7684\u662foutstandingQueue\u7684\u8bdd\u5219\u628a\u5b83\u6e05\u7a7a 57. if (queue === outstandingQueue) 58. outstandingQueue.head = null; 59. // \u5168\u90e8\u8282\u70b9\u6267\u884c\u5b8c 60. immediateInfo[kHasOutstanding] = 0; 61. } processImmediate\u7684\u903b\u8f91\u5c31\u662f\u9010\u4e2a\u6267\u884cimmediate\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9\u3002Immediate\u5206\u4e24\u4e2a\u961f\u5217\uff0c\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u63d2\u5165\u7684immediate\u8282\u70b9\u63d2\u5165\u5230immediateQueue\u961f\u5217\u3002\u5982\u679c\u6267\u884c\u7684\u65f6\u5019\u6709\u5f02\u5e38\uff0c\u5219\u672a\u5904\u7406\u5b8c\u7684\u8282\u70b9\u5c31\u4f1a\u88ab\u63d2\u5165\u5230outstandingQueue\u961f\u5217\uff0c\u7b49\u4e0b\u4e00\u6b21\u6267\u884c\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230runNextTicks\u3002runNextTicks\u5728\u6bcf\u6267\u884c\u5b8cimmediate\u8282\u70b9\u540e\uff0c\u90fd\u5148\u5904\u7406tick\u4efb\u52a1\u7136\u540e\u518d\u5904\u7406\u4e0b\u4e00\u4e2aimmediate\u8282\u70b9\u3002 11.1.5 Node.js\u7684setTimeout(fn,0)\u548csetImmediate\u8c01\u5148\u6267\u884c\u7684\u95ee\u9898 \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e0b\u9762\u8fd9\u6bb5\u4ee3\u7801 1. setTimeout(()=>{ console.log('setTimeout'); },0) 2. setImmediate(()=>{ console.log('setImmedate');}) \u6211\u4eec\u6267\u884c\u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\uff0c\u4f1a\u53d1\u73b0\u8f93\u51fa\u662f\u4e0d\u786e\u5b9a\u7684\u3002\u4e0b\u9762\u6765\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u3002Node.js\u7684\u4e8b\u4ef6\u5faa\u73af\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5(phase)\u3002setTimeout\u662f\u5c5e\u4e8e\u5b9a\u65f6\u5668\u9636\u6bb5\uff0csetImmediate\u662f\u5c5e\u4e8echeck\u9636\u6bb5\u3002\u987a\u5e8f\u4e0a\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u6bd4check\u66f4\u65e9\u88ab\u6267\u884c\u7684\u3002\u5176\u4e2dsetTimeout\u7684\u5b9e\u73b0\u4ee3\u7801\u91cc\u6709\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7ec6\u8282\u3002 1. after *= 1; // coalesce to number or NaN 2. if (!(after >= 1 && after <= TIMEOUT_MAX)) { 3. if (after > TIMEOUT_MAX) { 4. process.emitWarning(`\u9519\u8bef\u63d0\u793a`); 5. } 6. after = 1; // schedule on next tick, follows browser behavior 7. } \u6211\u4eec\u53d1\u73b0\u867d\u7136\u6211\u4eec\u4f20\u7684\u8d85\u65f6\u65f6\u95f4\u662f0\uff0c\u4f46\u662f0\u4e0d\u662f\u5408\u6cd5\u503c\uff0cNode.js\u4f1a\u628a\u8d85\u65f6\u65f6\u95f4\u53d8\u62101\u3002\u8fd9\u5c31\u662f\u5bfc\u81f4\u4e0a\u9762\u7684\u4ee3\u7801\u8f93\u51fa\u4e0d\u786e\u5b9a\u7684\u539f\u56e0\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u6bb5\u4ee3\u7801\u7684\u6267\u884c\u8fc7\u7a0b\u3002Node.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u7f16\u8bd1\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u5f00\u59cb\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u6302\u8f7d\u4e00\u4e2asetImmediate\u8282\u70b9\u5728\u961f\u5217\u3002\u7136\u540e\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\uff0cLibuv\u5224\u65ad\u4ece\u5f00\u542f\u5b9a\u65f6\u5668\u5230\u73b0\u5728\u662f\u5426\u5df2\u7ecf\u8fc7\u53bb\u4e861\u6beb\u79d2\uff0c\u662f\u7684\u8bdd\uff0c\u6267\u884c\u5b9a\u65f6\u5668\u56de\u8c03\uff0c\u5426\u5219\u6267\u884c\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u6267\u884c\u5b8c\u5176\u5b83\u9636\u6bb5\u540e\uff0c\u4f1a\u6267\u884ccheck\u9636\u6bb5\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884csetImmediate\u7684\u56de\u8c03\u3002\u6240\u4ee5\uff0c\u4e00\u5f00\u59cb\u7684\u90a3\u6bb5\u4ee3\u7801\u7684\u8f93\u51fa\u7ed3\u679c\u662f\u53d6\u51b3\u4e8e\u542f\u52a8\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u5230Libuv\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u5426\u8fc7\u53bb\u4e861\u6beb\u79d2\u3002 11.2 nextTick \u00b6 nextTick\u7528\u4e8e\u5f02\u6b65\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u548csetTimeout\u3001setImmediate\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u4ed6\u4eec\u7684\u6267\u884c\u65f6\u673a\uff0csetTimeout\u548csetImmediate\u7684\u4efb\u52a1\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u662fnextTick\u7684\u4efb\u52a1\u4e0d\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u5177\u4f53\u7684\u6267\u884c\u65f6\u673a\u6211\u4eec\u4f1a\u5728\u672c\u8282\u5206\u6790\u3002 11.2.1 \u521d\u59cb\u5316nextTick \u00b6 nextTick\u51fd\u6570\u662f\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5728\u6267\u884cbootstrap/node.js\u65f6\u6302\u8f7d\u5230process\u5bf9\u8c61\u4e2d\u3002 1. const { nextTick, runNextTicks } = setupTaskQueue(); 2. process.nextTick = nextTick; \u771f\u6b63\u7684\u5b9a\u4e49\u5728task_queues.js\u3002 1. setupTaskQueue() { 2. setTickCallback(processTicksAndRejections); 3. return { 4. nextTick, 5. }; 6. }, nextTick\u63a5\u4e0b\u6765\u4f1a\u8bb2\uff0csetTickCallback\u662f\u6ce8\u518c\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\uff0c 1. static void SetTickCallback(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. CHECK(args[0]->IsFunction()); 4. env->set_tick_callback_function(args[0].As<Function>()); 5. } \u53ea\u662f\u7b80\u5355\u5730\u4fdd\u5b58\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002\u540e\u7eed\u4f1a\u7528\u5230 11.2.2 nextTick\u751f\u4ea7\u4efb\u52a1 \u00b6 1. function nextTick(callback) { 2. let args; 3. switch (arguments.length) { 4. case 1: break; 5. case 2: args = [arguments[1]]; break; 6. case 3: args = [arguments[1], arguments[2]]; break; 7. case 4: args = [arguments[1], arguments[2], arguments[3]]; break; 8. default: 9. args = new Array(arguments.length - 1); 10. for (let i = 1; i < arguments.length; i++) 11. args[i - 1] = arguments[i]; 12. } 13. // \u7b2c\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f00\u542ftick\u5904\u7406\u903b\u8f91 14. if (queue.isEmpty()) 15. setHasTickScheduled(true); 16. const asyncId = newAsyncId(); 17. const triggerAsyncId = getDefaultTriggerAsyncId(); 18. const tickObject = { 19. [async_id_symbol]: asyncId, 20. [trigger_async_id_symbol]: triggerAsyncId, 21. callback, 22. args 23. }; 24. // \u63d2\u5165\u961f\u5217 25. queue.push(tickObject); 26. } \u8fd9\u5c31\u662f\u6211\u4eec\u6267\u884cnextTick\u65f6\u7684\u903b\u8f91\u3002\u6bcf\u6b21\u8c03\u7528nextTick\u90fd\u4f1a\u5f80\u961f\u5217\u4e2d\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002 11.2.3 \u5904\u7406tick\u4efb\u52a1 \u00b6 \u6211\u4eec\u518d\u770b\u4e00\u4e0b\u5904\u7406\u7684tick\u4efb\u52a1\u7684\u903b\u8f91\u3002Nodejs\u5728\u521d\u59cb\u5316\u65f6\uff0c\u901a\u8fc7\u6267\u884csetTickCallback(processTicksAndRejections)\u6ce8\u518c\u4e86\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002Node.js\u5728\u521d\u59cb\u5316\u65f6\u628a\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u4fdd\u5b58\u5230env\u4e2d\u3002\u53e6\u5916\uff0cNodejs\u4f7f\u7528TickInfo\u7c7b\u7ba1\u7406tick\u7684\u903b\u8f91\u3002 1. class TickInfo : public MemoryRetainer { 2. public: 3. inline AliasedUint8Array& fields(); 4. inline bool has_tick_scheduled() const; 5. inline bool has_rejection_to_warn() const; 6. private: 7. inline explicit TickInfo(v8::Isolate* isolate); 8. enum Fields { kHasTickScheduled = 0, kHasRejectionToWarn, kFieldsCount }; 9. 10. AliasedUint8Array fields_; 11. }; TickInfo\u4e3b\u8981\u662f\u6709\u4e24\u4e2a\u6807\u8bb0\u4f4d\uff0ckHasTickScheduled\u6807\u8bb0\u662f\u5426\u6709tick\u4efb\u52a1\u9700\u8981\u5904\u7406\u3002\u7136\u540e\u901a\u8fc7InternalCallbackScope\u7c7b\u7684\u5bf9\u8c61\u65b9\u6cd5Close\u51fd\u6570\u6267\u884ctick_callback_function\u3002\u5f53Nodejs\u5e95\u5c42\u9700\u8981\u6267\u884c\u4e00\u4e2ajs\u56de\u8c03\u65f6\uff0c\u4f1a\u8c03\u7528AsyncWrap\u7684MakeCallback\u3002MakeCallback\u91cc\u9762\u8c03\u7528\u4e86InternalMakeCallback\u3002 1. MaybeLocal<Value> InternalMakeCallback(Environment* env, Local<Object> recv, 2. const Local<Function> callback, int argc, Local<Value> argv[], 3. async_context asyncContext) { 4. InternalCallbackScope scope(env, recv, asyncContext); 5. // \u6267\u884c\u7528\u6237\u5c42js\u56de\u8c03 6. scope.Close(); 7. 8. return ret; 9. } \u6211\u4eec\u770bInternalCallbackScope \u7684Close 1. void InternalCallbackScope::Close() { 2. // \u7701\u7565\u90e8\u5206\u4ee3\u7801 3. TickInfo* tick_info = env_->tick_info(); 4. // \u6ca1\u6709tick\u4efb\u52a1\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\uff0c\u5728\u63d2\u5165tick\u4efb\u52a1\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8fd9\u4e2a\u4e3atrue\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u53d8\u6210false 5. if (!tick_info->has_tick_scheduled() && !tick_info->has_rejection_to_warn()) { 6. return; 7. } 8. 9. HandleScope handle_scope(env_->isolate()); 10. Local<Object> process = env_->process_object(); 11. 12. if (!env_->can_call_into_js()) return; 13. // \u5904\u7406tick\u7684\u51fd\u6570 14. Local<Function> tick_callback = env_->tick_callback_function(); 15. // \u5904\u7406tick\u4efb\u52a1 16. if (tick_callback->Call(env_->context(), process, 0, nullptr).IsEmpty()) { 17. failed_ = true; 18. } 19. } \u6211\u4eec\u770b\u5230\u6bcf\u6b21\u6267\u884cjs\u5c42\u7684\u56de\u8c03\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5904\u7406tick\u4efb\u52a1\u3002Close\u51fd\u6570\u53ef\u4ee5\u4e3b\u52a8\u8c03\u7528\uff0c\u6216\u8005\u5728InternalCallbackScope\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\u88ab\u8c03\u7528\u3002\u9664\u4e86\u6267\u884cjs\u56de\u8c03\u65f6\u662f\u4e3b\u52a8\u8c03\u7528Close\u5916\uff0c\u4e00\u822c\u5904\u7406tick\u4efb\u52a1\u7684\u65f6\u95f4\u70b9\u5c31\u662f\u5728InternalCallbackScope\u5bf9\u8c61\u88ab\u6790\u6784\u7684\u65f6\u5019\u3002\u6240\u4ee5\u5728\u5b9a\u4e49\u4e86InternalCallbackScope\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u4e00\u822c\u5c31\u4f1a\u5728\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\uff0c\u8fdb\u884ctick\u4efb\u52a1\u7684\u5904\u7406\u3002\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u5728\u6267\u884c\u7684js\u56de\u8c03\u91cc\uff0c\u8c03\u7528runNextTicks\u5904\u7406tick\u4efb\u52a1\u3002\u6bd4\u5982\u6267\u884cimmediate\u4efb\u52a1\u7684\u8fc7\u7a0b\u4e2d\u3002 1. function runNextTicks() { 2. if (!hasTickScheduled() && !hasRejectionToWarn()) 3. runMicrotasks(); 4. if (!hasTickScheduled() && !hasRejectionToWarn()) 5. return; 6. processTicksAndRejections(); 7. } \u6211\u4eec\u770bprocessTicksAndRejections\u662f\u5982\u4f55\u5904\u7406tick\u4efb\u52a1\u7684\u3002 1. function processTicksAndRejections() { 2. let tock; 3. do { 4. while (tock = queue.shift()) { 5. const asyncId = tock[async_id_symbol]; 6. emitBefore(asyncId, tock[trigger_async_id_symbol]); 7. 8. try { 9. const callback = tock.callback; 10. if (tock.args === undefined) { 11. callback(); 12. } else { 13. const args = tock.args; 14. switch (args.length) { 15. case 1: callback(args[0]); break; 16. case 2: callback(args[0], args[1]); break; 17. case 3: callback(args[0], args[1], args[2]); break; 18. case 4: callback(args[0], args[1], args[2], args[3]); break; 19. default: callback(...args); 20. } 21. } 22. } finally { 23. if (destroyHooksExist()) 24. emitDestroy(asyncId); 25. } 26. 27. emitAfter(asyncId); 28. } 29. runMicrotasks(); 30. } while (!queue.isEmpty() || processPromiseRejections()); 31. setHasTickScheduled(false); 32. setHasRejectionToWarn(false); 33. } \u4eceprocessTicksAndRejections\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cNode.js\u662f\u5b9e\u65f6\u4ece\u4efb\u52a1\u961f\u5217\u91cc\u53d6\u8282\u70b9\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5728nextTick\u7684\u56de\u8c03\u91cc\u4e00\u76f4\u8c03\u7528nextTick\u7684\u8bdd\uff0c\u5c31\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002 1. function test() { 2. process.nextTick(() => { 3. console.log(1); 4. test() 5. }); 6. } 7. test(); 8. 9. setTimeout(() => { 10. console.log(2) 11. }, 10) \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u4f1a\u4e00\u76f4\u8f93\u51fa1\uff0c\u4e0d\u4f1a\u8f93\u51fa2\u3002\u800c\u5728Nodejs\u6e90\u7801\u7684\u5f88\u591a\u5730\u65b9\u90fd\u5904\u7406\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u9996\u5148\u628a\u8981\u6267\u884c\u7684\u4efb\u52a1\u961f\u5217\u79fb\u5230\u4e00\u4e2a\u53d8\u91cfq2\u4e2d\uff0c\u6e05\u7a7a\u4e4b\u524d\u7684\u961f\u5217q1\u3002\u63a5\u7740\u904d\u5386q2\u6307\u5411\u7684\u961f\u5217\uff0c\u5982\u679c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u53c8\u65b0\u589e\u4e86\u8282\u70b9\uff0c\u53ea\u4f1a\u52a0\u5165\u5230q1\u4e2d\u3002q2\u4e0d\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002 11.2.4 nextTick\u7684\u4f7f\u7528 \u00b6 \u6211\u4eec\u77e5\u9053nextTick\u53ef\u7528\u4e8e\u5ef6\u8fdf\u6267\u884c\u4e00\u4e9b\u903b\u8f91\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u54ea\u4e9b\u573a\u666f\u4e0b\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1. const { EventEmitter } = require('events'); 2. class DemoEvents extends EventEmitter { 3. constructor() { 4. super(); 5. this.emit('start'); 6. } 7. } 8. 9. const demoEvents = new DemoEvents(); 10. demoEvents.on('start', () => { 11. console.log('start'); 12. }); \u4ee5\u4e0a\u4ee3\u7801\u5728\u6784\u9020\u51fd\u6570\u4e2d\u4f1a\u89e6\u53d1start\u4e8b\u4ef6\uff0c\u4f46\u662f\u4e8b\u4ef6\u7684\u6ce8\u518c\u5374\u5728\u6784\u9020\u51fd\u6570\u4e4b\u540e\u6267\u884c\uff0c\u800c\u5728\u6784\u9020\u51fd\u6570\u4e4b\u524d\u6211\u4eec\u8fd8\u6ca1\u6709\u62ff\u5230DemoEvents\u5bf9\u8c61\uff0c\u65e0\u6cd5\u5b8c\u6210\u4e8b\u4ef6\u7684\u6ce8\u518c\u3002\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1. const { EventEmitter } = require('events'); 2. class DemoEvents extends EventEmitter { 3. constructor() { 4. super(); 5. process.nextTick(() => { 6. this.emit('start'); 7. }) 8. } 9. } 10. 11. const demoEvents = new DemoEvents(); 12. demoEvents.on('start', () => { 13. console.log('start'); 14. });","title":"11-setImmediate\u548cnextTick"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#111-setimmediate","text":"","title":"11.1 setImmediate"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1111immediate","text":"\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e86\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570 1. // runNextTicks\u7528\u4e8e\u5904\u7406nextTick\u4ea7\u751f\u7684\u4efb\u52a1\uff0c\u8fd9\u91cc\u4e0d\u5173\u6ce8 2. const { processImmediate, processTimers } = getTimerCallbacks(runNextTicks); 3. setupTimers(processImmediate, processTimers); \u6211\u4eec\u5148\u770b\u770b\u4e00\u4e0bsetupTimers\uff08timer.cc\uff09\u7684\u903b\u8f91\u3002 1. void SetupTimers(const FunctionCallbackInfo<Value>& args) { 2. auto env = Environment::GetCurrent(args); 3. env->set_immediate_callback_function(args[0].As<Function>()); 4. env->set_timers_callback_function(args[1].As<Function>()); 5. } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570processImmediate, processTimers\uff0cprocessImmediate\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u4efb\u52a1\u7684\uff0c\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002","title":"11.1.1\u8bbe\u7f6e\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1112-check","text":"\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u540c\u65f6\u521d\u59cb\u5316\u4e86immediate\u4efb\u52a1\u76f8\u5173\u7684\u6570\u636e\u7ed3\u6784\u548c\u903b\u8f91\u3002 1. void Environment::InitializeLibuv(bool start_profiler_idle_notifier) { 2. // \u521d\u59cb\u5316immediate\u76f8\u5173\u7684handle 3. uv_check_init(event_loop(), immediate_check_handle()); 4. // \u4fee\u6539\u72b6\u6001\u4e3aunref\uff0c\u907f\u514d\u6ca1\u6709\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 5. uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle())); 6. // \u6fc0\u6d3bhandle\uff0c\u8bbe\u7f6e\u56de\u8c03 7. uv_check_start(immediate_check_handle(), CheckImmediate); 8. // \u5728idle\u9636\u6bb5\u4e5f\u63d2\u5165\u4e00\u4e2a\u76f8\u5173\u7684\u8282\u70b9 9. uv_idle_init(event_loop(), immediate_idle_handle()); 10. } Node.js\u9ed8\u8ba4\u4f1a\u5f80check\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u4e3aCheckImmediate\uff0c\u4f46\u662f\u521d\u59cb\u5316\u72b6\u6001\u662funref\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6ca1\u6709immediate\u4efb\u52a1\u7684\u8bdd\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u6211\u4eec\u770b\u4e00\u4e0bCheckImmediate\u51fd\u6570 1. void Environment::CheckImmediate(uv_check_t* handle) { 2. // \u7701\u7565\u90e8\u5206\u4ee3\u7801 3. // \u6ca1\u6709Immediate\u8282\u70b9\u9700\u8981\u5904\u7406 4. if (env->immediate_info()->count() == 0 || 5. !env->can_call_into_js()) 6. return; 7. do { 8. // \u6267\u884cJS\u5c42\u56de\u8c03immediate_callback_function 9. MakeCallback(env->isolate(), 10. env->process_object(), 11. env->immediate_callback_function(), 12. 0, 13. nullptr, 14. {0, 0}).ToLocalChecked(); 15. } while (env->immediate_info()->has_outstanding() && 16. env->can_call_into_js()); 17. /* 18. \u6240\u6709immediate\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86\uff0c\u7f6eidle\u9636\u6bb5\u5bf9\u5e94\u8282\u70b9\u4e3a\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c 19. \u5141\u8bb8Poll IO\u9636\u6bb5\u963b\u585e\u548c\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 20. */ 21. if (env->immediate_info()->ref_count() == 0) 22. env->ToggleImmediateRef(false); 23. } \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u65f6\uff0cCheckImmediate\u90fd\u4f1a\u88ab\u6267\u884c\uff0c\u4f46\u662f\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\u5219\u76f4\u63a5\u8fd4\u56de\u3002\u5982\u679c\u6709\u4efb\u52a1\uff0cCheckImmediate\u51fd\u6570\u6267\u884cimmediate_callback_function\u51fd\u6570\uff0c\u8fd9\u6b63\u662fNode.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u51fd\u6570processImmediate\u3002\u770b\u5b8c\u521d\u59cb\u5316\u548c\u5904\u7406immediate\u4efb\u52a1\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4ea7\u751f\u4e00\u4e2aimmediate\u4efb\u52a1\u3002","title":"11.1.2 \u6ce8\u518ccheck\u9636\u6bb5\u7684\u56de\u8c03"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1113-setimmediate","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setImmediate\u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u3002 1. function setImmediate(callback, arg1, arg2, arg3) { 2. let i, args; 3. switch (arguments.length) { 4. case 1: 5. break; 6. case 2: 7. args = [arg1]; 8. break; 9. case 3: 10. args = [arg1, arg2]; 11. break; 12. default: 13. args = [arg1, arg2, arg3]; 14. for (i = 4; i < arguments.length; i++) { 15. args[i - 1] = arguments[i]; 16. } 17. break; 18. } 19. 20. return new Immediate(callback, args); 21. } setImmediate\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e00\u4e2aImmediate\u3002\u6211\u4eec\u770b\u4e00\u4e0bImmediate\u7684\u7c7b\u3002 1. const Immediate = class Immediate { 2. constructor(callback, args) { 3. this._idleNext = null; 4. this._idlePrev = null; 5. this._onImmediate = callback; 6. this._argv = args; 7. this._destroyed = false; 8. this[kRefed] = false; 9. this.ref(); 10. // Immediate\u94fe\u8868\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u5305\u62ecref\u548cunref\u72b6\u6001 11. immediateInfo[kCount]++; 12. // \u52a0\u5165\u94fe\u8868\u4e2d 13. immediateQueue.append(this); 14. } 15. // \u6253\u4e0aref\u6807\u8bb0\uff0c\u5f80Libuv\u7684idle\u94fe\u8868\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u72b6\u6001\u7684\u8282\u70b9\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd 16. ref() { 17. if (this[kRefed] === false) { 18. this[kRefed] = true; 19. if (immediateInfo[kRefCount]++ === 0) 20. toggleImmediateRef(true); 21. } 22. return this; 23. } 24. // \u548c\u4e0a\u9762\u76f8\u53cd 25. unref() { 26. if (this[kRefed] === true) { 27. this[kRefed] = false; 28. if (--immediateInfo[kRefCount] === 0) 29. toggleImmediateRef(false); 30. } 31. return this; 32. } 33. 34. hasRef() { 35. return !!this[kRefed]; 36. } 37. }; Immediate\u7c7b\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u4e8b\u60c5\u3002 1 \u751f\u6210\u4e00\u4e2a\u8282\u70b9\u63d2\u5165\u5230\u94fe\u8868\u3002 1. const immediateQueue = new ImmediateList(); 2. 3. // \u53cc\u5411\u975e\u5faa\u73af\u7684\u94fe\u8868 4. function ImmediateList() { 5. this.head = null; 6. this.tail = null; 7. } 8. ImmediateList.prototype.append = function(item) { 9. // \u5c3e\u6307\u9488\u975e\u7a7a\uff0c\u8bf4\u660e\u94fe\u8868\u975e\u7a7a\uff0c\u76f4\u63a5\u8ffd\u52a0\u5728\u5c3e\u8282\u70b9\u540e\u9762 10. if (this.tail !== null) { 11. this.tail._idleNext = item; 12. item._idlePrev = this.tail; 13. } else { 14. // \u5c3e\u6307\u9488\u662f\u7a7a\u8bf4\u660e\u94fe\u8868\u662f\u7a7a\u7684\uff0c\u5934\u5c3e\u6307\u9488\u90fd\u6307\u5411item 15. this.head = item; 16. } 17. this.tail = item; 18. }; 19. 20. ImmediateList.prototype.remove = function(item) { 21. // \u5982\u679citem\u5728\u4e2d\u95f4\u5219\u81ea\u5df1\u5168\u8eab\u800c\u9000\uff0c\u524d\u540e\u4e24\u4e2a\u8282\u70b9\u8fde\u4e0a 22. if (item._idleNext !== null) { 23. item._idleNext._idlePrev = item._idlePrev; 24. } 25. 26. if (item._idlePrev !== null) { 27. item._idlePrev._idleNext = item._idleNext; 28. } 29. // \u662f\u5934\u6307\u9488\uff0c\u5219\u9700\u8981\u66f4\u65b0\u5934\u6307\u9488\u6307\u5411item\u7684\u4e0b\u4e00\u4e2a\uff0c\u56e0\u4e3aitem\u88ab\u5220\u9664\u4e86\uff0c\u5c3e\u6307\u9488\u540c\u7406 30. if (item === this.head) 31. this.head = item._idleNext; 32. if (item === this.tail) 33. this.tail = item._idlePrev; 34. // \u91cd\u7f6e\u524d\u540e\u6307\u9488 35. item._idleNext = null; 36. item._idlePrev = null; 37. }; 2 \u5982\u679c\u8fd8\u6ca1\u6709\u5f80Libuv\u7684idle\u94fe\u8868\u91cc\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u8282\u70b9\u7684\u8bdd\uff0c\u5219\u63d2\u5165\u4e00\u4e2a\u3002\u4ece\u4e4b\u524d\u7684\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053\uff0cNode.js\u5728check\u9636\u6bb5\u63d2\u5165\u4e86\u4e00\u4e2aunref\u8282\u70b9\uff0c\u5728\u6bcf\u6b21check\u9636\u6bb5\u90fd\u4f1a\u6267\u884c\u8be5\u8282\u70b9\u7684\u56de\u8c03\uff0c\u90a3\u4e48\u8fd9\u4e2aidle\u8282\u70b9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u7b54\u6848\u5728uv_backend_timeout\u51fd\u6570\u4e2d\uff0cuv_backend_timeout\u5b9a\u4e49\u4e86Poll IO\u963b\u585e\u7684\u65f6\u957f\uff0c\u5982\u679c\u6709ref\u72b6\u6001\u7684idle\u8282\u70b9\u5219Poll IO\u9636\u6bb5\u4e0d\u4f1a\u963b\u585e\uff08\u4f46\u662f\u4e0d\u4f1a\u5224\u65ad\u662f\u5426\u6709check\u8282\u70b9\uff09\u3002\u6240\u4ee5\u5f53\u6709immediate\u4efb\u52a1\u65f6\uff0cNode.js\u4f1a\u628a\u8fd9\u4e2aidle\u63d2\u5165idle\u9636\u6bb5\u4e2d\uff0c\u8868\u793a\u6709\u4efb\u52a1\u5904\u7406\uff0c\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\u3002\u6ca1\u6709immediate\u4efb\u52a1\u65f6\uff0c\u5219\u79fb\u9664idle\u8282\u70b9\u3002\u603b\u7684\u6765\u8bf4\uff0cidle\u8282\u70b9\u7684\u610f\u4e49\u662f\u6807\u8bb0\u662f\u5426\u6709immediate\u4efb\u52a1\u9700\u8981\u5904\u7406\uff0c\u6709\u7684\u8bdd\u5c31\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\uff0c\u5e76\u4e14\u4e0d\u80fd\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 1. void ToggleImmediateRef(const FunctionCallbackInfo<Value>& args) { 2. Environment::GetCurrent(args)->ToggleImmediateRef(args[0]->IsTrue()) 3. } 4. 5. void Environment::ToggleImmediateRef(bool ref) { 6. if (started_cleanup_) return; 7. // \u6539\u53d8handle\u7684\u72b6\u6001\uff08\u6fc0\u6d3b\u6216\u4e0d\u6fc0\u6d3b\uff09\uff0c\u9632\u6b62\u5728Poll IO\u9636\u6bb5\u963b\u585e 8. if (ref) { 9. uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ }); 10. } else { 11. // \u4e0d\u963b\u585ePoll IO\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 12. uv_idle_stop(immediate_idle_handle()); 13. } 14. } \u8fd9\u662fsetImmediate\u51fd\u6570\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u548c\u5b9a\u65f6\u5668\u4e00\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528immediate\u4efb\u52a1\u7684ref\u548cunref\u51fd\u6570\uff0c\u63a7\u5236\u5b83\u5bf9\u4e8b\u4ef6\u5faa\u73af\u7684\u5f71\u54cd\u3002","title":"11.1.3 setImmediate\u751f\u6210\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1114-setimmediate","text":"\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5728check\u9636\u6bb5\u65f6\uff0c\u662f\u5982\u4f55\u5904\u7406immediate\u4efb\u52a1\u7684\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053processImmediate\u51fd\u6570\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570\uff0c\u6765\u81eagetTimerCallbacks\uff08internal/timer.js\uff09\u3002 1. function processImmediate() { 2. /* 3. \u4e0a\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\u5982\u679c\u7531\u672a\u6355\u83b7\u7684\u5f02\u5e38\uff0c 4. \u5219outstandingQueue\u4fdd\u5b58\u4e86\u672a\u6267\u884c\u7684\u8282\u70b9\uff0c\u4e0b\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\uff0c 5. \u4f18\u5148\u6267\u884coutstandingQueue\u961f\u5217\u7684\u8282\u70b9 6. */ 7. const queue = outstandingQueue.head !== null ? 8. outstandingQueue : immediateQueue; 9. let immediate = queue.head; 10. /* 11. \u5728\u6267\u884cimmediateQueue\u961f\u5217\u7684\u8bdd\uff0c\u5148\u7f6e\u7a7a\u961f\u5217\uff0c\u907f\u514d\u6267\u884c\u56de\u8c03 12. \u7684\u65f6\u5019\u4e00\u76f4\u5f80\u961f\u5217\u52a0\u8282\u70b9\uff0c\u6b7b\u5faa\u73af\u3002 \u6240\u4ee5\u65b0\u52a0\u7684\u63a5\u53e3\u4f1a\u63d2\u5165\u65b0\u7684\u961f\u5217\uff0c 13. \u4e0d\u4f1a\u5728\u672c\u6b21\u88ab\u6267\u884c\u3002\u5e76\u6253\u4e00\u4e2a\u6807\u8bb0,\u5168\u90e8immediateQueue\u8282\u70b9\u90fd\u88ab\u6267 14. \u884c\u5219\u6e05\u7a7a\uff0c\u5426\u5219\u4f1a\u518d\u6267\u884cprocessImmediate\u4e00\u6b21\uff0c\u89c1Environment::CheckImmediate 15. */ 16. if (queue !== outstandingQueue) { 17. queue.head = queue.tail = null; 18. immediateInfo[kHasOutstanding] = 1; 19. } 20. 21. let prevImmediate; 22. let ranAtLeastOneImmediate = false; 23. while (immediate !== null) { 24. // \u6267\u884c\u5fae\u4efb\u52a1 25. if (ranAtLeastOneImmediate) 26. runNextTicks(); 27. else 28. ranAtLeastOneImmediate = true; 29. 30. // \u5fae\u4efb\u52a1\u628a\u8be5\u8282\u70b9\u5220\u9664\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u6307\u5411\u5b83\u7684\u56de\u8c03\u4e86\uff0c\u7ee7\u7eed\u4e0b\u4e00\u4e2a 31. if (immediate._destroyed) { 32. outstandingQueue.head = immediate = prevImmediate._idleNext; 33. continue; 34. } 35. 36. immediate._destroyed = true; 37. // \u6267\u884c\u5b8c\u8981\u4fee\u6539\u4e2a\u6570 38. immediateInfo[kCount]--; 39. if (immediate[kRefed]) 40. immediateInfo[kRefCount]--; 41. immediate[kRefed] = null; 42. // \u89c1\u4e0a\u9762if (immediate._destroyed)\u7684\u6ce8\u91ca 43. prevImmediate = immediate; 44. // \u6267\u884c\u56de\u8c03\uff0c\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9 45. try { 46. const argv = immediate._argv; 47. if (!argv) 48. immediate._onImmediate(); 49. else 50. immediate._onImmediate(...argv); 51. } finally { 52. immediate._onImmediate = null; 53. outstandingQueue.head = immediate = immediate._idleNext; 54. } 55. } 56. // \u5f53\u524d\u6267\u884c\u7684\u662foutstandingQueue\u7684\u8bdd\u5219\u628a\u5b83\u6e05\u7a7a 57. if (queue === outstandingQueue) 58. outstandingQueue.head = null; 59. // \u5168\u90e8\u8282\u70b9\u6267\u884c\u5b8c 60. immediateInfo[kHasOutstanding] = 0; 61. } processImmediate\u7684\u903b\u8f91\u5c31\u662f\u9010\u4e2a\u6267\u884cimmediate\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9\u3002Immediate\u5206\u4e24\u4e2a\u961f\u5217\uff0c\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u63d2\u5165\u7684immediate\u8282\u70b9\u63d2\u5165\u5230immediateQueue\u961f\u5217\u3002\u5982\u679c\u6267\u884c\u7684\u65f6\u5019\u6709\u5f02\u5e38\uff0c\u5219\u672a\u5904\u7406\u5b8c\u7684\u8282\u70b9\u5c31\u4f1a\u88ab\u63d2\u5165\u5230outstandingQueue\u961f\u5217\uff0c\u7b49\u4e0b\u4e00\u6b21\u6267\u884c\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230runNextTicks\u3002runNextTicks\u5728\u6bcf\u6267\u884c\u5b8cimmediate\u8282\u70b9\u540e\uff0c\u90fd\u5148\u5904\u7406tick\u4efb\u52a1\u7136\u540e\u518d\u5904\u7406\u4e0b\u4e00\u4e2aimmediate\u8282\u70b9\u3002","title":"11.1.4 \u5904\u7406setImmediate\u4ea7\u751f\u7684\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1115-nodejssettimeoutfn0setimmediate","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e0b\u9762\u8fd9\u6bb5\u4ee3\u7801 1. setTimeout(()=>{ console.log('setTimeout'); },0) 2. setImmediate(()=>{ console.log('setImmedate');}) \u6211\u4eec\u6267\u884c\u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\uff0c\u4f1a\u53d1\u73b0\u8f93\u51fa\u662f\u4e0d\u786e\u5b9a\u7684\u3002\u4e0b\u9762\u6765\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u3002Node.js\u7684\u4e8b\u4ef6\u5faa\u73af\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5(phase)\u3002setTimeout\u662f\u5c5e\u4e8e\u5b9a\u65f6\u5668\u9636\u6bb5\uff0csetImmediate\u662f\u5c5e\u4e8echeck\u9636\u6bb5\u3002\u987a\u5e8f\u4e0a\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u6bd4check\u66f4\u65e9\u88ab\u6267\u884c\u7684\u3002\u5176\u4e2dsetTimeout\u7684\u5b9e\u73b0\u4ee3\u7801\u91cc\u6709\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7ec6\u8282\u3002 1. after *= 1; // coalesce to number or NaN 2. if (!(after >= 1 && after <= TIMEOUT_MAX)) { 3. if (after > TIMEOUT_MAX) { 4. process.emitWarning(`\u9519\u8bef\u63d0\u793a`); 5. } 6. after = 1; // schedule on next tick, follows browser behavior 7. } \u6211\u4eec\u53d1\u73b0\u867d\u7136\u6211\u4eec\u4f20\u7684\u8d85\u65f6\u65f6\u95f4\u662f0\uff0c\u4f46\u662f0\u4e0d\u662f\u5408\u6cd5\u503c\uff0cNode.js\u4f1a\u628a\u8d85\u65f6\u65f6\u95f4\u53d8\u62101\u3002\u8fd9\u5c31\u662f\u5bfc\u81f4\u4e0a\u9762\u7684\u4ee3\u7801\u8f93\u51fa\u4e0d\u786e\u5b9a\u7684\u539f\u56e0\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u6bb5\u4ee3\u7801\u7684\u6267\u884c\u8fc7\u7a0b\u3002Node.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u7f16\u8bd1\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u5f00\u59cb\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u6302\u8f7d\u4e00\u4e2asetImmediate\u8282\u70b9\u5728\u961f\u5217\u3002\u7136\u540e\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\uff0cLibuv\u5224\u65ad\u4ece\u5f00\u542f\u5b9a\u65f6\u5668\u5230\u73b0\u5728\u662f\u5426\u5df2\u7ecf\u8fc7\u53bb\u4e861\u6beb\u79d2\uff0c\u662f\u7684\u8bdd\uff0c\u6267\u884c\u5b9a\u65f6\u5668\u56de\u8c03\uff0c\u5426\u5219\u6267\u884c\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u6267\u884c\u5b8c\u5176\u5b83\u9636\u6bb5\u540e\uff0c\u4f1a\u6267\u884ccheck\u9636\u6bb5\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884csetImmediate\u7684\u56de\u8c03\u3002\u6240\u4ee5\uff0c\u4e00\u5f00\u59cb\u7684\u90a3\u6bb5\u4ee3\u7801\u7684\u8f93\u51fa\u7ed3\u679c\u662f\u53d6\u51b3\u4e8e\u542f\u52a8\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u5230Libuv\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u5426\u8fc7\u53bb\u4e861\u6beb\u79d2\u3002","title":"11.1.5 Node.js\u7684setTimeout(fn,0)\u548csetImmediate\u8c01\u5148\u6267\u884c\u7684\u95ee\u9898"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#112-nexttick","text":"nextTick\u7528\u4e8e\u5f02\u6b65\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u548csetTimeout\u3001setImmediate\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u4ed6\u4eec\u7684\u6267\u884c\u65f6\u673a\uff0csetTimeout\u548csetImmediate\u7684\u4efb\u52a1\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u662fnextTick\u7684\u4efb\u52a1\u4e0d\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u5177\u4f53\u7684\u6267\u884c\u65f6\u673a\u6211\u4eec\u4f1a\u5728\u672c\u8282\u5206\u6790\u3002","title":"11.2 nextTick"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1121-nexttick","text":"nextTick\u51fd\u6570\u662f\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5728\u6267\u884cbootstrap/node.js\u65f6\u6302\u8f7d\u5230process\u5bf9\u8c61\u4e2d\u3002 1. const { nextTick, runNextTicks } = setupTaskQueue(); 2. process.nextTick = nextTick; \u771f\u6b63\u7684\u5b9a\u4e49\u5728task_queues.js\u3002 1. setupTaskQueue() { 2. setTickCallback(processTicksAndRejections); 3. return { 4. nextTick, 5. }; 6. }, nextTick\u63a5\u4e0b\u6765\u4f1a\u8bb2\uff0csetTickCallback\u662f\u6ce8\u518c\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\uff0c 1. static void SetTickCallback(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. CHECK(args[0]->IsFunction()); 4. env->set_tick_callback_function(args[0].As<Function>()); 5. } \u53ea\u662f\u7b80\u5355\u5730\u4fdd\u5b58\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002\u540e\u7eed\u4f1a\u7528\u5230","title":"11.2.1 \u521d\u59cb\u5316nextTick"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1122-nexttick","text":"1. function nextTick(callback) { 2. let args; 3. switch (arguments.length) { 4. case 1: break; 5. case 2: args = [arguments[1]]; break; 6. case 3: args = [arguments[1], arguments[2]]; break; 7. case 4: args = [arguments[1], arguments[2], arguments[3]]; break; 8. default: 9. args = new Array(arguments.length - 1); 10. for (let i = 1; i < arguments.length; i++) 11. args[i - 1] = arguments[i]; 12. } 13. // \u7b2c\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f00\u542ftick\u5904\u7406\u903b\u8f91 14. if (queue.isEmpty()) 15. setHasTickScheduled(true); 16. const asyncId = newAsyncId(); 17. const triggerAsyncId = getDefaultTriggerAsyncId(); 18. const tickObject = { 19. [async_id_symbol]: asyncId, 20. [trigger_async_id_symbol]: triggerAsyncId, 21. callback, 22. args 23. }; 24. // \u63d2\u5165\u961f\u5217 25. queue.push(tickObject); 26. } \u8fd9\u5c31\u662f\u6211\u4eec\u6267\u884cnextTick\u65f6\u7684\u903b\u8f91\u3002\u6bcf\u6b21\u8c03\u7528nextTick\u90fd\u4f1a\u5f80\u961f\u5217\u4e2d\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002","title":"11.2.2 nextTick\u751f\u4ea7\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1123-tick","text":"\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u5904\u7406\u7684tick\u4efb\u52a1\u7684\u903b\u8f91\u3002Nodejs\u5728\u521d\u59cb\u5316\u65f6\uff0c\u901a\u8fc7\u6267\u884csetTickCallback(processTicksAndRejections)\u6ce8\u518c\u4e86\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002Node.js\u5728\u521d\u59cb\u5316\u65f6\u628a\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u4fdd\u5b58\u5230env\u4e2d\u3002\u53e6\u5916\uff0cNodejs\u4f7f\u7528TickInfo\u7c7b\u7ba1\u7406tick\u7684\u903b\u8f91\u3002 1. class TickInfo : public MemoryRetainer { 2. public: 3. inline AliasedUint8Array& fields(); 4. inline bool has_tick_scheduled() const; 5. inline bool has_rejection_to_warn() const; 6. private: 7. inline explicit TickInfo(v8::Isolate* isolate); 8. enum Fields { kHasTickScheduled = 0, kHasRejectionToWarn, kFieldsCount }; 9. 10. AliasedUint8Array fields_; 11. }; TickInfo\u4e3b\u8981\u662f\u6709\u4e24\u4e2a\u6807\u8bb0\u4f4d\uff0ckHasTickScheduled\u6807\u8bb0\u662f\u5426\u6709tick\u4efb\u52a1\u9700\u8981\u5904\u7406\u3002\u7136\u540e\u901a\u8fc7InternalCallbackScope\u7c7b\u7684\u5bf9\u8c61\u65b9\u6cd5Close\u51fd\u6570\u6267\u884ctick_callback_function\u3002\u5f53Nodejs\u5e95\u5c42\u9700\u8981\u6267\u884c\u4e00\u4e2ajs\u56de\u8c03\u65f6\uff0c\u4f1a\u8c03\u7528AsyncWrap\u7684MakeCallback\u3002MakeCallback\u91cc\u9762\u8c03\u7528\u4e86InternalMakeCallback\u3002 1. MaybeLocal<Value> InternalMakeCallback(Environment* env, Local<Object> recv, 2. const Local<Function> callback, int argc, Local<Value> argv[], 3. async_context asyncContext) { 4. InternalCallbackScope scope(env, recv, asyncContext); 5. // \u6267\u884c\u7528\u6237\u5c42js\u56de\u8c03 6. scope.Close(); 7. 8. return ret; 9. } \u6211\u4eec\u770bInternalCallbackScope \u7684Close 1. void InternalCallbackScope::Close() { 2. // \u7701\u7565\u90e8\u5206\u4ee3\u7801 3. TickInfo* tick_info = env_->tick_info(); 4. // \u6ca1\u6709tick\u4efb\u52a1\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\uff0c\u5728\u63d2\u5165tick\u4efb\u52a1\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8fd9\u4e2a\u4e3atrue\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u53d8\u6210false 5. if (!tick_info->has_tick_scheduled() && !tick_info->has_rejection_to_warn()) { 6. return; 7. } 8. 9. HandleScope handle_scope(env_->isolate()); 10. Local<Object> process = env_->process_object(); 11. 12. if (!env_->can_call_into_js()) return; 13. // \u5904\u7406tick\u7684\u51fd\u6570 14. Local<Function> tick_callback = env_->tick_callback_function(); 15. // \u5904\u7406tick\u4efb\u52a1 16. if (tick_callback->Call(env_->context(), process, 0, nullptr).IsEmpty()) { 17. failed_ = true; 18. } 19. } \u6211\u4eec\u770b\u5230\u6bcf\u6b21\u6267\u884cjs\u5c42\u7684\u56de\u8c03\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5904\u7406tick\u4efb\u52a1\u3002Close\u51fd\u6570\u53ef\u4ee5\u4e3b\u52a8\u8c03\u7528\uff0c\u6216\u8005\u5728InternalCallbackScope\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\u88ab\u8c03\u7528\u3002\u9664\u4e86\u6267\u884cjs\u56de\u8c03\u65f6\u662f\u4e3b\u52a8\u8c03\u7528Close\u5916\uff0c\u4e00\u822c\u5904\u7406tick\u4efb\u52a1\u7684\u65f6\u95f4\u70b9\u5c31\u662f\u5728InternalCallbackScope\u5bf9\u8c61\u88ab\u6790\u6784\u7684\u65f6\u5019\u3002\u6240\u4ee5\u5728\u5b9a\u4e49\u4e86InternalCallbackScope\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u4e00\u822c\u5c31\u4f1a\u5728\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\uff0c\u8fdb\u884ctick\u4efb\u52a1\u7684\u5904\u7406\u3002\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u5728\u6267\u884c\u7684js\u56de\u8c03\u91cc\uff0c\u8c03\u7528runNextTicks\u5904\u7406tick\u4efb\u52a1\u3002\u6bd4\u5982\u6267\u884cimmediate\u4efb\u52a1\u7684\u8fc7\u7a0b\u4e2d\u3002 1. function runNextTicks() { 2. if (!hasTickScheduled() && !hasRejectionToWarn()) 3. runMicrotasks(); 4. if (!hasTickScheduled() && !hasRejectionToWarn()) 5. return; 6. processTicksAndRejections(); 7. } \u6211\u4eec\u770bprocessTicksAndRejections\u662f\u5982\u4f55\u5904\u7406tick\u4efb\u52a1\u7684\u3002 1. function processTicksAndRejections() { 2. let tock; 3. do { 4. while (tock = queue.shift()) { 5. const asyncId = tock[async_id_symbol]; 6. emitBefore(asyncId, tock[trigger_async_id_symbol]); 7. 8. try { 9. const callback = tock.callback; 10. if (tock.args === undefined) { 11. callback(); 12. } else { 13. const args = tock.args; 14. switch (args.length) { 15. case 1: callback(args[0]); break; 16. case 2: callback(args[0], args[1]); break; 17. case 3: callback(args[0], args[1], args[2]); break; 18. case 4: callback(args[0], args[1], args[2], args[3]); break; 19. default: callback(...args); 20. } 21. } 22. } finally { 23. if (destroyHooksExist()) 24. emitDestroy(asyncId); 25. } 26. 27. emitAfter(asyncId); 28. } 29. runMicrotasks(); 30. } while (!queue.isEmpty() || processPromiseRejections()); 31. setHasTickScheduled(false); 32. setHasRejectionToWarn(false); 33. } \u4eceprocessTicksAndRejections\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cNode.js\u662f\u5b9e\u65f6\u4ece\u4efb\u52a1\u961f\u5217\u91cc\u53d6\u8282\u70b9\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5728nextTick\u7684\u56de\u8c03\u91cc\u4e00\u76f4\u8c03\u7528nextTick\u7684\u8bdd\uff0c\u5c31\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002 1. function test() { 2. process.nextTick(() => { 3. console.log(1); 4. test() 5. }); 6. } 7. test(); 8. 9. setTimeout(() => { 10. console.log(2) 11. }, 10) \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u4f1a\u4e00\u76f4\u8f93\u51fa1\uff0c\u4e0d\u4f1a\u8f93\u51fa2\u3002\u800c\u5728Nodejs\u6e90\u7801\u7684\u5f88\u591a\u5730\u65b9\u90fd\u5904\u7406\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u9996\u5148\u628a\u8981\u6267\u884c\u7684\u4efb\u52a1\u961f\u5217\u79fb\u5230\u4e00\u4e2a\u53d8\u91cfq2\u4e2d\uff0c\u6e05\u7a7a\u4e4b\u524d\u7684\u961f\u5217q1\u3002\u63a5\u7740\u904d\u5386q2\u6307\u5411\u7684\u961f\u5217\uff0c\u5982\u679c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u53c8\u65b0\u589e\u4e86\u8282\u70b9\uff0c\u53ea\u4f1a\u52a0\u5165\u5230q1\u4e2d\u3002q2\u4e0d\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002","title":"11.2.3 \u5904\u7406tick\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1124-nexttick","text":"\u6211\u4eec\u77e5\u9053nextTick\u53ef\u7528\u4e8e\u5ef6\u8fdf\u6267\u884c\u4e00\u4e9b\u903b\u8f91\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u54ea\u4e9b\u573a\u666f\u4e0b\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1. const { EventEmitter } = require('events'); 2. class DemoEvents extends EventEmitter { 3. constructor() { 4. super(); 5. this.emit('start'); 6. } 7. } 8. 9. const demoEvents = new DemoEvents(); 10. demoEvents.on('start', () => { 11. console.log('start'); 12. }); \u4ee5\u4e0a\u4ee3\u7801\u5728\u6784\u9020\u51fd\u6570\u4e2d\u4f1a\u89e6\u53d1start\u4e8b\u4ef6\uff0c\u4f46\u662f\u4e8b\u4ef6\u7684\u6ce8\u518c\u5374\u5728\u6784\u9020\u51fd\u6570\u4e4b\u540e\u6267\u884c\uff0c\u800c\u5728\u6784\u9020\u51fd\u6570\u4e4b\u524d\u6211\u4eec\u8fd8\u6ca1\u6709\u62ff\u5230DemoEvents\u5bf9\u8c61\uff0c\u65e0\u6cd5\u5b8c\u6210\u4e8b\u4ef6\u7684\u6ce8\u518c\u3002\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1. const { EventEmitter } = require('events'); 2. class DemoEvents extends EventEmitter { 3. constructor() { 4. super(); 5. process.nextTick(() => { 6. this.emit('start'); 7. }) 8. } 9. } 10. 11. const demoEvents = new DemoEvents(); 12. demoEvents.on('start', () => { 13. console.log('start'); 14. });","title":"11.2.4 nextTick\u7684\u4f7f\u7528"},{"location":"chapter12-%E6%96%87%E4%BB%B6/","text":"\u6587\u4ef6\u64cd\u4f5c\u662f\u6211\u4eec\u4f7f\u7528Node.js\u65f6\u7ecf\u5e38\u4f1a\u7528\u5230\u7684\u529f\u80fd\u3002Node.js\u4e2d\uff0c\u6587\u4ef6\u6a21\u5757\u7684API\u51e0\u4e4e\u90fd\u63d0\u4f9b\u4e86\u540c\u6b65\u548c\u5f02\u6b65\u7684\u7248\u672c\u3002\u540c\u6b65\u7684API\u76f4\u63a5\u5728\u4e3b\u7ebf\u7a0b\u4e2d\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c\u5b83\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\u3002\u5f02\u6b65API\u5219\u662f\u5728Libuv\u63d0\u4f9b\u7684\u7ebf\u7a0b\u6c60\u4e2d\u6267\u884c\u963b\u585e\u5f0fAPI\u5b9e\u73b0\u7684\u3002\u8fd9\u6837\u5c31\u4e0d\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\u3002\u6587\u4ef6IO\u4e0d\u540c\u4e8e\u7f51\u7edcIO\uff0c\u6587\u4ef6IO\u7531\u4e8e\u517c\u5bb9\u6027\u95ee\u9898\uff0c\u65e0\u6cd5\u50cf\u7f51\u7edcIO\u4e00\u6837\u5229\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u80fd\u529b\u76f4\u63a5\u5b9e\u73b0\u5f02\u6b65\u3002\u5728Libuv\u4e2d\uff0c\u6587\u4ef6\u64cd\u4f5c\u662f\u4ee5\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u7684\uff0c\u64cd\u4f5c\u6587\u4ef6\u7684\u65f6\u5019\uff0c\u4f1a\u963b\u585e\u5728\u67d0\u4e2a\u7ebf\u7a0b\u3002\u6240\u4ee5\u8fd9\u79cd\u5f02\u6b65\u53ea\u662f\u5bf9\u7528\u6237\u800c\u8a00\u3002\u6587\u4ef6\u6a21\u5757\u867d\u7136\u63d0\u4f9b\u7684\u63a5\u53e3\u975e\u5e38\u591a\uff0c\u6e90\u7801\u4e5f\u51e0\u5343\u884c\uff0c\u4f46\u662f\u5f88\u591a\u903b\u8f91\u90fd\u662f\u7c7b\u4f3c\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u8bb2\u89e3\u4e0d\u540c\u7684\u5730\u65b9\u3002\u4ecb\u7ecd\u6587\u4ef6\u6a21\u5757\u4e4b\u524d\u5148\u4ecb\u7ecd\u4e00\u4e0bLinux\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u6587\u4ef6\u3002 Linux\u7cfb\u7edf\u4e2d\u4e07\u7269\u7686\u6587\u4ef6\uff0c\u4ece\u5e94\u7528\u5c42\u6765\u770b\uff0c\u6211\u4eec\u62ff\u5230\u90fd\u662f\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u6211\u4eec\u64cd\u4f5c\u7684\u4e5f\u662f\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u4f7f\u7528\u8d77\u6765\u975e\u5e38\u7b80\u5355\uff0c\u90a3\u662f\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u6211\u4eec\u505a\u4e86\u5f88\u591a\u4e8b\u60c5\u3002\u7b80\u5355\u6765\u8bf4\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ea\u662f\u4e00\u4e2a\u7d22\u5f15\u3002\u5b83\u7684\u5e95\u5c42\u53ef\u4ee5\u5bf9\u5e94\u5404\u79cd\u5404\u6837\u7684\u8d44\u6e90\uff0c\u5305\u62ec\u666e\u901a\u6587\u4ef6\uff0c\u7f51\u7edc\uff0c\u5185\u5b58\u7b49\u3002\u5f53\u6211\u4eec\u64cd\u4f5c\u4e00\u4e2a\u8d44\u6e90\u4e4b\u524d\uff0c\u6211\u4eec\u9996\u5148\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u62ff\u5230\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4e5f\u8bb0\u5f55\u4e86\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e95\u5c42\u5bf9\u5e94\u7684\u8d44\u6e90\u3001\u5c5e\u6027\u3001\u64cd\u4f5c\u51fd\u6570\u7b49\u3002\u5f53\u6211\u4eec\u540e\u7eed\u64cd\u4f5c\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u64cd\u4f5c\u3002\u6bd4\u5982\u6211\u4eec\u5728write\u7684\u65f6\u5019\uff0c\u4f20\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u666e\u901a\u6587\u4ef6\u548c\u7f51\u7edcsocket\uff0c\u5e95\u5c42\u6240\u505a\u7684\u64cd\u4f5c\u662f\u4e0d\u4e00\u6837\u7684\u3002\u4f46\u662f\u6211\u4eec\u4e00\u822c\u4e0d\u9700\u8981\u5173\u6ce8\u8fd9\u4e9b\u3002\u6211\u4eec\u53ea\u9700\u8981\u4ece\u62bd\u8c61\u7684\u89d2\u5ea6\u53bb\u4f7f\u7528\u5b83\u3002\u672c\u7ae0\u4ecb\u7ecdNode.js\u4e2d\u5173\u4e8e\u6587\u4ef6\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 12.1 \u540c\u6b65API \u00b6 \u5728Node.js\u4e2d\uff0c\u540c\u6b65API\u7684\u672c\u8d28\u662f\u76f4\u63a5\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u3002\u4e0b\u9762\u4ee5readFileSync\u4e3a\u4f8b\uff0c\u770b\u4e00\u4e0b\u6574\u4f53\u7684\u6d41\u7a0b\uff0c\u5982\u56fe12-1\u6240\u793a\u3002 \u56fe12-1 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801 1. function readFileSync(path, options) { 2. options = getOptions(options, { flag: 'r' }); 3. // \u4f20\u7684\u662ffd\u8fd8\u662f\u6587\u4ef6\u8def\u5f84 4. const isUserFd = isFd(path); 5. // \u4f20\u7684\u662f\u8def\u5f84\uff0c\u5219\u5148\u540c\u6b65\u6253\u5f00\u6587\u4ef6 6. const fd = isUserFd ? path : fs.openSync(path, options.flag, 0o666); 7. // \u67e5\u770b\u6587\u4ef6\u7684stat\u4fe1\u606f\uff0c\u62ff\u5230\u6587\u4ef6\u7684\u5927\u5c0f 8. const stats = tryStatSync(fd, isUserFd); 9. // \u662f\u5426\u662f\u4e00\u822c\u6587\u4ef6 10. const size = isFileType(stats, S_IFREG) ? stats[8] : 0; 11. let pos = 0; 12. let buffer; 13. let buffers; 14. // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0csize\u5219\u4e3a0 15. if (size === 0) { 16. buffers = []; 17. } else { 18. // \u4e00\u822c\u6587\u4ef6\u4e14\u6709\u5927\u5c0f\uff0c\u5219\u5206\u914d\u4e00\u4e2a\u5927\u5c0f\u4e3asize\u7684buffer\uff0csize\u9700\u8981\u5c0f\u4e8e2G 19. buffer = tryCreateBuffer(size, fd, isUserFd); 20. } 21. 22. let bytesRead; 23. // \u4e0d\u65ad\u5730\u540c\u6b65\u8bfb\u6587\u4ef6\u5185\u5bb9 24. if (size !== 0) { 25. do { 26. bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos); 27. pos += bytesRead; 28. } while (bytesRead !== 0 && pos < size); 29. } else { 30. do { 31. /* 32. \u6587\u4ef6\u5927\u5c0f\u4e3a0\uff0c\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0c\u4e5f\u5c1d\u8bd5\u53bb\u8bfb\uff0c 33. \u4f46\u662f\u56e0\u4e3a\u4e0d\u77e5\u9053\u5927\u5c0f\uff0c\u6240\u4ee5\u53ea\u80fd\u5206\u914d\u4e00\u4e2a\u4e00\u5b9a\u5927\u5c0f\u7684buffer, 34. \u6bcf\u6b21\u8bfb\u53d6\u4e00\u5b9a\u5927\u5c0f\u7684\u5185\u5bb9 35. */ 36. buffer = Buffer.allocUnsafe(8192); 37. bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192); 38. // \u628a\u8bfb\u53d6\u5230\u7684\u5185\u5bb9\u653e\u5230buffers\u91cc 39. if (bytesRead !== 0) { 40. buffers.push(buffer.slice(0, bytesRead)); 41. } 42. // \u8bb0\u5f55\u8bfb\u53d6\u5230\u7684\u6570\u636e\u957f\u5ea6 43. pos += bytesRead; 44. } while (bytesRead !== 0); 45. } 46. // \u7528\u6237\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\uff0cNode.js\u81ea\u5df1\u6253\u5f00\u4e86\u6587\u4ef6\uff0c\u6240\u4ee5\u9700\u8981\u81ea\u5df1\u5173\u95ed 47. if (!isUserFd) 48. fs.closeSync(fd); 49. // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u975e\u4e00\u822c\u6587\u4ef6\u7684\u8bdd\uff0c\u5982\u679c\u8bfb\u5230\u4e86\u5185\u5bb9 50. if (size === 0) { 51. // \u628a\u8bfb\u53d6\u5230\u7684\u6240\u6709\u5185\u5bb9\u653e\u5230buffer\u4e2d 52. buffer = Buffer.concat(buffers, pos); 53. } else if (pos < size) { 54. buffer = buffer.slice(0, pos); 55. } 56. // \u7f16\u7801 57. if (options.encoding) buffer = buffer.toString(options.encoding); 58. return buffer; 59. } tryReadSync\u8c03\u7528\u7684\u662ffs.readSync\uff0c\u7136\u540e\u5230binding.read(node_file.cc\u4e2d\u5b9a\u4e49\u7684Read\u51fd\u6570)\u3002Read\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1. FSReqWrapSync req_wrap_sync; 2. const int bytesRead = SyncCall(env, 3. args[6], 4. &req_wrap_sync, 5. \"read\", 6. uv_fs_read, 7. fd, 8. &uvbuf, 9. 1, 10. pos); \u6211\u4eec\u770b\u4e00\u4e0bSyncCall\u7684\u5b9e\u73b0 1. int SyncCall(Environment* env, 2. v8::Local<v8::Value> ctx, 3. FSReqWrapSync* req_wrap, 4. const char* syscall, 5. Func fn, 6. Args... args) { 7. /* 8. req_wrap->req\u662f\u4e00\u4e2auv_fs_t\u7ed3\u6784\u4f53\uff0c\u5c5e\u4e8erequest\u7c7b\uff0c 9. \u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u7684\u8bf7\u6c42 10. */ 11. int err = fn(env->event_loop(), 12. &(req_wrap->req), 13. args..., 14. nullptr); 15. // \u5ffd\u7565\u51fa\u9519\u5904\u7406 16. return err; 17. } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u8c03\u7528\u7684\u662fLibuv\u7684uv_fs_read\uff0c\u5e76\u4f7f\u7528uv_fs_t\u7ba1\u7406\u672c\u6b21\u8bf7\u6c42\u3002\u56e0\u4e3a\u662f\u963b\u585e\u5f0f\u8c03\u7528\uff0c\u6240\u4ee5Libuv\u4f1a\u76f4\u63a5\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\u51fd\u6570\u3002\u8fd9\u662fNode.js\u4e2d\u540c\u6b65API\u7684\u8fc7\u7a0b\u3002 12.2 \u5f02\u6b65API \u00b6 \u6587\u4ef6\u7cfb\u7edf\u7684API\u4e2d\uff0c\u5f02\u6b65\u7684\u5b9e\u73b0\u662f\u4f9d\u8d56\u4e8eLibuv\u7684\u7ebf\u7a0b\u6c60\u7684\u3002Node.js\u628a\u4efb\u52a1\u653e\u5230\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u8fd4\u56de\u4e3b\u7ebf\u7a0b\u7ee7\u7eed\u5904\u7406\u5176\u5b83\u4e8b\u60c5\uff0c\u7b49\u5230\u6761\u4ef6\u6ee1\u8db3\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8bb2\u89e3\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u5f02\u6b65\u8bfb\u53d6\u6587\u4ef6\u7684\u6d41\u7a0b\u56fe\uff0c\u5982\u56fe12-2\u6240\u793a\u3002 \u56fe12-2 \u4e0b\u9762\u6211\u4eec\u770b\u5177\u4f53\u7684\u5b9e\u73b0 1. function readFile(path, options, callback) { 2. callback = maybeCallback(callback || options); 3. options = getOptions(options, { flag: 'r' }); 4. // \u7ba1\u7406\u6587\u4ef6\u8bfb\u7684\u5bf9\u8c61 5. if (!ReadFileContext) 6. ReadFileContext = require('internal/fs/read_file_context'); 7. const context = new ReadFileContext(callback, options.encoding) 8. // \u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u8fd8\u662ffd 9. context.isUserFd = isFd(path); // File descriptor ownership 10. // C++\u5c42\u7684\u5bf9\u8c61\uff0c\u5c01\u88c5\u4e86uv_fs_t\u7ed3\u6784\u4f53\uff0c\u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u8bfb\u8bf7\u6c42 11. const req = new FSReqCallback(); 12. req.context = context; 13. // \u8bbe\u7f6e\u56de\u8c03\uff0c\u6253\u5f00\u6587\u4ef6\u540e\uff0c\u6267\u884c 14. req.oncomplete = readFileAfterOpen; 15. // \u4f20\u7684\u662ffd\uff0c\u5219\u4e0d\u9700\u8981\u6253\u5f00\u6587\u4ef6\uff0c\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884c\u56de\u8c03\u8bfb\u53d6\u6587\u4ef6 16. if (context.isUserFd) { 17. process.nextTick(function tick() { 18. req.oncomplete(null, path); 19. }); 20. return; 21. } 22. 23. path = getValidatedPath(path); 24. const flagsNumber = stringToFlags(options.flags); 25. // \u8c03\u7528C++\u5c42open\u6253\u5f00\u6587\u4ef6 26. binding.open(pathModule.toNamespacedPath(path), 27. flagsNumber, 28. 0o666, 29. req); 30. } ReadFileContext\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u8bfb\u64cd\u4f5c\u6574\u4e2a\u8fc7\u7a0b\uff0cFSReqCallback\u662f\u5bf9uv_fs_t\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21\u8bfb\u64cd\u4f5c\u5bf9\u4e8eLibuv\u6765\u8bf4\u5c31\u662f\u4e00\u6b21\u8bf7\u6c42\uff0c\u8be5\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\u5c31\u662f\u4f7f\u7528uv_fs_t\u8868\u793a\u3002\u8bf7\u6c42\u5b8c\u6210\u540e\uff0c\u4f1a\u6267\u884cFSReqCallback\u5bf9\u8c61\u7684oncomplete\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u7ee7\u7eed\u770breadFileAfterOpen\u3002 1. function readFileAfterOpen(err, fd) { 2. const context = this.context; 3. // \u6253\u5f00\u51fa\u9519\u5219\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u4f20\u5165err 4. if (err) { 5. context.callback(err); 6. return; 7. } 8. // \u4fdd\u5b58\u6253\u5f00\u6587\u4ef6\u7684fd 9. context.fd = fd; 10. // \u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u4e0b\u4e00\u4e2a\u5f02\u6b65\u8bf7\u6c42\u548c\u56de\u8c03 11. const req = new FSReqCallback(); 12. req.oncomplete = readFileAfterStat; 13. req.context = context; 14. // \u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u62ff\u5230\u6587\u4ef6\u5927\u5c0f 15. binding.fstat(fd, false, req); 16. } \u62ff\u5230\u6587\u4ef6\u7684\u5143\u6570\u636e\u540e\uff0c\u6267\u884creadFileAfterStat\uff0c\u8fd9\u6bb5\u903b\u8f91\u548c\u540c\u6b65\u7684\u7c7b\u4f3c\uff0c\u6839\u636e\u5143\u6570\u636e\u4e2d\u8bb0\u5f55\u7684\u6587\u4ef6\u5927\u5c0f\uff0c\u5206\u914d\u4e00\u4e2abuffer\u7528\u4e8e\u540e\u7eed\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u3002\u7136\u540e\u6267\u884c\u8bfb\u64cd\u4f5c\u3002 1. read() { 2. let buffer; 3. let offset; 4. let length; 5. 6. // \u7701\u7565\u90e8\u5206buffer\u5904\u7406\u7684\u903b\u8f91 7. const req = new FSReqCallback(); 8. req.oncomplete = readFileAfterRead; 9. req.context = this; 10. 11. read(this.fd, buffer, offset, length, -1, req); 12. } \u518d\u6b21\u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u5f02\u6b65\u8bfb\u53d6\u64cd\u4f5c\u548c\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42read\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. // \u62ff\u5230C++\u5c42\u7684FSReqCallback\u5bf9\u8c61 2. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); 3. // \u5f02\u6b65\u8c03\u7528uv_fs_read 4. AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger,uv_fs_read, fd, &uvbuf, 1, pos); AsyncCall\u6700\u540e\u8c03\u7528Libuv\u7684uv_fs_read\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u5173\u952e\u903b\u8f91\u3002 1. do { \\ 2. if (cb != NULL) { \\ 3. uv__req_register(loop, req); \\ 4. uv__work_submit(loop, \\ 5. &req->work_req, \\ 6. UV__WORK_FAST_IO, \\ 7. uv__fs_work, \\ 8. uv__fs_done); \\ 9. return 0; \\ 10. } \\ 11. else { \\ 12. uv__fs_work(&req->work_req); \\ 13. return req->result; \\ 14. } \\ 15. } \\ 16. while (0) uv__work_submit\u662f\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u8fd9\u4e2a\u4efb\u52a1\u65f6\uff0c\u5c31\u4f1a\u6267\u884cuv__fs_work\uff0cuv__fs_work\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\u7b49\u5230\u8bfb\u53d6\u6210\u529f\u540e\u6267\u884cuv__fs_done\u3002uv__fs_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002JS\u5c42\u7684\u56de\u8c03\u662freadFileAfterRead\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5c55\u5f00\uff0creadFileAfterRead\u7684\u903b\u8f91\u662f\u5224\u65ad\u662f\u5426\u8bfb\u53d6\u5b8c\u6bd5\uff0c\u662f\u7684\u8bdd\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5426\u5219\u7ee7\u7eed\u53d1\u8d77\u8bfb\u53d6\u64cd\u4f5c\u3002 12.3 \u6587\u4ef6\u76d1\u542c \u00b6 \u6587\u4ef6\u76d1\u542c\u662f\u975e\u5e38\u5e38\u7528\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6211\u4eec\u4fee\u6539\u4e86\u6587\u4ef6\u540ewebpack\u91cd\u65b0\u6253\u5305\u4ee3\u7801\u6216\u8005Node.js\u670d\u52a1\u91cd\u542f\uff0c\u90fd\u7528\u5230\u4e86\u6587\u4ef6\u76d1\u542c\u7684\u529f\u80fd\uff0cNode.js\u63d0\u4f9b\u4e86\u4e24\u5957\u6587\u4ef6\u76d1\u542c\u7684\u673a\u5236\u3002 12.3.1 \u57fa\u4e8e\u8f6e\u8be2\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236 \u00b6 \u57fa\u4e8e\u8f6e\u8be2\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542cAPI\u662fwatchFile\u3002\u6d41\u7a0b\u5982\u56fe12-3\u6240\u793a\u3002 \u56fe12-3 \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1. function watchFile(filename, options, listener) { 2. filename = getValidatedPath(filename); 3. filename = pathModule.resolve(filename); 4. let stat; 5. // \u7701\u7565\u90e8\u5206\u53c2\u6570\u5904\u7406\u903b\u8f91 6. options = { 7. interval: 5007, 8. // \u4e00\u76f4\u8f6e\u8be2 9. persistent: true, 10. ...options 11. }; 12. 13. // \u7f13\u5b58\u5904\u7406\uff0cfilename\u662f\u5426\u5df2\u7ecf\u5f00\u542f\u8fc7\u76d1\u542c 14. stat = statWatchers.get(filename); 15. 16. if (stat === undefined) { 17. if (!watchers) 18. watchers = require('internal/fs/watchers'); 19. stat = new watchers.StatWatcher(options.bigint); 20. // \u5f00\u542f\u76d1\u542c 21. stat[watchers.kFSStatWatcherStart](filename, 22. options.persistent, 23. options.interval); 24. // \u66f4\u65b0\u7f13\u5b58 25. statWatchers.set(filename, stat); 26. } 27. 28. stat.addListener('change', listener); 29. return stat; 30. } StatWatcher\u662f\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u7c7b\uff0c\u6211\u4eec\u770b\u4e00\u4e0bwatchers.kFSStatWatcherStart\u65b9\u6cd5\u7684\u5b9e\u73b0\u3002 1. StatWatcher.prototype[kFSStatWatcherStart] = function(filename,persistent, interval) { 2. this._handle = new _StatWatcher(this[kUseBigint]); 3. this._handle.onchange = onchange; 4. filename = getValidatedPath(filename, 'filename'); 5. const err = this._handle.start(toNamespacedPath(filename), 6. interval); 7. } \u65b0\u5efa\u4e00\u4e2a_StatWatcher\u5bf9\u8c61\uff0c_StatWatcher\u662fC++\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\uff08node_stat_watcher.cc\uff09\uff0c\u7136\u540e\u6267\u884c\u5b83\u7684start\u65b9\u6cd5\u3002Start\u65b9\u6cd5\u6267\u884cLibuv\u7684uv_fs_poll_start\u5f00\u59cb\u76d1\u542c\u6587\u4ef6\u3002 1. int uv_fs_poll_start(uv_fs_poll_t* handle,uv_fs_poll_cb cb, 2. const char* path, unsigned int interval) { 3. // \u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u6570\u636e\u7ed3\u6784 4. struct poll_ctx* ctx; 5. uv_loop_t* loop; 6. size_t len; 7. int err; 8. 9. loop = handle->loop; 10. len = strlen(path); 11. // calloc\u4f1a\u628a\u5185\u5b58\u521d\u59cb\u5316\u4e3a0 12. ctx = uv__calloc(1, sizeof(*ctx) + len); 13. ctx->loop = loop; 14. // C++\u5c42\u56de\u8c03 15. ctx->poll_cb = cb; 16. // \u591a\u4e45\u8f6e\u8be2\u4e00\u6b21 17. ctx->interval = interval ? interval : 1; 18. ctx->start_time = uv_now(loop); 19. // \u5173\u8054\u7684handle 20. ctx->parent_handle = handle; 21. // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 22. memcpy(ctx->path, path, len + 1); 23. // \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53 24. err = uv_timer_init(loop, &ctx->timer_handle); 25. // \u5f02\u6b65\u67e5\u8be2\u6587\u4ef6\u5143\u6570\u636e 26. err = uv_fs_stat(loop, &ctx->fs_req, ctx->path, poll_cb); 27. 28. if (handle->poll_ctx != NULL) 29. ctx->previous = handle->poll_ctx; 30. // \u5173\u8054\u8d1f\u8d23\u7ba1\u7406\u8f6e\u8be2\u7684\u5bf9\u8c61 31. handle->poll_ctx = ctx; 32. uv__handle_start(handle); 33. return 0; 34. } Start\u51fd\u6570\u521d\u59cb\u5316\u4e00\u4e2apoll_ctx\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u53d1\u8d77\u5f02\u6b65\u8bf7\u6c42\u6587\u4ef6\u5143\u6570\u636e\u7684\u8bf7\u6c42\uff0c\u83b7\u53d6\u5143\u6570\u636e\u540e\uff0c\u6267\u884cpoll_cb\u56de\u8c03\u3002 1. static void poll_cb(uv_fs_t* req) { 2. uv_stat_t* statbuf; 3. struct poll_ctx* ctx; 4. uint64_t interval; 5. // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 6. ctx = container_of(req, struct poll_ctx, fs_req); 7. statbuf = &req->statbuf; 8. /* 9. \u7b2c\u4e00\u6b21\u4e0d\u6267\u884c\u56de\u8c03\uff0c\u56e0\u4e3a\u6ca1\u6709\u53ef\u5bf9\u6bd4\u7684\u5143\u6570\u636e\uff0c\u7b2c\u4e8c\u6b21\u53ca\u540e\u7eed\u7684\u64cd\u4f5c\u624d\u53ef\u80fd 10. \u6267\u884c\u56de\u8c03\uff0cbusy_polling\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\u7f6e 11. busy_polling=1 12. */ 13. if (ctx->busy_polling != 0) 14. // \u51fa\u9519\u6216\u8005stat\u53d1\u751f\u4e86\u53d8\u5316\u5219\u6267\u884c\u56de\u8c03 15. if (ctx->busy_polling < 0 || 16. !statbuf_eq(&ctx->statbuf, statbuf)) 17. ctx->poll_cb(ctx->parent_handle, 18. 0, 19. &ctx->statbuf, 20. statbuf); 21. // \u4fdd\u5b58\u5f53\u524d\u83b7\u53d6\u5230\u7684stat\u4fe1\u606f\uff0c\u7f6e1 22. ctx->statbuf = *statbuf; 23. ctx->busy_polling = 1; 24. 25. out: 26. uv_fs_req_cleanup(req); 27. 28. if (ctx->parent_handle == NULL) { 29. uv_close((uv_handle_t*)&ctx->timer_handle, timer_close_cb); 30. return; 31. } 32. /* 33. \u5047\u8bbe\u5728\u5f00\u59cb\u65f6\u95f4\u70b9\u4e3a1\uff0cinterval\u4e3a10\u7684\u60c5\u51b5\u4e0b\u6267\u884c\u4e86stat\uff0cstat 34. \u5b8c\u6210\u6267\u884c\u5e76\u6267\u884cpoll_cb\u56de\u8c03\u7684\u65f6\u95f4\u70b9\u662f3\uff0c\u90a3\u4e48\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4 35. \u5219\u4e3a10-3=7\uff0c\u53737\u4e2a\u5355\u4f4d\u540e\u5c31\u8981\u89e6\u53d1\u8d85\u65f6\uff0c\u800c\u4e0d\u662f10\uff0c\u662f\u56e0\u4e3astat 36. \u963b\u585e\u6d88\u8017\u4e863\u4e2a\u5355\u4f4d\u7684\u65f6\u95f4\uff0c\u6240\u4ee5\u4e0b\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u51fd\u6570\u65f6\u8bf4\u660e\u4ece 37. start\u65f6\u95f4\u70b9\u5f00\u59cb\u7b97\uff0c\u5df2\u7ecf\u7ecf\u5386\u4e86x\u5355\u4f4d\u5404interval\uff0c\u7136\u540e\u8d85\u65f6\u56de\u8c03\u91cc 38. \u53c8\u6267\u884c\u4e86stat\u51fd\u6570\uff0c\u518d\u5230\u6267\u884cstat\u56de\u8c03\uff0c\u8fd9\u4e2a\u65f6\u95f4\u70b9\u5373now=start+x 39. \u5355\u4f4d\u4e2ainterval+stat\u6d88\u8017\u7684\u65f6\u95f4\u3002\u5f97\u51fanow-start\u4e3ainterval\u7684 40. x\u500d+stat\u6d88\u8017\uff0c\u5373\u5bf9interval\u53d6\u4f59\u53ef\u5f97\u5230stat\u6d88\u8017\uff0c\u6240\u4ee5\u5f53\u524d\u8f6e\uff0c 41. \u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4\u4e3ainterval - ((now-start) % interval) 42. */ 43. interval = ctx->interval; 44. interval = (uv_now(ctx->loop) - ctx->start_time) % interval; 45. 46. if (uv_timer_start(&ctx->timer_handle, timer_cb, interval, 0)) 47. abort(); 48. } \u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u6587\u4ef6\u673a\u5236\u672c\u8d28\u4e0a\u662f\u4e0d\u65ad\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u7136\u540e\u548c\u4e0a\u4e00\u6b21\u7684\u5143\u6570\u636e\u8fdb\u884c\u5bf9\u6bd4\uff0c\u5982\u679c\u6709\u4e0d\u4e00\u81f4\u7684\u5c31\u8ba4\u4e3a\u6587\u4ef6\u53d8\u5316\u4e86\uff0c\u56e0\u4e3a\u7b2c\u4e00\u6b21\u83b7\u53d6\u5143\u6570\u636e\u65f6\uff0c\u8fd8\u6ca1\u6709\u53ef\u4ee5\u5bf9\u6bd4\u7684\u6570\u636e\uff0c\u6240\u4ee5\u4e0d\u8ba4\u4e3a\u662f\u6587\u4ef6\u53d8\u5316\uff0c\u8fd9\u65f6\u5019\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u9694\u4e00\u6bb5\u65f6\u95f4\u518d\u53bb\u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u6b64\u53cd\u590d\uff0c\u76f4\u5230\u7528\u6237\u8c03stop\u51fd\u6570\u505c\u6b62\u8fd9\u4e2a\u884c\u4e3a\u3002\u4e0b\u9762\u662fLibuv\u5173\u4e8e\u6587\u4ef6\u53d8\u5316\u7684\u5b9a\u4e49\u3002 1. static int statbuf_eq(const uv_stat_t* a, const uv_stat_t* b) { 2. return a->st_ctim.tv_nsec == b->st_ctim.tv_nsec 3. && a->st_mtim.tv_nsec == b->st_mtim.tv_nsec 4. && a->st_birthtim.tv_nsec == b->st_birthtim.tv_nsec 5. && a->st_ctim.tv_sec == b->st_ctim.tv_sec 6. && a->st_mtim.tv_sec == b->st_mtim.tv_sec 7. && a->st_birthtim.tv_sec == b->st_birthtim.tv_sec 8. && a->st_size == b->st_size 9. && a->st_mode == b->st_mode 10. && a->st_uid == b->st_uid 11. && a->st_gid == b->st_gid 12. && a->st_ino == b->st_ino 13. && a->st_dev == b->st_dev 14. && a->st_flags == b->st_flags 15. && a->st_gen == b->st_gen; 16. } 12.3.2\u57fa\u4e8einotify\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236 \u00b6 \u6211\u4eec\u770b\u5230\u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u5176\u5b9e\u6548\u7387\u662f\u5f88\u4f4e\u7684\uff0c\u56e0\u4e3a\u9700\u8981\u6211\u4eec\u4e0d\u65ad\u53bb\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u679c\u6587\u4ef6\u5927\u90e8\u5206\u65f6\u95f4\u91cc\u90fd\u6ca1\u6709\u53d8\u5316\uff0c\u90a3\u5c31\u4f1a\u767d\u767d\u6d6a\u8d39CPU\u3002\u5982\u679c\u6587\u4ef6\u6539\u53d8\u4e86\u4f1a\u4e3b\u52a8\u901a\u77e5\u6211\u4eec\u90a3\u5c31\u597d\u4e86\uff0c\u8fd9\u5c31\u662f\u57fa\u4e8einotify\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542c\u3002Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u662fwatch\u3002watch\u7684\u5b9e\u73b0\u548cwatchFile\u7684\u6bd4\u8f83\u7c7b\u4f3c\u3002 1. function watch(filename, options, listener) { 2. // Don't make changes directly on options object 3. options = copyObject(options); 4. // \u662f\u5426\u6301\u7eed\u76d1\u542c 5. if (options.persistent === undefined) 6. options.persistent = true; 7. // \u5982\u679c\u662f\u76ee\u5f55\uff0c\u662f\u5426\u76d1\u542c\u6240\u6709\u5b50\u76ee\u5f55\u548c\u6587\u4ef6\u7684\u53d8\u5316 8. if (options.recursive === undefined) 9. options.recursive = false; 10. // \u6709\u4e9b\u5e73\u53f0\u4e0d\u652f\u6301 11. if (options.recursive && !(isOSX || isWindows)) 12. throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively'); 13. if (!watchers) 14. watchers = require('internal/fs/watchers'); 15. // \u65b0\u5efa\u4e00\u4e2aFSWatcher\u5bf9\u8c61\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u5f00\u542f\u76d1\u542c 16. const watcher = new watchers.FSWatcher(); 17. watcher[watchers.kFSWatchStart](filename, 18. options.persistent, 19. options.recursive, 20. options.encoding); 21. 22. if (listener) { 23. watcher.addListener('change', listener); 24. } 25. 26. return watcher; 27. } FSWatcher\u51fd\u6570\u662f\u5bf9C++\u5c42FSEvent\u6a21\u5757\u7684\u5c01\u88c5\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0bstart\u51fd\u6570\u7684\u903b\u8f91\uff0cstart\u51fd\u6570\u900f\u8fc7C++\u5c42\u8c03\u7528\u4e86Libuv\u7684uv_fs_event_start\u51fd\u6570\u3002\u5728\u8bb2\u89e3uv_fs_event_start\u51fd\u6570\u524d\uff0c\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0binotify\u7684\u539f\u7406\u548c\u5b83\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002inotify\u662fLinux\u7cfb\u7edf\u63d0\u4f9b\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u7cfb\u7edf\u7684\u673a\u5236\u3002inotify\u673a\u5236\u7684\u903b\u8f91\u5927\u81f4\u662f 1 init_inotify\u521b\u5efa\u4e00\u4e2ainotify\u7684\u5b9e\u4f8b\uff0c\u8fd4\u56de\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7c7b\u4f3cepoll\u3002 2 inotify_add_watch\u5f80inotify\u5b9e\u4f8b\u6ce8\u518c\u4e00\u4e2a\u9700\u76d1\u542c\u7684\u6587\u4ef6\uff08inotify_rm_watch\u662f\u79fb\u9664\uff09\u3002 3 read(inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26, &buf, sizeof(buf))\uff0c\u5982\u679c\u6ca1\u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u5219\u963b\u585e\uff08\u9664\u975e\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\uff09\u3002\u5426\u5219\u8fd4\u56de\u5f85\u8bfb\u53d6\u7684\u6570\u636e\u957f\u5ea6\u3002buf\u5c31\u662f\u4fdd\u5b58\u4e86\u89e6\u53d1\u4e8b\u4ef6\u7684\u4fe1\u606f\u3002 Libuv\u5728inotify\u673a\u5236\u7684\u57fa\u7840\u4e0a\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\u3002\u6211\u4eec\u770b\u4e00\u4e0binotify\u5728Libuv\u7684\u67b6\u6784\u56fe\u5982\u56fe12-4\u6240\u793a\u3002 \u56fe12-4 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bLibuv\u4e2d\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u3002 1. int main(int argc, char **argv) { 2. // \u5b9e\u73b0\u5faa\u73af\u6838\u5fc3\u7ed3\u6784\u4f53loop 3. loop = uv_default_loop(); 4. uv_fs_event_t *fs_event_req = malloc(sizeof(uv_fs_event_t)); 5. // \u521d\u59cb\u5316fs_event_req\u7ed3\u6784\u4f53\u7684\u7c7b\u578b\u4e3aUV_FS_EVENT 6. uv_fs_event_init(loop, fs_event_req); 7. /* 8. argv[argc]\u662f\u6587\u4ef6\u8def\u5f84\uff0c 9. uv_fs_event_start \u5411\u5e95\u5c42\u6ce8\u518c\u76d1\u542c\u6587\u4ef6argv[argc], 10. cb\u662f\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03 11. */ 12. uv_fs_event_start(fs_event_req, 13. cb, 14. argv[argc], 15. UV_FS_EVENT_RECURSIVE); 16. // \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af 17. return uv_run(loop, UV_RUN_DEFAULT); 18. } Libuv\u5728\u7b2c\u4e00\u6b21\u76d1\u542c\u6587\u4ef6\u7684\u65f6\u5019(\u8c03\u7528uv_fs_event_start\u7684\u65f6\u5019)\uff0c\u4f1a\u521b\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002 1. static int init_inotify(uv_loop_t* loop) { 2. int err; 3. // \u521d\u59cb\u5316\u8fc7\u4e86\u5219\u76f4\u63a5\u8fd4\u56de 4. if (loop->inotify_fd != -1) 5. return 0; 6. /* 7. \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684inotify_init\u51fd\u6570\u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b\uff0c 8. \u5e76\u8bbe\u7f6eUV__IN_NONBLOCK\uff0cUV__IN_CLOEXEC\u6807\u8bb0 9. */ 10. err = new_inotify_fd(); 11. if (err < 0) 12. return err; 13. // \u8bb0\u5f55inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26,\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e00\u4e2ainotify\u5b9e\u4f8b 14. loop->inotify_fd = err; 15. /* 16. inotify_read_watcher\u662f\u4e00\u4e2aIO\u89c2\u5bdf\u8005\uff0c 17. uv__io_init\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5f85\u89c2\u5bdf\u7684\u6587\u4ef6\uff09\u548c\u56de\u8c03 18. */ 19. uv__io_init(&loop->inotify_read_watcher, 20. uv__inotify_read, 21. loop->inotify_fd); 22. // \u5f80Libuv\u4e2d\u6ce8\u518c\u8be5IO\u89c2\u5bdf\u8005\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb 23. uv__io_start(loop, &loop->inotify_read_watcher, POLLIN); 24. 25. return 0; 26. } Libuv\u628ainotify\u5b9e\u4f8b\u5bf9\u5e94\u7684fd\u901a\u8fc7uv__io_start\u6ce8\u518c\u5230epoll\u4e2d\uff0c\u5f53\u6709\u6587\u4ef6\u53d8\u5316\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002\u5206\u6790\u5b8cLibuv\u7533\u8bf7inotify\u5b9e\u4f8b\u7684\u903b\u8f91\uff0c\u6211\u4eec\u56de\u5230main\u51fd\u6570\u770b\u770buv_fs_event_start\u51fd\u6570\u3002\u7528\u6237\u4f7f\u7528uv_fs_event_start\u51fd\u6570\u6765\u5f80Libuv\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1. int uv_fs_event_start(uv_fs_event_t* handle, 2. uv_fs_event_cb cb, 3. const char* path, 4. unsigned int flags) { 5. struct watcher_list* w; 6. int events; 7. int err; 8. int wd; 9. 10. if (uv__is_active(handle)) 11. return UV_EINVAL; 12. // \u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b 13. err = init_inotify(handle->loop); 14. if (err) 15. return err; 16. // \u76d1\u542c\u7684\u4e8b\u4ef6 17. events = UV__IN_ATTRIB 18. | UV__IN_CREATE 19. | UV__IN_MODIFY 20. | UV__IN_DELETE 21. | UV__IN_DELETE_SELF 22. | UV__IN_MOVE_SELF 23. | UV__IN_MOVED_FROM 24. | UV__IN_MOVED_TO; 25. // \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\uff0c\u8fd4\u56de\u4e00\u4e2a\u5bf9\u5e94\u4e8e\u8be5\u6587\u4ef6\u7684id 26. wd = uv__inotify_add_watch(handle->loop->inotify_fd, path, events); 27. if (wd == -1) 28. return UV__ERR(errno); 29. // \u5224\u65ad\u8be5\u6587\u4ef6\u662f\u4e0d\u662f\u5df2\u7ecf\u6ce8\u518c\u8fc7\u4e86 30. w = find_watcher(handle->loop, wd); 31. // \u5df2\u7ecf\u6ce8\u518c\u8fc7\u5219\u8df3\u8fc7\u63d2\u5165\u7684\u903b\u8f91 32. if (w) 33. goto no_insert; 34. // \u8fd8\u6ca1\u6709\u6ce8\u518c\u8fc7\u5219\u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811 35. w = uv__malloc(sizeof(*w) + strlen(path) + 1); 36. if (w == NULL) 37. return UV_ENOMEM; 38. 39. w->wd = wd; 40. w->path = strcpy((char*)(w + 1), path); 41. QUEUE_INIT(&w->watchers); 42. w->iterating = 0; 43. // \u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811,inotify_watchers\u662f\u6839\u8282\u70b9 44. RB_INSERT(watcher_root, CAST(&handle->loop->inotify_watchers), w); 45. 46. no_insert: 47. // \u6fc0\u6d3b\u8be5handle 48. uv__handle_start(handle); 49. // \u540c\u4e00\u4e2a\u6587\u4ef6\u53ef\u80fd\u6ce8\u518c\u4e86\u5f88\u591a\u4e2a\u56de\u8c03\uff0cw\u5bf9\u5e94\u4e00\u4e2a\u6587\u4ef6\uff0c\u6ce8\u518c\u5728\u7528\u4e00\u4e2a\u6587\u4ef6\u7684\u56de\u8c03\u6392\u6210\u961f 50. QUEUE_INSERT_TAIL(&w->watchers, &handle->watchers); 51. // \u4fdd\u5b58\u4fe1\u606f\u548c\u56de\u8c03 52. handle->path = w->path; 53. handle->cb = cb; 54. handle->wd = wd; 55. 56. return 0; 57. } \u4e0b\u9762\u6211\u4eec\u9010\u6b65\u5206\u6790\u4e0a\u9762\u7684\u51fd\u6570\u903b\u8f91\u3002 1 \u5982\u679c\u662f\u9996\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u5219\u65b0\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002\u5e76\u4e14\u5f80Libuv\u63d2\u5165\u4e00\u4e2a\u89c2\u5bdf\u8005io\uff0cLibuv\u4f1a\u5728Poll IO\u9636\u6bb5\u6ce8\u518c\u5230epoll\u4e2d\u3002 2 \u5f80\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u8fd4\u56de\u4e00\u4e2aid\u3002 3 Libuv\u5224\u65ad\u8be5id\u662f\u4e0d\u662f\u5728\u81ea\u5df1\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811\u4e2d\u3002\u4e0d\u5728\u7ea2\u9ed1\u6811\u4e2d\uff0c\u5219\u63d2\u5165\u7ea2\u9ed1\u6811\u3002\u8fd4\u56de\u4e00\u4e2a\u7ea2\u9ed1\u6811\u4e2d\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u628a\u672c\u6b21\u8bf7\u6c42\u7684\u4fe1\u606f\u5c01\u88c5\u5230handle\u4e2d\uff08\u56de\u8c03\u65f6\u9700\u8981\uff09\u3002\u7136\u540e\u628ahandle\u63d2\u5165\u521a\u624d\u8fd4\u56de\u7684\u8282\u70b9\u7684\u961f\u5217\u4e2d\u3002 \u8fd9\u65f6\u5019\u6ce8\u518c\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002Libuv\u5728Poll IO\u9636\u6bb5\u5982\u679c\u68c0\u6d4b\u5230\u6709\u6587\u4ef6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002 1. static void uv__inotify_read(uv_loop_t* loop, 2. uv__io_t* dummy, 3. unsigned int events) { 4. const struct uv__inotify_event* e; 5. struct watcher_list* w; 6. uv_fs_event_t* h; 7. QUEUE queue; 8. QUEUE* q; 9. const char* path; 10. ssize_t size; 11. const char *p; 12. /* needs to be large enough for sizeof(inotify_event) + strlen(path) */ 13. char buf[4096]; 14. // \u4e00\u6b21\u53ef\u80fd\u6ca1\u6709\u8bfb\u5b8c 15. while (1) { 16. do 17. // \u8bfb\u53d6\u89e6\u53d1\u7684\u4e8b\u4ef6\u4fe1\u606f\uff0csize\u662f\u6570\u636e\u5927\u5c0f\uff0cbuffer\u4fdd\u5b58\u6570\u636e 18. size = read(loop->inotify_fd, buf, sizeof(buf)); 19. while (size == -1 && errno == EINTR); 20. // \u6ca1\u6709\u6570\u636e\u53ef\u53d6\u4e86 21. if (size == -1) { 22. assert(errno == EAGAIN || errno == EWOULDBLOCK); 23. break; 24. } 25. // \u5904\u7406buffer\u7684\u4fe1\u606f 26. for (p = buf; p < buf + size; p += sizeof(*e) + e->len) { 27. // buffer\u91cc\u662f\u591a\u4e2auv__inotify_event\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86\u4e8b\u4ef6\u4fe1\u606f\u548c\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09 28. e = (const struct uv__inotify_event*)p; 29. 30. events = 0; 31. if (e->mask & (UV__IN_ATTRIB|UV__IN_MODIFY)) 32. events |= UV_CHANGE; 33. if (e->mask & ~(UV__IN_ATTRIB|UV__IN_MODIFY)) 34. events |= UV_RENAME; 35. // \u901a\u8fc7\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u8282\u70b9 36. w = find_watcher(loop, e->wd); 37. 38. path = e->len ? (const char*) (e + 1) : uv__basename_r(w->path); 39. w->iterating = 1; 40. // \u628a\u7ea2\u9ed1\u6811\u4e2d\uff0cwd\u5bf9\u5e94\u8282\u70b9\u7684handle\u961f\u5217\u79fb\u5230queue\u53d8\u91cf\uff0c\u51c6\u5907\u5904\u7406 41. QUEUE_MOVE(&w->watchers, &queue); 42. while (!QUEUE_EMPTY(&queue)) { 43. // \u5934\u7ed3\u70b9 44. q = QUEUE_HEAD(&queue); 45. // \u901a\u8fc7\u7ed3\u6784\u4f53\u504f\u79fb\u62ff\u5230\u9996\u5730\u5740 46. h = QUEUE_DATA(q, uv_fs_event_t, watchers); 47. // \u4ece\u5904\u7406\u961f\u5217\u4e2d\u79fb\u9664 48. QUEUE_REMOVE(q); 49. // \u653e\u56de\u539f\u961f\u5217 50. QUEUE_INSERT_TAIL(&w->watchers, q); 51. // \u6267\u884c\u56de\u8c03 52. h->cb(h, path, events, 0); 53. } 54. } 55. } 56. } uv__inotify_read\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u4ece\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\uff0c\u8fd9\u4e9b\u6570\u636e\u4e2d\u4fdd\u5b58\u4e86\u54ea\u4e9b\u6587\u4ef6\u89e6\u53d1\u4e86\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u7136\u540e\u904d\u5386\u6bcf\u4e2a\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u6587\u4ef6\u3002\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u8be5\u6587\u4ef6\u5bf9\u5e94\u7684\u7ea2\u9ed1\u6811\u8282\u70b9\u3002\u518d\u53d6\u51fa\u7ea2\u9ed1\u6811\u8282\u70b9\u4e2d\u7ef4\u62a4\u7684\u4e00\u4e2ahandle\u961f\u5217\uff0c\u6700\u540e\u6267\u884chandle\u961f\u5217\u4e2d\u6bcf\u4e2a\u8282\u70b9\u7684\u56de\u8c03\u3002 12.4 Promise\u5316API \u00b6 Node.js\u7684API\u90fd\u662f\u9075\u5faacallback\u6a21\u5f0f\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u8fd9\u6837\u5199 1. const fs = require('fs'); 2. fs.readFile('filename', 'utf-8' ,(err,data) => { 3. console.log(data) 4. }) \u4e3a\u4e86\u652f\u6301Promise\u6a21\u5f0f\uff0c\u6211\u4eec\u901a\u5e38\u8fd9\u6837\u5199 1. const fs = require('fs'); 2. function readFile(filename) { 3. return new Promise((resolve, reject) => { 4. fs.readFile(filename, 'utf-8' ,(err,data) => { 5. err ? reject(err) : resolve(data); 6. }); 7. }); 8. } \u4f46\u662f\u5728Node.js V14\u4e2d\uff0c\u6587\u4ef6\u6a21\u5757\u652f\u6301\u4e86Promise\u5316\u7684api\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528await\u8fdb\u884c\u6587\u4ef6\u64cd\u4f5c\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f7f\u7528\u4f8b\u5b50\u3002 1. const { open, readFile } = require('fs').promises; 2. async function runDemo() { 3. try { 4. console.log(await readFile('11111.md', { encoding: 'utf-8' })); 5. } catch (e){ 6. 7. } 8. } 9. runDemo(); \u4ece\u4f8b\u5b50\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u548c\u4e4b\u524d\u7684API\u8c03\u7528\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u6211\u4eec\u4e0d\u7528\u518d\u5199\u56de\u8c03\u4e86\uff0c\u800c\u662f\u901a\u8fc7await\u7684\u65b9\u5f0f\u63a5\u6536\u7ed3\u679c\u3002\u8fd9\u53ea\u662f\u65b0\u7248API\u7684\u7279\u6027\u4e4b\u4e00\u3002\u5728\u65b0\u7248API\u4e4b\u524d\uff0c\u6587\u4ef6\u6a21\u5757\u5927\u90e8\u5206API\u90fd\u662f\u7c7b\u4f3c\u5de5\u5177\u51fd\u6570\uff0c\u6bd4\u5982readFile\uff0cwriteFile\uff0c\u65b0\u7248API\u4e2d\u652f\u6301\u9762\u5411\u5bf9\u8c61\u7684\u8c03\u7528\u65b9\u5f0f\u3002 1. const { open, readFile } = require('fs').promises; 2. async function runDemo() { 3. let filehandle; 4. try { 5. filehandle = await open('filename', 'r'); 6. // console.log(await readFile(filehandle, { encoding: 'utf-8' })); 7. console.log(await filehandle.readFile({ encoding: 'utf-8' })); 8. } finally { 9. if (filehandle) { 10. await filehandle.close(); 11. } 12. } 13. } 14. runDemo(); \u9762\u5411\u5bf9\u8c61\u7684\u6a21\u5f0f\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u901a\u8fc7open\u51fd\u6570\u62ff\u5230\u4e00\u4e2aFileHandle\u5bf9\u8c61\uff08\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff09\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u5728\u8be5\u5bf9\u8c61\u4e0a\u8c03\u5404\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u51fd\u6570\u3002\u5728\u4f7f\u7528\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u7684API\u65f6\u6709\u4e00\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9\u662fNode.js\u4e0d\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5373\u4f7f\u6587\u4ef6\u64cd\u4f5c\u51fa\u9519\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u624b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u800c\u5728\u975e\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u4e2d\uff0c\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\uff0cNode.js\u90fd\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u9996\u5148\u4ecb\u7ecd\u4e00\u4e2aFileHandle\u7c7b\u3002\u8be5\u7c7b\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff0c\u63d0\u4f9b\u4e86\u9762\u5411\u5bf9\u8c61\u7684API\u3002 1. class FileHandle { 2. constructor(filehandle) { 3. // filehandle\u4e3aC++\u5bf9\u8c61 4. this[kHandle] = filehandle; 5. this[kFd] = filehandle.fd; 6. } 7. 8. get fd() { 9. return this[kFd]; 10. } 11. 12. readFile(options) { 13. return readFile(this, options); 14. } 15. 16. close = () => { 17. this[kFd] = -1; 18. return this[kHandle].close(); 19. } 20. // \u7701\u7565\u90e8\u5206\u64cd\u4f5c\u6587\u4ef6\u7684api 21. } FileHandle\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u5c01\u88c5\u4e86\u4e00\u7cfb\u5217\u6587\u4ef6\u64cd\u4f5c\u7684API\uff0c\u7136\u540e\u5b9e\u73b0\u4e86close\u51fd\u6570\u7528\u4e8e\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 \u64cd\u4f5c\u6587\u4ef6\u7cfb\u7edfAPI \u8fd9\u91cc\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8fdb\u884c\u5206\u6790 1. async function readFile(path, options) { 2. options = getOptions(options, { flag: 'r' }); 3. const flag = options.flag || 'r'; 4. // \u4ee5\u9762\u5411\u5bf9\u8c61\u7684\u65b9\u5f0f\u4f7f\u7528\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u81ea\u5df1\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 5. if (path instanceof FileHandle) 6. return readFileHandle(path, options); 7. // \u76f4\u63a5\u8c03\u7528\uff0c\u9996\u5148\u9700\u8981\u5148\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8bfb\u53d6\u5b8c\u6bd5\u540eNode.js\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 8. const fd = await open(path, flag, 0o666); 9. return readFileHandle(fd, options).finally(fd.close); 10. } \u4ecereadFile\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u4e0d\u540c\u8c03\u7528\u65b9\u5f0f\u4e0b\uff0cNode.js\u7684\u5904\u7406\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u5f53FileHandle\u662f\u6211\u4eec\u7ef4\u62a4\u65f6\uff0c\u5173\u95ed\u64cd\u4f5c\u4e5f\u662f\u6211\u4eec\u8d1f\u8d23\u6267\u884c\uff0c\u5f53FileHandle\u662fNode.js\u7ef4\u62a4\u65f6\uff0cNode.js\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\u90fd\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u63a5\u7740\u6211\u4eec\u770b\u5230readFileHandle\u7684\u5b9e\u73b0\u3002 1. async function readFileHandle(filehandle, options) { 2. // \u83b7\u53d6\u6587\u4ef6\u5143\u4fe1\u606f 3. const statFields = await binding.fstat(filehandle.fd, false, kUsePromises); 4. 5. let size; 6. // \u662f\u4e0d\u662f\u666e\u901a\u6587\u4ef6\uff0c\u6839\u636e\u6587\u4ef6\u7c7b\u578b\u83b7\u53d6\u5bf9\u5e94\u5927\u5c0f 7. if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) { 8. size = statFields[8/* size */]; 9. } else { 10. size = 0; 11. } 12. // \u592a\u5927\u4e86 13. if (size > kIoMaxLength) 14. throw new ERR_FS_FILE_TOO_LARGE(size); 15. 16. const chunks = []; 17. // \u8ba1\u7b97\u6bcf\u6b21\u8bfb\u53d6\u7684\u5927\u5c0f 18. const chunkSize = size === 0 ? 19. kReadFileMaxChunkSize : 20. MathMin(size, kReadFileMaxChunkSize); 21. let endOfFile = false; 22. do { 23. // \u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e 24. const buf = Buffer.alloc(chunkSize); 25. // \u8bfb\u53d6\u7684\u6570\u636e\u548c\u5927\u5c0f 26. const { bytesRead, buffer } = 27. await read(filehandle, buf, 0, chunkSize, -1); 28. // \u662f\u5426\u8bfb\u5b8c\u4e86 29. endOfFile = bytesRead === 0; 30. // \u8bfb\u53d6\u4e86\u6709\u6548\u6570\u636e\u5219\u628a\u6709\u6548\u6570\u636e\u90e8\u5206\u5b58\u8d77\u6765 31. if (bytesRead > 0) 32. chunks.push(buffer.slice(0, bytesRead)); 33. } while (!endOfFile); 34. 35. const result = Buffer.concat(chunks); 36. if (options.encoding) { 37. return result.toString(options.encoding); 38. } else { 39. return result; 40. } 41. } \u63a5\u7740\u6211\u4eec\u770bread\u51fd\u6570\u7684\u5b9e\u73b0 1. async function read(handle, buffer, offset, length, position) { 2. // ... 3. const bytesRead = (await binding.read(handle.fd, buffer, offset, length, position, kUsePromises)) || 0; 4. return { bytesRead, buffer }; 5. } Read\u6700\u7ec8\u6267\u884c\u4e86node_file.cc \u7684Read\u3002\u6211\u4eec\u770b\u4e00\u4e0bRead\u51fd\u6570\u7684\u5173\u952e\u4ee3\u7801\u3002 1. static void Read(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. // ... 4. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); 5. // \u5f02\u6b65\u6267\u884c\uff0c\u6709\u4e24\u79cd\u60c5\u51b5 6. if (req_wrap_async != nullptr) { 7. AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger, 8. uv_fs_read, fd, &uvbuf, 1, pos); 9. } else { 10. // \u540c\u6b65\u6267\u884c\uff0c\u6bd4\u5982fs.readFileSync 11. CHECK_EQ(argc, 7); 12. FSReqWrapSync req_wrap_sync; 13. FS_SYNC_TRACE_BEGIN(read); 14. const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, \"read\", 15. uv_fs_read, fd, &uvbuf, 1, pos); 16. FS_SYNC_TRACE_END(read, \"bytesRead\", bytesRead); 17. args.GetReturnValue().Set(bytesRead); 18. } 19. } Read\u51fd\u6570\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff0c\u540c\u6b65\u548c\u5f02\u6b65\uff0c\u5176\u4e2d\u5f02\u6b65\u53c8\u5206\u4e3a\u4e24\u79cd\uff0ccallback\u6a21\u5f0f\u548cPromise\u6a21\u5f0f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f02\u6b65\u6a21\u5f0f\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u8fd9\u53e5\u4ee3\u7801\u3002 1. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); GetReqWrap\u6839\u636e\u7b2c\u516d\u4e2a\u53c2\u6570\u83b7\u53d6\u5bf9\u5e94\u7684\u503c\u3002 1. FSReqBase* GetReqWrap(Environment* env, v8::Local<v8::Value> value, 2. bool use_bigint) { 3. // \u662f\u5bf9\u8c61\u8bf4\u660e\u662f\u7ee7\u627fFSReqBase\u7684\u5bf9\u8c61,\u6bd4\u5982FSReqCallback\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 4. if (value->IsObject()) { 5. return Unwrap<FSReqBase>(value.As<v8::Object>()); 6. } else if (value->StrictEquals(env->fs_use_promises_symbol())) { 7. // Promise\u6a21\u5f0f\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 8. if (use_bigint) { 9. return FSReqPromise<AliasedBigUint64Array>::New(env, use_bigint); 10. } else { 11. return FSReqPromise<AliasedFloat64Array>::New(env, use_bigint); 12. } 13. } 14. // \u540c\u6b65\u6a21\u5f0f 15. return nullptr; 16. } \u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8Promise\u6a21\u5f0f\u3002\u6240\u4ee5GetReqWrap\u8fd4\u56de\u7684\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\uff0c\u6211\u4eec\u56de\u5230Read\u51fd\u6570\u3002\u770b\u5230\u4ee5\u4e0b\u4ee3\u7801 1. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); 2. AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger, 3. uv_fs_read, fd, &uvbuf, 1, pos); \u7ee7\u7eed\u770bAsyncCall\u51fd\u6570\uff08node_file-inl.h\uff09 1. template <typename Func, typename... Args> 2. FSReqBase* AsyncCall(Environment* env, 3. FSReqBase* req_wrap, 4. const v8::FunctionCallbackInfo<v8::Value>& args, 5. const char* syscall, enum encoding enc, 6. uv_fs_cb after, Func fn, Args... fn_args) { 7. return AsyncDestCall(env, req_wrap, args, 8. syscall, nullptr, 0, enc, 9. after, fn, fn_args...); 10. } AsyncCall\u662f\u5bf9AsyncDestCall\u7684\u5c01\u88c5 1. template <typename Func, typename... Args> 2. FSReqBase* AsyncDestCall(Environment* env, FSReqBase* req_wrap, 3. const v8::FunctionCallbackInfo<v8::Value>& args, 4. const char* syscall, const char* dest, 5. size_t len, enum encoding enc, uv_fs_cb after, 6. Func fn, Args... fn_args) { 7. CHECK_NOT_NULL(req_wrap); 8. req_wrap->Init(syscall, dest, len, enc); 9. // \u8c03\u7528libuv\u51fd\u6570 10. int err = req_wrap->Dispatch(fn, fn_args..., after); 11. // \u5931\u8d25\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c\u5426\u5219\u8fd4\u56de\u4e00\u4e2aPromise\uff0c\u89c1SetReturnValue\u51fd\u6570 12. if (err < 0) { 13. uv_fs_t* uv_req = req_wrap->req(); 14. uv_req->result = err; 15. uv_req->path = nullptr; 16. after(uv_req); // after may delete req_wrap if there is an error 17. req_wrap = nullptr; 18. } else { 19. req_wrap->SetReturnValue(args); 20. } 21. 22. return req_wrap; 23. } AsyncDestCall\u51fd\u6570\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u901a\u8fc7Dispatch\u8c03\u7528\u5e95\u5c42Libuv\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u8fd9\u91cc\u662fuv_fs_read\u3002\u5982\u679c\u51fa\u9519\u6267\u884c\u56de\u8c03\u8fd4\u56de\u9519\u8bef\uff0c\u5426\u5219\u6267\u884creq_wrap->SetReturnValue(args)\u3002\u6211\u4eec\u77e5\u9053req_wrap\u662f\u5728GetReqWrap\u51fd\u6570\u4e2d\u7531FSReqPromise ::New(env, use_bigint)\u521b\u5efa\u3002 1. template <typename AliasedBufferT> 2. FSReqPromise<AliasedBufferT>* 3. FSReqPromise<AliasedBufferT>::New(Environment* env, bool use_bigint) { 4. v8::Local<v8::Object> obj; 5. // \u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u5b58\u5230obj\u4e2d 6. if (!env->fsreqpromise_constructor_template() 7. ->NewInstance(env->context()) 8. .ToLocal(&obj)) { 9. return nullptr; 10. } 11. // \u8bbe\u7f6e\u4e00\u4e2apromise\u5c5e\u6027\uff0c\u503c\u662f\u4e00\u4e2aPromise::Resolver 12. v8::Local<v8::Promise::Resolver> resolver; 13. if (!v8::Promise::Resolver::New(env->context()).ToLocal(&resolver) || 14. obj->Set(env->context(), env->promise_string(), resolver).IsNothing()) { 15. return nullptr; 16. } 17. // \u8fd4\u56de\u53e6\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86obj\uff0cobj\u4e5f\u4fdd\u5b58\u4e86\u6307\u5411FSReqPromise\u5bf9\u8c61\u7684\u6307\u9488 18. return new FSReqPromise(env, obj, use_bigint); 19. } \u6240\u4ee5req_wrap\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bFSReqPromise\u5bf9\u8c61\u7684SetReturnValue\u65b9\u6cd5\u3002 1. template <typename AliasedBufferT> 2. void FSReqPromise<AliasedBufferT>::SetReturnValue( 3. const v8::FunctionCallbackInfo<v8::Value>& args) { 4. // \u62ff\u5230Promise::Resolver\u5bf9\u8c61 5. v8::Local<v8::Value> val = 6. object()->Get(env()->context(), 7. env()->promise_string()).ToLocalChecked(); 8. v8::Local<v8::Promise::Resolver> resolver = val.As<v8::Promise::Resolver>(); 9. // \u62ff\u5230\u4e00\u4e2aPromise\u4f5c\u4e3a\u8fd4\u56de\u503c\uff0c\u5373JS\u5c42\u62ff\u5230\u7684\u503c 10. args.GetReturnValue().Set(resolver->GetPromise()); 11. } \u81f3\u6b64\u6211\u4eec\u770b\u5230\u4e86\u65b0\u7248API\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u6b63\u662f\u8fd9\u4e2aPromise\u8fd4\u56de\u503c\u3002\u901a\u8fc7\u5c42\u5c42\u8fd4\u56de\u540e\uff0c\u5728JS\u5c42\u5c31\u62ff\u5230\u8fd9\u4e2aPromise\uff0c\u7136\u540e\u5904\u4e8epending\u72b6\u6001\u7b49\u5f85\u51b3\u8bae\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0bPromise\u51b3\u8bae\u7684\u903b\u8f91\u3002\u5728\u5206\u6790Read\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\u6267\u884cLibuv\u7684uv_fs_read\u51fd\u6570\u65f6\uff0c\u8bbe\u7f6e\u7684\u56de\u8c03\u662fAfterInteger\u3002\u90a3\u4e48\u5f53\u8bfb\u53d6\u6587\u4ef6\u6210\u529f\u540e\u5c31\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1. void AfterInteger(uv_fs_t* req) { 2. // \u901a\u8fc7\u5c5e\u6027\u62ff\u5230\u5bf9\u8c61\u7684\u5730\u5740 3. FSReqBase* req_wrap = FSReqBase::from_req(req); 4. FSReqAfterScope after(req_wrap, req); 5. 6. if (after.Proceed()) 7. req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), req->result)); 8. } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bResolve 1. template <typename AliasedBufferT> 2. void FSReqPromise<AliasedBufferT>::Resolve(v8::Local<v8::Value> value) { 3. finished_ = true; 4. v8::HandleScope scope(env()->isolate()); 5. InternalCallbackScope callback_scope(this); 6. // \u62ff\u5230\u4fdd\u5b58\u7684Promise\u5bf9\u8c61\uff0c\u4fee\u6539\u72b6\u6001\u4e3aresolve\uff0c\u5e76\u8bbe\u7f6e\u7ed3\u679c 7. v8::Local<v8::Value> val = 8. object()->Get(env()->context(), 9. env()->promise_string()).ToLocalChecked(); 10. v8::Local<v8::Promise::Resolver> resolver = val.As<v8::Promise::Resolver>(); 11. USE(resolver->Resolve(env()->context(), value).FromJust()); 12. } Resolve\u51fd\u6570\u4fee\u6539Promise\u7684\u72b6\u6001\u548c\u8bbe\u7f6e\u8fd4\u56de\u503c\uff0c\u4ece\u800cJS\u5c42\u62ff\u5230\u8fd9\u4e2a\u51b3\u8bae\u7684\u503c\u3002\u56de\u5230fs\u5c42 1. const bytesRead = (await binding.read(handle.fd, 2. buffer, 3. offset, 4. length, 5. position, kUsePromises))|0; \u6211\u4eec\u5c31\u62ff\u5230\u4e86\u8fd4\u56de\u503c\u3002 12.5 \u6d41\u5f0fAPI \u00b6 \u524d\u9762\u5206\u6790\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u591a\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u65b9\u5f0f\uff0c\u4e0d\u7ba1\u662f\u540c\u6b65\u3001\u5f02\u6b65\u8fd8\u662fPromise\u5316\u7684API\uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u5bf9\u4e8e\u7528\u6237\u6765\u8bf4\uff0c\u6587\u4ef6\u64cd\u4f5c\u90fd\u662f\u4e00\u6b21\u6027\u5b8c\u6210\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8c03\u7528readFile\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u628a\u6240\u6709\u7684\u6587\u4ef6\u5185\u5bb9\u8bfb\u5230\u5185\u5b58\u4e2d\uff0c\u540c\u6837\u6211\u4eec\u8c03\u7528writeFile\u5199\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u628a\u7528\u6237\u7684\u6570\u636e\u5199\u5165\u786c\u76d8\uff0c\u8fd9\u5bf9\u5185\u5b58\u6765\u8bf4\u662f\u975e\u5e38\u6709\u538b\u529b\u7684\u3002\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u6837\u7684\u4e00\u4e2a\u573a\u666f\uff0c\u6211\u4eec\u9700\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u524d\u7aef\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u8bfb\u53d6\u6574\u4e2a\u6587\u4ef6\u5185\u5bb9\uff0c\u7136\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c\u8fd9\u65e0\u7591\u662f\u975e\u5e38\u6d88\u8017\u5185\u5b58\uff0c\u4e5f\u662f\u975e\u5e38\u4f4e\u6548\u7684\u3002 1. const http = require('http'); 2. const fs = require('fs'); 3. const server = http.createServer((req, res) => { 4. fs.readFile('11111.md', (err, data) => { 5. res.end(data); 6. }) 7. }).listen(11111); \u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u4f7f\u7528\u6d41\u5f0f\u7684API\u3002 1. const http = require('http'); 2. const fs = require('fs'); 3. const server = http.createServer((req, res) => { 4. fs.createReadStream('11111.md').pipe(res); 5. }).listen(11111); \u6d41\u5f0fAPI\u7684\u597d\u5904\u5728\u4e8e\u6587\u4ef6\u7684\u5185\u5bb9\u5e76\u4e0d\u662f\u4e00\u6b21\u6027\u8bfb\u53d6\u5230\u5185\u5b58\u7684\uff0c\u800c\u662f\u90e8\u5206\u8bfb\u53d6\uff0c\u6d88\u8d39\u5b8c\u540e\u518d\u7ee7\u7eed\u8bfb\u53d6\u3002Node.js\u5185\u90e8\u5e2e\u6211\u4eec\u505a\u4e86\u6d41\u91cf\u7684\u63a7\u5236\uff0c\u5982\u56fe12-5\u6240\u793a\u3002 \u56fe12-5 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6d41\u5f0fAPI\u7684\u5177\u4f53\u5b9e\u73b0\u3002 12.5.1 \u53ef\u8bfb\u6587\u4ef6\u6d41 \u00b6 \u53ef\u8bfb\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u8bfb\u53d6\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createReadStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u8bfb\u6d41\u3002\u6587\u4ef6\u53ef\u8bfb\u6d41\u7ee7\u627f\u4e8e\u53ef\u8bfb\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u8bfb\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1. const fs = require('fs'); 2. const { Writable } = require('stream'); 3. class DemoWritable extends Writable { 4. _write(data, encoding, cb) { 5. console.log(data); 6. cb(null); 7. } 8. } 9. fs.createReadStream('11111.md').pipe(new DemoWritable); \u6216\u8005 1. const fs = require('fs'); 2. const readStream = fs.createReadStream('11111.md'); 3. readStream.on('data', (data) => { 4. console.log(data) 5. }); \u6211\u4eec\u770b\u4e00\u4e0bcreateReadStream\u7684\u5b9e\u73b0\u3002 1. fs.createReadStream = function(path, options) { 2. return new ReadStream(path, options); 3. }; CreateReadStream\u662f\u5bf9ReadStream\u7684\u5c01\u88c5\u3002 1. function ReadStream(path, options) { 2. if (!(this instanceof ReadStream)) 3. return new ReadStream(path, options); 4. 5. options = copyObject(getOptions(options, {})); 6. // \u53ef\u8bfb\u6d41\u7684\u9608\u503c 7. if (options.highWaterMark === undefined) 8. options.highWaterMark = 64 * 1024; 9. 10. Readable.call(this, options); 11. 12. handleError((this.path = getPathFromURL(path))); 13. // \u652f\u6301\u4f20\u6587\u4ef6\u8def\u5f84\u6216\u6587\u4ef6\u63cf\u8ff0\u7b26 14. this.fd = options.fd === undefined ? null : options.fd; 15. this.flags = options.flags === undefined ? 'r' : options.flags; 16. this.mode = options.mode === undefined ? 0o666 : options.mode; 17. // \u8bfb\u53d6\u7684\u5f00\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e 18. this.start = typeof this.fd !== 'number' && options.start === undefined ? 19. 0 : options.start; 20. this.end = options.end; 21. // \u6d41\u51fa\u9519\u6216\u7ed3\u675f\u65f6\u662f\u5426\u81ea\u52a8\u9500\u6bc1\u6d41 22. this.autoClose = options.autoClose === undefined ? true : options.autoClose; 23. this.pos = undefined; 24. // \u5df2\u8bfb\u7684\u5b57\u8282\u6570 25. this.bytesRead = 0; 26. // \u6d41\u662f\u5426\u5df2\u7ecf\u5173\u95ed 27. this.closed = false; 28. // \u53c2\u6570\u6821\u9a8c 29. if (this.start !== undefined) { 30. if (typeof this.start !== 'number') { 31. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 32. 'start', 33. 'number', 34. this.start); 35. } 36. // \u9ed8\u8ba4\u8bfb\u53d6\u5168\u90e8\u5185\u5bb9 37. if (this.end === undefined) { 38. this.end = Infinity; 39. } else if (typeof this.end !== 'number') { 40. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 41. 'end', 42. 'number', 43. this.end); 44. } 45. 46. // \u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\uff0cstart\u662f\u5f00\u59cb\u4f4d\u7f6e\uff0cpos\u662f\u5f53\u524d\u4f4d\u7f6e\uff0c\u521d\u59cb\u5316\u7b49\u4e8e\u5f00\u59cb\u4f4d\u7f6e 47. this.pos = this.start; 48. } 49. // \u5982\u679c\u662f\u6839\u636e\u4e00\u4e2a\u6587\u4ef6\u540d\u521b\u5efa\u4e00\u4e2a\u6d41\uff0c\u5219\u9996\u5148\u6253\u5f00\u8fd9\u4e2a\u6587\u4ef6 50. if (typeof this.fd !== 'number') 51. this.open(); 52. 53. this.on('end', function() { 54. // \u6d41\u7ed3\u675f\u65f6\u81ea\u52a8\u9500\u6bc1\u6d41 55. if (this.autoClose) { 56. this.destroy(); 57. } 58. }); 59. } ReadStream\u521d\u59cb\u5316\u5b8c\u540e\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u8c03\u7528open\u6253\u5f00\u6587\u4ef6\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u63a5\u7740\u76d1\u542c\u6d41\u7ed3\u675f\u4e8b\u4ef6\uff0c\u7528\u6237\u53ef\u4ee5\u8bbe\u7f6eautoClose\u9009\u9879\u63a7\u5236\u5f53\u6d41\u7ed3\u675f\u6216\u8005\u51fa\u9519\u65f6\u662f\u5426\u9500\u6bc1\u6d41\uff0c\u5bf9\u4e8e\u6587\u4ef6\u6d41\u6765\u8bf4\uff0c\u9500\u6bc1\u6d41\u610f\u5473\u7740\u5173\u95ed\u5730\u65b9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bopen\u7684\u5b9e\u73b0 1. // \u6253\u5f00\u6587\u4ef6 2. ReadStream.prototype.open = function() { 3. var self = this; 4. fs.open(this.path, this.flags, this.mode, function(er, fd) { 5. if (er) { 6. // \u53d1\u751f\u9519\u8bef\uff0c\u662f\u5426\u9700\u8981\u81ea\u52a8\u9500\u6bc1\u6d41 7. if (self.autoClose) { 8. self.destroy(); 9. } 10. // \u901a\u77e5\u7528\u6237 11. self.emit('error', er); 12. return; 13. } 14. 15. self.fd = fd; 16. // \u89e6\u53d1open\uff0c\u4e00\u822c\u7528\u4e8eNode.js\u5185\u90e8\u903b\u8f91 17. self.emit('open', fd); 18. // start the flow of data. 19. // \u6253\u5f00\u6210\u529f\u540e\u5f00\u59cb\u6d41\u5f0f\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9 20. self.read(); 21. }); 22. }; open\u51fd\u6570\u9996\u5148\u6253\u5f00\u6587\u4ef6\uff0c\u6253\u5f00\u6210\u529f\u540e\u5f00\u542f\u6d41\u5f0f\u8bfb\u53d6\u3002\u4ece\u800c\u6587\u4ef6\u5185\u5bb9\u5c31\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u76ee\u7684\u6d41\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8bfb\u53d6\u64cd\u4f5c\u7684\u5b9e\u73b0\u3002 1. // \u5b9e\u73b0\u53ef\u8bfb\u6d41\u7684\u94a9\u5b50\u51fd\u6570 2. ReadStream.prototype._read = function(n) { 3. // \u5982\u679c\u6ca1\u6709\u8c03\u7528open\u800c\u662f\u76f4\u63a5\u8c03\u7528\u8be5\u65b9\u6cd5\u5219\u5148\u6267\u884copen 4. if (typeof this.fd !== 'number') { 5. return this.once('open', function() { 6. this._read(n); 7. }); 8. } 9. // \u6d41\u5df2\u7ecf\u9500\u6bc1\u5219\u4e0d\u5904\u7406 10. if (this.destroyed) 11. return; 12. // \u5224\u65ad\u6c60\u5b50\u7a7a\u95f4\u662f\u5426\u8db3\u591f\uff0c\u4e0d\u591f\u5219\u7533\u8bf7\u65b0\u7684 13. if (!pool || pool.length - pool.used < kMinPoolSpace) { 14. // discard the old pool. 15. allocNewPool(this.readableHighWaterMark); 16. } 17. 18. // \u8ba1\u7b97\u53ef\u8bfb\u7684\u6700\u5927\u6570\u91cf 19. var thisPool = pool; 20. /* 21. \u53ef\u8bfb\u53d6\u7684\u6700\u5927\u503c,\u53d6\u53ef\u7528\u5185\u5b58\u5927\u5c0f\u548cNode.js\u6253\u7b97\u8bfb\u53d6\u7684\u5927\u5c0f 22. \u4e2d\u7684\u5c0f\u503c,n\u4e0d\u662f\u7528\u6237\u60f3\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u800c\u662f\u53ef\u8bfb\u6d41\u5185\u90e8\u7684\u903b\u8f91 23. \u89c1_stream_readable.js\u7684this._read(state.highWaterMark) 24. */ 25. var toRead = Math.min(pool.length - pool.used, n); 26. var start = pool.used; 27. // \u5df2\u7ecf\u8bfb\u53d6\u4e86\u90e8\u5206\u4e86\uff0c\u5219\u8ba1\u7b97\u5269\u4e0b\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u548c\u8ba1\u7b97\u8bfb\u53d6\u7684toRead\u6bd4\u8f83\u53d6\u5c0f\u503c 28. if (this.pos !== undefined) 29. toRead = Math.min(this.end - this.pos + 1, toRead); 30. 31. // \u8bfb\u7ed3\u675f 32. if (toRead <= 0) 33. return this.push(null); 34. 35. // pool.used\u662f\u5373\u5c06\u8bfb\u53d6\u7684\u6570\u636e\u5b58\u50a8\u5728pool\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\uff0cthis.pos\u662f\u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\u53d6 36. fs.read(this.fd, pool, pool.used, toRead, this.pos, (er, bytesRead) => { 37. if (er) { 38. if (this.autoClose) { 39. this.destroy(); 40. } 41. this.emit('error', er); 42. } else { 43. var b = null; 44. if (bytesRead > 0) { 45. // \u5df2\u8bfb\u7684\u5b57\u8282\u6570\u7d2f\u52a0 46. this.bytesRead += bytesRead; 47. // \u83b7\u53d6\u6709\u6548\u6570\u636e 48. b = thisPool.slice(start, start + bytesRead); 49. } 50. // push\u5230\u5e95\u5c42\u6d41\u7684bufferList\u4e2d\uff0c\u5e95\u5c42\u7684push\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 51. this.push(b); 52. } 53. }); 54. 55. // \u91cd\u65b0\u8bbe\u7f6e\u5df2\u8bfb\u6307\u9488\u7684\u4f4d\u7f6e 56. if (this.pos !== undefined) 57. this.pos += toRead; 58. pool.used += toRead; 59. }; \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662f\u8c03\u7528\u5f02\u6b65read\u51fd\u6570\u8bfb\u53d6\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u653e\u5230\u53ef\u8bfb\u6d41\u4e2d\uff0c\u53ef\u8bfb\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u6570\u636e\u5230\u6765\uff0c\u7136\u540e\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8\u7740\u6570\u636e\u7684\u8bfb\u53d6\uff08\u53ef\u8bfb\u6d41\u4f1a\u6839\u636e\u5f53\u524d\u60c5\u51b5\u5224\u65ad\u662f\u5426\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ee5\u8fbe\u5230\u6d41\u91cf\u63a7\u5236\u7684\u76ee\u7684\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u548c\u9500\u6bc1\u4e00\u4e2a\u6587\u4ef6\u6d41\u7684\u5b9e\u73b0\u3002 1. ReadStream.prototype.close = function(cb) { 2. this.destroy(null, cb); 3. }; \u5f53\u6211\u4eec\u8bbe\u7f6eautoClose\u4e3afalse\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u9700\u8981\u81ea\u5df1\u624b\u52a8\u8c03\u7528close\u51fd\u6570\u5173\u95ed\u53ef\u8bfb\u6587\u4ef6\u6d41\u3002\u5173\u95ed\u6587\u4ef6\u6d41\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6b63\u5e38\u5730\u9500\u6bc1\u6d41\u3002\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0cNode.js\u505a\u4e86\u4ec0\u4e48\u3002 1. // \u5173\u95ed\u5e95\u5c42\u6587\u4ef6 2. ReadStream.prototype._destroy = function(err, cb) { 3. const isOpen = typeof this.fd !== 'number'; 4. if (isOpen) { 5. this.once('open', closeFsStream.bind(null, this, cb, err)); 6. return; 7. } 8. 9. closeFsStream(this, cb); 10. this.fd = null; 11. }; 12. 13. function closeFsStream(stream, cb, err) { 14. fs.close(stream.fd, (er) => { 15. er = er || err; 16. cb(er); 17. stream.closed = true; 18. if (!er) 19. stream.emit('close'); 20. }); 21. } \u9500\u6bc1\u6587\u4ef6\u6d41\u5c31\u662f\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u53e6\u5916\u5982\u679c\u662f\u56e0\u4e3a\u53d1\u751f\u9519\u8bef\u5bfc\u81f4\u9500\u6bc1\u6216\u8005\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u9519\u8bef\u5219\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002 12.5.2 \u53ef\u5199\u6587\u4ef6\u6d41 \u00b6 \u53ef\u5199\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u5199\u5165\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createWriteStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u5199\u6d41\u3002\u6587\u4ef6\u53ef\u4e9b\u6d41\u7ee7\u627f\u4e8e\u53ef\u5199\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u5199\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1. const fs = require('fs'); 2. const writeStream = fs.createWriteStream('123.md'); 3. writeStream.end('world'); \u6216\u8005 1. const fs = require('fs'); 2. const { Readable } = require('stream'); 3. 4. class DemoReadStream extends Readable { 5. constructor() { 6. super(); 7. this.i = 0; 8. } 9. _read(n) { 10. this.i++; 11. if (this.i > 10) { 12. this.push(null); 13. } else { 14. this.push('1'.repeat(n)); 15. } 16. 17. } 18. } 19. new DemoReadStream().pipe(fs.createWriteStream('123.md')); \u6211\u4eec\u770b\u4e00\u4e0bcreateWriteStream\u7684\u5b9e\u73b0\u3002 1. fs.createWriteStream = function(path, options) { 2. return new WriteStream(path, options); 3. }; createWriteStream\u662f\u5bf9WriteStream\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bWriteStream\u7684\u5b9e\u73b0 1. function WriteStream(path, options) { 2. if (!(this instanceof WriteStream)) 3. return new WriteStream(path, options); 4. options = copyObject(getOptions(options, {})); 5. 6. Writable.call(this, options); 7. 8. handleError((this.path = getPathFromURL(path))); 9. this.fd = options.fd === undefined ? null : options.fd; 10. this.flags = options.flags === undefined ? 'w' : options.flags; 11. this.mode = options.mode === undefined ? 0o666 : options.mode; 12. // \u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e 13. this.start = options.start; 14. // \u6d41\u7ed3\u675f\u548c\u89e6\u53d1\u9519\u8bef\u7684\u65f6\u5019\u662f\u5426\u9500\u6bc1\u6d41 15. this.autoClose = options.autoClose === undefined ? true : !!options.autoClose; 16. // \u5f53\u524d\u5199\u5165\u4f4d\u7f6e 17. this.pos = undefined; 18. // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570 19. this.bytesWritten = 0; 20. this.closed = false; 21. 22. if (this.start !== undefined) { 23. if (typeof this.start !== 'number') { 24. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 25. 'start', 26. 'number', 27. this.start); 28. } 29. if (this.start < 0) { 30. const errVal = `{start: ${this.start}}`; 31. throw new errors.RangeError('ERR_OUT_OF_RANGE', 32. 'start', 33. '>= 0', 34. errVal); 35. } 36. // \u8bb0\u5f55\u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e 37. this.pos = this.start; 38. } 39. 40. if (options.encoding) 41. this.setDefaultEncoding(options.encoding); 42. // \u6ca1\u6709\u4f20\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u6253\u5f00\u4e00\u4e2a\u65b0\u7684\u6587\u4ef6 43. if (typeof this.fd !== 'number') 44. this.open(); 45. 46. // \u76d1\u542c\u53ef\u5199\u6d41\u7684finish\u4e8b\u4ef6\uff0c\u5224\u65ad\u662f\u5426\u9700\u8981\u6267\u884c\u9500\u6bc1\u64cd\u4f5c 47. this.once('finish', function() { 48. if (this.autoClose) { 49. this.destroy(); 50. } 51. }); 52. } WriteStream\u521d\u59cb\u5316\u4e86\u4e00\u7cfb\u5217\u5b57\u6bb5\u540e\uff0c\u5982\u679c\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u5219\u6253\u5f00\u6587\u4ef6\uff0c\u5982\u679c\u4f20\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6253\u5f00\u6587\u4ef6\u3002\u540e\u7eed\u5bf9\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u64cd\u4f5c\u5c31\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5199\u5165\u6587\u4ef6\u7684\u903b\u8f91\u3002\u6211\u4eec\u77e5\u9053\u53ef\u5199\u6d41\u53ea\u662f\u5b9e\u73b0\u4e86\u4e00\u4e9b\u62bd\u8c61\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u5199\u903b\u8f91\u662f\u5177\u4f53\u7684\u6d41\u901a\u8fc7_write\u6216\u8005_writev\u5b9e\u73b0\u7684\uff0c\u6211\u4eec\u770b\u4e00\u4e0b_write\u7684\u5b9e\u73b0\u3002 1. WriteStream.prototype._write = function(data, encoding, cb) { 2. if (!(data instanceof Buffer)) { 3. const err = new errors.TypeError('ERR_INVALID_ARG_TYPE', 4. 'data', 5. 'Buffer', 6. data); 7. return this.emit('error', err); 8. } 9. // \u8fd8\u6ca1\u6253\u5f00\u6587\u4ef6\uff0c\u5219\u7b49\u5f85\u6253\u5f00\u6210\u529f\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c 10. if (typeof this.fd !== 'number') { 11. return this.once('open', function() { 12. this._write(data, encoding, cb); 13. }); 14. } 15. // \u6267\u884c\u5199\u64cd\u4f5c,0\u4ee3\u8868\u4ecedata\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5199\uff0c\u8fd9\u91cc\u662f\u5168\u90e8\u5199\u5165\uff0c\u6240\u4ee5\u662f0\uff0cpos\u4ee3\u8868\u6587\u4ef6\u7684\u4f4d\u7f6e 16. fs.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => { 17. if (er) { 18. if (this.autoClose) { 19. this.destroy(); 20. } 21. return cb(er); 22. } 23. // \u5199\u5165\u6210\u529f\u7684\u5b57\u8282\u957f\u5ea6 24. this.bytesWritten += bytes; 25. cb(); 26. }); 27. // \u4e0b\u4e00\u4e2a\u5199\u5165\u7684\u4f4d\u7f6e 28. if (this.pos !== undefined) 29. this.pos += data.length; 30. }; _write\u5c31\u662f\u6839\u636e\u7528\u6237\u4f20\u5165\u6570\u636e\u7684\u5927\u5c0f\uff0c\u4e0d\u65ad\u8c03\u7528fs.write\u5f80\u5e95\u5c42\u5199\u5165\u6570\u636e\uff0c\u76f4\u5230\u5199\u5b8c\u6210\u6216\u8005\u51fa\u9519\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u7684\u903b\u8f91\u3002 1. // \u5b9e\u73b0\u53ef\u5199\u6d41\u6279\u91cf\u5199\u94a9\u5b50 2. WriteStream.prototype._writev = function(data, cb) { 3. if (typeof this.fd !== 'number') { 4. return this.once('open', function() { 5. this._writev(data, cb); 6. }); 7. } 8. 9. const self = this; 10. const len = data.length; 11. const chunks = new Array(len); 12. var size = 0; 13. // \u8ba1\u7b97\u5f85\u5199\u5165\u7684\u51fa\u603b\u5927\u5c0f\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4fdd\u5b58\u5230chunk\u6570\u7ec4\u4e2d\uff0c\u51c6\u5907\u5199\u5165 14. for (var i = 0; i < len; i++) { 15. var chunk = data[i].chunk; 16. 17. chunks[i] = chunk; 18. size += chunk.length; 19. } 20. // \u6267\u884c\u6279\u91cf\u5199 21. writev(this.fd, chunks, this.pos, function(er, bytes) { 22. if (er) { 23. self.destroy(); 24. return cb(er); 25. } 26. // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u53ef\u80fd\u5c0f\u4e8e\u5e0c\u671b\u5199\u5165\u7684\u5b57\u8282\u6570 27. self.bytesWritten += bytes; 28. cb(); 29. }); 30. /* 31. \u66f4\u65b0\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\uff0c\u5982\u679c\u5199\u90e8\u5206\u6210\u529f\uff0c\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\u65f6 32. \u4e5f\u4f1a\u5305\u62ec\u6ca1\u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u6240\u4ee5\u662f\u5047\u8bbesize\u800c\u4e0d\u662fbytes 33. */ 34. if (this.pos !== undefined) 35. this.pos += size; 36. }; \u6279\u91cf\u5199\u5165\u7684\u903b\u8f91\u548c_write\u7c7b\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u5b83\u8c03\u7528\u7684\u662f\u4e0d\u540c\u7684\u63a5\u53e3\u5f80\u5e95\u5c42\u5199\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u5173\u95ed\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1. WriteStream.prototype.close = function(cb) { 2. // \u5173\u95ed\u6587\u4ef6\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 3. if (cb) { 4. if (this.closed) { 5. process.nextTick(cb); 6. return; 7. } else { 8. this.on('close', cb); 9. } 10. } 11. 12. /* 13. \u5982\u679cautoClose\u662ffalse\uff0c\u8bf4\u660e\u6d41\u7ed3\u675f\u89e6\u53d1finish\u4e8b\u4ef6\u65f6\uff0c\u4e0d\u4f1a\u9500\u6bc1\u6d41\uff0c 14. \u89c1WriteStream\u521d\u59cb\u5316\u4ee3\u7801 \u4ee5\u8fd9\u91cc\u9700\u8981\u76d1\u542cfinish\u4e8b\u4ef6\uff0c\u4fdd\u8bc1\u53ef\u5199\u6d41\u7ed3\u675f\u65f6\u53ef\u4ee5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 15. */ 16. if (!this.autoClose) { 17. this.on('finish', this.destroy.bind(this)); 18. } 19. 20. // \u7ed3\u675f\u6d41\uff0c\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6 21. this.end(); 22. }; \u53ef\u5199\u6587\u4ef6\u6d41\u548c\u53ef\u8bfb\u6587\u4ef6\u6d41\u4e0d\u4e00\u6837\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5728\u8bfb\u5b8c\u6587\u4ef6\u5185\u5bb9\u540eNode.js\u4f1a\u81ea\u52a8\u9500\u6bc1\u6d41\uff08\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\uff0c\u800c\u5199\u5165\u6587\u4ef6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0bNode.js\u662f\u65e0\u6cd5\u77e5\u9053\u4ec0\u4e48\u65f6\u5019\u6d41\u7ed3\u675f\u7684\uff0c\u8fd9\u9700\u8981\u6211\u4eec\u663e\u5f0f\u5730\u901a\u77e5Node.js\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u662f\u4e0d\u9700\u8981\u663e\u5f0f\u901a\u77e5Node.js\u7684 1. fs.createReadStream('11111.md').pipe(fs.createWriteStream('123.md')); \u56e0\u4e3a\u53ef\u8bfb\u6587\u4ef6\u6d41\u5728\u6587\u4ef6\u8bfb\u5b8c\u540e\u4f1a\u8c03\u7528\u53ef\u5199\u6587\u4ef6\u7684end\u65b9\u6cd5\uff0c\u4ece\u800c\u5173\u95ed\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u800c\u5728\u4ee5\u4e0b\u4ee3\u7801\u4e2d\u60c5\u51b5\u5c31\u53d8\u5f97\u590d\u6742\u3002 1. const stream = fs.createWriteStream('123.md'); 2. stream.write('hello'); 3. // stream.close \u6216 stream.end(); \u5728\u9ed8\u8ba4\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528end\u6216\u8005close\u53bb\u901a\u77e5Node.js\u6d41\u7ed3\u675f\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86autoClose\u4e3afalse\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u80fd\u8c03\u7528close\u800c\u4e0d\u80fd\u8c03\u7528end\u3002\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u56e0\u4e3aend\u53ea\u662f\u5173\u95ed\u4e86\u6d41\u3002\u4f46\u662f\u6ca1\u6709\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u800cclose\u4f1a\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801\u3002 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md'); 3. stream.write('hello'); 4. // \u9632\u6b62\u8fdb\u7a0b\u9000\u51fa 5. setInterval(() => {}); \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u5bfc\u81f4\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u6211\u4eec\u5728Linux\u4e0b\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\uff0c\u901a\u8fc7ps aux\u627e\u5230\u8fdb\u7a0bid\uff0c\u7136\u540e\u6267\u884clsof -p pid\u5c31\u53ef\u4ee5\u770b\u5230\u8fdb\u7a0b\u6253\u5f00\u7684\u6240\u6709\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u8f93\u51fa\u598212-6\u6240\u793a\u3002 \u56fe12-6 \u6587\u4ef6\u63cf\u8ff0\u7b2617\u6307\u5411\u4e86123.md\u6587\u4ef6\u3002\u6240\u4ee5\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ca1\u6709\u88ab\u5173\u95ed\uff0c\u5f15\u8d77\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u6211\u4eec\u4fee\u6539\u4e00\u4e0b\u4ee3\u7801\u3002 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md'); 3. stream.end('hello'); 4. setInterval(() => {}); \u4e0b\u9762\u662f\u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\uff0c\u6211\u4eec\u770b\u5230\u6ca1\u6709123.md\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe12-7\u6240\u793a\u3002 \u56fe12-7 \u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md', {autoClose: false}); 3. stream.end('hello'); 4. setInterval(() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-8\u6240\u793a\u3002 \u56fe12-8 \u6211\u4eec\u770b\u5230\u4f7f\u7528end\u4e5f\u65e0\u6cd5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7ee7\u7eed\u4fee\u6539\u3002 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md', {autoClose: false}) 3. stream.close(); 4. setInterval(() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-9\u6240\u793a\u3002 \u56fe12-9 \u6211\u4eec\u770b\u5230\u6210\u529f\u5173\u95ed\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"12-\u6587\u4ef6"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#121-api","text":"\u5728Node.js\u4e2d\uff0c\u540c\u6b65API\u7684\u672c\u8d28\u662f\u76f4\u63a5\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u3002\u4e0b\u9762\u4ee5readFileSync\u4e3a\u4f8b\uff0c\u770b\u4e00\u4e0b\u6574\u4f53\u7684\u6d41\u7a0b\uff0c\u5982\u56fe12-1\u6240\u793a\u3002 \u56fe12-1 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801 1. function readFileSync(path, options) { 2. options = getOptions(options, { flag: 'r' }); 3. // \u4f20\u7684\u662ffd\u8fd8\u662f\u6587\u4ef6\u8def\u5f84 4. const isUserFd = isFd(path); 5. // \u4f20\u7684\u662f\u8def\u5f84\uff0c\u5219\u5148\u540c\u6b65\u6253\u5f00\u6587\u4ef6 6. const fd = isUserFd ? path : fs.openSync(path, options.flag, 0o666); 7. // \u67e5\u770b\u6587\u4ef6\u7684stat\u4fe1\u606f\uff0c\u62ff\u5230\u6587\u4ef6\u7684\u5927\u5c0f 8. const stats = tryStatSync(fd, isUserFd); 9. // \u662f\u5426\u662f\u4e00\u822c\u6587\u4ef6 10. const size = isFileType(stats, S_IFREG) ? stats[8] : 0; 11. let pos = 0; 12. let buffer; 13. let buffers; 14. // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0csize\u5219\u4e3a0 15. if (size === 0) { 16. buffers = []; 17. } else { 18. // \u4e00\u822c\u6587\u4ef6\u4e14\u6709\u5927\u5c0f\uff0c\u5219\u5206\u914d\u4e00\u4e2a\u5927\u5c0f\u4e3asize\u7684buffer\uff0csize\u9700\u8981\u5c0f\u4e8e2G 19. buffer = tryCreateBuffer(size, fd, isUserFd); 20. } 21. 22. let bytesRead; 23. // \u4e0d\u65ad\u5730\u540c\u6b65\u8bfb\u6587\u4ef6\u5185\u5bb9 24. if (size !== 0) { 25. do { 26. bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos); 27. pos += bytesRead; 28. } while (bytesRead !== 0 && pos < size); 29. } else { 30. do { 31. /* 32. \u6587\u4ef6\u5927\u5c0f\u4e3a0\uff0c\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0c\u4e5f\u5c1d\u8bd5\u53bb\u8bfb\uff0c 33. \u4f46\u662f\u56e0\u4e3a\u4e0d\u77e5\u9053\u5927\u5c0f\uff0c\u6240\u4ee5\u53ea\u80fd\u5206\u914d\u4e00\u4e2a\u4e00\u5b9a\u5927\u5c0f\u7684buffer, 34. \u6bcf\u6b21\u8bfb\u53d6\u4e00\u5b9a\u5927\u5c0f\u7684\u5185\u5bb9 35. */ 36. buffer = Buffer.allocUnsafe(8192); 37. bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192); 38. // \u628a\u8bfb\u53d6\u5230\u7684\u5185\u5bb9\u653e\u5230buffers\u91cc 39. if (bytesRead !== 0) { 40. buffers.push(buffer.slice(0, bytesRead)); 41. } 42. // \u8bb0\u5f55\u8bfb\u53d6\u5230\u7684\u6570\u636e\u957f\u5ea6 43. pos += bytesRead; 44. } while (bytesRead !== 0); 45. } 46. // \u7528\u6237\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\uff0cNode.js\u81ea\u5df1\u6253\u5f00\u4e86\u6587\u4ef6\uff0c\u6240\u4ee5\u9700\u8981\u81ea\u5df1\u5173\u95ed 47. if (!isUserFd) 48. fs.closeSync(fd); 49. // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u975e\u4e00\u822c\u6587\u4ef6\u7684\u8bdd\uff0c\u5982\u679c\u8bfb\u5230\u4e86\u5185\u5bb9 50. if (size === 0) { 51. // \u628a\u8bfb\u53d6\u5230\u7684\u6240\u6709\u5185\u5bb9\u653e\u5230buffer\u4e2d 52. buffer = Buffer.concat(buffers, pos); 53. } else if (pos < size) { 54. buffer = buffer.slice(0, pos); 55. } 56. // \u7f16\u7801 57. if (options.encoding) buffer = buffer.toString(options.encoding); 58. return buffer; 59. } tryReadSync\u8c03\u7528\u7684\u662ffs.readSync\uff0c\u7136\u540e\u5230binding.read(node_file.cc\u4e2d\u5b9a\u4e49\u7684Read\u51fd\u6570)\u3002Read\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1. FSReqWrapSync req_wrap_sync; 2. const int bytesRead = SyncCall(env, 3. args[6], 4. &req_wrap_sync, 5. \"read\", 6. uv_fs_read, 7. fd, 8. &uvbuf, 9. 1, 10. pos); \u6211\u4eec\u770b\u4e00\u4e0bSyncCall\u7684\u5b9e\u73b0 1. int SyncCall(Environment* env, 2. v8::Local<v8::Value> ctx, 3. FSReqWrapSync* req_wrap, 4. const char* syscall, 5. Func fn, 6. Args... args) { 7. /* 8. req_wrap->req\u662f\u4e00\u4e2auv_fs_t\u7ed3\u6784\u4f53\uff0c\u5c5e\u4e8erequest\u7c7b\uff0c 9. \u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u7684\u8bf7\u6c42 10. */ 11. int err = fn(env->event_loop(), 12. &(req_wrap->req), 13. args..., 14. nullptr); 15. // \u5ffd\u7565\u51fa\u9519\u5904\u7406 16. return err; 17. } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u8c03\u7528\u7684\u662fLibuv\u7684uv_fs_read\uff0c\u5e76\u4f7f\u7528uv_fs_t\u7ba1\u7406\u672c\u6b21\u8bf7\u6c42\u3002\u56e0\u4e3a\u662f\u963b\u585e\u5f0f\u8c03\u7528\uff0c\u6240\u4ee5Libuv\u4f1a\u76f4\u63a5\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\u51fd\u6570\u3002\u8fd9\u662fNode.js\u4e2d\u540c\u6b65API\u7684\u8fc7\u7a0b\u3002","title":"12.1 \u540c\u6b65API"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#122-api","text":"\u6587\u4ef6\u7cfb\u7edf\u7684API\u4e2d\uff0c\u5f02\u6b65\u7684\u5b9e\u73b0\u662f\u4f9d\u8d56\u4e8eLibuv\u7684\u7ebf\u7a0b\u6c60\u7684\u3002Node.js\u628a\u4efb\u52a1\u653e\u5230\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u8fd4\u56de\u4e3b\u7ebf\u7a0b\u7ee7\u7eed\u5904\u7406\u5176\u5b83\u4e8b\u60c5\uff0c\u7b49\u5230\u6761\u4ef6\u6ee1\u8db3\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8bb2\u89e3\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u5f02\u6b65\u8bfb\u53d6\u6587\u4ef6\u7684\u6d41\u7a0b\u56fe\uff0c\u5982\u56fe12-2\u6240\u793a\u3002 \u56fe12-2 \u4e0b\u9762\u6211\u4eec\u770b\u5177\u4f53\u7684\u5b9e\u73b0 1. function readFile(path, options, callback) { 2. callback = maybeCallback(callback || options); 3. options = getOptions(options, { flag: 'r' }); 4. // \u7ba1\u7406\u6587\u4ef6\u8bfb\u7684\u5bf9\u8c61 5. if (!ReadFileContext) 6. ReadFileContext = require('internal/fs/read_file_context'); 7. const context = new ReadFileContext(callback, options.encoding) 8. // \u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u8fd8\u662ffd 9. context.isUserFd = isFd(path); // File descriptor ownership 10. // C++\u5c42\u7684\u5bf9\u8c61\uff0c\u5c01\u88c5\u4e86uv_fs_t\u7ed3\u6784\u4f53\uff0c\u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u8bfb\u8bf7\u6c42 11. const req = new FSReqCallback(); 12. req.context = context; 13. // \u8bbe\u7f6e\u56de\u8c03\uff0c\u6253\u5f00\u6587\u4ef6\u540e\uff0c\u6267\u884c 14. req.oncomplete = readFileAfterOpen; 15. // \u4f20\u7684\u662ffd\uff0c\u5219\u4e0d\u9700\u8981\u6253\u5f00\u6587\u4ef6\uff0c\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884c\u56de\u8c03\u8bfb\u53d6\u6587\u4ef6 16. if (context.isUserFd) { 17. process.nextTick(function tick() { 18. req.oncomplete(null, path); 19. }); 20. return; 21. } 22. 23. path = getValidatedPath(path); 24. const flagsNumber = stringToFlags(options.flags); 25. // \u8c03\u7528C++\u5c42open\u6253\u5f00\u6587\u4ef6 26. binding.open(pathModule.toNamespacedPath(path), 27. flagsNumber, 28. 0o666, 29. req); 30. } ReadFileContext\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u8bfb\u64cd\u4f5c\u6574\u4e2a\u8fc7\u7a0b\uff0cFSReqCallback\u662f\u5bf9uv_fs_t\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21\u8bfb\u64cd\u4f5c\u5bf9\u4e8eLibuv\u6765\u8bf4\u5c31\u662f\u4e00\u6b21\u8bf7\u6c42\uff0c\u8be5\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\u5c31\u662f\u4f7f\u7528uv_fs_t\u8868\u793a\u3002\u8bf7\u6c42\u5b8c\u6210\u540e\uff0c\u4f1a\u6267\u884cFSReqCallback\u5bf9\u8c61\u7684oncomplete\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u7ee7\u7eed\u770breadFileAfterOpen\u3002 1. function readFileAfterOpen(err, fd) { 2. const context = this.context; 3. // \u6253\u5f00\u51fa\u9519\u5219\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u4f20\u5165err 4. if (err) { 5. context.callback(err); 6. return; 7. } 8. // \u4fdd\u5b58\u6253\u5f00\u6587\u4ef6\u7684fd 9. context.fd = fd; 10. // \u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u4e0b\u4e00\u4e2a\u5f02\u6b65\u8bf7\u6c42\u548c\u56de\u8c03 11. const req = new FSReqCallback(); 12. req.oncomplete = readFileAfterStat; 13. req.context = context; 14. // \u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u62ff\u5230\u6587\u4ef6\u5927\u5c0f 15. binding.fstat(fd, false, req); 16. } \u62ff\u5230\u6587\u4ef6\u7684\u5143\u6570\u636e\u540e\uff0c\u6267\u884creadFileAfterStat\uff0c\u8fd9\u6bb5\u903b\u8f91\u548c\u540c\u6b65\u7684\u7c7b\u4f3c\uff0c\u6839\u636e\u5143\u6570\u636e\u4e2d\u8bb0\u5f55\u7684\u6587\u4ef6\u5927\u5c0f\uff0c\u5206\u914d\u4e00\u4e2abuffer\u7528\u4e8e\u540e\u7eed\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u3002\u7136\u540e\u6267\u884c\u8bfb\u64cd\u4f5c\u3002 1. read() { 2. let buffer; 3. let offset; 4. let length; 5. 6. // \u7701\u7565\u90e8\u5206buffer\u5904\u7406\u7684\u903b\u8f91 7. const req = new FSReqCallback(); 8. req.oncomplete = readFileAfterRead; 9. req.context = this; 10. 11. read(this.fd, buffer, offset, length, -1, req); 12. } \u518d\u6b21\u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u5f02\u6b65\u8bfb\u53d6\u64cd\u4f5c\u548c\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42read\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. // \u62ff\u5230C++\u5c42\u7684FSReqCallback\u5bf9\u8c61 2. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); 3. // \u5f02\u6b65\u8c03\u7528uv_fs_read 4. AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger,uv_fs_read, fd, &uvbuf, 1, pos); AsyncCall\u6700\u540e\u8c03\u7528Libuv\u7684uv_fs_read\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u5173\u952e\u903b\u8f91\u3002 1. do { \\ 2. if (cb != NULL) { \\ 3. uv__req_register(loop, req); \\ 4. uv__work_submit(loop, \\ 5. &req->work_req, \\ 6. UV__WORK_FAST_IO, \\ 7. uv__fs_work, \\ 8. uv__fs_done); \\ 9. return 0; \\ 10. } \\ 11. else { \\ 12. uv__fs_work(&req->work_req); \\ 13. return req->result; \\ 14. } \\ 15. } \\ 16. while (0) uv__work_submit\u662f\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u8fd9\u4e2a\u4efb\u52a1\u65f6\uff0c\u5c31\u4f1a\u6267\u884cuv__fs_work\uff0cuv__fs_work\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\u7b49\u5230\u8bfb\u53d6\u6210\u529f\u540e\u6267\u884cuv__fs_done\u3002uv__fs_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002JS\u5c42\u7684\u56de\u8c03\u662freadFileAfterRead\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5c55\u5f00\uff0creadFileAfterRead\u7684\u903b\u8f91\u662f\u5224\u65ad\u662f\u5426\u8bfb\u53d6\u5b8c\u6bd5\uff0c\u662f\u7684\u8bdd\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5426\u5219\u7ee7\u7eed\u53d1\u8d77\u8bfb\u53d6\u64cd\u4f5c\u3002","title":"12.2 \u5f02\u6b65API"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#123","text":"\u6587\u4ef6\u76d1\u542c\u662f\u975e\u5e38\u5e38\u7528\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6211\u4eec\u4fee\u6539\u4e86\u6587\u4ef6\u540ewebpack\u91cd\u65b0\u6253\u5305\u4ee3\u7801\u6216\u8005Node.js\u670d\u52a1\u91cd\u542f\uff0c\u90fd\u7528\u5230\u4e86\u6587\u4ef6\u76d1\u542c\u7684\u529f\u80fd\uff0cNode.js\u63d0\u4f9b\u4e86\u4e24\u5957\u6587\u4ef6\u76d1\u542c\u7684\u673a\u5236\u3002","title":"12.3 \u6587\u4ef6\u76d1\u542c"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1231","text":"\u57fa\u4e8e\u8f6e\u8be2\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542cAPI\u662fwatchFile\u3002\u6d41\u7a0b\u5982\u56fe12-3\u6240\u793a\u3002 \u56fe12-3 \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1. function watchFile(filename, options, listener) { 2. filename = getValidatedPath(filename); 3. filename = pathModule.resolve(filename); 4. let stat; 5. // \u7701\u7565\u90e8\u5206\u53c2\u6570\u5904\u7406\u903b\u8f91 6. options = { 7. interval: 5007, 8. // \u4e00\u76f4\u8f6e\u8be2 9. persistent: true, 10. ...options 11. }; 12. 13. // \u7f13\u5b58\u5904\u7406\uff0cfilename\u662f\u5426\u5df2\u7ecf\u5f00\u542f\u8fc7\u76d1\u542c 14. stat = statWatchers.get(filename); 15. 16. if (stat === undefined) { 17. if (!watchers) 18. watchers = require('internal/fs/watchers'); 19. stat = new watchers.StatWatcher(options.bigint); 20. // \u5f00\u542f\u76d1\u542c 21. stat[watchers.kFSStatWatcherStart](filename, 22. options.persistent, 23. options.interval); 24. // \u66f4\u65b0\u7f13\u5b58 25. statWatchers.set(filename, stat); 26. } 27. 28. stat.addListener('change', listener); 29. return stat; 30. } StatWatcher\u662f\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u7c7b\uff0c\u6211\u4eec\u770b\u4e00\u4e0bwatchers.kFSStatWatcherStart\u65b9\u6cd5\u7684\u5b9e\u73b0\u3002 1. StatWatcher.prototype[kFSStatWatcherStart] = function(filename,persistent, interval) { 2. this._handle = new _StatWatcher(this[kUseBigint]); 3. this._handle.onchange = onchange; 4. filename = getValidatedPath(filename, 'filename'); 5. const err = this._handle.start(toNamespacedPath(filename), 6. interval); 7. } \u65b0\u5efa\u4e00\u4e2a_StatWatcher\u5bf9\u8c61\uff0c_StatWatcher\u662fC++\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\uff08node_stat_watcher.cc\uff09\uff0c\u7136\u540e\u6267\u884c\u5b83\u7684start\u65b9\u6cd5\u3002Start\u65b9\u6cd5\u6267\u884cLibuv\u7684uv_fs_poll_start\u5f00\u59cb\u76d1\u542c\u6587\u4ef6\u3002 1. int uv_fs_poll_start(uv_fs_poll_t* handle,uv_fs_poll_cb cb, 2. const char* path, unsigned int interval) { 3. // \u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u6570\u636e\u7ed3\u6784 4. struct poll_ctx* ctx; 5. uv_loop_t* loop; 6. size_t len; 7. int err; 8. 9. loop = handle->loop; 10. len = strlen(path); 11. // calloc\u4f1a\u628a\u5185\u5b58\u521d\u59cb\u5316\u4e3a0 12. ctx = uv__calloc(1, sizeof(*ctx) + len); 13. ctx->loop = loop; 14. // C++\u5c42\u56de\u8c03 15. ctx->poll_cb = cb; 16. // \u591a\u4e45\u8f6e\u8be2\u4e00\u6b21 17. ctx->interval = interval ? interval : 1; 18. ctx->start_time = uv_now(loop); 19. // \u5173\u8054\u7684handle 20. ctx->parent_handle = handle; 21. // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 22. memcpy(ctx->path, path, len + 1); 23. // \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53 24. err = uv_timer_init(loop, &ctx->timer_handle); 25. // \u5f02\u6b65\u67e5\u8be2\u6587\u4ef6\u5143\u6570\u636e 26. err = uv_fs_stat(loop, &ctx->fs_req, ctx->path, poll_cb); 27. 28. if (handle->poll_ctx != NULL) 29. ctx->previous = handle->poll_ctx; 30. // \u5173\u8054\u8d1f\u8d23\u7ba1\u7406\u8f6e\u8be2\u7684\u5bf9\u8c61 31. handle->poll_ctx = ctx; 32. uv__handle_start(handle); 33. return 0; 34. } Start\u51fd\u6570\u521d\u59cb\u5316\u4e00\u4e2apoll_ctx\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u53d1\u8d77\u5f02\u6b65\u8bf7\u6c42\u6587\u4ef6\u5143\u6570\u636e\u7684\u8bf7\u6c42\uff0c\u83b7\u53d6\u5143\u6570\u636e\u540e\uff0c\u6267\u884cpoll_cb\u56de\u8c03\u3002 1. static void poll_cb(uv_fs_t* req) { 2. uv_stat_t* statbuf; 3. struct poll_ctx* ctx; 4. uint64_t interval; 5. // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 6. ctx = container_of(req, struct poll_ctx, fs_req); 7. statbuf = &req->statbuf; 8. /* 9. \u7b2c\u4e00\u6b21\u4e0d\u6267\u884c\u56de\u8c03\uff0c\u56e0\u4e3a\u6ca1\u6709\u53ef\u5bf9\u6bd4\u7684\u5143\u6570\u636e\uff0c\u7b2c\u4e8c\u6b21\u53ca\u540e\u7eed\u7684\u64cd\u4f5c\u624d\u53ef\u80fd 10. \u6267\u884c\u56de\u8c03\uff0cbusy_polling\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\u7f6e 11. busy_polling=1 12. */ 13. if (ctx->busy_polling != 0) 14. // \u51fa\u9519\u6216\u8005stat\u53d1\u751f\u4e86\u53d8\u5316\u5219\u6267\u884c\u56de\u8c03 15. if (ctx->busy_polling < 0 || 16. !statbuf_eq(&ctx->statbuf, statbuf)) 17. ctx->poll_cb(ctx->parent_handle, 18. 0, 19. &ctx->statbuf, 20. statbuf); 21. // \u4fdd\u5b58\u5f53\u524d\u83b7\u53d6\u5230\u7684stat\u4fe1\u606f\uff0c\u7f6e1 22. ctx->statbuf = *statbuf; 23. ctx->busy_polling = 1; 24. 25. out: 26. uv_fs_req_cleanup(req); 27. 28. if (ctx->parent_handle == NULL) { 29. uv_close((uv_handle_t*)&ctx->timer_handle, timer_close_cb); 30. return; 31. } 32. /* 33. \u5047\u8bbe\u5728\u5f00\u59cb\u65f6\u95f4\u70b9\u4e3a1\uff0cinterval\u4e3a10\u7684\u60c5\u51b5\u4e0b\u6267\u884c\u4e86stat\uff0cstat 34. \u5b8c\u6210\u6267\u884c\u5e76\u6267\u884cpoll_cb\u56de\u8c03\u7684\u65f6\u95f4\u70b9\u662f3\uff0c\u90a3\u4e48\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4 35. \u5219\u4e3a10-3=7\uff0c\u53737\u4e2a\u5355\u4f4d\u540e\u5c31\u8981\u89e6\u53d1\u8d85\u65f6\uff0c\u800c\u4e0d\u662f10\uff0c\u662f\u56e0\u4e3astat 36. \u963b\u585e\u6d88\u8017\u4e863\u4e2a\u5355\u4f4d\u7684\u65f6\u95f4\uff0c\u6240\u4ee5\u4e0b\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u51fd\u6570\u65f6\u8bf4\u660e\u4ece 37. start\u65f6\u95f4\u70b9\u5f00\u59cb\u7b97\uff0c\u5df2\u7ecf\u7ecf\u5386\u4e86x\u5355\u4f4d\u5404interval\uff0c\u7136\u540e\u8d85\u65f6\u56de\u8c03\u91cc 38. \u53c8\u6267\u884c\u4e86stat\u51fd\u6570\uff0c\u518d\u5230\u6267\u884cstat\u56de\u8c03\uff0c\u8fd9\u4e2a\u65f6\u95f4\u70b9\u5373now=start+x 39. \u5355\u4f4d\u4e2ainterval+stat\u6d88\u8017\u7684\u65f6\u95f4\u3002\u5f97\u51fanow-start\u4e3ainterval\u7684 40. x\u500d+stat\u6d88\u8017\uff0c\u5373\u5bf9interval\u53d6\u4f59\u53ef\u5f97\u5230stat\u6d88\u8017\uff0c\u6240\u4ee5\u5f53\u524d\u8f6e\uff0c 41. \u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4\u4e3ainterval - ((now-start) % interval) 42. */ 43. interval = ctx->interval; 44. interval = (uv_now(ctx->loop) - ctx->start_time) % interval; 45. 46. if (uv_timer_start(&ctx->timer_handle, timer_cb, interval, 0)) 47. abort(); 48. } \u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u6587\u4ef6\u673a\u5236\u672c\u8d28\u4e0a\u662f\u4e0d\u65ad\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u7136\u540e\u548c\u4e0a\u4e00\u6b21\u7684\u5143\u6570\u636e\u8fdb\u884c\u5bf9\u6bd4\uff0c\u5982\u679c\u6709\u4e0d\u4e00\u81f4\u7684\u5c31\u8ba4\u4e3a\u6587\u4ef6\u53d8\u5316\u4e86\uff0c\u56e0\u4e3a\u7b2c\u4e00\u6b21\u83b7\u53d6\u5143\u6570\u636e\u65f6\uff0c\u8fd8\u6ca1\u6709\u53ef\u4ee5\u5bf9\u6bd4\u7684\u6570\u636e\uff0c\u6240\u4ee5\u4e0d\u8ba4\u4e3a\u662f\u6587\u4ef6\u53d8\u5316\uff0c\u8fd9\u65f6\u5019\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u9694\u4e00\u6bb5\u65f6\u95f4\u518d\u53bb\u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u6b64\u53cd\u590d\uff0c\u76f4\u5230\u7528\u6237\u8c03stop\u51fd\u6570\u505c\u6b62\u8fd9\u4e2a\u884c\u4e3a\u3002\u4e0b\u9762\u662fLibuv\u5173\u4e8e\u6587\u4ef6\u53d8\u5316\u7684\u5b9a\u4e49\u3002 1. static int statbuf_eq(const uv_stat_t* a, const uv_stat_t* b) { 2. return a->st_ctim.tv_nsec == b->st_ctim.tv_nsec 3. && a->st_mtim.tv_nsec == b->st_mtim.tv_nsec 4. && a->st_birthtim.tv_nsec == b->st_birthtim.tv_nsec 5. && a->st_ctim.tv_sec == b->st_ctim.tv_sec 6. && a->st_mtim.tv_sec == b->st_mtim.tv_sec 7. && a->st_birthtim.tv_sec == b->st_birthtim.tv_sec 8. && a->st_size == b->st_size 9. && a->st_mode == b->st_mode 10. && a->st_uid == b->st_uid 11. && a->st_gid == b->st_gid 12. && a->st_ino == b->st_ino 13. && a->st_dev == b->st_dev 14. && a->st_flags == b->st_flags 15. && a->st_gen == b->st_gen; 16. }","title":"12.3.1 \u57fa\u4e8e\u8f6e\u8be2\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1232inotify","text":"\u6211\u4eec\u770b\u5230\u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u5176\u5b9e\u6548\u7387\u662f\u5f88\u4f4e\u7684\uff0c\u56e0\u4e3a\u9700\u8981\u6211\u4eec\u4e0d\u65ad\u53bb\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u679c\u6587\u4ef6\u5927\u90e8\u5206\u65f6\u95f4\u91cc\u90fd\u6ca1\u6709\u53d8\u5316\uff0c\u90a3\u5c31\u4f1a\u767d\u767d\u6d6a\u8d39CPU\u3002\u5982\u679c\u6587\u4ef6\u6539\u53d8\u4e86\u4f1a\u4e3b\u52a8\u901a\u77e5\u6211\u4eec\u90a3\u5c31\u597d\u4e86\uff0c\u8fd9\u5c31\u662f\u57fa\u4e8einotify\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542c\u3002Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u662fwatch\u3002watch\u7684\u5b9e\u73b0\u548cwatchFile\u7684\u6bd4\u8f83\u7c7b\u4f3c\u3002 1. function watch(filename, options, listener) { 2. // Don't make changes directly on options object 3. options = copyObject(options); 4. // \u662f\u5426\u6301\u7eed\u76d1\u542c 5. if (options.persistent === undefined) 6. options.persistent = true; 7. // \u5982\u679c\u662f\u76ee\u5f55\uff0c\u662f\u5426\u76d1\u542c\u6240\u6709\u5b50\u76ee\u5f55\u548c\u6587\u4ef6\u7684\u53d8\u5316 8. if (options.recursive === undefined) 9. options.recursive = false; 10. // \u6709\u4e9b\u5e73\u53f0\u4e0d\u652f\u6301 11. if (options.recursive && !(isOSX || isWindows)) 12. throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively'); 13. if (!watchers) 14. watchers = require('internal/fs/watchers'); 15. // \u65b0\u5efa\u4e00\u4e2aFSWatcher\u5bf9\u8c61\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u5f00\u542f\u76d1\u542c 16. const watcher = new watchers.FSWatcher(); 17. watcher[watchers.kFSWatchStart](filename, 18. options.persistent, 19. options.recursive, 20. options.encoding); 21. 22. if (listener) { 23. watcher.addListener('change', listener); 24. } 25. 26. return watcher; 27. } FSWatcher\u51fd\u6570\u662f\u5bf9C++\u5c42FSEvent\u6a21\u5757\u7684\u5c01\u88c5\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0bstart\u51fd\u6570\u7684\u903b\u8f91\uff0cstart\u51fd\u6570\u900f\u8fc7C++\u5c42\u8c03\u7528\u4e86Libuv\u7684uv_fs_event_start\u51fd\u6570\u3002\u5728\u8bb2\u89e3uv_fs_event_start\u51fd\u6570\u524d\uff0c\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0binotify\u7684\u539f\u7406\u548c\u5b83\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002inotify\u662fLinux\u7cfb\u7edf\u63d0\u4f9b\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u7cfb\u7edf\u7684\u673a\u5236\u3002inotify\u673a\u5236\u7684\u903b\u8f91\u5927\u81f4\u662f 1 init_inotify\u521b\u5efa\u4e00\u4e2ainotify\u7684\u5b9e\u4f8b\uff0c\u8fd4\u56de\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7c7b\u4f3cepoll\u3002 2 inotify_add_watch\u5f80inotify\u5b9e\u4f8b\u6ce8\u518c\u4e00\u4e2a\u9700\u76d1\u542c\u7684\u6587\u4ef6\uff08inotify_rm_watch\u662f\u79fb\u9664\uff09\u3002 3 read(inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26, &buf, sizeof(buf))\uff0c\u5982\u679c\u6ca1\u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u5219\u963b\u585e\uff08\u9664\u975e\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\uff09\u3002\u5426\u5219\u8fd4\u56de\u5f85\u8bfb\u53d6\u7684\u6570\u636e\u957f\u5ea6\u3002buf\u5c31\u662f\u4fdd\u5b58\u4e86\u89e6\u53d1\u4e8b\u4ef6\u7684\u4fe1\u606f\u3002 Libuv\u5728inotify\u673a\u5236\u7684\u57fa\u7840\u4e0a\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\u3002\u6211\u4eec\u770b\u4e00\u4e0binotify\u5728Libuv\u7684\u67b6\u6784\u56fe\u5982\u56fe12-4\u6240\u793a\u3002 \u56fe12-4 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bLibuv\u4e2d\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u3002 1. int main(int argc, char **argv) { 2. // \u5b9e\u73b0\u5faa\u73af\u6838\u5fc3\u7ed3\u6784\u4f53loop 3. loop = uv_default_loop(); 4. uv_fs_event_t *fs_event_req = malloc(sizeof(uv_fs_event_t)); 5. // \u521d\u59cb\u5316fs_event_req\u7ed3\u6784\u4f53\u7684\u7c7b\u578b\u4e3aUV_FS_EVENT 6. uv_fs_event_init(loop, fs_event_req); 7. /* 8. argv[argc]\u662f\u6587\u4ef6\u8def\u5f84\uff0c 9. uv_fs_event_start \u5411\u5e95\u5c42\u6ce8\u518c\u76d1\u542c\u6587\u4ef6argv[argc], 10. cb\u662f\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03 11. */ 12. uv_fs_event_start(fs_event_req, 13. cb, 14. argv[argc], 15. UV_FS_EVENT_RECURSIVE); 16. // \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af 17. return uv_run(loop, UV_RUN_DEFAULT); 18. } Libuv\u5728\u7b2c\u4e00\u6b21\u76d1\u542c\u6587\u4ef6\u7684\u65f6\u5019(\u8c03\u7528uv_fs_event_start\u7684\u65f6\u5019)\uff0c\u4f1a\u521b\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002 1. static int init_inotify(uv_loop_t* loop) { 2. int err; 3. // \u521d\u59cb\u5316\u8fc7\u4e86\u5219\u76f4\u63a5\u8fd4\u56de 4. if (loop->inotify_fd != -1) 5. return 0; 6. /* 7. \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684inotify_init\u51fd\u6570\u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b\uff0c 8. \u5e76\u8bbe\u7f6eUV__IN_NONBLOCK\uff0cUV__IN_CLOEXEC\u6807\u8bb0 9. */ 10. err = new_inotify_fd(); 11. if (err < 0) 12. return err; 13. // \u8bb0\u5f55inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26,\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e00\u4e2ainotify\u5b9e\u4f8b 14. loop->inotify_fd = err; 15. /* 16. inotify_read_watcher\u662f\u4e00\u4e2aIO\u89c2\u5bdf\u8005\uff0c 17. uv__io_init\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5f85\u89c2\u5bdf\u7684\u6587\u4ef6\uff09\u548c\u56de\u8c03 18. */ 19. uv__io_init(&loop->inotify_read_watcher, 20. uv__inotify_read, 21. loop->inotify_fd); 22. // \u5f80Libuv\u4e2d\u6ce8\u518c\u8be5IO\u89c2\u5bdf\u8005\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb 23. uv__io_start(loop, &loop->inotify_read_watcher, POLLIN); 24. 25. return 0; 26. } Libuv\u628ainotify\u5b9e\u4f8b\u5bf9\u5e94\u7684fd\u901a\u8fc7uv__io_start\u6ce8\u518c\u5230epoll\u4e2d\uff0c\u5f53\u6709\u6587\u4ef6\u53d8\u5316\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002\u5206\u6790\u5b8cLibuv\u7533\u8bf7inotify\u5b9e\u4f8b\u7684\u903b\u8f91\uff0c\u6211\u4eec\u56de\u5230main\u51fd\u6570\u770b\u770buv_fs_event_start\u51fd\u6570\u3002\u7528\u6237\u4f7f\u7528uv_fs_event_start\u51fd\u6570\u6765\u5f80Libuv\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1. int uv_fs_event_start(uv_fs_event_t* handle, 2. uv_fs_event_cb cb, 3. const char* path, 4. unsigned int flags) { 5. struct watcher_list* w; 6. int events; 7. int err; 8. int wd; 9. 10. if (uv__is_active(handle)) 11. return UV_EINVAL; 12. // \u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b 13. err = init_inotify(handle->loop); 14. if (err) 15. return err; 16. // \u76d1\u542c\u7684\u4e8b\u4ef6 17. events = UV__IN_ATTRIB 18. | UV__IN_CREATE 19. | UV__IN_MODIFY 20. | UV__IN_DELETE 21. | UV__IN_DELETE_SELF 22. | UV__IN_MOVE_SELF 23. | UV__IN_MOVED_FROM 24. | UV__IN_MOVED_TO; 25. // \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\uff0c\u8fd4\u56de\u4e00\u4e2a\u5bf9\u5e94\u4e8e\u8be5\u6587\u4ef6\u7684id 26. wd = uv__inotify_add_watch(handle->loop->inotify_fd, path, events); 27. if (wd == -1) 28. return UV__ERR(errno); 29. // \u5224\u65ad\u8be5\u6587\u4ef6\u662f\u4e0d\u662f\u5df2\u7ecf\u6ce8\u518c\u8fc7\u4e86 30. w = find_watcher(handle->loop, wd); 31. // \u5df2\u7ecf\u6ce8\u518c\u8fc7\u5219\u8df3\u8fc7\u63d2\u5165\u7684\u903b\u8f91 32. if (w) 33. goto no_insert; 34. // \u8fd8\u6ca1\u6709\u6ce8\u518c\u8fc7\u5219\u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811 35. w = uv__malloc(sizeof(*w) + strlen(path) + 1); 36. if (w == NULL) 37. return UV_ENOMEM; 38. 39. w->wd = wd; 40. w->path = strcpy((char*)(w + 1), path); 41. QUEUE_INIT(&w->watchers); 42. w->iterating = 0; 43. // \u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811,inotify_watchers\u662f\u6839\u8282\u70b9 44. RB_INSERT(watcher_root, CAST(&handle->loop->inotify_watchers), w); 45. 46. no_insert: 47. // \u6fc0\u6d3b\u8be5handle 48. uv__handle_start(handle); 49. // \u540c\u4e00\u4e2a\u6587\u4ef6\u53ef\u80fd\u6ce8\u518c\u4e86\u5f88\u591a\u4e2a\u56de\u8c03\uff0cw\u5bf9\u5e94\u4e00\u4e2a\u6587\u4ef6\uff0c\u6ce8\u518c\u5728\u7528\u4e00\u4e2a\u6587\u4ef6\u7684\u56de\u8c03\u6392\u6210\u961f 50. QUEUE_INSERT_TAIL(&w->watchers, &handle->watchers); 51. // \u4fdd\u5b58\u4fe1\u606f\u548c\u56de\u8c03 52. handle->path = w->path; 53. handle->cb = cb; 54. handle->wd = wd; 55. 56. return 0; 57. } \u4e0b\u9762\u6211\u4eec\u9010\u6b65\u5206\u6790\u4e0a\u9762\u7684\u51fd\u6570\u903b\u8f91\u3002 1 \u5982\u679c\u662f\u9996\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u5219\u65b0\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002\u5e76\u4e14\u5f80Libuv\u63d2\u5165\u4e00\u4e2a\u89c2\u5bdf\u8005io\uff0cLibuv\u4f1a\u5728Poll IO\u9636\u6bb5\u6ce8\u518c\u5230epoll\u4e2d\u3002 2 \u5f80\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u8fd4\u56de\u4e00\u4e2aid\u3002 3 Libuv\u5224\u65ad\u8be5id\u662f\u4e0d\u662f\u5728\u81ea\u5df1\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811\u4e2d\u3002\u4e0d\u5728\u7ea2\u9ed1\u6811\u4e2d\uff0c\u5219\u63d2\u5165\u7ea2\u9ed1\u6811\u3002\u8fd4\u56de\u4e00\u4e2a\u7ea2\u9ed1\u6811\u4e2d\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u628a\u672c\u6b21\u8bf7\u6c42\u7684\u4fe1\u606f\u5c01\u88c5\u5230handle\u4e2d\uff08\u56de\u8c03\u65f6\u9700\u8981\uff09\u3002\u7136\u540e\u628ahandle\u63d2\u5165\u521a\u624d\u8fd4\u56de\u7684\u8282\u70b9\u7684\u961f\u5217\u4e2d\u3002 \u8fd9\u65f6\u5019\u6ce8\u518c\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002Libuv\u5728Poll IO\u9636\u6bb5\u5982\u679c\u68c0\u6d4b\u5230\u6709\u6587\u4ef6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002 1. static void uv__inotify_read(uv_loop_t* loop, 2. uv__io_t* dummy, 3. unsigned int events) { 4. const struct uv__inotify_event* e; 5. struct watcher_list* w; 6. uv_fs_event_t* h; 7. QUEUE queue; 8. QUEUE* q; 9. const char* path; 10. ssize_t size; 11. const char *p; 12. /* needs to be large enough for sizeof(inotify_event) + strlen(path) */ 13. char buf[4096]; 14. // \u4e00\u6b21\u53ef\u80fd\u6ca1\u6709\u8bfb\u5b8c 15. while (1) { 16. do 17. // \u8bfb\u53d6\u89e6\u53d1\u7684\u4e8b\u4ef6\u4fe1\u606f\uff0csize\u662f\u6570\u636e\u5927\u5c0f\uff0cbuffer\u4fdd\u5b58\u6570\u636e 18. size = read(loop->inotify_fd, buf, sizeof(buf)); 19. while (size == -1 && errno == EINTR); 20. // \u6ca1\u6709\u6570\u636e\u53ef\u53d6\u4e86 21. if (size == -1) { 22. assert(errno == EAGAIN || errno == EWOULDBLOCK); 23. break; 24. } 25. // \u5904\u7406buffer\u7684\u4fe1\u606f 26. for (p = buf; p < buf + size; p += sizeof(*e) + e->len) { 27. // buffer\u91cc\u662f\u591a\u4e2auv__inotify_event\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86\u4e8b\u4ef6\u4fe1\u606f\u548c\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09 28. e = (const struct uv__inotify_event*)p; 29. 30. events = 0; 31. if (e->mask & (UV__IN_ATTRIB|UV__IN_MODIFY)) 32. events |= UV_CHANGE; 33. if (e->mask & ~(UV__IN_ATTRIB|UV__IN_MODIFY)) 34. events |= UV_RENAME; 35. // \u901a\u8fc7\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u8282\u70b9 36. w = find_watcher(loop, e->wd); 37. 38. path = e->len ? (const char*) (e + 1) : uv__basename_r(w->path); 39. w->iterating = 1; 40. // \u628a\u7ea2\u9ed1\u6811\u4e2d\uff0cwd\u5bf9\u5e94\u8282\u70b9\u7684handle\u961f\u5217\u79fb\u5230queue\u53d8\u91cf\uff0c\u51c6\u5907\u5904\u7406 41. QUEUE_MOVE(&w->watchers, &queue); 42. while (!QUEUE_EMPTY(&queue)) { 43. // \u5934\u7ed3\u70b9 44. q = QUEUE_HEAD(&queue); 45. // \u901a\u8fc7\u7ed3\u6784\u4f53\u504f\u79fb\u62ff\u5230\u9996\u5730\u5740 46. h = QUEUE_DATA(q, uv_fs_event_t, watchers); 47. // \u4ece\u5904\u7406\u961f\u5217\u4e2d\u79fb\u9664 48. QUEUE_REMOVE(q); 49. // \u653e\u56de\u539f\u961f\u5217 50. QUEUE_INSERT_TAIL(&w->watchers, q); 51. // \u6267\u884c\u56de\u8c03 52. h->cb(h, path, events, 0); 53. } 54. } 55. } 56. } uv__inotify_read\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u4ece\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\uff0c\u8fd9\u4e9b\u6570\u636e\u4e2d\u4fdd\u5b58\u4e86\u54ea\u4e9b\u6587\u4ef6\u89e6\u53d1\u4e86\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u7136\u540e\u904d\u5386\u6bcf\u4e2a\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u6587\u4ef6\u3002\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u8be5\u6587\u4ef6\u5bf9\u5e94\u7684\u7ea2\u9ed1\u6811\u8282\u70b9\u3002\u518d\u53d6\u51fa\u7ea2\u9ed1\u6811\u8282\u70b9\u4e2d\u7ef4\u62a4\u7684\u4e00\u4e2ahandle\u961f\u5217\uff0c\u6700\u540e\u6267\u884chandle\u961f\u5217\u4e2d\u6bcf\u4e2a\u8282\u70b9\u7684\u56de\u8c03\u3002","title":"12.3.2\u57fa\u4e8einotify\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#124-promiseapi","text":"Node.js\u7684API\u90fd\u662f\u9075\u5faacallback\u6a21\u5f0f\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u8fd9\u6837\u5199 1. const fs = require('fs'); 2. fs.readFile('filename', 'utf-8' ,(err,data) => { 3. console.log(data) 4. }) \u4e3a\u4e86\u652f\u6301Promise\u6a21\u5f0f\uff0c\u6211\u4eec\u901a\u5e38\u8fd9\u6837\u5199 1. const fs = require('fs'); 2. function readFile(filename) { 3. return new Promise((resolve, reject) => { 4. fs.readFile(filename, 'utf-8' ,(err,data) => { 5. err ? reject(err) : resolve(data); 6. }); 7. }); 8. } \u4f46\u662f\u5728Node.js V14\u4e2d\uff0c\u6587\u4ef6\u6a21\u5757\u652f\u6301\u4e86Promise\u5316\u7684api\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528await\u8fdb\u884c\u6587\u4ef6\u64cd\u4f5c\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f7f\u7528\u4f8b\u5b50\u3002 1. const { open, readFile } = require('fs').promises; 2. async function runDemo() { 3. try { 4. console.log(await readFile('11111.md', { encoding: 'utf-8' })); 5. } catch (e){ 6. 7. } 8. } 9. runDemo(); \u4ece\u4f8b\u5b50\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u548c\u4e4b\u524d\u7684API\u8c03\u7528\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u6211\u4eec\u4e0d\u7528\u518d\u5199\u56de\u8c03\u4e86\uff0c\u800c\u662f\u901a\u8fc7await\u7684\u65b9\u5f0f\u63a5\u6536\u7ed3\u679c\u3002\u8fd9\u53ea\u662f\u65b0\u7248API\u7684\u7279\u6027\u4e4b\u4e00\u3002\u5728\u65b0\u7248API\u4e4b\u524d\uff0c\u6587\u4ef6\u6a21\u5757\u5927\u90e8\u5206API\u90fd\u662f\u7c7b\u4f3c\u5de5\u5177\u51fd\u6570\uff0c\u6bd4\u5982readFile\uff0cwriteFile\uff0c\u65b0\u7248API\u4e2d\u652f\u6301\u9762\u5411\u5bf9\u8c61\u7684\u8c03\u7528\u65b9\u5f0f\u3002 1. const { open, readFile } = require('fs').promises; 2. async function runDemo() { 3. let filehandle; 4. try { 5. filehandle = await open('filename', 'r'); 6. // console.log(await readFile(filehandle, { encoding: 'utf-8' })); 7. console.log(await filehandle.readFile({ encoding: 'utf-8' })); 8. } finally { 9. if (filehandle) { 10. await filehandle.close(); 11. } 12. } 13. } 14. runDemo(); \u9762\u5411\u5bf9\u8c61\u7684\u6a21\u5f0f\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u901a\u8fc7open\u51fd\u6570\u62ff\u5230\u4e00\u4e2aFileHandle\u5bf9\u8c61\uff08\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff09\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u5728\u8be5\u5bf9\u8c61\u4e0a\u8c03\u5404\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u51fd\u6570\u3002\u5728\u4f7f\u7528\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u7684API\u65f6\u6709\u4e00\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9\u662fNode.js\u4e0d\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5373\u4f7f\u6587\u4ef6\u64cd\u4f5c\u51fa\u9519\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u624b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u800c\u5728\u975e\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u4e2d\uff0c\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\uff0cNode.js\u90fd\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u9996\u5148\u4ecb\u7ecd\u4e00\u4e2aFileHandle\u7c7b\u3002\u8be5\u7c7b\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff0c\u63d0\u4f9b\u4e86\u9762\u5411\u5bf9\u8c61\u7684API\u3002 1. class FileHandle { 2. constructor(filehandle) { 3. // filehandle\u4e3aC++\u5bf9\u8c61 4. this[kHandle] = filehandle; 5. this[kFd] = filehandle.fd; 6. } 7. 8. get fd() { 9. return this[kFd]; 10. } 11. 12. readFile(options) { 13. return readFile(this, options); 14. } 15. 16. close = () => { 17. this[kFd] = -1; 18. return this[kHandle].close(); 19. } 20. // \u7701\u7565\u90e8\u5206\u64cd\u4f5c\u6587\u4ef6\u7684api 21. } FileHandle\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u5c01\u88c5\u4e86\u4e00\u7cfb\u5217\u6587\u4ef6\u64cd\u4f5c\u7684API\uff0c\u7136\u540e\u5b9e\u73b0\u4e86close\u51fd\u6570\u7528\u4e8e\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 \u64cd\u4f5c\u6587\u4ef6\u7cfb\u7edfAPI \u8fd9\u91cc\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8fdb\u884c\u5206\u6790 1. async function readFile(path, options) { 2. options = getOptions(options, { flag: 'r' }); 3. const flag = options.flag || 'r'; 4. // \u4ee5\u9762\u5411\u5bf9\u8c61\u7684\u65b9\u5f0f\u4f7f\u7528\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u81ea\u5df1\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 5. if (path instanceof FileHandle) 6. return readFileHandle(path, options); 7. // \u76f4\u63a5\u8c03\u7528\uff0c\u9996\u5148\u9700\u8981\u5148\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8bfb\u53d6\u5b8c\u6bd5\u540eNode.js\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 8. const fd = await open(path, flag, 0o666); 9. return readFileHandle(fd, options).finally(fd.close); 10. } \u4ecereadFile\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u4e0d\u540c\u8c03\u7528\u65b9\u5f0f\u4e0b\uff0cNode.js\u7684\u5904\u7406\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u5f53FileHandle\u662f\u6211\u4eec\u7ef4\u62a4\u65f6\uff0c\u5173\u95ed\u64cd\u4f5c\u4e5f\u662f\u6211\u4eec\u8d1f\u8d23\u6267\u884c\uff0c\u5f53FileHandle\u662fNode.js\u7ef4\u62a4\u65f6\uff0cNode.js\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\u90fd\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u63a5\u7740\u6211\u4eec\u770b\u5230readFileHandle\u7684\u5b9e\u73b0\u3002 1. async function readFileHandle(filehandle, options) { 2. // \u83b7\u53d6\u6587\u4ef6\u5143\u4fe1\u606f 3. const statFields = await binding.fstat(filehandle.fd, false, kUsePromises); 4. 5. let size; 6. // \u662f\u4e0d\u662f\u666e\u901a\u6587\u4ef6\uff0c\u6839\u636e\u6587\u4ef6\u7c7b\u578b\u83b7\u53d6\u5bf9\u5e94\u5927\u5c0f 7. if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) { 8. size = statFields[8/* size */]; 9. } else { 10. size = 0; 11. } 12. // \u592a\u5927\u4e86 13. if (size > kIoMaxLength) 14. throw new ERR_FS_FILE_TOO_LARGE(size); 15. 16. const chunks = []; 17. // \u8ba1\u7b97\u6bcf\u6b21\u8bfb\u53d6\u7684\u5927\u5c0f 18. const chunkSize = size === 0 ? 19. kReadFileMaxChunkSize : 20. MathMin(size, kReadFileMaxChunkSize); 21. let endOfFile = false; 22. do { 23. // \u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e 24. const buf = Buffer.alloc(chunkSize); 25. // \u8bfb\u53d6\u7684\u6570\u636e\u548c\u5927\u5c0f 26. const { bytesRead, buffer } = 27. await read(filehandle, buf, 0, chunkSize, -1); 28. // \u662f\u5426\u8bfb\u5b8c\u4e86 29. endOfFile = bytesRead === 0; 30. // \u8bfb\u53d6\u4e86\u6709\u6548\u6570\u636e\u5219\u628a\u6709\u6548\u6570\u636e\u90e8\u5206\u5b58\u8d77\u6765 31. if (bytesRead > 0) 32. chunks.push(buffer.slice(0, bytesRead)); 33. } while (!endOfFile); 34. 35. const result = Buffer.concat(chunks); 36. if (options.encoding) { 37. return result.toString(options.encoding); 38. } else { 39. return result; 40. } 41. } \u63a5\u7740\u6211\u4eec\u770bread\u51fd\u6570\u7684\u5b9e\u73b0 1. async function read(handle, buffer, offset, length, position) { 2. // ... 3. const bytesRead = (await binding.read(handle.fd, buffer, offset, length, position, kUsePromises)) || 0; 4. return { bytesRead, buffer }; 5. } Read\u6700\u7ec8\u6267\u884c\u4e86node_file.cc \u7684Read\u3002\u6211\u4eec\u770b\u4e00\u4e0bRead\u51fd\u6570\u7684\u5173\u952e\u4ee3\u7801\u3002 1. static void Read(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. // ... 4. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); 5. // \u5f02\u6b65\u6267\u884c\uff0c\u6709\u4e24\u79cd\u60c5\u51b5 6. if (req_wrap_async != nullptr) { 7. AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger, 8. uv_fs_read, fd, &uvbuf, 1, pos); 9. } else { 10. // \u540c\u6b65\u6267\u884c\uff0c\u6bd4\u5982fs.readFileSync 11. CHECK_EQ(argc, 7); 12. FSReqWrapSync req_wrap_sync; 13. FS_SYNC_TRACE_BEGIN(read); 14. const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, \"read\", 15. uv_fs_read, fd, &uvbuf, 1, pos); 16. FS_SYNC_TRACE_END(read, \"bytesRead\", bytesRead); 17. args.GetReturnValue().Set(bytesRead); 18. } 19. } Read\u51fd\u6570\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff0c\u540c\u6b65\u548c\u5f02\u6b65\uff0c\u5176\u4e2d\u5f02\u6b65\u53c8\u5206\u4e3a\u4e24\u79cd\uff0ccallback\u6a21\u5f0f\u548cPromise\u6a21\u5f0f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f02\u6b65\u6a21\u5f0f\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u8fd9\u53e5\u4ee3\u7801\u3002 1. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); GetReqWrap\u6839\u636e\u7b2c\u516d\u4e2a\u53c2\u6570\u83b7\u53d6\u5bf9\u5e94\u7684\u503c\u3002 1. FSReqBase* GetReqWrap(Environment* env, v8::Local<v8::Value> value, 2. bool use_bigint) { 3. // \u662f\u5bf9\u8c61\u8bf4\u660e\u662f\u7ee7\u627fFSReqBase\u7684\u5bf9\u8c61,\u6bd4\u5982FSReqCallback\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 4. if (value->IsObject()) { 5. return Unwrap<FSReqBase>(value.As<v8::Object>()); 6. } else if (value->StrictEquals(env->fs_use_promises_symbol())) { 7. // Promise\u6a21\u5f0f\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 8. if (use_bigint) { 9. return FSReqPromise<AliasedBigUint64Array>::New(env, use_bigint); 10. } else { 11. return FSReqPromise<AliasedFloat64Array>::New(env, use_bigint); 12. } 13. } 14. // \u540c\u6b65\u6a21\u5f0f 15. return nullptr; 16. } \u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8Promise\u6a21\u5f0f\u3002\u6240\u4ee5GetReqWrap\u8fd4\u56de\u7684\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\uff0c\u6211\u4eec\u56de\u5230Read\u51fd\u6570\u3002\u770b\u5230\u4ee5\u4e0b\u4ee3\u7801 1. FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); 2. AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger, 3. uv_fs_read, fd, &uvbuf, 1, pos); \u7ee7\u7eed\u770bAsyncCall\u51fd\u6570\uff08node_file-inl.h\uff09 1. template <typename Func, typename... Args> 2. FSReqBase* AsyncCall(Environment* env, 3. FSReqBase* req_wrap, 4. const v8::FunctionCallbackInfo<v8::Value>& args, 5. const char* syscall, enum encoding enc, 6. uv_fs_cb after, Func fn, Args... fn_args) { 7. return AsyncDestCall(env, req_wrap, args, 8. syscall, nullptr, 0, enc, 9. after, fn, fn_args...); 10. } AsyncCall\u662f\u5bf9AsyncDestCall\u7684\u5c01\u88c5 1. template <typename Func, typename... Args> 2. FSReqBase* AsyncDestCall(Environment* env, FSReqBase* req_wrap, 3. const v8::FunctionCallbackInfo<v8::Value>& args, 4. const char* syscall, const char* dest, 5. size_t len, enum encoding enc, uv_fs_cb after, 6. Func fn, Args... fn_args) { 7. CHECK_NOT_NULL(req_wrap); 8. req_wrap->Init(syscall, dest, len, enc); 9. // \u8c03\u7528libuv\u51fd\u6570 10. int err = req_wrap->Dispatch(fn, fn_args..., after); 11. // \u5931\u8d25\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c\u5426\u5219\u8fd4\u56de\u4e00\u4e2aPromise\uff0c\u89c1SetReturnValue\u51fd\u6570 12. if (err < 0) { 13. uv_fs_t* uv_req = req_wrap->req(); 14. uv_req->result = err; 15. uv_req->path = nullptr; 16. after(uv_req); // after may delete req_wrap if there is an error 17. req_wrap = nullptr; 18. } else { 19. req_wrap->SetReturnValue(args); 20. } 21. 22. return req_wrap; 23. } AsyncDestCall\u51fd\u6570\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u901a\u8fc7Dispatch\u8c03\u7528\u5e95\u5c42Libuv\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u8fd9\u91cc\u662fuv_fs_read\u3002\u5982\u679c\u51fa\u9519\u6267\u884c\u56de\u8c03\u8fd4\u56de\u9519\u8bef\uff0c\u5426\u5219\u6267\u884creq_wrap->SetReturnValue(args)\u3002\u6211\u4eec\u77e5\u9053req_wrap\u662f\u5728GetReqWrap\u51fd\u6570\u4e2d\u7531FSReqPromise ::New(env, use_bigint)\u521b\u5efa\u3002 1. template <typename AliasedBufferT> 2. FSReqPromise<AliasedBufferT>* 3. FSReqPromise<AliasedBufferT>::New(Environment* env, bool use_bigint) { 4. v8::Local<v8::Object> obj; 5. // \u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u5b58\u5230obj\u4e2d 6. if (!env->fsreqpromise_constructor_template() 7. ->NewInstance(env->context()) 8. .ToLocal(&obj)) { 9. return nullptr; 10. } 11. // \u8bbe\u7f6e\u4e00\u4e2apromise\u5c5e\u6027\uff0c\u503c\u662f\u4e00\u4e2aPromise::Resolver 12. v8::Local<v8::Promise::Resolver> resolver; 13. if (!v8::Promise::Resolver::New(env->context()).ToLocal(&resolver) || 14. obj->Set(env->context(), env->promise_string(), resolver).IsNothing()) { 15. return nullptr; 16. } 17. // \u8fd4\u56de\u53e6\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86obj\uff0cobj\u4e5f\u4fdd\u5b58\u4e86\u6307\u5411FSReqPromise\u5bf9\u8c61\u7684\u6307\u9488 18. return new FSReqPromise(env, obj, use_bigint); 19. } \u6240\u4ee5req_wrap\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bFSReqPromise\u5bf9\u8c61\u7684SetReturnValue\u65b9\u6cd5\u3002 1. template <typename AliasedBufferT> 2. void FSReqPromise<AliasedBufferT>::SetReturnValue( 3. const v8::FunctionCallbackInfo<v8::Value>& args) { 4. // \u62ff\u5230Promise::Resolver\u5bf9\u8c61 5. v8::Local<v8::Value> val = 6. object()->Get(env()->context(), 7. env()->promise_string()).ToLocalChecked(); 8. v8::Local<v8::Promise::Resolver> resolver = val.As<v8::Promise::Resolver>(); 9. // \u62ff\u5230\u4e00\u4e2aPromise\u4f5c\u4e3a\u8fd4\u56de\u503c\uff0c\u5373JS\u5c42\u62ff\u5230\u7684\u503c 10. args.GetReturnValue().Set(resolver->GetPromise()); 11. } \u81f3\u6b64\u6211\u4eec\u770b\u5230\u4e86\u65b0\u7248API\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u6b63\u662f\u8fd9\u4e2aPromise\u8fd4\u56de\u503c\u3002\u901a\u8fc7\u5c42\u5c42\u8fd4\u56de\u540e\uff0c\u5728JS\u5c42\u5c31\u62ff\u5230\u8fd9\u4e2aPromise\uff0c\u7136\u540e\u5904\u4e8epending\u72b6\u6001\u7b49\u5f85\u51b3\u8bae\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0bPromise\u51b3\u8bae\u7684\u903b\u8f91\u3002\u5728\u5206\u6790Read\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\u6267\u884cLibuv\u7684uv_fs_read\u51fd\u6570\u65f6\uff0c\u8bbe\u7f6e\u7684\u56de\u8c03\u662fAfterInteger\u3002\u90a3\u4e48\u5f53\u8bfb\u53d6\u6587\u4ef6\u6210\u529f\u540e\u5c31\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1. void AfterInteger(uv_fs_t* req) { 2. // \u901a\u8fc7\u5c5e\u6027\u62ff\u5230\u5bf9\u8c61\u7684\u5730\u5740 3. FSReqBase* req_wrap = FSReqBase::from_req(req); 4. FSReqAfterScope after(req_wrap, req); 5. 6. if (after.Proceed()) 7. req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), req->result)); 8. } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bResolve 1. template <typename AliasedBufferT> 2. void FSReqPromise<AliasedBufferT>::Resolve(v8::Local<v8::Value> value) { 3. finished_ = true; 4. v8::HandleScope scope(env()->isolate()); 5. InternalCallbackScope callback_scope(this); 6. // \u62ff\u5230\u4fdd\u5b58\u7684Promise\u5bf9\u8c61\uff0c\u4fee\u6539\u72b6\u6001\u4e3aresolve\uff0c\u5e76\u8bbe\u7f6e\u7ed3\u679c 7. v8::Local<v8::Value> val = 8. object()->Get(env()->context(), 9. env()->promise_string()).ToLocalChecked(); 10. v8::Local<v8::Promise::Resolver> resolver = val.As<v8::Promise::Resolver>(); 11. USE(resolver->Resolve(env()->context(), value).FromJust()); 12. } Resolve\u51fd\u6570\u4fee\u6539Promise\u7684\u72b6\u6001\u548c\u8bbe\u7f6e\u8fd4\u56de\u503c\uff0c\u4ece\u800cJS\u5c42\u62ff\u5230\u8fd9\u4e2a\u51b3\u8bae\u7684\u503c\u3002\u56de\u5230fs\u5c42 1. const bytesRead = (await binding.read(handle.fd, 2. buffer, 3. offset, 4. length, 5. position, kUsePromises))|0; \u6211\u4eec\u5c31\u62ff\u5230\u4e86\u8fd4\u56de\u503c\u3002","title":"12.4 Promise\u5316API"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#125-api","text":"\u524d\u9762\u5206\u6790\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u591a\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u65b9\u5f0f\uff0c\u4e0d\u7ba1\u662f\u540c\u6b65\u3001\u5f02\u6b65\u8fd8\u662fPromise\u5316\u7684API\uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u5bf9\u4e8e\u7528\u6237\u6765\u8bf4\uff0c\u6587\u4ef6\u64cd\u4f5c\u90fd\u662f\u4e00\u6b21\u6027\u5b8c\u6210\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8c03\u7528readFile\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u628a\u6240\u6709\u7684\u6587\u4ef6\u5185\u5bb9\u8bfb\u5230\u5185\u5b58\u4e2d\uff0c\u540c\u6837\u6211\u4eec\u8c03\u7528writeFile\u5199\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u628a\u7528\u6237\u7684\u6570\u636e\u5199\u5165\u786c\u76d8\uff0c\u8fd9\u5bf9\u5185\u5b58\u6765\u8bf4\u662f\u975e\u5e38\u6709\u538b\u529b\u7684\u3002\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u6837\u7684\u4e00\u4e2a\u573a\u666f\uff0c\u6211\u4eec\u9700\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u524d\u7aef\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u8bfb\u53d6\u6574\u4e2a\u6587\u4ef6\u5185\u5bb9\uff0c\u7136\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c\u8fd9\u65e0\u7591\u662f\u975e\u5e38\u6d88\u8017\u5185\u5b58\uff0c\u4e5f\u662f\u975e\u5e38\u4f4e\u6548\u7684\u3002 1. const http = require('http'); 2. const fs = require('fs'); 3. const server = http.createServer((req, res) => { 4. fs.readFile('11111.md', (err, data) => { 5. res.end(data); 6. }) 7. }).listen(11111); \u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u4f7f\u7528\u6d41\u5f0f\u7684API\u3002 1. const http = require('http'); 2. const fs = require('fs'); 3. const server = http.createServer((req, res) => { 4. fs.createReadStream('11111.md').pipe(res); 5. }).listen(11111); \u6d41\u5f0fAPI\u7684\u597d\u5904\u5728\u4e8e\u6587\u4ef6\u7684\u5185\u5bb9\u5e76\u4e0d\u662f\u4e00\u6b21\u6027\u8bfb\u53d6\u5230\u5185\u5b58\u7684\uff0c\u800c\u662f\u90e8\u5206\u8bfb\u53d6\uff0c\u6d88\u8d39\u5b8c\u540e\u518d\u7ee7\u7eed\u8bfb\u53d6\u3002Node.js\u5185\u90e8\u5e2e\u6211\u4eec\u505a\u4e86\u6d41\u91cf\u7684\u63a7\u5236\uff0c\u5982\u56fe12-5\u6240\u793a\u3002 \u56fe12-5 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6d41\u5f0fAPI\u7684\u5177\u4f53\u5b9e\u73b0\u3002","title":"12.5 \u6d41\u5f0fAPI"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1251","text":"\u53ef\u8bfb\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u8bfb\u53d6\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createReadStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u8bfb\u6d41\u3002\u6587\u4ef6\u53ef\u8bfb\u6d41\u7ee7\u627f\u4e8e\u53ef\u8bfb\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u8bfb\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1. const fs = require('fs'); 2. const { Writable } = require('stream'); 3. class DemoWritable extends Writable { 4. _write(data, encoding, cb) { 5. console.log(data); 6. cb(null); 7. } 8. } 9. fs.createReadStream('11111.md').pipe(new DemoWritable); \u6216\u8005 1. const fs = require('fs'); 2. const readStream = fs.createReadStream('11111.md'); 3. readStream.on('data', (data) => { 4. console.log(data) 5. }); \u6211\u4eec\u770b\u4e00\u4e0bcreateReadStream\u7684\u5b9e\u73b0\u3002 1. fs.createReadStream = function(path, options) { 2. return new ReadStream(path, options); 3. }; CreateReadStream\u662f\u5bf9ReadStream\u7684\u5c01\u88c5\u3002 1. function ReadStream(path, options) { 2. if (!(this instanceof ReadStream)) 3. return new ReadStream(path, options); 4. 5. options = copyObject(getOptions(options, {})); 6. // \u53ef\u8bfb\u6d41\u7684\u9608\u503c 7. if (options.highWaterMark === undefined) 8. options.highWaterMark = 64 * 1024; 9. 10. Readable.call(this, options); 11. 12. handleError((this.path = getPathFromURL(path))); 13. // \u652f\u6301\u4f20\u6587\u4ef6\u8def\u5f84\u6216\u6587\u4ef6\u63cf\u8ff0\u7b26 14. this.fd = options.fd === undefined ? null : options.fd; 15. this.flags = options.flags === undefined ? 'r' : options.flags; 16. this.mode = options.mode === undefined ? 0o666 : options.mode; 17. // \u8bfb\u53d6\u7684\u5f00\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e 18. this.start = typeof this.fd !== 'number' && options.start === undefined ? 19. 0 : options.start; 20. this.end = options.end; 21. // \u6d41\u51fa\u9519\u6216\u7ed3\u675f\u65f6\u662f\u5426\u81ea\u52a8\u9500\u6bc1\u6d41 22. this.autoClose = options.autoClose === undefined ? true : options.autoClose; 23. this.pos = undefined; 24. // \u5df2\u8bfb\u7684\u5b57\u8282\u6570 25. this.bytesRead = 0; 26. // \u6d41\u662f\u5426\u5df2\u7ecf\u5173\u95ed 27. this.closed = false; 28. // \u53c2\u6570\u6821\u9a8c 29. if (this.start !== undefined) { 30. if (typeof this.start !== 'number') { 31. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 32. 'start', 33. 'number', 34. this.start); 35. } 36. // \u9ed8\u8ba4\u8bfb\u53d6\u5168\u90e8\u5185\u5bb9 37. if (this.end === undefined) { 38. this.end = Infinity; 39. } else if (typeof this.end !== 'number') { 40. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 41. 'end', 42. 'number', 43. this.end); 44. } 45. 46. // \u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\uff0cstart\u662f\u5f00\u59cb\u4f4d\u7f6e\uff0cpos\u662f\u5f53\u524d\u4f4d\u7f6e\uff0c\u521d\u59cb\u5316\u7b49\u4e8e\u5f00\u59cb\u4f4d\u7f6e 47. this.pos = this.start; 48. } 49. // \u5982\u679c\u662f\u6839\u636e\u4e00\u4e2a\u6587\u4ef6\u540d\u521b\u5efa\u4e00\u4e2a\u6d41\uff0c\u5219\u9996\u5148\u6253\u5f00\u8fd9\u4e2a\u6587\u4ef6 50. if (typeof this.fd !== 'number') 51. this.open(); 52. 53. this.on('end', function() { 54. // \u6d41\u7ed3\u675f\u65f6\u81ea\u52a8\u9500\u6bc1\u6d41 55. if (this.autoClose) { 56. this.destroy(); 57. } 58. }); 59. } ReadStream\u521d\u59cb\u5316\u5b8c\u540e\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u8c03\u7528open\u6253\u5f00\u6587\u4ef6\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u63a5\u7740\u76d1\u542c\u6d41\u7ed3\u675f\u4e8b\u4ef6\uff0c\u7528\u6237\u53ef\u4ee5\u8bbe\u7f6eautoClose\u9009\u9879\u63a7\u5236\u5f53\u6d41\u7ed3\u675f\u6216\u8005\u51fa\u9519\u65f6\u662f\u5426\u9500\u6bc1\u6d41\uff0c\u5bf9\u4e8e\u6587\u4ef6\u6d41\u6765\u8bf4\uff0c\u9500\u6bc1\u6d41\u610f\u5473\u7740\u5173\u95ed\u5730\u65b9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bopen\u7684\u5b9e\u73b0 1. // \u6253\u5f00\u6587\u4ef6 2. ReadStream.prototype.open = function() { 3. var self = this; 4. fs.open(this.path, this.flags, this.mode, function(er, fd) { 5. if (er) { 6. // \u53d1\u751f\u9519\u8bef\uff0c\u662f\u5426\u9700\u8981\u81ea\u52a8\u9500\u6bc1\u6d41 7. if (self.autoClose) { 8. self.destroy(); 9. } 10. // \u901a\u77e5\u7528\u6237 11. self.emit('error', er); 12. return; 13. } 14. 15. self.fd = fd; 16. // \u89e6\u53d1open\uff0c\u4e00\u822c\u7528\u4e8eNode.js\u5185\u90e8\u903b\u8f91 17. self.emit('open', fd); 18. // start the flow of data. 19. // \u6253\u5f00\u6210\u529f\u540e\u5f00\u59cb\u6d41\u5f0f\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9 20. self.read(); 21. }); 22. }; open\u51fd\u6570\u9996\u5148\u6253\u5f00\u6587\u4ef6\uff0c\u6253\u5f00\u6210\u529f\u540e\u5f00\u542f\u6d41\u5f0f\u8bfb\u53d6\u3002\u4ece\u800c\u6587\u4ef6\u5185\u5bb9\u5c31\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u76ee\u7684\u6d41\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8bfb\u53d6\u64cd\u4f5c\u7684\u5b9e\u73b0\u3002 1. // \u5b9e\u73b0\u53ef\u8bfb\u6d41\u7684\u94a9\u5b50\u51fd\u6570 2. ReadStream.prototype._read = function(n) { 3. // \u5982\u679c\u6ca1\u6709\u8c03\u7528open\u800c\u662f\u76f4\u63a5\u8c03\u7528\u8be5\u65b9\u6cd5\u5219\u5148\u6267\u884copen 4. if (typeof this.fd !== 'number') { 5. return this.once('open', function() { 6. this._read(n); 7. }); 8. } 9. // \u6d41\u5df2\u7ecf\u9500\u6bc1\u5219\u4e0d\u5904\u7406 10. if (this.destroyed) 11. return; 12. // \u5224\u65ad\u6c60\u5b50\u7a7a\u95f4\u662f\u5426\u8db3\u591f\uff0c\u4e0d\u591f\u5219\u7533\u8bf7\u65b0\u7684 13. if (!pool || pool.length - pool.used < kMinPoolSpace) { 14. // discard the old pool. 15. allocNewPool(this.readableHighWaterMark); 16. } 17. 18. // \u8ba1\u7b97\u53ef\u8bfb\u7684\u6700\u5927\u6570\u91cf 19. var thisPool = pool; 20. /* 21. \u53ef\u8bfb\u53d6\u7684\u6700\u5927\u503c,\u53d6\u53ef\u7528\u5185\u5b58\u5927\u5c0f\u548cNode.js\u6253\u7b97\u8bfb\u53d6\u7684\u5927\u5c0f 22. \u4e2d\u7684\u5c0f\u503c,n\u4e0d\u662f\u7528\u6237\u60f3\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u800c\u662f\u53ef\u8bfb\u6d41\u5185\u90e8\u7684\u903b\u8f91 23. \u89c1_stream_readable.js\u7684this._read(state.highWaterMark) 24. */ 25. var toRead = Math.min(pool.length - pool.used, n); 26. var start = pool.used; 27. // \u5df2\u7ecf\u8bfb\u53d6\u4e86\u90e8\u5206\u4e86\uff0c\u5219\u8ba1\u7b97\u5269\u4e0b\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u548c\u8ba1\u7b97\u8bfb\u53d6\u7684toRead\u6bd4\u8f83\u53d6\u5c0f\u503c 28. if (this.pos !== undefined) 29. toRead = Math.min(this.end - this.pos + 1, toRead); 30. 31. // \u8bfb\u7ed3\u675f 32. if (toRead <= 0) 33. return this.push(null); 34. 35. // pool.used\u662f\u5373\u5c06\u8bfb\u53d6\u7684\u6570\u636e\u5b58\u50a8\u5728pool\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\uff0cthis.pos\u662f\u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\u53d6 36. fs.read(this.fd, pool, pool.used, toRead, this.pos, (er, bytesRead) => { 37. if (er) { 38. if (this.autoClose) { 39. this.destroy(); 40. } 41. this.emit('error', er); 42. } else { 43. var b = null; 44. if (bytesRead > 0) { 45. // \u5df2\u8bfb\u7684\u5b57\u8282\u6570\u7d2f\u52a0 46. this.bytesRead += bytesRead; 47. // \u83b7\u53d6\u6709\u6548\u6570\u636e 48. b = thisPool.slice(start, start + bytesRead); 49. } 50. // push\u5230\u5e95\u5c42\u6d41\u7684bufferList\u4e2d\uff0c\u5e95\u5c42\u7684push\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 51. this.push(b); 52. } 53. }); 54. 55. // \u91cd\u65b0\u8bbe\u7f6e\u5df2\u8bfb\u6307\u9488\u7684\u4f4d\u7f6e 56. if (this.pos !== undefined) 57. this.pos += toRead; 58. pool.used += toRead; 59. }; \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662f\u8c03\u7528\u5f02\u6b65read\u51fd\u6570\u8bfb\u53d6\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u653e\u5230\u53ef\u8bfb\u6d41\u4e2d\uff0c\u53ef\u8bfb\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u6570\u636e\u5230\u6765\uff0c\u7136\u540e\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8\u7740\u6570\u636e\u7684\u8bfb\u53d6\uff08\u53ef\u8bfb\u6d41\u4f1a\u6839\u636e\u5f53\u524d\u60c5\u51b5\u5224\u65ad\u662f\u5426\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ee5\u8fbe\u5230\u6d41\u91cf\u63a7\u5236\u7684\u76ee\u7684\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u548c\u9500\u6bc1\u4e00\u4e2a\u6587\u4ef6\u6d41\u7684\u5b9e\u73b0\u3002 1. ReadStream.prototype.close = function(cb) { 2. this.destroy(null, cb); 3. }; \u5f53\u6211\u4eec\u8bbe\u7f6eautoClose\u4e3afalse\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u9700\u8981\u81ea\u5df1\u624b\u52a8\u8c03\u7528close\u51fd\u6570\u5173\u95ed\u53ef\u8bfb\u6587\u4ef6\u6d41\u3002\u5173\u95ed\u6587\u4ef6\u6d41\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6b63\u5e38\u5730\u9500\u6bc1\u6d41\u3002\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0cNode.js\u505a\u4e86\u4ec0\u4e48\u3002 1. // \u5173\u95ed\u5e95\u5c42\u6587\u4ef6 2. ReadStream.prototype._destroy = function(err, cb) { 3. const isOpen = typeof this.fd !== 'number'; 4. if (isOpen) { 5. this.once('open', closeFsStream.bind(null, this, cb, err)); 6. return; 7. } 8. 9. closeFsStream(this, cb); 10. this.fd = null; 11. }; 12. 13. function closeFsStream(stream, cb, err) { 14. fs.close(stream.fd, (er) => { 15. er = er || err; 16. cb(er); 17. stream.closed = true; 18. if (!er) 19. stream.emit('close'); 20. }); 21. } \u9500\u6bc1\u6587\u4ef6\u6d41\u5c31\u662f\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u53e6\u5916\u5982\u679c\u662f\u56e0\u4e3a\u53d1\u751f\u9519\u8bef\u5bfc\u81f4\u9500\u6bc1\u6216\u8005\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u9519\u8bef\u5219\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002","title":"12.5.1 \u53ef\u8bfb\u6587\u4ef6\u6d41"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1252","text":"\u53ef\u5199\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u5199\u5165\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createWriteStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u5199\u6d41\u3002\u6587\u4ef6\u53ef\u4e9b\u6d41\u7ee7\u627f\u4e8e\u53ef\u5199\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u5199\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1. const fs = require('fs'); 2. const writeStream = fs.createWriteStream('123.md'); 3. writeStream.end('world'); \u6216\u8005 1. const fs = require('fs'); 2. const { Readable } = require('stream'); 3. 4. class DemoReadStream extends Readable { 5. constructor() { 6. super(); 7. this.i = 0; 8. } 9. _read(n) { 10. this.i++; 11. if (this.i > 10) { 12. this.push(null); 13. } else { 14. this.push('1'.repeat(n)); 15. } 16. 17. } 18. } 19. new DemoReadStream().pipe(fs.createWriteStream('123.md')); \u6211\u4eec\u770b\u4e00\u4e0bcreateWriteStream\u7684\u5b9e\u73b0\u3002 1. fs.createWriteStream = function(path, options) { 2. return new WriteStream(path, options); 3. }; createWriteStream\u662f\u5bf9WriteStream\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bWriteStream\u7684\u5b9e\u73b0 1. function WriteStream(path, options) { 2. if (!(this instanceof WriteStream)) 3. return new WriteStream(path, options); 4. options = copyObject(getOptions(options, {})); 5. 6. Writable.call(this, options); 7. 8. handleError((this.path = getPathFromURL(path))); 9. this.fd = options.fd === undefined ? null : options.fd; 10. this.flags = options.flags === undefined ? 'w' : options.flags; 11. this.mode = options.mode === undefined ? 0o666 : options.mode; 12. // \u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e 13. this.start = options.start; 14. // \u6d41\u7ed3\u675f\u548c\u89e6\u53d1\u9519\u8bef\u7684\u65f6\u5019\u662f\u5426\u9500\u6bc1\u6d41 15. this.autoClose = options.autoClose === undefined ? true : !!options.autoClose; 16. // \u5f53\u524d\u5199\u5165\u4f4d\u7f6e 17. this.pos = undefined; 18. // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570 19. this.bytesWritten = 0; 20. this.closed = false; 21. 22. if (this.start !== undefined) { 23. if (typeof this.start !== 'number') { 24. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 25. 'start', 26. 'number', 27. this.start); 28. } 29. if (this.start < 0) { 30. const errVal = `{start: ${this.start}}`; 31. throw new errors.RangeError('ERR_OUT_OF_RANGE', 32. 'start', 33. '>= 0', 34. errVal); 35. } 36. // \u8bb0\u5f55\u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e 37. this.pos = this.start; 38. } 39. 40. if (options.encoding) 41. this.setDefaultEncoding(options.encoding); 42. // \u6ca1\u6709\u4f20\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u6253\u5f00\u4e00\u4e2a\u65b0\u7684\u6587\u4ef6 43. if (typeof this.fd !== 'number') 44. this.open(); 45. 46. // \u76d1\u542c\u53ef\u5199\u6d41\u7684finish\u4e8b\u4ef6\uff0c\u5224\u65ad\u662f\u5426\u9700\u8981\u6267\u884c\u9500\u6bc1\u64cd\u4f5c 47. this.once('finish', function() { 48. if (this.autoClose) { 49. this.destroy(); 50. } 51. }); 52. } WriteStream\u521d\u59cb\u5316\u4e86\u4e00\u7cfb\u5217\u5b57\u6bb5\u540e\uff0c\u5982\u679c\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u5219\u6253\u5f00\u6587\u4ef6\uff0c\u5982\u679c\u4f20\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6253\u5f00\u6587\u4ef6\u3002\u540e\u7eed\u5bf9\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u64cd\u4f5c\u5c31\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5199\u5165\u6587\u4ef6\u7684\u903b\u8f91\u3002\u6211\u4eec\u77e5\u9053\u53ef\u5199\u6d41\u53ea\u662f\u5b9e\u73b0\u4e86\u4e00\u4e9b\u62bd\u8c61\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u5199\u903b\u8f91\u662f\u5177\u4f53\u7684\u6d41\u901a\u8fc7_write\u6216\u8005_writev\u5b9e\u73b0\u7684\uff0c\u6211\u4eec\u770b\u4e00\u4e0b_write\u7684\u5b9e\u73b0\u3002 1. WriteStream.prototype._write = function(data, encoding, cb) { 2. if (!(data instanceof Buffer)) { 3. const err = new errors.TypeError('ERR_INVALID_ARG_TYPE', 4. 'data', 5. 'Buffer', 6. data); 7. return this.emit('error', err); 8. } 9. // \u8fd8\u6ca1\u6253\u5f00\u6587\u4ef6\uff0c\u5219\u7b49\u5f85\u6253\u5f00\u6210\u529f\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c 10. if (typeof this.fd !== 'number') { 11. return this.once('open', function() { 12. this._write(data, encoding, cb); 13. }); 14. } 15. // \u6267\u884c\u5199\u64cd\u4f5c,0\u4ee3\u8868\u4ecedata\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5199\uff0c\u8fd9\u91cc\u662f\u5168\u90e8\u5199\u5165\uff0c\u6240\u4ee5\u662f0\uff0cpos\u4ee3\u8868\u6587\u4ef6\u7684\u4f4d\u7f6e 16. fs.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => { 17. if (er) { 18. if (this.autoClose) { 19. this.destroy(); 20. } 21. return cb(er); 22. } 23. // \u5199\u5165\u6210\u529f\u7684\u5b57\u8282\u957f\u5ea6 24. this.bytesWritten += bytes; 25. cb(); 26. }); 27. // \u4e0b\u4e00\u4e2a\u5199\u5165\u7684\u4f4d\u7f6e 28. if (this.pos !== undefined) 29. this.pos += data.length; 30. }; _write\u5c31\u662f\u6839\u636e\u7528\u6237\u4f20\u5165\u6570\u636e\u7684\u5927\u5c0f\uff0c\u4e0d\u65ad\u8c03\u7528fs.write\u5f80\u5e95\u5c42\u5199\u5165\u6570\u636e\uff0c\u76f4\u5230\u5199\u5b8c\u6210\u6216\u8005\u51fa\u9519\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u7684\u903b\u8f91\u3002 1. // \u5b9e\u73b0\u53ef\u5199\u6d41\u6279\u91cf\u5199\u94a9\u5b50 2. WriteStream.prototype._writev = function(data, cb) { 3. if (typeof this.fd !== 'number') { 4. return this.once('open', function() { 5. this._writev(data, cb); 6. }); 7. } 8. 9. const self = this; 10. const len = data.length; 11. const chunks = new Array(len); 12. var size = 0; 13. // \u8ba1\u7b97\u5f85\u5199\u5165\u7684\u51fa\u603b\u5927\u5c0f\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4fdd\u5b58\u5230chunk\u6570\u7ec4\u4e2d\uff0c\u51c6\u5907\u5199\u5165 14. for (var i = 0; i < len; i++) { 15. var chunk = data[i].chunk; 16. 17. chunks[i] = chunk; 18. size += chunk.length; 19. } 20. // \u6267\u884c\u6279\u91cf\u5199 21. writev(this.fd, chunks, this.pos, function(er, bytes) { 22. if (er) { 23. self.destroy(); 24. return cb(er); 25. } 26. // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u53ef\u80fd\u5c0f\u4e8e\u5e0c\u671b\u5199\u5165\u7684\u5b57\u8282\u6570 27. self.bytesWritten += bytes; 28. cb(); 29. }); 30. /* 31. \u66f4\u65b0\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\uff0c\u5982\u679c\u5199\u90e8\u5206\u6210\u529f\uff0c\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\u65f6 32. \u4e5f\u4f1a\u5305\u62ec\u6ca1\u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u6240\u4ee5\u662f\u5047\u8bbesize\u800c\u4e0d\u662fbytes 33. */ 34. if (this.pos !== undefined) 35. this.pos += size; 36. }; \u6279\u91cf\u5199\u5165\u7684\u903b\u8f91\u548c_write\u7c7b\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u5b83\u8c03\u7528\u7684\u662f\u4e0d\u540c\u7684\u63a5\u53e3\u5f80\u5e95\u5c42\u5199\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u5173\u95ed\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1. WriteStream.prototype.close = function(cb) { 2. // \u5173\u95ed\u6587\u4ef6\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 3. if (cb) { 4. if (this.closed) { 5. process.nextTick(cb); 6. return; 7. } else { 8. this.on('close', cb); 9. } 10. } 11. 12. /* 13. \u5982\u679cautoClose\u662ffalse\uff0c\u8bf4\u660e\u6d41\u7ed3\u675f\u89e6\u53d1finish\u4e8b\u4ef6\u65f6\uff0c\u4e0d\u4f1a\u9500\u6bc1\u6d41\uff0c 14. \u89c1WriteStream\u521d\u59cb\u5316\u4ee3\u7801 \u4ee5\u8fd9\u91cc\u9700\u8981\u76d1\u542cfinish\u4e8b\u4ef6\uff0c\u4fdd\u8bc1\u53ef\u5199\u6d41\u7ed3\u675f\u65f6\u53ef\u4ee5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 15. */ 16. if (!this.autoClose) { 17. this.on('finish', this.destroy.bind(this)); 18. } 19. 20. // \u7ed3\u675f\u6d41\uff0c\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6 21. this.end(); 22. }; \u53ef\u5199\u6587\u4ef6\u6d41\u548c\u53ef\u8bfb\u6587\u4ef6\u6d41\u4e0d\u4e00\u6837\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5728\u8bfb\u5b8c\u6587\u4ef6\u5185\u5bb9\u540eNode.js\u4f1a\u81ea\u52a8\u9500\u6bc1\u6d41\uff08\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\uff0c\u800c\u5199\u5165\u6587\u4ef6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0bNode.js\u662f\u65e0\u6cd5\u77e5\u9053\u4ec0\u4e48\u65f6\u5019\u6d41\u7ed3\u675f\u7684\uff0c\u8fd9\u9700\u8981\u6211\u4eec\u663e\u5f0f\u5730\u901a\u77e5Node.js\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u662f\u4e0d\u9700\u8981\u663e\u5f0f\u901a\u77e5Node.js\u7684 1. fs.createReadStream('11111.md').pipe(fs.createWriteStream('123.md')); \u56e0\u4e3a\u53ef\u8bfb\u6587\u4ef6\u6d41\u5728\u6587\u4ef6\u8bfb\u5b8c\u540e\u4f1a\u8c03\u7528\u53ef\u5199\u6587\u4ef6\u7684end\u65b9\u6cd5\uff0c\u4ece\u800c\u5173\u95ed\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u800c\u5728\u4ee5\u4e0b\u4ee3\u7801\u4e2d\u60c5\u51b5\u5c31\u53d8\u5f97\u590d\u6742\u3002 1. const stream = fs.createWriteStream('123.md'); 2. stream.write('hello'); 3. // stream.close \u6216 stream.end(); \u5728\u9ed8\u8ba4\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528end\u6216\u8005close\u53bb\u901a\u77e5Node.js\u6d41\u7ed3\u675f\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86autoClose\u4e3afalse\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u80fd\u8c03\u7528close\u800c\u4e0d\u80fd\u8c03\u7528end\u3002\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u56e0\u4e3aend\u53ea\u662f\u5173\u95ed\u4e86\u6d41\u3002\u4f46\u662f\u6ca1\u6709\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u800cclose\u4f1a\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801\u3002 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md'); 3. stream.write('hello'); 4. // \u9632\u6b62\u8fdb\u7a0b\u9000\u51fa 5. setInterval(() => {}); \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u5bfc\u81f4\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u6211\u4eec\u5728Linux\u4e0b\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\uff0c\u901a\u8fc7ps aux\u627e\u5230\u8fdb\u7a0bid\uff0c\u7136\u540e\u6267\u884clsof -p pid\u5c31\u53ef\u4ee5\u770b\u5230\u8fdb\u7a0b\u6253\u5f00\u7684\u6240\u6709\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u8f93\u51fa\u598212-6\u6240\u793a\u3002 \u56fe12-6 \u6587\u4ef6\u63cf\u8ff0\u7b2617\u6307\u5411\u4e86123.md\u6587\u4ef6\u3002\u6240\u4ee5\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ca1\u6709\u88ab\u5173\u95ed\uff0c\u5f15\u8d77\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u6211\u4eec\u4fee\u6539\u4e00\u4e0b\u4ee3\u7801\u3002 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md'); 3. stream.end('hello'); 4. setInterval(() => {}); \u4e0b\u9762\u662f\u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\uff0c\u6211\u4eec\u770b\u5230\u6ca1\u6709123.md\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe12-7\u6240\u793a\u3002 \u56fe12-7 \u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md', {autoClose: false}); 3. stream.end('hello'); 4. setInterval(() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-8\u6240\u793a\u3002 \u56fe12-8 \u6211\u4eec\u770b\u5230\u4f7f\u7528end\u4e5f\u65e0\u6cd5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7ee7\u7eed\u4fee\u6539\u3002 1. const fs = require('fs'); 2. const stream = fs.createWriteStream('123.md', {autoClose: false}) 3. stream.close(); 4. setInterval(() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-9\u6240\u793a\u3002 \u56fe12-9 \u6211\u4eec\u770b\u5230\u6210\u529f\u5173\u95ed\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"12.5.2 \u53ef\u5199\u6587\u4ef6\u6d41"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/","text":"\u8fdb\u7a0b\u662f\u64cd\u4f5c\u7cfb\u7edf\u91cc\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\uff0c\u4e5f\u662f\u4e0d\u5bb9\u6613\u7406\u89e3\u7684\u6982\u5ff5\uff0c\u4f46\u662f\u770b\u8d77\u6765\u5f88\u590d\u6742\u7684\u8fdb\u7a0b\uff0c\u5176\u5b9e\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u4ee3\u7801\u91cc\uff0c\u4e5f\u53ea\u662f\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5\uff0c\u53ea\u4e0d\u8fc7\u5b83\u6bd4\u4e00\u822c\u7684\u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5\u66f4\u590d\u6742\u3002\u8fdb\u7a0b\u5728\u64cd\u4f5c\u7cfb\u7edf\u91cc\uff0c\u662f\u7528\u4e00\u4e2atask_struct\u7ed3\u6784\u4f53\u8868\u793a\u7684\u3002\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u662f\u5927\u90e8\u5206\u662f\u7528C\u8bed\u8a00\u5b9e\u73b0\u7684\uff0c\u6ca1\u6709\u5bf9\u8c61\u8fd9\u4e2a\u6982\u5ff5\u3002\u5982\u679c\u6211\u4eec\u7528JS\u6765\u7406\u89e3\u7684\u8bdd\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u5c31\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u6bcf\u6b21\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5c31\u662f\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002task_struct\u7ed3\u6784\u4f53\u91cc\u4fdd\u5b58\u4e86\u4e00\u4e2a\u8fdb\u7a0b\u6240\u9700\u8981\u7684\u4e00\u4e9b\u4fe1\u606f\uff0c\u5305\u62ec\u6267\u884c\u72b6\u6001\u3001\u6267\u884c\u4e0a\u4e0b\u6587\u3001\u6253\u5f00\u7684\u6587\u4ef6\u3001\u6839\u76ee\u5f55\u3001\u5de5\u4f5c\u76ee\u5f55\u3001\u6536\u5230\u7684\u4fe1\u53f7\u3001\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u3001\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7684\u4fe1\u606f\u3001\u8fdb\u7a0bid\u3001\u6267\u884c\u65f6\u95f4\u3001\u9000\u51fa\u7801\u7b49\u7b49\u3002\u672c\u7ae0\u5c06\u4f1a\u4ecb\u7ecdNode.js\u8fdb\u7a0b\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 13.1 Node.js\u4e3b\u8fdb\u7a0b \u00b6 \u5f53\u6211\u4eec\u6267\u884cnode index.js\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aNode.js\u8fdb\u7a0b\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u5c31\u662f\u5728\u8fd9\u4e2aNode.js\u8fdb\u7a0b\u4e2d\u6267\u884c\u3002\u4ece\u4ee3\u7801\u89d2\u5ea6\u6765\u8bf4\uff0c\u6211\u4eec\u5728Node.js\u4e2d\u611f\u77e5\u8fdb\u7a0b\u7684\u65b9\u5f0f\u662f\u901a\u8fc7process\u5bf9\u8c61\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u5bf9\u8c61\u3002 13.1.1 \u521b\u5efaprocess\u5bf9\u8c61 \u00b6 Node.js\u542f\u52a8\u7684\u65f6\u5019\u4f1a\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efaprocess\u5bf9\u8c61\uff08env.cc\uff09\u3002 1. Local<Object> process_object = node::CreateProcessObject(this).FromMaybe(Local<Object>()); 2. set_process_object(process_object); process\u5bf9\u8c61\u901a\u8fc7CreateProcessObject\u521b\u5efa\uff0c\u7136\u540e\u4fdd\u5b58\u5230env\u5bf9\u8c61\u4e2d\u3002\u6211\u4eec\u770b\u4e00\u4e0bCreateProcessObject\u3002 1. MaybeLocal<Object> CreateProcessObject(Environment* env) { 2. Isolate* isolate = env->isolate(); 3. EscapableHandleScope scope(isolate); 4. Local<Context> context = env->context(); 5. 6. Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate); 7. process_template->SetClassName(env->process_string()); 8. Local<Function> process_ctor; 9. Local<Object> process; 10. // \u65b0\u5efaprocess\u5bf9\u8c61 11. if (!process_template->GetFunction(context).ToLocal(&process_ctor) || !process_ctor->NewInstance(context).ToLocal(&process)) { 12. return MaybeLocal<Object>(); 13. } 14. // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u901a\u8fc7process\u5bf9\u8c61\u8bbf\u95ee\u7684\u5c5e\u6027 15. // Node.js\u7684\u7248\u672c 16. READONLY_PROPERTY(process,\"version\", 17. FIXED_ONE_BYTE_STRING(env->isolate(), 18. NODE_VERSION)); 19. // \u5ffd\u7565\u5176\u4ed6\u5c5e\u6027 20. 21. return scope.Escape(process); 22. } \u8fd9\u662f\u4f7f\u7528V8\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u7684\u5178\u578b\u4f8b\u5b50\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5f88\u591a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u6302\u8f7d\u5c5e\u6027\u3002\u4e0b\u9762\u6211\u4eec\u770b\u6211\u4eec\u5e38\u7528\u7684process.env\u662f\u600e\u4e48\u6302\u8f7d\u7684\u3002 13.1.2 \u6302\u8f7denv\u5c5e\u6027 \u00b6 1. Local<String> env_string = FIXED_ONE_BYTE_STRING(isolate_, \"env\"); 2. Local<Object> env_var_proxy; 3. // \u8bbe\u7f6eprocess\u7684env\u5c5e\u6027 4. if (!CreateEnvVarProxy(context(), 5. isolate_, 6. as_callback_data()) 7. .ToLocal(&env_var_proxy) || 8. process_object()->Set(context(), 9. env_string, 10. env_var_proxy).IsNothing()) { 11. return MaybeLocal<Value>(); 12. } \u4e0a\u9762\u7684\u4ee3\u7801\u901a\u8fc7CreateEnvVarProxy\u521b\u5efa\u4e86\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u4fdd\u5b58\u5230env_var_proxy\u4e2d\uff0c\u6700\u540e\u7ed9process\u6302\u8f7d\u4e86env\u5c5e\u6027\u3002\u5b83\u7684\u503c\u662fCreateEnvVarProxy\u521b\u5efa\u7684\u5bf9\u8c61\u3002 1. MaybeLocal<Object> CreateEnvVarProxy(Local<Context> context, 2. Isolate* isolate, 3. Local<Object> data) { 4. EscapableHandleScope scope(isolate); 5. Local<ObjectTemplate> env_proxy_template = ObjectTemplate::New(isolate); 6. env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration( 7. EnvGetter, 8. EnvSetter, 9. EnvQuery, 10. EnvDeleter, 11. EnvEnumerator, 12. data, 13. PropertyHandlerFlags::kHasNoSideEffect)); 14. return scope.EscapeMaybe(env_proxy_template->NewInstance(context)); 15. } CreateEnvVarProxy\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u5bf9\u8c61\u6a21\u677f\uff0c\u7136\u540e\u8bbe\u7f6e\u901a\u8fc7\u8be5\u5bf9\u8c61\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u7684\u8bbf\u95ee\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0bgetter\u63cf\u8ff0\u7b26\uff08EnvGetter\uff09\u7684\u5b9e\u73b0\uff0cgetter\u63cf\u8ff0\u7b26\u548c\u6211\u4eec\u5728JS\u91cc\u4f7f\u7528\u7684\u7c7b\u4f3c\u3002 1. static void EnvGetter(Local<Name> property, 2. const PropertyCallbackInfo<Value>& info) { 3. Environment* env = Environment::GetCurrent(info); 4. MaybeLocal<String> value_string = env->env_vars()->Get(env->isolate(), property.As<String>()); 5. if (!value_string.IsEmpty()) { 6. info.GetReturnValue().Set(value_string.ToLocalChecked()); 7. } 8. } \u6211\u4eec\u770b\u5230getter\u662f\u4eceenv->env_vars()\u4e2d\u83b7\u53d6\u6570\u636e\uff0c\u90a3\u4e48env->env_vars()\u53c8\u662f\u4ec0\u4e48\u5462\uff1fenv_vars\u662f\u4e00\u4e2akv\u5b58\u50a8\u7cfb\u7edf\uff0c\u5176\u5b9e\u5c31\u662f\u4e00\u4e2amap\u3002\u5b83\u53ea\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\uff08\u521b\u5efaenv\u5bf9\u8c61\u65f6\uff09\u3002 set_env_vars(per_process::system_environment); \u90a3\u4e48per_process::system_environment\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\uff0c std::shared_ptr<KVStore> system_environment = std::make_shared<RealEnvStore>(); \u6211\u4eec\u770b\u5230system_environment\u662f\u4e00\u4e2aRealEnvStore\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bRealEnvStore\u7c7b\u7684\u5b9e\u73b0\u3002 1. class RealEnvStore final : public KVStore { 2. public: 3. MaybeLocal<String> Get(Isolate* isolate, Local<String> key) const override; 4. void Set(Isolate* isolate, Local<String> key, Local<String> value) override; 5. int32_t Query(Isolate* isolate, Local<String> key) const override; 6. void Delete(Isolate* isolate, Local<String> key) override; 7. Local<Array> Enumerate(Isolate* isolate) const override; 8. }; \u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u589e\u5220\u6539\u67e5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u67e5\u8be2Get\u7684\u5b9e\u73b0\u3002 1. MaybeLocal<String> RealEnvStore::Get(Isolate* isolate, 2. Local<String> property) const { 3. Mutex::ScopedLock lock(per_process::env_var_mutex); 4. 5. node::Utf8Value key(isolate, property); 6. size_t init_sz = 256; 7. MaybeStackBuffer<char, 256> val; 8. int ret = uv_os_getenv(*key, *val, &init_sz); 9. if (ret >= 0) { // Env key value fetch success. 10. MaybeLocal<String> value_string = 11. String::NewFromUtf8(isolate, 12. *val, 13. NewStringType::kNormal, 14. init_sz); 15. return value_string; 16. } 17. 18. return MaybeLocal<String>(); 19. } \u6211\u4eec\u770b\u5230\u662f\u901a\u8fc7uv_os_getenv\u83b7\u53d6\u7684\u6570\u636e\u3002uv_os_getenv\u662f\u5bf9getenv\u51fd\u6570\u7684\u5c01\u88c5\uff0c\u8fdb\u7a0b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\uff0c\u6709\u4e00\u90e8\u5206\u662f\u7528\u4e8e\u5b58\u50a8\u73af\u5883\u53d8\u91cf\u7684\uff0cgetenv\u5c31\u662f\u4ece\u90a3\u4e00\u5757\u5185\u5b58\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\u3002\u6211\u4eec\u6267\u884cexecve\u7684\u65f6\u5019\u53ef\u4ee5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u3002\u5177\u4f53\u7684\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u7ae0\u8282\u4f1a\u770b\u5230\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u77e5\u9053process\u7684env\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u5c31\u662f\u8fdb\u7a0b\u73af\u5883\u53d8\u91cf\u7684\u5185\u5bb9\u3002 13.1.3 \u6302\u8f7d\u5176\u5b83\u5c5e\u6027 \u00b6 \u5728Node.js\u7684\u542f\u52a8\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5730\u6302\u8f7d\u5c5e\u6027\u5230process\u3002\u4e3b\u8981\u5728bootstrap/node.js\u4e2d\u3002\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1. const rawMethods = internalBinding('process_methods'); 2. process.dlopen = rawMethods.dlopen; 3. process.uptime = rawMethods.uptime; 4. process.nextTick = nextTick; \u4e0b\u9762\u662fprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027\uff0c\u4e3b\u5217\u51fa\u5e38\u7528\u7684\u3002 1. env->SetMethod(target, \"memoryUsage\", MemoryUsage); 2. env->SetMethod(target, \"cpuUsage\", CPUUsage); 3. env->SetMethod(target, \"hrtime\", Hrtime); 4. env->SetMethod(target, \"dlopen\", binding::DLOpen); 5. env->SetMethodNoSideEffect(target, \"uptime\", Uptime); \u6211\u4eec\u770b\u5230\u5728JS\u5c42\u8bbf\u95eeprocess\u5c5e\u6027\u7684\u65f6\u5019\uff0c\u8bbf\u95ee\u7684\u662f\u5bf9\u5e94\u7684C++\u5c42\u7684\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u5927\u90e8\u5206\u4e5f\u53ea\u662f\u5bf9Libuv\u7684\u5c01\u88c5\u3002\u53e6\u5916\u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u6267\u884cPatchProcessObject\u3002PatchProcessObject\u51fd\u6570\u4f1a\u6302\u8f7d\u4e00\u4e9b\u989d\u5916\u7684\u5c5e\u6027\u7ed9process\u3002 1. // process.argv 2. process->Set(context, 3. FIXED_ONE_BYTE_STRING(isolate, \"argv\"), 4. ToV8Value(context, env->argv()).ToLocalChecked()).Check(); 5. 6. READONLY_PROPERTY(process, 7. \"pid\", 8. Integer::New(isolate, uv_os_getpid())); 9. 10. CHECK(process->SetAccessor(context, 11. FIXED_ONE_BYTE_STRING(isolate, \"ppid\"), 12. GetParentProcessId).FromJust()) \u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5728\u591a\u4e2a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027\uff0c\u8fd9\u91cc\u53ea\u5217\u51fa\u4e86\u4e00\u90e8\u5206\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u4ecebootstrap/node.js\u7684\u4ee3\u7801\u5f00\u59cb\u770b\u90fd\u6302\u8f7d\u4e86\u4ec0\u4e48\u5c5e\u6027\u3002\u56e0\u4e3aNode.js\u652f\u6301\u591a\u7ebf\u7a0b\uff0c\u6240\u4ee5\u9488\u5bf9\u7ebf\u7a0b\u7684\u60c5\u51b5\uff0c\u6709\u4e00\u4e9b\u7279\u6b8a\u7684\u5904\u7406\u3002 1. const perThreadSetup = require('internal/process/per_thread'); 2. // rawMethods\u6765\u81eaprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027 3. const wrapped = perThreadSetup.wrapProcessMethods(rawMethods); 4. process.hrtime = wrapped.hrtime; 5. process.cpuUsage = wrapped.cpuUsage; 6. process.memoryUsage = wrapped.memoryUsage; 7. process.kill = wrapped.kill; 8. process.exit = wrapped.exit; \u5927\u90e8\u5206\u51fd\u6570\u90fd\u662f\u5bf9process_methods\u6a21\u5757\uff08node_process_methods.cc\uff09\u7684\u5c01\u88c5\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u5c5e\u6027\u6211\u4eec\u9700\u8981\u5173\u6ce8\u4e00\u4e0b\uff0c\u5c31\u662fexit\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u4e2d\u8c03\u7528process.exit\u7684\u65f6\u5019\uff0c\u53ea\u4f1a\u9000\u51fa\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\u3002 1. function exit(code) { 2. if (code || code === 0) 3. process.exitCode = code; 4. 5. if (!process._exiting) { 6. process._exiting = true; 7. process.emit('exit', process.exitCode || 0); 8. } 9. process.reallyExit(process.exitCode || 0); 10. } \u6211\u4eec\u7ee7\u7eed\u770breallyExit 1. static void ReallyExit(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. RunAtExit(env); 4. int code = args[0]->Int32Value(env->context()).FromMaybe(0); 5. env->Exit(code); 6. } \u8c03\u7528\u4e86env\u7684Exit\u3002 1. void Environment::Exit(int exit_code) { 2. if (is_main_thread()) { 3. stop_sub_worker_contexts(); 4. DisposePlatform(); 5. exit(exit_code); 6. } else { 7. worker_context_->Exit(exit_code); 8. } 9. } \u8fd9\u91cc\u6211\u4eec\u770b\u5230\u4e86\u91cd\u70b9\uff0c\u6839\u636e\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u4f1a\u505a\u4e0d\u540c\u7684\u5904\u7406\u3002\u4e00\u4e2a\u7ebf\u7a0b\u4f1a\u5bf9\u5e94\u4e00\u4e2aenv\uff0cenv\u5bf9\u8c61\u4e2d\u7684worker_context_\u4fdd\u5b58\u5c31\u662f\u7ebf\u7a0b\u5bf9\u8c61\uff08Worker\uff09\u3002\u6211\u4eec\u5148\u770b\u5b50\u7ebf\u7a0b\u7684\u903b\u8f91\u3002 1. void Worker::Exit(int code) { 2. Mutex::ScopedLock lock(mutex_); 3. if (env_ != nullptr) { 4. exit_code_ = code; 5. Stop(env_); 6. } else { 7. stopped_ = true; 8. } 9. } 10. 11. int Stop(Environment* env) { 12. env->ExitEnv(); 13. return 0; 14. } 15. 16. void Environment::ExitEnv() { 17. set_can_call_into_js(false); 18. set_stopping(true); 19. isolate_->TerminateExecution(); 20. // \u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af 21. SetImmediateThreadsafe([](Environment* env) { uv_stop(env->event_loop()); }); 22. } \u6211\u4eec\u770b\u5230\u5b50\u7ebf\u7a0b\u6700\u540e\u8c03\u7528uv_stop\u63d0\u51fa\u4e86Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u9000\u51fa\u3002\u6211\u4eec\u518d\u6765\u770b\u4e3b\u7ebf\u7a0b\u7684\u9000\u51fa\u903b\u8f91\u3002 1. if (is_main_thread()) { 2. stop_sub_worker_contexts(); 3. DisposePlatform(); 4. exit(exit_code); 5. } \u6211\u4eec\u770b\u5230\u6700\u540e\u4e3b\u8fdb\u7a0b\u4e2d\u8c03\u7528exit\u9000\u51fa\u8fdb\u7a0b\u3002\u4f46\u662f\u9000\u51fa\u524d\u8fd8\u6709\u4e00\u4e9b\u5904\u7406\u5de5\u4f5c\uff0c\u6211\u4eec\u770bstop_sub_worker_contexts 1. void Environment::stop_sub_worker_contexts() { 2. while (!sub_worker_contexts_.empty()) { 3. Worker* w = *sub_worker_contexts_.begin(); 4. remove_sub_worker_context(w); 5. w->Exit(1); 6. w->JoinThread(); 7. } 8. } sub_worker_contexts\u4fdd\u5b58\u7684\u662fWorker\u5bf9\u8c61\u5217\u8868\uff0c\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5f80\u91cc\u8ffd\u52a0\u4e00\u4e2a\u5143\u7d20\u3002\u8fd9\u91cc\u904d\u5386\u8fd9\u4e2a\u5217\u8868\uff0c\u7136\u540e\u8c03\u7528Exit\u51fd\u6570\uff0c\u8fd9\u4e2a\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u662f\u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af\u3002\u4e3b\u7ebf\u7a0b\u63a5\u7740\u8c03JoinThread\uff0cJoinThread\u4e3b\u8981\u662f\u4e3a\u4e86\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\uff0c\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u5728\u9000\u51fa\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u4f1a\u88ab\u64cd\u4f5c\u7cfb\u7edf\u6302\u8d77\uff08\u6267\u884c\u65f6\u95f4\u7247\u5230\u4e86\uff09\uff0c\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u88ab\u8c03\u5ea6\u6267\u884c\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u8fd8\u4e0d\u80fd\u9000\u51fa\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f7f\u7528join\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\u3002Node.js\u7684JoinThread\u9664\u4e86\u5bf9\u7ebf\u7a0bjoin\u51fd\u6570\u7684\u5c01\u88c5\u3002\u8fd8\u505a\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982\u89e6\u53d1exit\u4e8b\u4ef6\u3002 13.2 \u521b\u5efa\u5b50\u8fdb\u7a0b \u00b6 \u56e0\u4e3aNode.js\u662f\u5355\u8fdb\u7a0b\u7684\uff0c\u4f46\u6709\u5f88\u591a\u4e8b\u60c5\u53ef\u80fd\u4e0d\u9002\u5408\u5728\u4e3b\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\uff0c\u6240\u4ee5Node.js\u63d0\u4f9b\u4e86\u5b50\u8fdb\u7a0b\u6a21\u5757\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u5b50\u8fdb\u7a0b\u505a\u4e00\u4e9b\u989d\u5916\u4efb\u52a1\u7684\u5904\u7406\uff0c\u53e6\u5916\uff0c\u5b50\u8fdb\u7a0b\u7684\u597d\u5904\u662f\uff0c\u4e00\u65e6\u5b50\u8fdb\u7a0b\u51fa\u95ee\u9898\u6302\u6389\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u7528C\u8bed\u8a00\u5982\u4f55\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u3002 1. #include<unistd.h> 2. #include<stdlib.h> 3. 4. int main(int argc,char *argv[]){ 5. pid_t pid = fork(); 6. if (pid < 0) { 7. // \u9519\u8bef 8. } else if(pid == 0) { 9. // \u5b50\u8fdb\u7a0b\uff0c\u53ef\u4ee5\u4f7f\u7528exec*\u7cfb\u5217\u51fd\u6570\u6267\u884c\u65b0\u7684\u7a0b\u5e8f 10. } else { 11. // \u7236\u8fdb\u7a0b 12. } 13. } fork\u51fd\u6570\u7684\u7279\u70b9\uff0c\u6211\u4eec\u542c\u5f97\u6700\u591a\u7684\u53ef\u80fd\u662f\u6267\u884c\u4e00\u6b21\u8fd4\u56de\u4e24\u6b21\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u7591\u60d1\uff0c\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u600e\u4e48\u53ef\u80fd\u8fd4\u56de\u4e86\u4e24\u6b21\u5462\uff1f\u4e4b\u524d\u6211\u4eec\u8bb2\u8fc7\uff0c\u8fdb\u7a0b\u662ftask_struct\u8868\u793a\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u8c03\u7528 fork\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2a\u65b0\u7684task_struct\u5b9e\u4f8b\u51fa\u6765\uff08\u53d8\u6210\u4e24\u4e2a\u8fdb\u7a0b\uff09\uff0cfork\u8fd4\u56de\u4e24\u6b21\u7684\u610f\u601d\u5176\u5b9e\u662f\u5728\u5728\u4e24\u4e2a\u8fdb\u7a0b\u5206\u522b\u8fd4\u56de\u4e00\u6b21\uff0c\u6267\u884c\u7684\u90fd\u662ffork\u540e\u9762\u7684\u4e00\u884c\u4ee3\u7801\u3002\u800c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u662f\u4e3b\u8fdb\u7a0b\u8fd8\u662f\u5b50\u8fdb\u7a0b\uff0c\u8bbe\u7f6e\u4e86fork\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0cfork\u8fd4\u56de\u503c\u4e0d\u4e00\u6837\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u4ee3\u7801\u4e2dif else\u6761\u4ef6\u3002\u4f46\u662ffork\u53ea\u662f\u590d\u5236\u4e3b\u8fdb\u7a0b\u7684\u5185\u5bb9\uff0c\u5982\u679c\u6211\u4eec\u60f3\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u600e\u4e48\u529e\u5462\uff1f\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u7528\u5230exec*\u7cfb\u5217\u51fd\u6570\uff0c\u8be5\u7cfb\u5217\u51fd\u6570\u4f1a\u8986\u76d6\u65e7\u8fdb\u7a0b\uff08task_struct\uff09\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u91cd\u65b0\u52a0\u8f7d\u65b0\u7684\u7a0b\u5e8f\u5185\u5bb9\u3002\u8fd9\u4e5f\u662fNode.js\u4e2d\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u5e95\u5c42\u539f\u7406\u3002Node.js\u867d\u7136\u63d0\u4f9b\u4e86\u5f88\u591a\u79cd\u521b\u5efa\u8fdb\u7a0b\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u540c\u6b65\u548c\u5f02\u6b65\u4e24\u79cd\u65b9\u5f0f\u3002 13.2.1 \u5f02\u6b65\u521b\u5efa\u8fdb\u7a0b \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5f02\u6b65\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u65f6\u7684\u5173\u7cfb\u56fe\u5982\u56fe13-1\u6240\u793a\u3002 \u56fe13-1 \u6211\u4eec\u4ecefork\u8fd9\u4e2a\u51fd\u6570\u5f00\u59cb\uff0c\u770b\u4e00\u4e0b\u6574\u4e2a\u6d41\u7a0b\u3002 1. function fork(modulePath /* , args, options */) { 2. // \u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406 3. return spawn(options.execPath, args, options); 4. } \u6211\u4eec\u63a5\u7740\u770bspawn 1. var spawn = exports.spawn = function(/*file, args, options*/) { var opts = normalizeSpawnArguments.apply(null, arguments); 2. var options = opts.options; 3. var child = new ChildProcess(); 4. 5. child.spawn({ 6. file: opts.file, 7. args: opts.args, 8. cwd: options.cwd, 9. windowsHide: !!options.windowsHide, 10. windowsVerbatimArguments: !!options.windowsVerbatimArguments, 11. detached: !!options.detached, 12. envPairs: opts.envPairs, 13. stdio: options.stdio, 14. uid: options.uid, 15. gid: options.gid 16. }); 17. 18. return child; 19. }; \u6211\u4eec\u770b\u5230spawn\u51fd\u6570\u53ea\u662f\u5bf9ChildProcess\u7684\u5c01\u88c5\u3002\u7136\u540e\u8c03\u7528\u5b83\u7684spawn\u51fd\u6570\u3002\u6211\u4eec\u770b\u770bChildProcess\u3002 1. function ChildProcess() { 2. // C++\u5c42\u5b9a\u4e49 3. this._handle = new Process(); 4. } 5. 6. ChildProcess.prototype.spawn = function(options) { 7. // \u521b\u5efa\u8fdb\u7a0b 8. const err = this._handle.spawn(options); 9. } 10. ChildProcess\u662f\u5bf9C++\u5c42\u7684\u5c01\u88c5\uff0c\u4e0d\u8fc7Process\u5728C++\u5c42\u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u8fdb\u884c\u53c2\u6570\u7684\u5904\u7406\u7136\u540e\u8c03\u7528Libuv\u7684uv_spawn\u3002\u6211\u4eec\u901a\u8fc7uv_spawn\u6765\u5230\u4e86C\u8bed\u8a00\u5c42\u3002\u6211\u4eec\u770b\u770buv_spawn\u7684\u6574\u4f53\u6d41\u7a0b\u3002 1. int uv_spawn(uv_loop_t* loop, 2. uv_process_t* process, 3. const uv_process_options_t* options) { 4. 5. uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS); 6. QUEUE_INIT(&process->queue); 7. // \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 8. for (i = 0; i < options->stdio_count; i++) { 9. err = uv__process_init_stdio(options->stdio + i, pipes[i]); 10. if (err) 11. goto error; 12. } 13. /* 14. \u521b\u5efa\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u521b\u5efa\u8fdb\u7a0b\u671f\u95f4\u7684\u7236\u8fdb\u7a0b\u5b50\u901a\u4fe1\uff0c 15. \u8bbe\u7f6eUV__O_CLOEXEC\u6807\u8bb0\uff0c\u5b50\u8fdb\u7a0b\u6267\u884cexecvp 16. \u7684\u65f6\u5019\u7ba1\u9053\u7684\u4e00\u7aef\u4f1a\u88ab\u5173\u95ed 17. */ 18. err = uv__make_pipe(signal_pipe, 0); 19. // \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570 20. uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD); 21. 22. uv_rwlock_wrlock(&loop->cloexec_lock); 23. // \u521b\u5efa\u5b50\u8fdb\u7a0b 24. pid = fork(); 25. // \u5b50\u8fdb\u7a0b 26. if (pid == 0) { 27. uv__process_child_init(options, 28. stdio_count, 29. pipes, 30. signal_pipe[1]); 31. abort(); 32. } 33. // \u7236\u8fdb\u7a0b 34. uv_rwlock_wrunlock(&loop->cloexec_lock); 35. // \u5173\u95ed\u7ba1\u9053\u5199\u7aef\uff0c\u7b49\u5f85\u5b50\u8fdb\u7a0b\u5199 36. uv__close(signal_pipe[1]); 37. 38. process->status = 0; 39. exec_errorno = 0; 40. // \u5224\u65ad\u5b50\u8fdb\u7a0b\u662f\u5426\u6267\u884c\u6210\u529f 41. do 42. r = read(signal_pipe[0],&exec_errorno,sizeof(exec_errorno)); 43. while (r == -1 && errno == EINTR); 44. // \u5ffd\u7565\u5904\u7406r\u7684\u903b\u8f91 45. // \u4fdd\u5b58\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 46. for (i = 0; i < options->stdio_count; i++) { 47. uv__process_open_stream(options->stdio + i, pipes[i]); 48. } 49. 50. // \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u6784\u4f53 51. if (exec_errorno == 0) { 52. QUEUE_INSERT_TAIL(&loop->process_handles, &process->queue); 53. uv__handle_start(process); 54. } 55. 56. process->pid = pid; 57. process->exit_cb = options->exit_cb; 58. 59. return exec_errorno; 60. } uv_spawn\u7684\u903b\u8f91\u5927\u81f4\u5206\u4e3a\u4e0b\u9762\u51e0\u4e2a 1 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 2 \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406\u51fd\u6570 3 \u521b\u5efa\u5b50\u8fdb\u7a0b 4 \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684process_handles\u5bf9\u8c61\uff0c\u4fdd\u5b58\u72b6\u6001\u7801\u548c\u56de\u8c03\u7b49\u3002 \u6211\u4eec\u5206\u67902,3\uff0c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6211\u4eec\u5355\u72ec\u5206\u6790\u3002 1 \u5904\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa \u4e3b\u8fdb\u7a0b\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u4e4b\u524d\uff0c\u4f1a\u6ce8\u518cSIGCHLD\u4fe1\u53f7\u3002\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u662fuv__chld\u3002\u5f53\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u3002Node.js\u4e3b\u8fdb\u7a0b\u4f1a\u6536\u5230SIGCHLD\u4fe1\u53f7\u3002\u7136\u540e\u6267\u884cuv__chld\u3002\u8be5\u51fd\u6570\u904d\u5386Libuv\u8fdb\u7a0b\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u901a\u8fc7waitpid\u5224\u65ad\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u8fdb\u7a0b\u662f\u5426\u5df2\u7ecf\u9000\u51fa\u540e\uff0c\u4ece\u800c\u5904\u7406\u5df2\u9000\u51fa\u7684\u8282\u70b9\uff0c\u7136\u540e\u79fb\u51faLibuv\u961f\u5217\uff0c\u6700\u540e\u6267\u884c\u5df2\u9000\u51fa\u8fdb\u7a0b\u7684\u56de\u8c03\u3002 1. static void uv__chld(uv_signal_t* handle, int signum) { 2. uv_process_t* process; 3. uv_loop_t* loop; 4. int exit_status; 5. int term_signal; 6. int status; 7. pid_t pid; 8. QUEUE pending; 9. QUEUE* q; 10. QUEUE* h; 11. // \u4fdd\u5b58\u8fdb\u7a0b\uff08\u5df2\u9000\u51fa\u7684\u72b6\u6001\uff09\u7684\u961f\u5217 12. QUEUE_INIT(&pending); 13. loop = handle->loop; 14. 15. h = &loop->process_handles; 16. q = QUEUE_HEAD(h); 17. // \u6536\u96c6\u5df2\u9000\u51fa\u7684\u8fdb\u7a0b 18. while (q != h) { 19. process = QUEUE_DATA(q, uv_process_t, queue); 20. q = QUEUE_NEXT(q); 21. 22. do 23. /* 24. WNOHANG\u975e\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u5176\u5b9e\u5c31\u662f\u770b\u5b50\u8fdb\u7a0b\u662f\u5426\u9000\u51fa\u4e86\uff0c 25. \u6ca1\u6709\u7684\u8bdd\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u800c\u4e0d\u662f\u963b\u585e 26. */ 27. pid = waitpid(process->pid, &status, WNOHANG); 28. while (pid == -1 && errno == EINTR); 29. 30. if (pid == 0) 31. continue; 32. /* 33. \u8fdb\u7a0b\u9000\u51fa\u4e86\uff0c\u4fdd\u5b58\u9000\u51fa\u72b6\u6001\uff0c\u79fb\u51fa\u961f\u5217\uff0c 34. \u63d2\u5165peding\u961f\u5217\uff0c\u7b49\u5f85\u5904\u7406 35. */ 36. process->status = status; 37. QUEUE_REMOVE(&process->queue); 38. QUEUE_INSERT_TAIL(&pending, &process->queue); 39. } 40. 41. h = &pending; 42. q = QUEUE_HEAD(h); 43. // \u662f\u5426\u6709\u9000\u51fa\u7684\u8fdb\u7a0b 44. while (q != h) { 45. process = QUEUE_DATA(q, uv_process_t, queue); 46. q = QUEUE_NEXT(q); 47. QUEUE_REMOVE(&process->queue); 48. QUEUE_INIT(&process->queue); 49. uv__handle_stop(process); 50. 51. if (process->exit_cb == NULL) 52. continue; 53. 54. exit_status = 0; 55. // \u83b7\u53d6\u9000\u51fa\u4fe1\u606f\uff0c\u6267\u884c\u4e0a\u4f20\u56de\u8c03 56. if (WIFEXITED(process->status)) 57. exit_status = WEXITSTATUS(process->status); 58. // \u662f\u5426\u56e0\u4e3a\u4fe1\u53f7\u800c\u9000\u51fa 59. term_signal = 0; 60. if (WIFSIGNALED(process->status)) 61. term_signal = WTERMSIG(process->status); 62. 63. process->exit_cb(process, exit_status, term_signal); 64. } 65. } \u5f53\u4e3b\u8fdb\u7a0b\u4e0b\u7684\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\uff0c\u7236\u8fdb\u7a0b\u4e3b\u8981\u8d1f\u8d23\u6536\u96c6\u5b50\u8fdb\u7a0b\u9000\u51fa\u72b6\u6001\u548c\u539f\u56e0\u7b49\u4fe1\u606f\uff0c\u7136\u540e\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 2 \u521b\u5efa\u5b50\u8fdb\u7a0b\uff08uv__process_child_init\uff09 \u4e3b\u8fdb\u7a0b\u9996\u5148\u4f7f\u7528uv__make_pipe\u7533\u8bf7\u4e00\u4e2a\u533f\u540d\u7ba1\u9053\u7528\u4e8e\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\uff0c\u533f\u540d\u7ba1\u9053\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e2d\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u79cd\uff0c\u5b83\u53ea\u7528\u4e8e\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u56e0\u4e3a\u533f\u540d\uff0c\u975e\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\u65e0\u6cd5\u627e\u5230\u8fd9\u4e2a\u7ba1\u9053\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5b8c\u6210\u901a\u4fe1\uff0c\u800c\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u662f\u901a\u8fc7fork\u51fa\u6765\u7684\uff0c\u7236\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u83b7\u5f97\u5f97\u5230\u7ba1\u9053\u3002\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528\u7ee7\u627f\u4e8e\u7236\u8fdb\u7a0b\u7684\u8d44\u6e90\uff0c\u7ba1\u9053\u901a\u4fe1\u7684\u539f\u7406\u5982\u56fe13-2\u6240\u793a\u3002 \u56fe13-2 \u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u8fc7\u5171\u4eabfile\u548cinode\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5bf9\u540c\u4e00\u5757\u5185\u5b58\u7684\u8bfb\u5199\u3002\u4e3b\u8fdb\u7a0bfork\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u4f1a\u901a\u8fc7read\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7684\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002 1. static void uv__process_child_init(const uv_process_options_t* options, 2. int stdio_count, 3. int (*pipes)[2], 4. int error_fd) { 5. sigset_t set; 6. int close_fd; 7. int use_fd; 8. int err; 9. int fd; 10. int n; 11. // \u7701\u7565\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u7b49\u53c2\u6570\u903b\u8f91 12. // \u5904\u7406\u73af\u5883\u53d8\u91cf 13. if (options->env != NULL) { 14. environ = options->env; 15. } 16. // \u5904\u7406\u4fe1\u53f7 17. for (n = 1; n < 32; n += 1) { 18. // \u8fd9\u4e24\u4e2a\u4fe1\u53f7\u89e6\u53d1\u65f6\uff0c\u9ed8\u8ba4\u884c\u4e3a\u662f\u8fdb\u7a0b\u9000\u51fa\u4e14\u4e0d\u80fd\u963b\u6b62\u7684 19. if (n == SIGKILL || n == SIGSTOP) 20. continue; /* Can't be changed. */ 21. // \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u5904\u7406\u65b9\u5f0f 22. if (SIG_ERR != signal(n, SIG_DFL)) 23. continue; 24. // \u51fa\u9519\u5219\u901a\u77e5\u4e3b\u8fdb\u7a0b 25. uv__write_int(error_fd, UV__ERR(errno)); 26. _exit(127); 27. } 28. // \u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6 29. execvp(options->file, options->args); 30. // \u52a0\u8f7d\u6210\u529f\u5219\u4e0d\u4f1a\u8d70\u5230\u8fd9\uff0c\u8d70\u5230\u8fd9\u8bf4\u660e\u52a0\u8f7d\u6267\u884c\u6587\u4ef6\u5931\u8d25 31. uv__write_int(error_fd, UV__ERR(errno)); 32. _exit(127); 33. } \u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e3b\u8981\u662f\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4fe1\u53f7\u3001\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u7b49\u3002\u7136\u540e\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u3002\u56e0\u4e3a\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86cloexec\u6807\u8bb0\u3002\u6240\u4ee5\u5f53\u5b50\u8fdb\u7a0b\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u5c31\u4f1a\u5173\u95ed\u7528\u4e8e\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4ece\u800c\u5bfc\u81f4\u4e3b\u8fdb\u7a0b\u8bfb\u53d6\u7ba1\u9053\u8bfb\u7aef\u7684\u65f6\u5019\u8fd4\u56de0\uff0c\u8fd9\u6837\u4e3b\u8fdb\u7a0b\u5c31\u77e5\u9053\u5b50\u8fdb\u7a0b\u6210\u529f\u6267\u884c\u4e86\u3002 13.2.2 \u540c\u6b65\u521b\u5efa\u8fdb\u7a0b \u00b6 \u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u7684\u8fdb\u7a0b\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u3002\u63a5\u4e0b\u6765\u770b\u770b\u5982\u4f55\u4ee5\u540c\u6b65\u7684\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u3002JS\u5c42\u5165\u53e3\u51fd\u6570\u662fspawnSync\u3002spawnSync\u8c03\u7528C++\u6a21\u5757spawn_sync\u7684spawn\u51fd\u6570\u521b\u5efa\u8fdb\u7a0b\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u5e94\u7684C++\u6a21\u5757spawn_sync\u5bfc\u51fa\u7684\u5c5e\u6027\u3002 1. void SyncProcessRunner::Initialize(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. env->SetMethod(target, \"spawn\", Spawn); 7. } \u8be5\u6a21\u5757\u503c\u5bfc\u51fa\u4e86\u4e00\u4e2a\u5c5e\u6027spawn\uff0c\u5f53\u6211\u4eec\u8c03\u7528spawn\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u662fC++\u7684Spawn\u3002 1. void SyncProcessRunner::Spawn(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. env->PrintSyncTrace(); 4. SyncProcessRunner p(env); 5. Local<Value> result; 6. if (!p.Run(args[0]).ToLocal(&result)) return; 7. args.GetReturnValue().Set(result); 8. } Spawn\u4e2d\u4e3b\u8981\u662f\u65b0\u5efa\u4e86\u4e00\u4e2aSyncProcessRunner\u5bf9\u8c61\u5e76\u4e14\u6267\u884cRun\u65b9\u6cd5\u3002\u6211\u4eec\u770b\u4e00\u4e0bSyncProcessRunner\u7684Run\u505a\u4e86\u4ec0\u4e48\u3002 1. MaybeLocal<Object> SyncProcessRunner::Run(Local<Value> options) { 2. EscapableHandleScope scope(env()->isolate()); 3. Maybe<bool> r = TryInitializeAndRunLoop(options); 4. Local<Object> result = BuildResultObject(); 5. return scope.Escape(result); 6. } \u6267\u884c\u4e86TryInitializeAndRunLoop\u3002 1. Maybe<bool> SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) { 2. int r; 3. 4. lifecycle_ = kInitialized; 5. // \u65b0\u5efa\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af 6. uv_loop_ = new uv_loop_t; 7. if (!ParseOptions(options).To(&r)) return Nothing<bool>(); 8. if (r < 0) { 9. SetError(r); 10. return Just(false); 11. } 12. // \u8bbe\u7f6e\u5b50\u8fdb\u7a0b\u6267\u884c\u7684\u65f6\u95f4 13. if (timeout_ > 0) { 14. r = uv_timer_init(uv_loop_, &uv_timer_); 15. uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_)); 16. uv_timer_.data = this; 17. kill_timer_initialized_ = true; 18. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u6267\u884cKillTimerCallback 19. r = uv_timer_start(&uv_timer_, 20. KillTimerCallback, 21. timeout_, 22. 0); 23. } 24. // \u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u5904\u7406\u51fd\u6570 25. uv_process_options_.exit_cb = ExitCallback; 26. // \u4f20\u8fdb\u53bb\u65b0\u7684loop\u800c\u4e0d\u662f\u4e3b\u8fdb\u7a0b\u672c\u8eab\u7684loop 27. r = uv_spawn(uv_loop_, &uv_process_, &uv_process_options_); 28. uv_process_.data = this; 29. 30. for (const auto& pipe : stdio_pipes_) { 31. if (pipe != nullptr) { 32. r = pipe->Start(); 33. if (r < 0) { 34. SetPipeError(r); 35. return Just(false); 36. } 37. } 38. } 39. // \u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af 40. r = uv_run(uv_loop_, UV_RUN_DEFAULT); 41. return Just(true); 42. } \u4ece\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5230Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u7684\u3002\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u65f6\uff0cNode.js\u91cd\u65b0\u5f00\u542f\u4e86\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5e76\u4e14\u628a\u8868\u793a\u5b50\u8fdb\u7a0b\u7ed3\u6784\u4f53\u7684handle\u63d2\u5165\u5230\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u63a5\u7740Libuv\u4e00\u76f4\u5904\u4e8e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u56e0\u4e3a\u4e00\u76f4\u6709\u4e00\u4e2auv_process_t\uff08handle\uff09\uff0c\u6240\u4ee5\u65b0\u521b\u5efa\u7684uv_run\u4f1a\u4e00\u76f4\u5728\u6267\u884c\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u201d\u963b\u585e\u201d\u5728\u8be5uv_run\u3002\u76f4\u5230\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u540e\uff0c\u5220\u9664\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684uv_process_t\u3002\u7136\u540e\u6267\u884c\u56de\u8c03ExitCallback\u3002\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u518d\u6b21\u56de\u5230Node.js\u539f\u6765\u7684\u4e8b\u4ef6\u5faa\u73af\u3002\u5982\u56fe\u6240\u793a13-3\u3002 \u56fe13-3 \u8fd9\u5c31\u662f\u540c\u6b65\u7684\u672c\u8d28\u548c\u539f\u56e0\u3002\u6211\u4eec\u5206\u51e0\u6b65\u5206\u6790\u4e00\u4e0b\u4ee5\u4e0a\u4ee3\u7801 13.2.2.1 \u6267\u884c\u65f6\u95f4 \u00b6 \u56e0\u4e3a\u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u5b50\u8fdb\u7a0b\u4f1a\u5bfc\u81f4Node.js\u4e3b\u8fdb\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u907f\u514d\u5b50\u8fdb\u7a0b\u6709\u95ee\u9898\uff0c\u4ece\u800c\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u7684\u6267\u884c\uff0cNode.js\u652f\u6301\u53ef\u914d\u7f6e\u5b50\u8fdb\u7a0b\u7684\u6700\u5927\u6267\u884c\u65f6\u95f4\u3002\u6211\u4eec\u770b\u5230\uff0cNode.js\u5f00\u542f\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5e76\u8bbe\u7f6e\u4e86\u56de\u8c03KillTimerCallback\u3002 1. void SyncProcessRunner::KillTimerCallback(uv_timer_t* handle) { 2. SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data); 3. self->OnKillTimerTimeout(); 4. } 5. 6. void SyncProcessRunner::OnKillTimerTimeout() { 7. SetError(UV_ETIMEDOUT); 8. Kill(); 9. } 10. 11. void SyncProcessRunner::Kill() { 12. if (killed_) 13. return; 14. killed_ = true; 15. if (exit_status_ < 0) { 16. // kill_signal_\u4e3a\u7528\u6237\u81ea\u5b9a\u4e49\u53d1\u9001\u7684\u6740\u6b7b\u8fdb\u7a0b\u7684\u4fe1\u53f7 17. int r = uv_process_kill(&uv_process_, kill_signal_); 18. // \u4e0d\u652f\u6301\u7528\u6237\u4f20\u7684\u4fe1\u53f7 19. if (r < 0 && r != UV_ESRCH) { 20. SetError(r); 21. // \u56de\u9000\u4f7f\u7528SIGKILL\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b 22. r = uv_process_kill(&uv_process_, SIGKILL); 23. CHECK(r >= 0 || r == UV_ESRCH); 24. } 25. } 26. 27. // Close all stdio pipes. 28. CloseStdioPipes(); 29. 30. // \u6e05\u9664\u5b9a\u65f6\u5668 31. CloseKillTimer(); 32. } \u5f53\u6267\u884c\u65f6\u95f4\u5230\u8fbe\u8bbe\u7f6e\u7684\u9608\u503c\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u7ed9\u5b50\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u9ed8\u8ba4\u662f\u6740\u6b7b\u5b50\u8fdb\u7a0b\u3002 13.2.2.2 \u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406 \u00b6 \u9000\u51fa\u5904\u7406\u4e3b\u8981\u662f\u8bb0\u5f55\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u7684\u9519\u8bef\u7801\u548c\u88ab\u54ea\u4e2a\u4fe1\u53f7\u6740\u6b7b\u7684\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u3002 1. void SyncProcessRunner::ExitCallback(uv_process_t* handle, 2. int64_t exit_status, 3. int term_signal) { 4. SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data); 5. uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr); 6. self->OnExit(exit_status, term_signal); 7. } 8. 9. void SyncProcessRunner::OnExit(int64_t exit_status, int term_signal) { 10. if (exit_status < 0) 11. return SetError(static_cast<int>(exit_status)); 12. 13. exit_status_ = exit_status; 14. term_signal_ = term_signal; 15. } 13.3 \u8fdb\u7a0b\u95f4\u901a\u4fe1 \u00b6 \u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u591a\u8fdb\u7a0b\u7cfb\u7edf\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u529f\u80fd\uff0c\u5426\u5219\u8fdb\u7a0b\u5c31\u50cf\u5b64\u5c9b\u4e00\u6837\uff0c\u4e0d\u80fd\u4ea4\u6d41\u4fe1\u606f\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u9694\u79bb\u7684\uff0c\u5982\u679c\u8fdb\u7a0b\u95f4\u60f3\u901a\u4fe1\uff0c\u5c31\u9700\u8981\u4e00\u4e2a\u516c\u5171\u7684\u5730\u65b9\uff0c\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u5b8c\u6210\u4fe1\u606f\u7684\u4f20\u9012\u3002\u5728Linux\u4e2d\uff0c\u540c\u4e3b\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\u6709\u5f88\u591a\uff0c\u4f46\u662f\u57fa\u672c\u90fd\u662f\u4f7f\u7528\u72ec\u7acb\u4e8e\u8fdb\u7a0b\u7684\u989d\u5916\u5185\u5b58\u4f5c\u4e3a\u4fe1\u606f\u627f\u8f7d\u7684\u5730\u65b9\uff0c\u7136\u540e\u5728\u901a\u8fc7\u67d0\u79cd\u65b9\u5f0f\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\u5230\u8fd9\u5757\u516c\u5171\u5185\u5b58\uff0c\u6bd4\u5982\u7ba1\u9053\u3001\u5171\u4eab\u5185\u5b58\u3001Unix\u57df\u3001\u6d88\u606f\u961f\u5217\u7b49\u7b49\u3002\u4e0d\u8fc7\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u662f\u4e0d\u5c5e\u4e8e\u4ee5\u4e0a\u60c5\u51b5\u7684\uff0c\u90a3\u5c31\u662f\u4fe1\u53f7\u3002\u4fe1\u53f7\u4f5c\u4e3a\u4e00\u79cd\u7b80\u5355\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u63a5\u53e3\u8ba9\u8fdb\u7a0b\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u7684\u6570\u636e\uff08PCB\uff09\uff0c\u4ee5\u6b64\u8fbe\u5230\u901a\u4fe1\u76ee\u7684\u3002\u672c\u8282\u4ecb\u7ecdNode.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 13.3.1 \u521b\u5efa\u901a\u4fe1\u901a\u9053 \u00b6 \u6211\u4eec\u4ecefork\u51fd\u6570\u5f00\u59cb\u5206\u6790Node.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u903b\u8f91\u3002 1. function fork(modulePath) { 2. // \u5ffd\u7565options\u53c2\u6570\u5904\u7406 3. if (typeof options.stdio === 'string') { 4. options.stdio = stdioStringToArray(options.stdio, 'ipc'); 5. } else if (!ArrayIsArray(options.stdio)) { 6. // silent\u4e3atrue\u5219\u662f\u7ba1\u9053\u5f62\u5f0f\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\uff0c\u5426\u5219\u662f\u7ee7\u627f 7. options.stdio = stdioStringToArray( 8. options.silent ? 'pipe' : 'inherit', 9. 'ipc'); 10. } else if (!options.stdio.includes('ipc')) { 11. // \u5fc5\u987b\u8981IPC\uff0c\u652f\u6301\u8fdb\u7a0b\u95f4\u901a\u4fe1 12. throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio'); 13. } 14. 15. return spawn(options.execPath, args, options); 16. } \u6211\u4eec\u770b\u4e00\u4e0bstdioStringToArray\u7684\u5904\u7406\u3002 1. function stdioStringToArray(stdio, channel) { 2. const options = []; 3. 4. switch (stdio) { 5. case 'ignore': 6. case 'pipe': options.push(stdio, stdio, stdio); break; 7. case 'inherit': options.push(0, 1, 2); break; 8. default: 9. throw new ERR_INVALID_OPT_VALUE('stdio', stdio); 10. } 11. 12. if (channel) options.push(channel); 13. 14. return options; 15. } stdioStringToArray\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6570\u7ec4\uff0c\u6bd4\u5982['pipe', 'pipe', 'pipe', 'ipc']\u6216[0, 1, 2, 'ipc']\uff0cipc\u4ee3\u8868\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053\uff0c\u5e76\u4e14\u652f\u6301\u6587\u4ef6\u63cf\u8ff0\u4f20\u9012\u3002\u6211\u4eec\u63a5\u7740\u770bspawn\u3002 1. ChildProcess.prototype.spawn = function(options) { 2. let i = 0; 3. // \u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 4. stdio = getValidStdio(stdio, false); 5. const ipc = stdio.ipc; 6. // IPC\u6587\u4ef6\u63cf\u8ff0\u7b26 7. const ipcFd = stdio.ipcFd; 8. stdio = options.stdio = stdio.stdio; 9. // \u901a\u8fc7\u73af\u5883\u53d8\u91cf\u544a\u8bc9\u5b50\u8fdb\u7a0bIPC\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6570\u636e\u5904\u7406\u6a21\u5f0f 10. if (ipc !== undefined) { 11. options.envPairs.push(`NODE_CHANNEL_FD=${ipcFd}`); 12. options.envPairs.push(`NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`); 13. } 14. // \u521b\u5efa\u5b50\u8fdb\u7a0b 15. const err = this._handle.spawn(options); 16. this.pid = this._handle.pid; 17. // \u5904\u7406IPC\u901a\u4fe1 18. if (ipc !== undefined) setupChannel(this, ipc, serialization); 19. return err; 20. } Spawn\u4e2d\u4f1a\u6267\u884cgetValidStdio\u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u53ea\u5173\u6ce8ipc\u7684\u3002 1. function getValidStdio(stdio, sync) { 2. let ipc; 3. let ipcFd; 4. 5. stdio = stdio.reduce((acc, stdio, i) => { 6. if (stdio === 'ipc') { 7. ipc = new Pipe(PipeConstants.IPC); 8. ipcFd = i; 9. acc.push({ 10. type: 'pipe', 11. handle: ipc, 12. ipc: true 13. }); 14. } else { 15. // \u5176\u5b83\u7c7b\u578b\u7684\u5904\u7406 16. } 17. return acc; 18. }, []); 19. 20. return { stdio, ipc, ipcFd }; 21. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1anew Pipe(PipeConstants.IPC);\u521b\u5efa\u4e00\u4e2aUnix\u57df\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff0c\u4f46\u662f\u8fd9\u91cc\u53ea\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u8fd8\u6ca1\u6709\u53ef\u7528\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u5f80\u4e0b\u770bC++\u5c42\u7684spawn\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002C++\u5c42\u9996\u5148\u5904\u7406\u53c2\u6570\uff0c 1. static void ParseStdioOptions(Environment* env, 2. Local<Object> js_options, 3. uv_process_options_t* options) { 4. Local<Context> context = env->context(); 5. Local<String> stdio_key = env->stdio_string(); 6. // \u62ff\u5230JS\u5c42stdio\u7684\u503c 7. Local<Array> stdios = 8. js_options->Get(context, stdio_key).ToLocalChecked().As<Array>(); 9. 10. uint32_t len = stdios->Length(); 11. options->stdio = new uv_stdio_container_t[len]; 12. options->stdio_count = len; 13. // \u904d\u5386stdio\uff0cstdio\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4 14. for (uint32_t i = 0; i < len; i++) { 15. Local<Object> stdio = 16. stdios->Get(context, i).ToLocalChecked().As<Object>(); 17. // \u62ff\u5230stdio\u7684\u7c7b\u578b 18. Local<Value> type = 19. stdio->Get(context, env->type_string()).ToLocalChecked(); 20. // \u521b\u5efaIPC\u901a\u9053 21. if (type->StrictEquals(env->pipe_string())) { 22. options->stdio[i].flags = static_cast<uv_stdio_flags>( 23. UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE); 24. // \u62ff\u5230\u5bf9\u5e94\u7684stream 25. options->stdio[i].data.stream = StreamForWrap(env, stdio); 26. } 27. } 28. } \u8fd9\u91cc\u4f1a\u628aStreamForWrap\u7684\u7ed3\u679c\u4fdd\u5b58\u5230stream\u4e2d\uff0c\u6211\u4eec\u770b\u770bStreamForWrap\u7684\u903b\u8f91 1. static uv_stream_t* StreamForWrap(Environment* env, Local<Object> stdio) { 2. Local<String> handle_key = env->handle_string(); 3. /* 4. \u83b7\u53d6\u5bf9\u8c61\u4e2d\u7684key\u4e3ahandle\u7684\u503c\uff0c\u5373\u521a\u624dJS\u5c42\u7684 5. new Pipe(SOCKET.IPC); 6. */ 7. Local<Object> handle = 8. stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>(); 9. // \u83b7\u53d6JS\u5c42\u4f7f\u7528\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684C++\u5bf9\u8c61\u4e2d\u7684stream 10. uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream(); 11. CHECK_NOT_NULL(stream); 12. return stream; 13. } 14. 15. // \u4eceJS\u5c42\u4f7f\u7528\u7684object\u4e2d\u83b7\u53d6\u5173\u8054\u7684C++\u5bf9\u8c61 16. ibuvStreamWrap* LibuvStreamWrap::From(Environment* env, Local<Object> object) { 17. return Unwrap<LibuvStreamWrap>(object); 18. } \u4ee5\u4e0a\u4ee3\u7801\u83b7\u53d6\u4e86IPC\u5bf9\u5e94\u7684stream\u7ed3\u6784\u4f53\u3002\u5728Libuv\u4e2d\u4f1a\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230stream\u4e2d\u3002\u6211\u4eec\u63a5\u7740\u770bC++\u5c42\u8c03\u7528Libuv\u7684uv_spawn\u3002 1. int uv_spawn(uv_loop_t* loop, 2. uv_process_t* process, 3. const uv_process_options_t* options) { 4. 5. int pipes_storage[8][2]; 6. int (*pipes)[2]; 7. int stdio_count; 8. // \u521d\u59cb\u5316\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 9. stdio_count = options->stdio_count; 10. if (stdio_count < 3) 11. stdio_count = 3; 12. 13. for (i = 0; i < stdio_count; i++) { 14. pipes[i][0] = -1; 15. pipes[i][1] = -1; 16. } 17. // \u521b\u5efa\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 18. for (i = 0; i < options->stdio_count; i++) { 19. err = uv__process_init_stdio(options->stdio + i, pipes[i]); 20. if (err) 21. goto error; 22. } 23. 24. // \u8bbe\u7f6e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 25. for (i = 0; i < options->stdio_count; i++) { 26. uv__process_open_stream(options->stdio + i, pipes[i]); 27. 28. } 29. 30. } Libuv\u4e2d\u4f1a\u521b\u5efa\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u8bbe\u7f6e\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 1. static int uv__process_open_stream(uv_stdio_container_t* container, 2. int pipefds[2]) { 3. int flags; 4. int err; 5. 6. if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0) 7. return 0; 8. 9. err = uv__close(pipefds[1]); 10. if (err != 0) 11. abort(); 12. 13. pipefds[1] = -1; 14. uv__nonblock(pipefds[0], 1); 15. 16. flags = 0; 17. if (container->flags & UV_WRITABLE_PIPE) 18. flags |= UV_HANDLE_READABLE; 19. if (container->flags & UV_READABLE_PIPE) 20. flags |= UV_HANDLE_WRITABLE; 21. 22. return uv__stream_open(container->data.stream, pipefds[0], flags); 23. } \u6267\u884c\u5b8cuv__process_open_stream\uff0c\u7528\u4e8eIPC\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c31\u4fdd\u5b58\u5230new Pipe(SOCKET.IPC)\u4e2d\u4e86\u3002\u6709\u4e86IPC\u901a\u9053\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8fdb\u7a0b\u8fd8\u9700\u8981\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u5230JS\u5c42\u6267\u884c\u5b8cspawn\u540e\uff0c\u4e3b\u8fdb\u7a0b\u901a\u8fc7setupChannel\u5bf9\u8fdb\u7a0b\u95f4\u901a\u4fe1\u8fdb\u884c\u4e86\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0bsetupChannel\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002 13.3.2 \u4e3b\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053 \u00b6 1 \u8bfb\u7aef 1. function setupChannel(target, channel, serializationMode) { 2. // channel\u662fnew Pipe(PipeConstants.IPC); 3. const control = new Control(channel); 4. target.channel = control; 5. // \u2026 6. channel.pendingHandle = null; 7. // \u6ce8\u518c\u5904\u7406\u6570\u636e\u7684\u51fd\u6570 8. channel.onread = function(arrayBuffer) { 9. // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 10. const recvHandle = channel.pendingHandle; 11. channel.pendingHandle = null; 12. if (arrayBuffer) { 13. const nread = streamBaseState[kReadBytesOrError]; 14. const offset = streamBaseState[kArrayBufferOffset]; 15. const pool = new Uint8Array(arrayBuffer, offset, nread); 16. if (recvHandle) 17. pendingHandle = recvHandle; 18. // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f 19. for (const message of parseChannelMessages(channel, pool)) { 20. // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 21. if (isInternal(message)) { 22. // \u6536\u5230handle 23. if (message.cmd === 'NODE_HANDLE') { 24. handleMessage(message, pendingHandle, true); 25. pendingHandle = null; 26. } else { 27. handleMessage(message, undefined, true); 28. } 29. } else { 30. handleMessage(message, undefined, false); 31. } 32. } 33. } 34. 35. }; 36. 37. function handleMessage(message, handle, internal) { 38. const eventName = (internal ? 'internalMessage' : 'message'); 39. process.nextTick(emit, eventName, message, handle); 40. } 41. // \u5f00\u542f\u8bfb 42. channel.readStart(); 43. return control; 44. } onread\u5904\u7406\u5b8c\u540e\u4f1a\u89e6\u53d1internalMessage\u6216message\u4e8b\u4ef6\uff0cmessage\u662f\u7528\u6237\u4f7f\u7528\u7684\u3002 2\u5199\u7aef 1. target._send = function(message, handle, options, callback) { 2. let obj; 3. const req = new WriteWrap(); 4. // \u53d1\u9001\u7ed9\u5bf9\u7aef 5. const err = writeChannelMessage(channel, req, message,handle); 6. 7. return channel.writeQueueSize < (65536 * 2); 8. } \u6211\u4eec\u770b\u770bwriteChannelMessage 1. writeChannelMessage(channel, req, message, handle) { 2. const ser = new ChildProcessSerializer(); 3. ser.writeHeader(); 4. ser.writeValue(message); 5. const serializedMessage = ser.releaseBuffer(); 6. const sizeBuffer = Buffer.allocUnsafe(4); 7. sizeBuffer.writeUInt32BE(serializedMessage.length); 8. // channel\u662f\u5c01\u88c5\u4e86Unix\u57df\u7684\u5bf9\u8c61 9. return channel.writeBuffer(req, Buffer.concat([ 10. sizeBuffer, 11. serializedMessage 12. ]), handle); 13. }, channel.writeBuffer\u901a\u8fc7\u521a\u624d\u521b\u5efa\u7684IPC\u901a\u9053\u5b8c\u6210\u6570\u636e\u7684\u53d1\u9001\uff0c\u5e76\u4e14\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 13.3.3 \u5b50\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053 \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\uff0cNode.js\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u544a\u8bc9\u5b50\u8fdb\u7a0bUnix\u57df\u901a\u4fe1\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728\u6267\u884c\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u5904\u7406\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5177\u4f53\u5b9e\u73b0\u5728setupChildProcessIpcChannel\u51fd\u6570\u4e2d\u3002 1. function setupChildProcessIpcChannel() { 2. // \u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u8be5\u503c 3. if (process.env.NODE_CHANNEL_FD) { 4. const fd = parseInt(process.env.NODE_CHANNEL_FD, 10); 5. delete process.env.NODE_CHANNEL_FD; 6. require('child_process')._forkChild(fd, serializationMode); 7. } 8. } \u63a5\u7740\u6267\u884c_forkChild\u51fd\u6570\u3002 1. function _forkChild(fd, serializationMode) { 2. const p = new Pipe(PipeConstants.IPC); 3. p.open(fd); 4. const control = setupChannel(process, p, serializationMode); 5. } \u8be5\u51fd\u6570\u521b\u5efa\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u4e3b\u8fdb\u7a0b\u4f20\u8fc7\u6765\u7684fd\u4fdd\u5b58\u5230\u8be5Pipe\u5bf9\u8c61\u3002\u5bf9\u8be5Pipe\u5bf9\u8c61\u7684\u8bfb\u5199\uff0c\u5c31\u662f\u5730\u5bf9fd\u8fdb\u884c\u8bfb\u5199\u3002\u6700\u540e\u6267\u884csetupChannel\u3002setupChannel\u4e3b\u8981\u662f\u5b8c\u6210\u4e86Unix\u57df\u901a\u4fe1\u7684\u5c01\u88c5\uff0c\u5305\u62ec\u5904\u7406\u63a5\u6536\u7684\u6d88\u606f\u3001\u53d1\u9001\u6d88\u606f\u3001\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7b49\uff0c\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u6700\u540e\u901a\u8fc7\u5728process\u5bf9\u8c61\u4e2d\u6302\u8f7d\u51fd\u6570\u548c\u76d1\u542c\u4e8b\u4ef6\uff0c\u4f7f\u5f97\u5b50\u8fdb\u7a0b\u5177\u6709\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u80fd\u529b\u3002\u6240\u6709\u7684\u901a\u4fe1\u90fd\u662f\u57fa\u4e8e\u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u4f20\u9012\u8fc7\u6765\u7684fd\u8fdb\u884c\u7684\u3002 13.4 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 \u00b6 \u524d\u9762\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u539f\u7406\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770bNode.js\u662f\u5982\u4f55\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u3002 13.4.1 \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 \u00b6 \u6211\u4eec\u770b\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53d1\u9001\u51fd\u6570send\u7684\u5b9e\u73b0 1. process.send = function(message, handle, options, callback) { 2. return this._send(message, handle, options, callback); 3. }; 4. 5. target._send = function(message, handle, options, callback) { 6. // Support legacy function signature 7. if (typeof options === 'boolean') { 8. options = { swallowErrors: options }; 9. } 10. 11. let obj; 12. 13. // \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0chandle\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5 14. if (handle) { 15. message = { 16. cmd: 'NODE_HANDLE', 17. type: null, 18. msg: message 19. }; 20. // handle\u7684\u7c7b\u578b 21. if (handle instanceof net.Socket) { 22. message.type = 'net.Socket'; 23. } else if (handle instanceof net.Server) { 24. message.type = 'net.Server'; 25. } else if (handle instanceof TCP || handle instanceof Pipe) { 26. message.type = 'net.Native'; 27. } else if (handle instanceof dgram.Socket) { 28. message.type = 'dgram.Socket'; 29. } else if (handle instanceof UDP) { 30. message.type = 'dgram.Native'; 31. } else { 32. throw new ERR_INVALID_HANDLE_TYPE(); 33. } 34. // \u6839\u636e\u7c7b\u578b\u8f6c\u6362\u5bf9\u8c61 35. obj = handleConversion[message.type]; 36. 37. // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u5bf9\u8c61 38. handle=handleConversion[message.type].send.call(target, 39. message, 40. handle, 41. options); 42. } 43. // \u53d1\u9001 44. const req = new WriteWrap(); 45. // \u53d1\u9001\u7ed9\u5bf9\u7aef 46. const err = writeChannelMessage(channel, req, message, handle); 47. 48. } Node.js\u5728\u53d1\u9001\u4e00\u4e2a\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u9996\u5148\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1. send(message, server, options) { 2. return server._handle; 3. } \u6211\u4eec\u63a5\u7740\u770bwriteChannelMessage\u3002 1. // channel\u662fnew Pipe(PipeConstants.IPC); 2. writeChannelMessage(channel, req, message, handle) { 3. const string = JSONStringify(message) + '\\n'; 4. return channel.writeUtf8String(req, string, handle); 5. } \u6211\u4eec\u770b\u4e00\u4e0bwriteUtf8String 1. template <enum encoding enc> 2. int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. // new WriteWrap() 5. Local<Object> req_wrap_obj = args[0].As<Object>(); 6. Local<String> string = args[1].As<String>(); 7. Local<Object> send_handle_obj; 8. // \u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u5bf9\u8c61 9. if (args[2]->IsObject()) 10. send_handle_obj = args[2].As<Object>(); 11. 12. uv_stream_t* send_handle = nullptr; 13. // \u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 14. if (IsIPCPipe() && !send_handle_obj.IsEmpty()) { 15. HandleWrap* wrap; 16. /* 17. send_handle_obj\u662f\u7531C++\u5c42\u521b\u5efa\u5728JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c 18. \u89e3\u5305\u51fa\u771f\u6b63\u5728C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 19. */ 20. ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL); 21. // \u62ff\u5230Libuv\u5c42\u7684handle\u7ed3\u6784\u4f53 22. send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); 23. /* 24. Reference LibuvStreamWrap instance to prevent it 25. from being garbage\uff0ccollected before`AfterWrite` is 26. called. 27. */ 28. req_wrap_obj->Set(env->context(), 29. env->handle_string(), 30. send_handle_obj).Check(); 31. } 32. 33. Write(&buf, 1, send_handle, req_wrap_obj); 34. } Write\u4f1a\u8c03\u7528Libuv\u7684uv__write\uff0cuv__write\u4f1a\u628aLibuv\u5c42\u7684handle\u4e2d\u7684fd\u53d6\u51fa\u6765\uff0c\u4f7f\u7528sendmsg\u4f20\u9012\u5230\u5176\u5b83\u8fdb\u7a0b\u3002\u6574\u4e2a\u53d1\u9001\u7684\u8fc7\u7a0b\u672c\u8d28\u662f\u4eceJS\u5c42\u5230Libuv\u5c42\u5c42\u5c42\u63ed\u5f00\u8981\u53d1\u9001\u7684\u5bf9\u8c61\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5982\u56fe13-4\u6240\u793a\u3002 \u56fe13-4 13.4.2 \u63a5\u6536\u6587\u4ef6\u63cf\u8ff0\u7b26 \u00b6 \u5206\u6790\u5b8c\u53d1\u9001\uff0c\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u63a5\u6536\u7684\u903b\u8f91\u3002\u524d\u9762\u6211\u4eec\u5206\u6790\u8fc7\uff0c\u5f53\u6587\u4ef6\u63cf\u8ff0\u7b26\u6536\u5230\u6570\u636e\u65f6\uff0c\u4f1a\u628a\u6587\u4ef6\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c01\u88c5\u6210\u5bf9\u5e94\u7684\u5bf9\u8c61\u3002 1. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 2. HandleScope scope(env()->isolate()); 3. Context::Scope context_scope(env()->context()); 4. uv_handle_type type = UV_UNKNOWN_HANDLE; 5. // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b 6. if (is_named_pipe_ipc() && 7. uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) { 8. type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream())); 9. } 10. 11. // \u8bfb\u53d6\u6210\u529f 12. if (nread > 0) { 13. MaybeLocal<Object> pending_obj; 14. // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef 15. if (type == UV_TCP) { 16. pending_obj = AcceptHandle<TCPWrap>(env(), this); 17. } else if (type == UV_NAMED_PIPE) { 18. pending_obj = AcceptHandle<PipeWrap>(env(), this); 19. } else if (type == UV_UDP) { 20. pending_obj = AcceptHandle<UDPWrap>(env(), this); 21. } else { 22. CHECK_EQ(type, UV_UNKNOWN_HANDLE); 23. } 24. // \u4fdd\u5b58\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e2d\uff0c\u952e\u662fpendingHandle 25. if (!pending_obj.IsEmpty()) { 26. object() 27. ->Set(env()->context(), 28. env()->pending_handle_string(), 29. pending_obj.ToLocalChecked()) 30. .Check(); 31. } 32. } 33. 34. EmitRead(nread, *buf); 35. } \u63a5\u7740\u6211\u4eec\u770b\u770bJS\u5c42\u7684\u5904\u7406\u3002 1. channel.onread = function(arrayBuffer) { 2. // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 3. const recvHandle = channel.pendingHandle; 4. channel.pendingHandle = null; 5. if (arrayBuffer) { 6. const nread = streamBaseState[kReadBytesOrError]; 7. const offset = streamBaseState[kArrayBufferOffset]; 8. const pool = new Uint8Array(arrayBuffer, offset, nread); 9. if (recvHandle) 10. pendingHandle = recvHandle; 11. // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f 12. for (const message of parseChannelMessages(channel, pool)) { // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 13. if (isInternal(message)) { 14. if (message.cmd === 'NODE_HANDLE') { 15. handleMessage(message, pendingHandle, true); 16. pendingHandle = null; 17. } else { 18. handleMessage(message, undefined, true); 19. } 20. } else { 21. handleMessage(message, undefined, false); 22. } 23. } 24. } 25. }; \u8fd9\u91cc\u4f1a\u89e6\u53d1\u5185\u90e8\u4e8b\u4ef6internalMessage 1. target.on('internalMessage', function(message, handle) { 2. // \u662f\u5426\u6536\u5230\u4e86handle 3. if (message.cmd !== 'NODE_HANDLE') return; 4. 5. // \u6210\u529f\u6536\u5230\uff0c\u53d1\u9001ACK 6. target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true); 7. 8. const obj = handleConversion[message.type]; 9. 10. /* 11. C++\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u8f6c\u5b8c\u4e4b\u540e\u518d\u6839\u636e\u91cc\u5c42\u7684\u5b57\u6bb5 12. message.msg\u8fdb\u4e00\u6b65\u5904\u7406\uff0c\u6216\u8005\u89e6\u53d1message\u4e8b\u4ef6\u4f20\u7ed9\u7528\u6237 13. */ 14. obj.got.call(this, message, handle, (handle) => { 15. handleMessage(message.msg, handle, isInternal(message.msg)); }); 16. }) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u628aC++\u5c42\u7684\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1. got(message, handle, emit) { 2. const server = new net.Server(); 3. server.listen(handle, () => { 4. emit(server); 5. }); 6. } \u8fd9\u5c31\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u5728Node.js\u4e2d\u7684\u5904\u7406\u6d41\u7a0b\uff0c\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u4e00\u4e2a\u975e\u5e38\u6709\u7528\u7684\u80fd\u529b\uff0c\u6bd4\u5982\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u628a\u4e00\u4e2aTCP\u8fde\u63a5\u6240\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u76f4\u63a5\u53d1\u9001\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u5904\u7406\u3002\u8fd9\u4e5f\u662fcluser\u6a21\u5757\u7684\u539f\u7406\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002\u5728Node.js\u4e2d\uff0c\u6574\u4f53\u7684\u5904\u7406\u6d41\u7a0b\u5c31\u662f\uff0c\u53d1\u9001\u7684\u65f6\u5019\u628a\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e00\u5c42\u5c42\u5730\u5265\u5f00\uff0c\u53d8\u6210C++\u5bf9\u8c61\uff0c\u7136\u540e\u518d\u53d8\u6210fd\uff0c\u6700\u540e\u901a\u8fc7\u5e95\u5c42API\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u3002\u63a5\u6536\u7684\u65f6\u5019\u5c31\u662f\u628a\u4e00\u4e2afd\u4e00\u5c42\u5c42\u5730\u5305\u88f9\uff0c\u53d8\u6210\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002","title":"13-\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#131-nodejs","text":"\u5f53\u6211\u4eec\u6267\u884cnode index.js\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aNode.js\u8fdb\u7a0b\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u5c31\u662f\u5728\u8fd9\u4e2aNode.js\u8fdb\u7a0b\u4e2d\u6267\u884c\u3002\u4ece\u4ee3\u7801\u89d2\u5ea6\u6765\u8bf4\uff0c\u6211\u4eec\u5728Node.js\u4e2d\u611f\u77e5\u8fdb\u7a0b\u7684\u65b9\u5f0f\u662f\u901a\u8fc7process\u5bf9\u8c61\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u5bf9\u8c61\u3002","title":"13.1 Node.js\u4e3b\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1311-process","text":"Node.js\u542f\u52a8\u7684\u65f6\u5019\u4f1a\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efaprocess\u5bf9\u8c61\uff08env.cc\uff09\u3002 1. Local<Object> process_object = node::CreateProcessObject(this).FromMaybe(Local<Object>()); 2. set_process_object(process_object); process\u5bf9\u8c61\u901a\u8fc7CreateProcessObject\u521b\u5efa\uff0c\u7136\u540e\u4fdd\u5b58\u5230env\u5bf9\u8c61\u4e2d\u3002\u6211\u4eec\u770b\u4e00\u4e0bCreateProcessObject\u3002 1. MaybeLocal<Object> CreateProcessObject(Environment* env) { 2. Isolate* isolate = env->isolate(); 3. EscapableHandleScope scope(isolate); 4. Local<Context> context = env->context(); 5. 6. Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate); 7. process_template->SetClassName(env->process_string()); 8. Local<Function> process_ctor; 9. Local<Object> process; 10. // \u65b0\u5efaprocess\u5bf9\u8c61 11. if (!process_template->GetFunction(context).ToLocal(&process_ctor) || !process_ctor->NewInstance(context).ToLocal(&process)) { 12. return MaybeLocal<Object>(); 13. } 14. // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u901a\u8fc7process\u5bf9\u8c61\u8bbf\u95ee\u7684\u5c5e\u6027 15. // Node.js\u7684\u7248\u672c 16. READONLY_PROPERTY(process,\"version\", 17. FIXED_ONE_BYTE_STRING(env->isolate(), 18. NODE_VERSION)); 19. // \u5ffd\u7565\u5176\u4ed6\u5c5e\u6027 20. 21. return scope.Escape(process); 22. } \u8fd9\u662f\u4f7f\u7528V8\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u7684\u5178\u578b\u4f8b\u5b50\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5f88\u591a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u6302\u8f7d\u5c5e\u6027\u3002\u4e0b\u9762\u6211\u4eec\u770b\u6211\u4eec\u5e38\u7528\u7684process.env\u662f\u600e\u4e48\u6302\u8f7d\u7684\u3002","title":"13.1.1 \u521b\u5efaprocess\u5bf9\u8c61"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1312-env","text":"1. Local<String> env_string = FIXED_ONE_BYTE_STRING(isolate_, \"env\"); 2. Local<Object> env_var_proxy; 3. // \u8bbe\u7f6eprocess\u7684env\u5c5e\u6027 4. if (!CreateEnvVarProxy(context(), 5. isolate_, 6. as_callback_data()) 7. .ToLocal(&env_var_proxy) || 8. process_object()->Set(context(), 9. env_string, 10. env_var_proxy).IsNothing()) { 11. return MaybeLocal<Value>(); 12. } \u4e0a\u9762\u7684\u4ee3\u7801\u901a\u8fc7CreateEnvVarProxy\u521b\u5efa\u4e86\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u4fdd\u5b58\u5230env_var_proxy\u4e2d\uff0c\u6700\u540e\u7ed9process\u6302\u8f7d\u4e86env\u5c5e\u6027\u3002\u5b83\u7684\u503c\u662fCreateEnvVarProxy\u521b\u5efa\u7684\u5bf9\u8c61\u3002 1. MaybeLocal<Object> CreateEnvVarProxy(Local<Context> context, 2. Isolate* isolate, 3. Local<Object> data) { 4. EscapableHandleScope scope(isolate); 5. Local<ObjectTemplate> env_proxy_template = ObjectTemplate::New(isolate); 6. env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration( 7. EnvGetter, 8. EnvSetter, 9. EnvQuery, 10. EnvDeleter, 11. EnvEnumerator, 12. data, 13. PropertyHandlerFlags::kHasNoSideEffect)); 14. return scope.EscapeMaybe(env_proxy_template->NewInstance(context)); 15. } CreateEnvVarProxy\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u5bf9\u8c61\u6a21\u677f\uff0c\u7136\u540e\u8bbe\u7f6e\u901a\u8fc7\u8be5\u5bf9\u8c61\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u7684\u8bbf\u95ee\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0bgetter\u63cf\u8ff0\u7b26\uff08EnvGetter\uff09\u7684\u5b9e\u73b0\uff0cgetter\u63cf\u8ff0\u7b26\u548c\u6211\u4eec\u5728JS\u91cc\u4f7f\u7528\u7684\u7c7b\u4f3c\u3002 1. static void EnvGetter(Local<Name> property, 2. const PropertyCallbackInfo<Value>& info) { 3. Environment* env = Environment::GetCurrent(info); 4. MaybeLocal<String> value_string = env->env_vars()->Get(env->isolate(), property.As<String>()); 5. if (!value_string.IsEmpty()) { 6. info.GetReturnValue().Set(value_string.ToLocalChecked()); 7. } 8. } \u6211\u4eec\u770b\u5230getter\u662f\u4eceenv->env_vars()\u4e2d\u83b7\u53d6\u6570\u636e\uff0c\u90a3\u4e48env->env_vars()\u53c8\u662f\u4ec0\u4e48\u5462\uff1fenv_vars\u662f\u4e00\u4e2akv\u5b58\u50a8\u7cfb\u7edf\uff0c\u5176\u5b9e\u5c31\u662f\u4e00\u4e2amap\u3002\u5b83\u53ea\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\uff08\u521b\u5efaenv\u5bf9\u8c61\u65f6\uff09\u3002 set_env_vars(per_process::system_environment); \u90a3\u4e48per_process::system_environment\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\uff0c std::shared_ptr<KVStore> system_environment = std::make_shared<RealEnvStore>(); \u6211\u4eec\u770b\u5230system_environment\u662f\u4e00\u4e2aRealEnvStore\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bRealEnvStore\u7c7b\u7684\u5b9e\u73b0\u3002 1. class RealEnvStore final : public KVStore { 2. public: 3. MaybeLocal<String> Get(Isolate* isolate, Local<String> key) const override; 4. void Set(Isolate* isolate, Local<String> key, Local<String> value) override; 5. int32_t Query(Isolate* isolate, Local<String> key) const override; 6. void Delete(Isolate* isolate, Local<String> key) override; 7. Local<Array> Enumerate(Isolate* isolate) const override; 8. }; \u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u589e\u5220\u6539\u67e5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u67e5\u8be2Get\u7684\u5b9e\u73b0\u3002 1. MaybeLocal<String> RealEnvStore::Get(Isolate* isolate, 2. Local<String> property) const { 3. Mutex::ScopedLock lock(per_process::env_var_mutex); 4. 5. node::Utf8Value key(isolate, property); 6. size_t init_sz = 256; 7. MaybeStackBuffer<char, 256> val; 8. int ret = uv_os_getenv(*key, *val, &init_sz); 9. if (ret >= 0) { // Env key value fetch success. 10. MaybeLocal<String> value_string = 11. String::NewFromUtf8(isolate, 12. *val, 13. NewStringType::kNormal, 14. init_sz); 15. return value_string; 16. } 17. 18. return MaybeLocal<String>(); 19. } \u6211\u4eec\u770b\u5230\u662f\u901a\u8fc7uv_os_getenv\u83b7\u53d6\u7684\u6570\u636e\u3002uv_os_getenv\u662f\u5bf9getenv\u51fd\u6570\u7684\u5c01\u88c5\uff0c\u8fdb\u7a0b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\uff0c\u6709\u4e00\u90e8\u5206\u662f\u7528\u4e8e\u5b58\u50a8\u73af\u5883\u53d8\u91cf\u7684\uff0cgetenv\u5c31\u662f\u4ece\u90a3\u4e00\u5757\u5185\u5b58\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\u3002\u6211\u4eec\u6267\u884cexecve\u7684\u65f6\u5019\u53ef\u4ee5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u3002\u5177\u4f53\u7684\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u7ae0\u8282\u4f1a\u770b\u5230\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u77e5\u9053process\u7684env\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u5c31\u662f\u8fdb\u7a0b\u73af\u5883\u53d8\u91cf\u7684\u5185\u5bb9\u3002","title":"13.1.2 \u6302\u8f7denv\u5c5e\u6027"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1313","text":"\u5728Node.js\u7684\u542f\u52a8\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5730\u6302\u8f7d\u5c5e\u6027\u5230process\u3002\u4e3b\u8981\u5728bootstrap/node.js\u4e2d\u3002\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1. const rawMethods = internalBinding('process_methods'); 2. process.dlopen = rawMethods.dlopen; 3. process.uptime = rawMethods.uptime; 4. process.nextTick = nextTick; \u4e0b\u9762\u662fprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027\uff0c\u4e3b\u5217\u51fa\u5e38\u7528\u7684\u3002 1. env->SetMethod(target, \"memoryUsage\", MemoryUsage); 2. env->SetMethod(target, \"cpuUsage\", CPUUsage); 3. env->SetMethod(target, \"hrtime\", Hrtime); 4. env->SetMethod(target, \"dlopen\", binding::DLOpen); 5. env->SetMethodNoSideEffect(target, \"uptime\", Uptime); \u6211\u4eec\u770b\u5230\u5728JS\u5c42\u8bbf\u95eeprocess\u5c5e\u6027\u7684\u65f6\u5019\uff0c\u8bbf\u95ee\u7684\u662f\u5bf9\u5e94\u7684C++\u5c42\u7684\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u5927\u90e8\u5206\u4e5f\u53ea\u662f\u5bf9Libuv\u7684\u5c01\u88c5\u3002\u53e6\u5916\u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u6267\u884cPatchProcessObject\u3002PatchProcessObject\u51fd\u6570\u4f1a\u6302\u8f7d\u4e00\u4e9b\u989d\u5916\u7684\u5c5e\u6027\u7ed9process\u3002 1. // process.argv 2. process->Set(context, 3. FIXED_ONE_BYTE_STRING(isolate, \"argv\"), 4. ToV8Value(context, env->argv()).ToLocalChecked()).Check(); 5. 6. READONLY_PROPERTY(process, 7. \"pid\", 8. Integer::New(isolate, uv_os_getpid())); 9. 10. CHECK(process->SetAccessor(context, 11. FIXED_ONE_BYTE_STRING(isolate, \"ppid\"), 12. GetParentProcessId).FromJust()) \u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5728\u591a\u4e2a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027\uff0c\u8fd9\u91cc\u53ea\u5217\u51fa\u4e86\u4e00\u90e8\u5206\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u4ecebootstrap/node.js\u7684\u4ee3\u7801\u5f00\u59cb\u770b\u90fd\u6302\u8f7d\u4e86\u4ec0\u4e48\u5c5e\u6027\u3002\u56e0\u4e3aNode.js\u652f\u6301\u591a\u7ebf\u7a0b\uff0c\u6240\u4ee5\u9488\u5bf9\u7ebf\u7a0b\u7684\u60c5\u51b5\uff0c\u6709\u4e00\u4e9b\u7279\u6b8a\u7684\u5904\u7406\u3002 1. const perThreadSetup = require('internal/process/per_thread'); 2. // rawMethods\u6765\u81eaprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027 3. const wrapped = perThreadSetup.wrapProcessMethods(rawMethods); 4. process.hrtime = wrapped.hrtime; 5. process.cpuUsage = wrapped.cpuUsage; 6. process.memoryUsage = wrapped.memoryUsage; 7. process.kill = wrapped.kill; 8. process.exit = wrapped.exit; \u5927\u90e8\u5206\u51fd\u6570\u90fd\u662f\u5bf9process_methods\u6a21\u5757\uff08node_process_methods.cc\uff09\u7684\u5c01\u88c5\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u5c5e\u6027\u6211\u4eec\u9700\u8981\u5173\u6ce8\u4e00\u4e0b\uff0c\u5c31\u662fexit\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u4e2d\u8c03\u7528process.exit\u7684\u65f6\u5019\uff0c\u53ea\u4f1a\u9000\u51fa\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\u3002 1. function exit(code) { 2. if (code || code === 0) 3. process.exitCode = code; 4. 5. if (!process._exiting) { 6. process._exiting = true; 7. process.emit('exit', process.exitCode || 0); 8. } 9. process.reallyExit(process.exitCode || 0); 10. } \u6211\u4eec\u7ee7\u7eed\u770breallyExit 1. static void ReallyExit(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. RunAtExit(env); 4. int code = args[0]->Int32Value(env->context()).FromMaybe(0); 5. env->Exit(code); 6. } \u8c03\u7528\u4e86env\u7684Exit\u3002 1. void Environment::Exit(int exit_code) { 2. if (is_main_thread()) { 3. stop_sub_worker_contexts(); 4. DisposePlatform(); 5. exit(exit_code); 6. } else { 7. worker_context_->Exit(exit_code); 8. } 9. } \u8fd9\u91cc\u6211\u4eec\u770b\u5230\u4e86\u91cd\u70b9\uff0c\u6839\u636e\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u4f1a\u505a\u4e0d\u540c\u7684\u5904\u7406\u3002\u4e00\u4e2a\u7ebf\u7a0b\u4f1a\u5bf9\u5e94\u4e00\u4e2aenv\uff0cenv\u5bf9\u8c61\u4e2d\u7684worker_context_\u4fdd\u5b58\u5c31\u662f\u7ebf\u7a0b\u5bf9\u8c61\uff08Worker\uff09\u3002\u6211\u4eec\u5148\u770b\u5b50\u7ebf\u7a0b\u7684\u903b\u8f91\u3002 1. void Worker::Exit(int code) { 2. Mutex::ScopedLock lock(mutex_); 3. if (env_ != nullptr) { 4. exit_code_ = code; 5. Stop(env_); 6. } else { 7. stopped_ = true; 8. } 9. } 10. 11. int Stop(Environment* env) { 12. env->ExitEnv(); 13. return 0; 14. } 15. 16. void Environment::ExitEnv() { 17. set_can_call_into_js(false); 18. set_stopping(true); 19. isolate_->TerminateExecution(); 20. // \u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af 21. SetImmediateThreadsafe([](Environment* env) { uv_stop(env->event_loop()); }); 22. } \u6211\u4eec\u770b\u5230\u5b50\u7ebf\u7a0b\u6700\u540e\u8c03\u7528uv_stop\u63d0\u51fa\u4e86Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u9000\u51fa\u3002\u6211\u4eec\u518d\u6765\u770b\u4e3b\u7ebf\u7a0b\u7684\u9000\u51fa\u903b\u8f91\u3002 1. if (is_main_thread()) { 2. stop_sub_worker_contexts(); 3. DisposePlatform(); 4. exit(exit_code); 5. } \u6211\u4eec\u770b\u5230\u6700\u540e\u4e3b\u8fdb\u7a0b\u4e2d\u8c03\u7528exit\u9000\u51fa\u8fdb\u7a0b\u3002\u4f46\u662f\u9000\u51fa\u524d\u8fd8\u6709\u4e00\u4e9b\u5904\u7406\u5de5\u4f5c\uff0c\u6211\u4eec\u770bstop_sub_worker_contexts 1. void Environment::stop_sub_worker_contexts() { 2. while (!sub_worker_contexts_.empty()) { 3. Worker* w = *sub_worker_contexts_.begin(); 4. remove_sub_worker_context(w); 5. w->Exit(1); 6. w->JoinThread(); 7. } 8. } sub_worker_contexts\u4fdd\u5b58\u7684\u662fWorker\u5bf9\u8c61\u5217\u8868\uff0c\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5f80\u91cc\u8ffd\u52a0\u4e00\u4e2a\u5143\u7d20\u3002\u8fd9\u91cc\u904d\u5386\u8fd9\u4e2a\u5217\u8868\uff0c\u7136\u540e\u8c03\u7528Exit\u51fd\u6570\uff0c\u8fd9\u4e2a\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u662f\u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af\u3002\u4e3b\u7ebf\u7a0b\u63a5\u7740\u8c03JoinThread\uff0cJoinThread\u4e3b\u8981\u662f\u4e3a\u4e86\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\uff0c\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u5728\u9000\u51fa\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u4f1a\u88ab\u64cd\u4f5c\u7cfb\u7edf\u6302\u8d77\uff08\u6267\u884c\u65f6\u95f4\u7247\u5230\u4e86\uff09\uff0c\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u88ab\u8c03\u5ea6\u6267\u884c\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u8fd8\u4e0d\u80fd\u9000\u51fa\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f7f\u7528join\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\u3002Node.js\u7684JoinThread\u9664\u4e86\u5bf9\u7ebf\u7a0bjoin\u51fd\u6570\u7684\u5c01\u88c5\u3002\u8fd8\u505a\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982\u89e6\u53d1exit\u4e8b\u4ef6\u3002","title":"13.1.3 \u6302\u8f7d\u5176\u5b83\u5c5e\u6027"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#132","text":"\u56e0\u4e3aNode.js\u662f\u5355\u8fdb\u7a0b\u7684\uff0c\u4f46\u6709\u5f88\u591a\u4e8b\u60c5\u53ef\u80fd\u4e0d\u9002\u5408\u5728\u4e3b\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\uff0c\u6240\u4ee5Node.js\u63d0\u4f9b\u4e86\u5b50\u8fdb\u7a0b\u6a21\u5757\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u5b50\u8fdb\u7a0b\u505a\u4e00\u4e9b\u989d\u5916\u4efb\u52a1\u7684\u5904\u7406\uff0c\u53e6\u5916\uff0c\u5b50\u8fdb\u7a0b\u7684\u597d\u5904\u662f\uff0c\u4e00\u65e6\u5b50\u8fdb\u7a0b\u51fa\u95ee\u9898\u6302\u6389\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u7528C\u8bed\u8a00\u5982\u4f55\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u3002 1. #include<unistd.h> 2. #include<stdlib.h> 3. 4. int main(int argc,char *argv[]){ 5. pid_t pid = fork(); 6. if (pid < 0) { 7. // \u9519\u8bef 8. } else if(pid == 0) { 9. // \u5b50\u8fdb\u7a0b\uff0c\u53ef\u4ee5\u4f7f\u7528exec*\u7cfb\u5217\u51fd\u6570\u6267\u884c\u65b0\u7684\u7a0b\u5e8f 10. } else { 11. // \u7236\u8fdb\u7a0b 12. } 13. } fork\u51fd\u6570\u7684\u7279\u70b9\uff0c\u6211\u4eec\u542c\u5f97\u6700\u591a\u7684\u53ef\u80fd\u662f\u6267\u884c\u4e00\u6b21\u8fd4\u56de\u4e24\u6b21\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u7591\u60d1\uff0c\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u600e\u4e48\u53ef\u80fd\u8fd4\u56de\u4e86\u4e24\u6b21\u5462\uff1f\u4e4b\u524d\u6211\u4eec\u8bb2\u8fc7\uff0c\u8fdb\u7a0b\u662ftask_struct\u8868\u793a\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u8c03\u7528 fork\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2a\u65b0\u7684task_struct\u5b9e\u4f8b\u51fa\u6765\uff08\u53d8\u6210\u4e24\u4e2a\u8fdb\u7a0b\uff09\uff0cfork\u8fd4\u56de\u4e24\u6b21\u7684\u610f\u601d\u5176\u5b9e\u662f\u5728\u5728\u4e24\u4e2a\u8fdb\u7a0b\u5206\u522b\u8fd4\u56de\u4e00\u6b21\uff0c\u6267\u884c\u7684\u90fd\u662ffork\u540e\u9762\u7684\u4e00\u884c\u4ee3\u7801\u3002\u800c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u662f\u4e3b\u8fdb\u7a0b\u8fd8\u662f\u5b50\u8fdb\u7a0b\uff0c\u8bbe\u7f6e\u4e86fork\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0cfork\u8fd4\u56de\u503c\u4e0d\u4e00\u6837\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u4ee3\u7801\u4e2dif else\u6761\u4ef6\u3002\u4f46\u662ffork\u53ea\u662f\u590d\u5236\u4e3b\u8fdb\u7a0b\u7684\u5185\u5bb9\uff0c\u5982\u679c\u6211\u4eec\u60f3\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u600e\u4e48\u529e\u5462\uff1f\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u7528\u5230exec*\u7cfb\u5217\u51fd\u6570\uff0c\u8be5\u7cfb\u5217\u51fd\u6570\u4f1a\u8986\u76d6\u65e7\u8fdb\u7a0b\uff08task_struct\uff09\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u91cd\u65b0\u52a0\u8f7d\u65b0\u7684\u7a0b\u5e8f\u5185\u5bb9\u3002\u8fd9\u4e5f\u662fNode.js\u4e2d\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u5e95\u5c42\u539f\u7406\u3002Node.js\u867d\u7136\u63d0\u4f9b\u4e86\u5f88\u591a\u79cd\u521b\u5efa\u8fdb\u7a0b\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u540c\u6b65\u548c\u5f02\u6b65\u4e24\u79cd\u65b9\u5f0f\u3002","title":"13.2 \u521b\u5efa\u5b50\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1321","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5f02\u6b65\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u65f6\u7684\u5173\u7cfb\u56fe\u5982\u56fe13-1\u6240\u793a\u3002 \u56fe13-1 \u6211\u4eec\u4ecefork\u8fd9\u4e2a\u51fd\u6570\u5f00\u59cb\uff0c\u770b\u4e00\u4e0b\u6574\u4e2a\u6d41\u7a0b\u3002 1. function fork(modulePath /* , args, options */) { 2. // \u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406 3. return spawn(options.execPath, args, options); 4. } \u6211\u4eec\u63a5\u7740\u770bspawn 1. var spawn = exports.spawn = function(/*file, args, options*/) { var opts = normalizeSpawnArguments.apply(null, arguments); 2. var options = opts.options; 3. var child = new ChildProcess(); 4. 5. child.spawn({ 6. file: opts.file, 7. args: opts.args, 8. cwd: options.cwd, 9. windowsHide: !!options.windowsHide, 10. windowsVerbatimArguments: !!options.windowsVerbatimArguments, 11. detached: !!options.detached, 12. envPairs: opts.envPairs, 13. stdio: options.stdio, 14. uid: options.uid, 15. gid: options.gid 16. }); 17. 18. return child; 19. }; \u6211\u4eec\u770b\u5230spawn\u51fd\u6570\u53ea\u662f\u5bf9ChildProcess\u7684\u5c01\u88c5\u3002\u7136\u540e\u8c03\u7528\u5b83\u7684spawn\u51fd\u6570\u3002\u6211\u4eec\u770b\u770bChildProcess\u3002 1. function ChildProcess() { 2. // C++\u5c42\u5b9a\u4e49 3. this._handle = new Process(); 4. } 5. 6. ChildProcess.prototype.spawn = function(options) { 7. // \u521b\u5efa\u8fdb\u7a0b 8. const err = this._handle.spawn(options); 9. } 10. ChildProcess\u662f\u5bf9C++\u5c42\u7684\u5c01\u88c5\uff0c\u4e0d\u8fc7Process\u5728C++\u5c42\u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u8fdb\u884c\u53c2\u6570\u7684\u5904\u7406\u7136\u540e\u8c03\u7528Libuv\u7684uv_spawn\u3002\u6211\u4eec\u901a\u8fc7uv_spawn\u6765\u5230\u4e86C\u8bed\u8a00\u5c42\u3002\u6211\u4eec\u770b\u770buv_spawn\u7684\u6574\u4f53\u6d41\u7a0b\u3002 1. int uv_spawn(uv_loop_t* loop, 2. uv_process_t* process, 3. const uv_process_options_t* options) { 4. 5. uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS); 6. QUEUE_INIT(&process->queue); 7. // \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 8. for (i = 0; i < options->stdio_count; i++) { 9. err = uv__process_init_stdio(options->stdio + i, pipes[i]); 10. if (err) 11. goto error; 12. } 13. /* 14. \u521b\u5efa\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u521b\u5efa\u8fdb\u7a0b\u671f\u95f4\u7684\u7236\u8fdb\u7a0b\u5b50\u901a\u4fe1\uff0c 15. \u8bbe\u7f6eUV__O_CLOEXEC\u6807\u8bb0\uff0c\u5b50\u8fdb\u7a0b\u6267\u884cexecvp 16. \u7684\u65f6\u5019\u7ba1\u9053\u7684\u4e00\u7aef\u4f1a\u88ab\u5173\u95ed 17. */ 18. err = uv__make_pipe(signal_pipe, 0); 19. // \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570 20. uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD); 21. 22. uv_rwlock_wrlock(&loop->cloexec_lock); 23. // \u521b\u5efa\u5b50\u8fdb\u7a0b 24. pid = fork(); 25. // \u5b50\u8fdb\u7a0b 26. if (pid == 0) { 27. uv__process_child_init(options, 28. stdio_count, 29. pipes, 30. signal_pipe[1]); 31. abort(); 32. } 33. // \u7236\u8fdb\u7a0b 34. uv_rwlock_wrunlock(&loop->cloexec_lock); 35. // \u5173\u95ed\u7ba1\u9053\u5199\u7aef\uff0c\u7b49\u5f85\u5b50\u8fdb\u7a0b\u5199 36. uv__close(signal_pipe[1]); 37. 38. process->status = 0; 39. exec_errorno = 0; 40. // \u5224\u65ad\u5b50\u8fdb\u7a0b\u662f\u5426\u6267\u884c\u6210\u529f 41. do 42. r = read(signal_pipe[0],&exec_errorno,sizeof(exec_errorno)); 43. while (r == -1 && errno == EINTR); 44. // \u5ffd\u7565\u5904\u7406r\u7684\u903b\u8f91 45. // \u4fdd\u5b58\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 46. for (i = 0; i < options->stdio_count; i++) { 47. uv__process_open_stream(options->stdio + i, pipes[i]); 48. } 49. 50. // \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u6784\u4f53 51. if (exec_errorno == 0) { 52. QUEUE_INSERT_TAIL(&loop->process_handles, &process->queue); 53. uv__handle_start(process); 54. } 55. 56. process->pid = pid; 57. process->exit_cb = options->exit_cb; 58. 59. return exec_errorno; 60. } uv_spawn\u7684\u903b\u8f91\u5927\u81f4\u5206\u4e3a\u4e0b\u9762\u51e0\u4e2a 1 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 2 \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406\u51fd\u6570 3 \u521b\u5efa\u5b50\u8fdb\u7a0b 4 \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684process_handles\u5bf9\u8c61\uff0c\u4fdd\u5b58\u72b6\u6001\u7801\u548c\u56de\u8c03\u7b49\u3002 \u6211\u4eec\u5206\u67902,3\uff0c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6211\u4eec\u5355\u72ec\u5206\u6790\u3002 1 \u5904\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa \u4e3b\u8fdb\u7a0b\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u4e4b\u524d\uff0c\u4f1a\u6ce8\u518cSIGCHLD\u4fe1\u53f7\u3002\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u662fuv__chld\u3002\u5f53\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u3002Node.js\u4e3b\u8fdb\u7a0b\u4f1a\u6536\u5230SIGCHLD\u4fe1\u53f7\u3002\u7136\u540e\u6267\u884cuv__chld\u3002\u8be5\u51fd\u6570\u904d\u5386Libuv\u8fdb\u7a0b\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u901a\u8fc7waitpid\u5224\u65ad\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u8fdb\u7a0b\u662f\u5426\u5df2\u7ecf\u9000\u51fa\u540e\uff0c\u4ece\u800c\u5904\u7406\u5df2\u9000\u51fa\u7684\u8282\u70b9\uff0c\u7136\u540e\u79fb\u51faLibuv\u961f\u5217\uff0c\u6700\u540e\u6267\u884c\u5df2\u9000\u51fa\u8fdb\u7a0b\u7684\u56de\u8c03\u3002 1. static void uv__chld(uv_signal_t* handle, int signum) { 2. uv_process_t* process; 3. uv_loop_t* loop; 4. int exit_status; 5. int term_signal; 6. int status; 7. pid_t pid; 8. QUEUE pending; 9. QUEUE* q; 10. QUEUE* h; 11. // \u4fdd\u5b58\u8fdb\u7a0b\uff08\u5df2\u9000\u51fa\u7684\u72b6\u6001\uff09\u7684\u961f\u5217 12. QUEUE_INIT(&pending); 13. loop = handle->loop; 14. 15. h = &loop->process_handles; 16. q = QUEUE_HEAD(h); 17. // \u6536\u96c6\u5df2\u9000\u51fa\u7684\u8fdb\u7a0b 18. while (q != h) { 19. process = QUEUE_DATA(q, uv_process_t, queue); 20. q = QUEUE_NEXT(q); 21. 22. do 23. /* 24. WNOHANG\u975e\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u5176\u5b9e\u5c31\u662f\u770b\u5b50\u8fdb\u7a0b\u662f\u5426\u9000\u51fa\u4e86\uff0c 25. \u6ca1\u6709\u7684\u8bdd\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u800c\u4e0d\u662f\u963b\u585e 26. */ 27. pid = waitpid(process->pid, &status, WNOHANG); 28. while (pid == -1 && errno == EINTR); 29. 30. if (pid == 0) 31. continue; 32. /* 33. \u8fdb\u7a0b\u9000\u51fa\u4e86\uff0c\u4fdd\u5b58\u9000\u51fa\u72b6\u6001\uff0c\u79fb\u51fa\u961f\u5217\uff0c 34. \u63d2\u5165peding\u961f\u5217\uff0c\u7b49\u5f85\u5904\u7406 35. */ 36. process->status = status; 37. QUEUE_REMOVE(&process->queue); 38. QUEUE_INSERT_TAIL(&pending, &process->queue); 39. } 40. 41. h = &pending; 42. q = QUEUE_HEAD(h); 43. // \u662f\u5426\u6709\u9000\u51fa\u7684\u8fdb\u7a0b 44. while (q != h) { 45. process = QUEUE_DATA(q, uv_process_t, queue); 46. q = QUEUE_NEXT(q); 47. QUEUE_REMOVE(&process->queue); 48. QUEUE_INIT(&process->queue); 49. uv__handle_stop(process); 50. 51. if (process->exit_cb == NULL) 52. continue; 53. 54. exit_status = 0; 55. // \u83b7\u53d6\u9000\u51fa\u4fe1\u606f\uff0c\u6267\u884c\u4e0a\u4f20\u56de\u8c03 56. if (WIFEXITED(process->status)) 57. exit_status = WEXITSTATUS(process->status); 58. // \u662f\u5426\u56e0\u4e3a\u4fe1\u53f7\u800c\u9000\u51fa 59. term_signal = 0; 60. if (WIFSIGNALED(process->status)) 61. term_signal = WTERMSIG(process->status); 62. 63. process->exit_cb(process, exit_status, term_signal); 64. } 65. } \u5f53\u4e3b\u8fdb\u7a0b\u4e0b\u7684\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\uff0c\u7236\u8fdb\u7a0b\u4e3b\u8981\u8d1f\u8d23\u6536\u96c6\u5b50\u8fdb\u7a0b\u9000\u51fa\u72b6\u6001\u548c\u539f\u56e0\u7b49\u4fe1\u606f\uff0c\u7136\u540e\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 2 \u521b\u5efa\u5b50\u8fdb\u7a0b\uff08uv__process_child_init\uff09 \u4e3b\u8fdb\u7a0b\u9996\u5148\u4f7f\u7528uv__make_pipe\u7533\u8bf7\u4e00\u4e2a\u533f\u540d\u7ba1\u9053\u7528\u4e8e\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\uff0c\u533f\u540d\u7ba1\u9053\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e2d\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u79cd\uff0c\u5b83\u53ea\u7528\u4e8e\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u56e0\u4e3a\u533f\u540d\uff0c\u975e\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\u65e0\u6cd5\u627e\u5230\u8fd9\u4e2a\u7ba1\u9053\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5b8c\u6210\u901a\u4fe1\uff0c\u800c\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u662f\u901a\u8fc7fork\u51fa\u6765\u7684\uff0c\u7236\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u83b7\u5f97\u5f97\u5230\u7ba1\u9053\u3002\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528\u7ee7\u627f\u4e8e\u7236\u8fdb\u7a0b\u7684\u8d44\u6e90\uff0c\u7ba1\u9053\u901a\u4fe1\u7684\u539f\u7406\u5982\u56fe13-2\u6240\u793a\u3002 \u56fe13-2 \u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u8fc7\u5171\u4eabfile\u548cinode\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5bf9\u540c\u4e00\u5757\u5185\u5b58\u7684\u8bfb\u5199\u3002\u4e3b\u8fdb\u7a0bfork\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u4f1a\u901a\u8fc7read\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7684\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002 1. static void uv__process_child_init(const uv_process_options_t* options, 2. int stdio_count, 3. int (*pipes)[2], 4. int error_fd) { 5. sigset_t set; 6. int close_fd; 7. int use_fd; 8. int err; 9. int fd; 10. int n; 11. // \u7701\u7565\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u7b49\u53c2\u6570\u903b\u8f91 12. // \u5904\u7406\u73af\u5883\u53d8\u91cf 13. if (options->env != NULL) { 14. environ = options->env; 15. } 16. // \u5904\u7406\u4fe1\u53f7 17. for (n = 1; n < 32; n += 1) { 18. // \u8fd9\u4e24\u4e2a\u4fe1\u53f7\u89e6\u53d1\u65f6\uff0c\u9ed8\u8ba4\u884c\u4e3a\u662f\u8fdb\u7a0b\u9000\u51fa\u4e14\u4e0d\u80fd\u963b\u6b62\u7684 19. if (n == SIGKILL || n == SIGSTOP) 20. continue; /* Can't be changed. */ 21. // \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u5904\u7406\u65b9\u5f0f 22. if (SIG_ERR != signal(n, SIG_DFL)) 23. continue; 24. // \u51fa\u9519\u5219\u901a\u77e5\u4e3b\u8fdb\u7a0b 25. uv__write_int(error_fd, UV__ERR(errno)); 26. _exit(127); 27. } 28. // \u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6 29. execvp(options->file, options->args); 30. // \u52a0\u8f7d\u6210\u529f\u5219\u4e0d\u4f1a\u8d70\u5230\u8fd9\uff0c\u8d70\u5230\u8fd9\u8bf4\u660e\u52a0\u8f7d\u6267\u884c\u6587\u4ef6\u5931\u8d25 31. uv__write_int(error_fd, UV__ERR(errno)); 32. _exit(127); 33. } \u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e3b\u8981\u662f\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4fe1\u53f7\u3001\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u7b49\u3002\u7136\u540e\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u3002\u56e0\u4e3a\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86cloexec\u6807\u8bb0\u3002\u6240\u4ee5\u5f53\u5b50\u8fdb\u7a0b\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u5c31\u4f1a\u5173\u95ed\u7528\u4e8e\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4ece\u800c\u5bfc\u81f4\u4e3b\u8fdb\u7a0b\u8bfb\u53d6\u7ba1\u9053\u8bfb\u7aef\u7684\u65f6\u5019\u8fd4\u56de0\uff0c\u8fd9\u6837\u4e3b\u8fdb\u7a0b\u5c31\u77e5\u9053\u5b50\u8fdb\u7a0b\u6210\u529f\u6267\u884c\u4e86\u3002","title":"13.2.1 \u5f02\u6b65\u521b\u5efa\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1322","text":"\u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u7684\u8fdb\u7a0b\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u3002\u63a5\u4e0b\u6765\u770b\u770b\u5982\u4f55\u4ee5\u540c\u6b65\u7684\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u3002JS\u5c42\u5165\u53e3\u51fd\u6570\u662fspawnSync\u3002spawnSync\u8c03\u7528C++\u6a21\u5757spawn_sync\u7684spawn\u51fd\u6570\u521b\u5efa\u8fdb\u7a0b\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u5e94\u7684C++\u6a21\u5757spawn_sync\u5bfc\u51fa\u7684\u5c5e\u6027\u3002 1. void SyncProcessRunner::Initialize(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. env->SetMethod(target, \"spawn\", Spawn); 7. } \u8be5\u6a21\u5757\u503c\u5bfc\u51fa\u4e86\u4e00\u4e2a\u5c5e\u6027spawn\uff0c\u5f53\u6211\u4eec\u8c03\u7528spawn\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u662fC++\u7684Spawn\u3002 1. void SyncProcessRunner::Spawn(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. env->PrintSyncTrace(); 4. SyncProcessRunner p(env); 5. Local<Value> result; 6. if (!p.Run(args[0]).ToLocal(&result)) return; 7. args.GetReturnValue().Set(result); 8. } Spawn\u4e2d\u4e3b\u8981\u662f\u65b0\u5efa\u4e86\u4e00\u4e2aSyncProcessRunner\u5bf9\u8c61\u5e76\u4e14\u6267\u884cRun\u65b9\u6cd5\u3002\u6211\u4eec\u770b\u4e00\u4e0bSyncProcessRunner\u7684Run\u505a\u4e86\u4ec0\u4e48\u3002 1. MaybeLocal<Object> SyncProcessRunner::Run(Local<Value> options) { 2. EscapableHandleScope scope(env()->isolate()); 3. Maybe<bool> r = TryInitializeAndRunLoop(options); 4. Local<Object> result = BuildResultObject(); 5. return scope.Escape(result); 6. } \u6267\u884c\u4e86TryInitializeAndRunLoop\u3002 1. Maybe<bool> SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) { 2. int r; 3. 4. lifecycle_ = kInitialized; 5. // \u65b0\u5efa\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af 6. uv_loop_ = new uv_loop_t; 7. if (!ParseOptions(options).To(&r)) return Nothing<bool>(); 8. if (r < 0) { 9. SetError(r); 10. return Just(false); 11. } 12. // \u8bbe\u7f6e\u5b50\u8fdb\u7a0b\u6267\u884c\u7684\u65f6\u95f4 13. if (timeout_ > 0) { 14. r = uv_timer_init(uv_loop_, &uv_timer_); 15. uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_)); 16. uv_timer_.data = this; 17. kill_timer_initialized_ = true; 18. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u6267\u884cKillTimerCallback 19. r = uv_timer_start(&uv_timer_, 20. KillTimerCallback, 21. timeout_, 22. 0); 23. } 24. // \u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u5904\u7406\u51fd\u6570 25. uv_process_options_.exit_cb = ExitCallback; 26. // \u4f20\u8fdb\u53bb\u65b0\u7684loop\u800c\u4e0d\u662f\u4e3b\u8fdb\u7a0b\u672c\u8eab\u7684loop 27. r = uv_spawn(uv_loop_, &uv_process_, &uv_process_options_); 28. uv_process_.data = this; 29. 30. for (const auto& pipe : stdio_pipes_) { 31. if (pipe != nullptr) { 32. r = pipe->Start(); 33. if (r < 0) { 34. SetPipeError(r); 35. return Just(false); 36. } 37. } 38. } 39. // \u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af 40. r = uv_run(uv_loop_, UV_RUN_DEFAULT); 41. return Just(true); 42. } \u4ece\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5230Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u7684\u3002\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u65f6\uff0cNode.js\u91cd\u65b0\u5f00\u542f\u4e86\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5e76\u4e14\u628a\u8868\u793a\u5b50\u8fdb\u7a0b\u7ed3\u6784\u4f53\u7684handle\u63d2\u5165\u5230\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u63a5\u7740Libuv\u4e00\u76f4\u5904\u4e8e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u56e0\u4e3a\u4e00\u76f4\u6709\u4e00\u4e2auv_process_t\uff08handle\uff09\uff0c\u6240\u4ee5\u65b0\u521b\u5efa\u7684uv_run\u4f1a\u4e00\u76f4\u5728\u6267\u884c\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u201d\u963b\u585e\u201d\u5728\u8be5uv_run\u3002\u76f4\u5230\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u540e\uff0c\u5220\u9664\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684uv_process_t\u3002\u7136\u540e\u6267\u884c\u56de\u8c03ExitCallback\u3002\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u518d\u6b21\u56de\u5230Node.js\u539f\u6765\u7684\u4e8b\u4ef6\u5faa\u73af\u3002\u5982\u56fe\u6240\u793a13-3\u3002 \u56fe13-3 \u8fd9\u5c31\u662f\u540c\u6b65\u7684\u672c\u8d28\u548c\u539f\u56e0\u3002\u6211\u4eec\u5206\u51e0\u6b65\u5206\u6790\u4e00\u4e0b\u4ee5\u4e0a\u4ee3\u7801","title":"13.2.2 \u540c\u6b65\u521b\u5efa\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#13221","text":"\u56e0\u4e3a\u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u5b50\u8fdb\u7a0b\u4f1a\u5bfc\u81f4Node.js\u4e3b\u8fdb\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u907f\u514d\u5b50\u8fdb\u7a0b\u6709\u95ee\u9898\uff0c\u4ece\u800c\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u7684\u6267\u884c\uff0cNode.js\u652f\u6301\u53ef\u914d\u7f6e\u5b50\u8fdb\u7a0b\u7684\u6700\u5927\u6267\u884c\u65f6\u95f4\u3002\u6211\u4eec\u770b\u5230\uff0cNode.js\u5f00\u542f\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5e76\u8bbe\u7f6e\u4e86\u56de\u8c03KillTimerCallback\u3002 1. void SyncProcessRunner::KillTimerCallback(uv_timer_t* handle) { 2. SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data); 3. self->OnKillTimerTimeout(); 4. } 5. 6. void SyncProcessRunner::OnKillTimerTimeout() { 7. SetError(UV_ETIMEDOUT); 8. Kill(); 9. } 10. 11. void SyncProcessRunner::Kill() { 12. if (killed_) 13. return; 14. killed_ = true; 15. if (exit_status_ < 0) { 16. // kill_signal_\u4e3a\u7528\u6237\u81ea\u5b9a\u4e49\u53d1\u9001\u7684\u6740\u6b7b\u8fdb\u7a0b\u7684\u4fe1\u53f7 17. int r = uv_process_kill(&uv_process_, kill_signal_); 18. // \u4e0d\u652f\u6301\u7528\u6237\u4f20\u7684\u4fe1\u53f7 19. if (r < 0 && r != UV_ESRCH) { 20. SetError(r); 21. // \u56de\u9000\u4f7f\u7528SIGKILL\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b 22. r = uv_process_kill(&uv_process_, SIGKILL); 23. CHECK(r >= 0 || r == UV_ESRCH); 24. } 25. } 26. 27. // Close all stdio pipes. 28. CloseStdioPipes(); 29. 30. // \u6e05\u9664\u5b9a\u65f6\u5668 31. CloseKillTimer(); 32. } \u5f53\u6267\u884c\u65f6\u95f4\u5230\u8fbe\u8bbe\u7f6e\u7684\u9608\u503c\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u7ed9\u5b50\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u9ed8\u8ba4\u662f\u6740\u6b7b\u5b50\u8fdb\u7a0b\u3002","title":"13.2.2.1 \u6267\u884c\u65f6\u95f4"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#13222","text":"\u9000\u51fa\u5904\u7406\u4e3b\u8981\u662f\u8bb0\u5f55\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u7684\u9519\u8bef\u7801\u548c\u88ab\u54ea\u4e2a\u4fe1\u53f7\u6740\u6b7b\u7684\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u3002 1. void SyncProcessRunner::ExitCallback(uv_process_t* handle, 2. int64_t exit_status, 3. int term_signal) { 4. SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data); 5. uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr); 6. self->OnExit(exit_status, term_signal); 7. } 8. 9. void SyncProcessRunner::OnExit(int64_t exit_status, int term_signal) { 10. if (exit_status < 0) 11. return SetError(static_cast<int>(exit_status)); 12. 13. exit_status_ = exit_status; 14. term_signal_ = term_signal; 15. }","title":"13.2.2.2 \u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#133","text":"\u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u591a\u8fdb\u7a0b\u7cfb\u7edf\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u529f\u80fd\uff0c\u5426\u5219\u8fdb\u7a0b\u5c31\u50cf\u5b64\u5c9b\u4e00\u6837\uff0c\u4e0d\u80fd\u4ea4\u6d41\u4fe1\u606f\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u9694\u79bb\u7684\uff0c\u5982\u679c\u8fdb\u7a0b\u95f4\u60f3\u901a\u4fe1\uff0c\u5c31\u9700\u8981\u4e00\u4e2a\u516c\u5171\u7684\u5730\u65b9\uff0c\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u5b8c\u6210\u4fe1\u606f\u7684\u4f20\u9012\u3002\u5728Linux\u4e2d\uff0c\u540c\u4e3b\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\u6709\u5f88\u591a\uff0c\u4f46\u662f\u57fa\u672c\u90fd\u662f\u4f7f\u7528\u72ec\u7acb\u4e8e\u8fdb\u7a0b\u7684\u989d\u5916\u5185\u5b58\u4f5c\u4e3a\u4fe1\u606f\u627f\u8f7d\u7684\u5730\u65b9\uff0c\u7136\u540e\u5728\u901a\u8fc7\u67d0\u79cd\u65b9\u5f0f\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\u5230\u8fd9\u5757\u516c\u5171\u5185\u5b58\uff0c\u6bd4\u5982\u7ba1\u9053\u3001\u5171\u4eab\u5185\u5b58\u3001Unix\u57df\u3001\u6d88\u606f\u961f\u5217\u7b49\u7b49\u3002\u4e0d\u8fc7\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u662f\u4e0d\u5c5e\u4e8e\u4ee5\u4e0a\u60c5\u51b5\u7684\uff0c\u90a3\u5c31\u662f\u4fe1\u53f7\u3002\u4fe1\u53f7\u4f5c\u4e3a\u4e00\u79cd\u7b80\u5355\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u63a5\u53e3\u8ba9\u8fdb\u7a0b\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u7684\u6570\u636e\uff08PCB\uff09\uff0c\u4ee5\u6b64\u8fbe\u5230\u901a\u4fe1\u76ee\u7684\u3002\u672c\u8282\u4ecb\u7ecdNode.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002","title":"13.3 \u8fdb\u7a0b\u95f4\u901a\u4fe1"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1331","text":"\u6211\u4eec\u4ecefork\u51fd\u6570\u5f00\u59cb\u5206\u6790Node.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u903b\u8f91\u3002 1. function fork(modulePath) { 2. // \u5ffd\u7565options\u53c2\u6570\u5904\u7406 3. if (typeof options.stdio === 'string') { 4. options.stdio = stdioStringToArray(options.stdio, 'ipc'); 5. } else if (!ArrayIsArray(options.stdio)) { 6. // silent\u4e3atrue\u5219\u662f\u7ba1\u9053\u5f62\u5f0f\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\uff0c\u5426\u5219\u662f\u7ee7\u627f 7. options.stdio = stdioStringToArray( 8. options.silent ? 'pipe' : 'inherit', 9. 'ipc'); 10. } else if (!options.stdio.includes('ipc')) { 11. // \u5fc5\u987b\u8981IPC\uff0c\u652f\u6301\u8fdb\u7a0b\u95f4\u901a\u4fe1 12. throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio'); 13. } 14. 15. return spawn(options.execPath, args, options); 16. } \u6211\u4eec\u770b\u4e00\u4e0bstdioStringToArray\u7684\u5904\u7406\u3002 1. function stdioStringToArray(stdio, channel) { 2. const options = []; 3. 4. switch (stdio) { 5. case 'ignore': 6. case 'pipe': options.push(stdio, stdio, stdio); break; 7. case 'inherit': options.push(0, 1, 2); break; 8. default: 9. throw new ERR_INVALID_OPT_VALUE('stdio', stdio); 10. } 11. 12. if (channel) options.push(channel); 13. 14. return options; 15. } stdioStringToArray\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6570\u7ec4\uff0c\u6bd4\u5982['pipe', 'pipe', 'pipe', 'ipc']\u6216[0, 1, 2, 'ipc']\uff0cipc\u4ee3\u8868\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053\uff0c\u5e76\u4e14\u652f\u6301\u6587\u4ef6\u63cf\u8ff0\u4f20\u9012\u3002\u6211\u4eec\u63a5\u7740\u770bspawn\u3002 1. ChildProcess.prototype.spawn = function(options) { 2. let i = 0; 3. // \u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 4. stdio = getValidStdio(stdio, false); 5. const ipc = stdio.ipc; 6. // IPC\u6587\u4ef6\u63cf\u8ff0\u7b26 7. const ipcFd = stdio.ipcFd; 8. stdio = options.stdio = stdio.stdio; 9. // \u901a\u8fc7\u73af\u5883\u53d8\u91cf\u544a\u8bc9\u5b50\u8fdb\u7a0bIPC\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6570\u636e\u5904\u7406\u6a21\u5f0f 10. if (ipc !== undefined) { 11. options.envPairs.push(`NODE_CHANNEL_FD=${ipcFd}`); 12. options.envPairs.push(`NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`); 13. } 14. // \u521b\u5efa\u5b50\u8fdb\u7a0b 15. const err = this._handle.spawn(options); 16. this.pid = this._handle.pid; 17. // \u5904\u7406IPC\u901a\u4fe1 18. if (ipc !== undefined) setupChannel(this, ipc, serialization); 19. return err; 20. } Spawn\u4e2d\u4f1a\u6267\u884cgetValidStdio\u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u53ea\u5173\u6ce8ipc\u7684\u3002 1. function getValidStdio(stdio, sync) { 2. let ipc; 3. let ipcFd; 4. 5. stdio = stdio.reduce((acc, stdio, i) => { 6. if (stdio === 'ipc') { 7. ipc = new Pipe(PipeConstants.IPC); 8. ipcFd = i; 9. acc.push({ 10. type: 'pipe', 11. handle: ipc, 12. ipc: true 13. }); 14. } else { 15. // \u5176\u5b83\u7c7b\u578b\u7684\u5904\u7406 16. } 17. return acc; 18. }, []); 19. 20. return { stdio, ipc, ipcFd }; 21. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1anew Pipe(PipeConstants.IPC);\u521b\u5efa\u4e00\u4e2aUnix\u57df\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff0c\u4f46\u662f\u8fd9\u91cc\u53ea\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u8fd8\u6ca1\u6709\u53ef\u7528\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u5f80\u4e0b\u770bC++\u5c42\u7684spawn\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002C++\u5c42\u9996\u5148\u5904\u7406\u53c2\u6570\uff0c 1. static void ParseStdioOptions(Environment* env, 2. Local<Object> js_options, 3. uv_process_options_t* options) { 4. Local<Context> context = env->context(); 5. Local<String> stdio_key = env->stdio_string(); 6. // \u62ff\u5230JS\u5c42stdio\u7684\u503c 7. Local<Array> stdios = 8. js_options->Get(context, stdio_key).ToLocalChecked().As<Array>(); 9. 10. uint32_t len = stdios->Length(); 11. options->stdio = new uv_stdio_container_t[len]; 12. options->stdio_count = len; 13. // \u904d\u5386stdio\uff0cstdio\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4 14. for (uint32_t i = 0; i < len; i++) { 15. Local<Object> stdio = 16. stdios->Get(context, i).ToLocalChecked().As<Object>(); 17. // \u62ff\u5230stdio\u7684\u7c7b\u578b 18. Local<Value> type = 19. stdio->Get(context, env->type_string()).ToLocalChecked(); 20. // \u521b\u5efaIPC\u901a\u9053 21. if (type->StrictEquals(env->pipe_string())) { 22. options->stdio[i].flags = static_cast<uv_stdio_flags>( 23. UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE); 24. // \u62ff\u5230\u5bf9\u5e94\u7684stream 25. options->stdio[i].data.stream = StreamForWrap(env, stdio); 26. } 27. } 28. } \u8fd9\u91cc\u4f1a\u628aStreamForWrap\u7684\u7ed3\u679c\u4fdd\u5b58\u5230stream\u4e2d\uff0c\u6211\u4eec\u770b\u770bStreamForWrap\u7684\u903b\u8f91 1. static uv_stream_t* StreamForWrap(Environment* env, Local<Object> stdio) { 2. Local<String> handle_key = env->handle_string(); 3. /* 4. \u83b7\u53d6\u5bf9\u8c61\u4e2d\u7684key\u4e3ahandle\u7684\u503c\uff0c\u5373\u521a\u624dJS\u5c42\u7684 5. new Pipe(SOCKET.IPC); 6. */ 7. Local<Object> handle = 8. stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>(); 9. // \u83b7\u53d6JS\u5c42\u4f7f\u7528\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684C++\u5bf9\u8c61\u4e2d\u7684stream 10. uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream(); 11. CHECK_NOT_NULL(stream); 12. return stream; 13. } 14. 15. // \u4eceJS\u5c42\u4f7f\u7528\u7684object\u4e2d\u83b7\u53d6\u5173\u8054\u7684C++\u5bf9\u8c61 16. ibuvStreamWrap* LibuvStreamWrap::From(Environment* env, Local<Object> object) { 17. return Unwrap<LibuvStreamWrap>(object); 18. } \u4ee5\u4e0a\u4ee3\u7801\u83b7\u53d6\u4e86IPC\u5bf9\u5e94\u7684stream\u7ed3\u6784\u4f53\u3002\u5728Libuv\u4e2d\u4f1a\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230stream\u4e2d\u3002\u6211\u4eec\u63a5\u7740\u770bC++\u5c42\u8c03\u7528Libuv\u7684uv_spawn\u3002 1. int uv_spawn(uv_loop_t* loop, 2. uv_process_t* process, 3. const uv_process_options_t* options) { 4. 5. int pipes_storage[8][2]; 6. int (*pipes)[2]; 7. int stdio_count; 8. // \u521d\u59cb\u5316\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 9. stdio_count = options->stdio_count; 10. if (stdio_count < 3) 11. stdio_count = 3; 12. 13. for (i = 0; i < stdio_count; i++) { 14. pipes[i][0] = -1; 15. pipes[i][1] = -1; 16. } 17. // \u521b\u5efa\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 18. for (i = 0; i < options->stdio_count; i++) { 19. err = uv__process_init_stdio(options->stdio + i, pipes[i]); 20. if (err) 21. goto error; 22. } 23. 24. // \u8bbe\u7f6e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 25. for (i = 0; i < options->stdio_count; i++) { 26. uv__process_open_stream(options->stdio + i, pipes[i]); 27. 28. } 29. 30. } Libuv\u4e2d\u4f1a\u521b\u5efa\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u8bbe\u7f6e\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 1. static int uv__process_open_stream(uv_stdio_container_t* container, 2. int pipefds[2]) { 3. int flags; 4. int err; 5. 6. if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0) 7. return 0; 8. 9. err = uv__close(pipefds[1]); 10. if (err != 0) 11. abort(); 12. 13. pipefds[1] = -1; 14. uv__nonblock(pipefds[0], 1); 15. 16. flags = 0; 17. if (container->flags & UV_WRITABLE_PIPE) 18. flags |= UV_HANDLE_READABLE; 19. if (container->flags & UV_READABLE_PIPE) 20. flags |= UV_HANDLE_WRITABLE; 21. 22. return uv__stream_open(container->data.stream, pipefds[0], flags); 23. } \u6267\u884c\u5b8cuv__process_open_stream\uff0c\u7528\u4e8eIPC\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c31\u4fdd\u5b58\u5230new Pipe(SOCKET.IPC)\u4e2d\u4e86\u3002\u6709\u4e86IPC\u901a\u9053\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8fdb\u7a0b\u8fd8\u9700\u8981\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u5230JS\u5c42\u6267\u884c\u5b8cspawn\u540e\uff0c\u4e3b\u8fdb\u7a0b\u901a\u8fc7setupChannel\u5bf9\u8fdb\u7a0b\u95f4\u901a\u4fe1\u8fdb\u884c\u4e86\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0bsetupChannel\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002","title":"13.3.1 \u521b\u5efa\u901a\u4fe1\u901a\u9053"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1332","text":"1 \u8bfb\u7aef 1. function setupChannel(target, channel, serializationMode) { 2. // channel\u662fnew Pipe(PipeConstants.IPC); 3. const control = new Control(channel); 4. target.channel = control; 5. // \u2026 6. channel.pendingHandle = null; 7. // \u6ce8\u518c\u5904\u7406\u6570\u636e\u7684\u51fd\u6570 8. channel.onread = function(arrayBuffer) { 9. // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 10. const recvHandle = channel.pendingHandle; 11. channel.pendingHandle = null; 12. if (arrayBuffer) { 13. const nread = streamBaseState[kReadBytesOrError]; 14. const offset = streamBaseState[kArrayBufferOffset]; 15. const pool = new Uint8Array(arrayBuffer, offset, nread); 16. if (recvHandle) 17. pendingHandle = recvHandle; 18. // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f 19. for (const message of parseChannelMessages(channel, pool)) { 20. // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 21. if (isInternal(message)) { 22. // \u6536\u5230handle 23. if (message.cmd === 'NODE_HANDLE') { 24. handleMessage(message, pendingHandle, true); 25. pendingHandle = null; 26. } else { 27. handleMessage(message, undefined, true); 28. } 29. } else { 30. handleMessage(message, undefined, false); 31. } 32. } 33. } 34. 35. }; 36. 37. function handleMessage(message, handle, internal) { 38. const eventName = (internal ? 'internalMessage' : 'message'); 39. process.nextTick(emit, eventName, message, handle); 40. } 41. // \u5f00\u542f\u8bfb 42. channel.readStart(); 43. return control; 44. } onread\u5904\u7406\u5b8c\u540e\u4f1a\u89e6\u53d1internalMessage\u6216message\u4e8b\u4ef6\uff0cmessage\u662f\u7528\u6237\u4f7f\u7528\u7684\u3002 2\u5199\u7aef 1. target._send = function(message, handle, options, callback) { 2. let obj; 3. const req = new WriteWrap(); 4. // \u53d1\u9001\u7ed9\u5bf9\u7aef 5. const err = writeChannelMessage(channel, req, message,handle); 6. 7. return channel.writeQueueSize < (65536 * 2); 8. } \u6211\u4eec\u770b\u770bwriteChannelMessage 1. writeChannelMessage(channel, req, message, handle) { 2. const ser = new ChildProcessSerializer(); 3. ser.writeHeader(); 4. ser.writeValue(message); 5. const serializedMessage = ser.releaseBuffer(); 6. const sizeBuffer = Buffer.allocUnsafe(4); 7. sizeBuffer.writeUInt32BE(serializedMessage.length); 8. // channel\u662f\u5c01\u88c5\u4e86Unix\u57df\u7684\u5bf9\u8c61 9. return channel.writeBuffer(req, Buffer.concat([ 10. sizeBuffer, 11. serializedMessage 12. ]), handle); 13. }, channel.writeBuffer\u901a\u8fc7\u521a\u624d\u521b\u5efa\u7684IPC\u901a\u9053\u5b8c\u6210\u6570\u636e\u7684\u53d1\u9001\uff0c\u5e76\u4e14\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"13.3.2 \u4e3b\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1333","text":"\u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\uff0cNode.js\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u544a\u8bc9\u5b50\u8fdb\u7a0bUnix\u57df\u901a\u4fe1\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728\u6267\u884c\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u5904\u7406\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5177\u4f53\u5b9e\u73b0\u5728setupChildProcessIpcChannel\u51fd\u6570\u4e2d\u3002 1. function setupChildProcessIpcChannel() { 2. // \u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u8be5\u503c 3. if (process.env.NODE_CHANNEL_FD) { 4. const fd = parseInt(process.env.NODE_CHANNEL_FD, 10); 5. delete process.env.NODE_CHANNEL_FD; 6. require('child_process')._forkChild(fd, serializationMode); 7. } 8. } \u63a5\u7740\u6267\u884c_forkChild\u51fd\u6570\u3002 1. function _forkChild(fd, serializationMode) { 2. const p = new Pipe(PipeConstants.IPC); 3. p.open(fd); 4. const control = setupChannel(process, p, serializationMode); 5. } \u8be5\u51fd\u6570\u521b\u5efa\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u4e3b\u8fdb\u7a0b\u4f20\u8fc7\u6765\u7684fd\u4fdd\u5b58\u5230\u8be5Pipe\u5bf9\u8c61\u3002\u5bf9\u8be5Pipe\u5bf9\u8c61\u7684\u8bfb\u5199\uff0c\u5c31\u662f\u5730\u5bf9fd\u8fdb\u884c\u8bfb\u5199\u3002\u6700\u540e\u6267\u884csetupChannel\u3002setupChannel\u4e3b\u8981\u662f\u5b8c\u6210\u4e86Unix\u57df\u901a\u4fe1\u7684\u5c01\u88c5\uff0c\u5305\u62ec\u5904\u7406\u63a5\u6536\u7684\u6d88\u606f\u3001\u53d1\u9001\u6d88\u606f\u3001\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7b49\uff0c\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u6700\u540e\u901a\u8fc7\u5728process\u5bf9\u8c61\u4e2d\u6302\u8f7d\u51fd\u6570\u548c\u76d1\u542c\u4e8b\u4ef6\uff0c\u4f7f\u5f97\u5b50\u8fdb\u7a0b\u5177\u6709\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u80fd\u529b\u3002\u6240\u6709\u7684\u901a\u4fe1\u90fd\u662f\u57fa\u4e8e\u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u4f20\u9012\u8fc7\u6765\u7684fd\u8fdb\u884c\u7684\u3002","title":"13.3.3 \u5b50\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#134","text":"\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u539f\u7406\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770bNode.js\u662f\u5982\u4f55\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u3002","title":"13.4 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1341","text":"\u6211\u4eec\u770b\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53d1\u9001\u51fd\u6570send\u7684\u5b9e\u73b0 1. process.send = function(message, handle, options, callback) { 2. return this._send(message, handle, options, callback); 3. }; 4. 5. target._send = function(message, handle, options, callback) { 6. // Support legacy function signature 7. if (typeof options === 'boolean') { 8. options = { swallowErrors: options }; 9. } 10. 11. let obj; 12. 13. // \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0chandle\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5 14. if (handle) { 15. message = { 16. cmd: 'NODE_HANDLE', 17. type: null, 18. msg: message 19. }; 20. // handle\u7684\u7c7b\u578b 21. if (handle instanceof net.Socket) { 22. message.type = 'net.Socket'; 23. } else if (handle instanceof net.Server) { 24. message.type = 'net.Server'; 25. } else if (handle instanceof TCP || handle instanceof Pipe) { 26. message.type = 'net.Native'; 27. } else if (handle instanceof dgram.Socket) { 28. message.type = 'dgram.Socket'; 29. } else if (handle instanceof UDP) { 30. message.type = 'dgram.Native'; 31. } else { 32. throw new ERR_INVALID_HANDLE_TYPE(); 33. } 34. // \u6839\u636e\u7c7b\u578b\u8f6c\u6362\u5bf9\u8c61 35. obj = handleConversion[message.type]; 36. 37. // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u5bf9\u8c61 38. handle=handleConversion[message.type].send.call(target, 39. message, 40. handle, 41. options); 42. } 43. // \u53d1\u9001 44. const req = new WriteWrap(); 45. // \u53d1\u9001\u7ed9\u5bf9\u7aef 46. const err = writeChannelMessage(channel, req, message, handle); 47. 48. } Node.js\u5728\u53d1\u9001\u4e00\u4e2a\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u9996\u5148\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1. send(message, server, options) { 2. return server._handle; 3. } \u6211\u4eec\u63a5\u7740\u770bwriteChannelMessage\u3002 1. // channel\u662fnew Pipe(PipeConstants.IPC); 2. writeChannelMessage(channel, req, message, handle) { 3. const string = JSONStringify(message) + '\\n'; 4. return channel.writeUtf8String(req, string, handle); 5. } \u6211\u4eec\u770b\u4e00\u4e0bwriteUtf8String 1. template <enum encoding enc> 2. int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. // new WriteWrap() 5. Local<Object> req_wrap_obj = args[0].As<Object>(); 6. Local<String> string = args[1].As<String>(); 7. Local<Object> send_handle_obj; 8. // \u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u5bf9\u8c61 9. if (args[2]->IsObject()) 10. send_handle_obj = args[2].As<Object>(); 11. 12. uv_stream_t* send_handle = nullptr; 13. // \u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 14. if (IsIPCPipe() && !send_handle_obj.IsEmpty()) { 15. HandleWrap* wrap; 16. /* 17. send_handle_obj\u662f\u7531C++\u5c42\u521b\u5efa\u5728JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c 18. \u89e3\u5305\u51fa\u771f\u6b63\u5728C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 19. */ 20. ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL); 21. // \u62ff\u5230Libuv\u5c42\u7684handle\u7ed3\u6784\u4f53 22. send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); 23. /* 24. Reference LibuvStreamWrap instance to prevent it 25. from being garbage\uff0ccollected before`AfterWrite` is 26. called. 27. */ 28. req_wrap_obj->Set(env->context(), 29. env->handle_string(), 30. send_handle_obj).Check(); 31. } 32. 33. Write(&buf, 1, send_handle, req_wrap_obj); 34. } Write\u4f1a\u8c03\u7528Libuv\u7684uv__write\uff0cuv__write\u4f1a\u628aLibuv\u5c42\u7684handle\u4e2d\u7684fd\u53d6\u51fa\u6765\uff0c\u4f7f\u7528sendmsg\u4f20\u9012\u5230\u5176\u5b83\u8fdb\u7a0b\u3002\u6574\u4e2a\u53d1\u9001\u7684\u8fc7\u7a0b\u672c\u8d28\u662f\u4eceJS\u5c42\u5230Libuv\u5c42\u5c42\u5c42\u63ed\u5f00\u8981\u53d1\u9001\u7684\u5bf9\u8c61\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5982\u56fe13-4\u6240\u793a\u3002 \u56fe13-4","title":"13.4.1 \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1342","text":"\u5206\u6790\u5b8c\u53d1\u9001\uff0c\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u63a5\u6536\u7684\u903b\u8f91\u3002\u524d\u9762\u6211\u4eec\u5206\u6790\u8fc7\uff0c\u5f53\u6587\u4ef6\u63cf\u8ff0\u7b26\u6536\u5230\u6570\u636e\u65f6\uff0c\u4f1a\u628a\u6587\u4ef6\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c01\u88c5\u6210\u5bf9\u5e94\u7684\u5bf9\u8c61\u3002 1. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 2. HandleScope scope(env()->isolate()); 3. Context::Scope context_scope(env()->context()); 4. uv_handle_type type = UV_UNKNOWN_HANDLE; 5. // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b 6. if (is_named_pipe_ipc() && 7. uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) { 8. type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream())); 9. } 10. 11. // \u8bfb\u53d6\u6210\u529f 12. if (nread > 0) { 13. MaybeLocal<Object> pending_obj; 14. // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef 15. if (type == UV_TCP) { 16. pending_obj = AcceptHandle<TCPWrap>(env(), this); 17. } else if (type == UV_NAMED_PIPE) { 18. pending_obj = AcceptHandle<PipeWrap>(env(), this); 19. } else if (type == UV_UDP) { 20. pending_obj = AcceptHandle<UDPWrap>(env(), this); 21. } else { 22. CHECK_EQ(type, UV_UNKNOWN_HANDLE); 23. } 24. // \u4fdd\u5b58\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e2d\uff0c\u952e\u662fpendingHandle 25. if (!pending_obj.IsEmpty()) { 26. object() 27. ->Set(env()->context(), 28. env()->pending_handle_string(), 29. pending_obj.ToLocalChecked()) 30. .Check(); 31. } 32. } 33. 34. EmitRead(nread, *buf); 35. } \u63a5\u7740\u6211\u4eec\u770b\u770bJS\u5c42\u7684\u5904\u7406\u3002 1. channel.onread = function(arrayBuffer) { 2. // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 3. const recvHandle = channel.pendingHandle; 4. channel.pendingHandle = null; 5. if (arrayBuffer) { 6. const nread = streamBaseState[kReadBytesOrError]; 7. const offset = streamBaseState[kArrayBufferOffset]; 8. const pool = new Uint8Array(arrayBuffer, offset, nread); 9. if (recvHandle) 10. pendingHandle = recvHandle; 11. // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f 12. for (const message of parseChannelMessages(channel, pool)) { // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 13. if (isInternal(message)) { 14. if (message.cmd === 'NODE_HANDLE') { 15. handleMessage(message, pendingHandle, true); 16. pendingHandle = null; 17. } else { 18. handleMessage(message, undefined, true); 19. } 20. } else { 21. handleMessage(message, undefined, false); 22. } 23. } 24. } 25. }; \u8fd9\u91cc\u4f1a\u89e6\u53d1\u5185\u90e8\u4e8b\u4ef6internalMessage 1. target.on('internalMessage', function(message, handle) { 2. // \u662f\u5426\u6536\u5230\u4e86handle 3. if (message.cmd !== 'NODE_HANDLE') return; 4. 5. // \u6210\u529f\u6536\u5230\uff0c\u53d1\u9001ACK 6. target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true); 7. 8. const obj = handleConversion[message.type]; 9. 10. /* 11. C++\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u8f6c\u5b8c\u4e4b\u540e\u518d\u6839\u636e\u91cc\u5c42\u7684\u5b57\u6bb5 12. message.msg\u8fdb\u4e00\u6b65\u5904\u7406\uff0c\u6216\u8005\u89e6\u53d1message\u4e8b\u4ef6\u4f20\u7ed9\u7528\u6237 13. */ 14. obj.got.call(this, message, handle, (handle) => { 15. handleMessage(message.msg, handle, isInternal(message.msg)); }); 16. }) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u628aC++\u5c42\u7684\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1. got(message, handle, emit) { 2. const server = new net.Server(); 3. server.listen(handle, () => { 4. emit(server); 5. }); 6. } \u8fd9\u5c31\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u5728Node.js\u4e2d\u7684\u5904\u7406\u6d41\u7a0b\uff0c\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u4e00\u4e2a\u975e\u5e38\u6709\u7528\u7684\u80fd\u529b\uff0c\u6bd4\u5982\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u628a\u4e00\u4e2aTCP\u8fde\u63a5\u6240\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u76f4\u63a5\u53d1\u9001\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u5904\u7406\u3002\u8fd9\u4e5f\u662fcluser\u6a21\u5757\u7684\u539f\u7406\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002\u5728Node.js\u4e2d\uff0c\u6574\u4f53\u7684\u5904\u7406\u6d41\u7a0b\u5c31\u662f\uff0c\u53d1\u9001\u7684\u65f6\u5019\u628a\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e00\u5c42\u5c42\u5730\u5265\u5f00\uff0c\u53d8\u6210C++\u5bf9\u8c61\uff0c\u7136\u540e\u518d\u53d8\u6210fd\uff0c\u6700\u540e\u901a\u8fc7\u5e95\u5c42API\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u3002\u63a5\u6536\u7684\u65f6\u5019\u5c31\u662f\u628a\u4e00\u4e2afd\u4e00\u5c42\u5c42\u5730\u5305\u88f9\uff0c\u53d8\u6210\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002","title":"13.4.2 \u63a5\u6536\u6587\u4ef6\u63cf\u8ff0\u7b26"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/","text":"\u7ebf\u7a0b\u662f\u64cd\u4f5c\u7cfb\u7edf\u7684\u6700\u5c0f\u8c03\u5ea6\u5355\u4f4d\uff0c\u5b83\u672c\u8d28\u4e0a\u662f\u8fdb\u7a0b\u4e2d\u7684\u4e00\u4e2a\u6267\u884c\u6d41\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u8fdb\u7a0b\u6709\u4ee3\u7801\u6bb5\uff0c\u7ebf\u7a0b\u5176\u5b9e\u5c31\u662f\u8fdb\u7a0b\u4ee3\u7801\u6bb5\u4e2d\u7684\u5176\u4e2d\u4e00\u6bb5\u4ee3\u7801\u3002\u7ebf\u7a0b\u7684\u4e00\u79cd\u5b9e\u73b0\u662f\u4f5c\u4e3a\u8fdb\u7a0b\u6765\u5b9e\u73b0\u7684\uff08pthread\u7ebf\u7a0b\u5e93\uff09\uff0c\u901a\u8fc7\u8c03\u7528clone\uff0c\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u7136\u540e\u6267\u884c\u7236\u8fdb\u7a0b\u4ee3\u7801\u6bb5\u91cc\u7684\u4e00\u4e2a\u4ee3\u7801\u7247\u6bb5\uff0c\u5176\u4e2d\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u5185\u5b58\u7b49\u4fe1\u606f\u90fd\u662f\u5171\u4eab\u7684\u3002\u56e0\u4e3a\u5185\u5b58\u662f\u5171\u4eab\u7684\uff0c\u6240\u4ee5\u7ebf\u7a0b\u4e0d\u80fd\u5171\u4eab\u6808\uff0c\u5426\u5219\u8bbf\u95ee\u6808\u7684\u5730\u5740\u7684\u65f6\u5019\uff0c\u4f1a\u6620\u5c04\u5230\u76f8\u540c\u7684\u7269\u7406\u5730\u5740\uff0c\u90a3\u6837\u5c31\u4f1a\u4e92\u76f8\u5f71\u54cd\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7ebf\u7a0b\u4f1a\u6709\u81ea\u5df1\u72ec\u7acb\u7684\u6808\u3002\u5728\u8c03\u7528clone\u51fd\u6570\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u6808\u7684\u8303\u56f4\uff0c\u6bd4\u5982\u5728\u5806\u4e0a\u5206\u914d\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u505a\u7ebf\u7a0b\u7684\u6808\uff0c\u5e76\u4e14\u652f\u6301\u8bbe\u7f6e\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u5171\u4eab\u54ea\u4e9b\u8d44\u6e90\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003clone\u7cfb\u7edf\u8c03\u7528\u3002 \u7531\u4e8eNode.js\u662f\u5355\u7ebf\u7a0b\u7684\uff0c\u867d\u7136\u5e95\u5c42\u7684Libuv\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u4f46\u662f\u8fd9\u4e2a\u7ebf\u7a0b\u6c60\u53ea\u80fd\u6267\u884cC\u3001C++\u5c42\u5b9a\u4e49\u7684\u4efb\u52a1\u3002\u5982\u679c\u6211\u4eec\u60f3\u81ea\u5b9a\u4e49\u4e00\u4e9b\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u90a3\u5c31\u53ea\u80fd\u5728C++\u5c42\u5904\u7406\uff0c\u7136\u540e\u66b4\u9732\u63a5\u53e3\u7ed9JS\u5c42\u8c03\u7528\uff0c\u8fd9\u4e2a\u6210\u672c\u662f\u975e\u5e38\u9ad8\u7684\uff0c\u5728\u65e9\u671f\u7684Node.js\u7248\u672c\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u8fdb\u7a0b\u53bb\u5b9e\u73b0\u8fd9\u6837\u7684\u9700\u6c42\u3002\u4f46\u662f\u8fdb\u7a0b\u592a\u91cd\u4e86\uff0c\u5728\u65b0\u7248\u7684Node.js\u4e2d\uff0cNode.js\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u591a\u7ebf\u7a0b\u7684\u529f\u80fd\u3002\u8fd9\u4e00\u7ae0\u4ee5Node.js\u591a\u7ebf\u7a0b\u6a21\u5757\u4e3a\u80cc\u666f\uff0c\u5206\u6790Node.js\u4e2d\u591a\u7ebf\u7a0b\u7684\u539f\u7406\uff0c\u4f46\u662f\u4e0d\u5206\u6790Libuv\u7684\u7ebf\u7a0b\u5b9e\u73b0\uff0c\u5b83\u672c\u8d28\u662f\u5bf9\u7ebf\u7a0b\u5e93\u7684\u7b80\u5355\u5c01\u88c5\u3002Node.js\u4e2d\uff0c\u7ebf\u7a0b\u7684\u5b9e\u73b0\u4e5f\u975e\u5e38\u590d\u6742\u3002\u867d\u7136\u5e95\u5c42\u53ea\u662f\u5bf9\u7ebf\u7a0b\u5e93\u7684\u5c01\u88c5\uff0c\u4f46\u662f\u628a\u5b83\u548cNode.js\u539f\u672c\u7684\u67b6\u6784\u7ed3\u5408\u8d77\u6765\u53d8\u5f97\u590d\u6742\u8d77\u6765\u3002 14.1 \u4f7f\u7528\u591a\u7ebf\u7a0b \u00b6 \u5bf9\u4e8e\u540c\u6b65\u6587\u4ef6\u64cd\u4f5c\u3001DNS\u89e3\u6790\u7b49\u64cd\u4f5c\uff0cNode.js\u4f7f\u7528\u4e86\u5185\u7f6e\u7684\u7ebf\u7a0b\u6c60\u652f\u6301\u4e86\u5f02\u6b65\u3002\u4f46\u662f\u4e00\u4e9b\u52a0\u89e3\u5bc6\u3001\u5b57\u7b26\u4e32\u8fd0\u7b97\u3001\u963b\u585e\u578bAPI\u7b49\u64cd\u4f5c\u3002\u6211\u4eec\u5c31\u4e0d\u80fd\u5728\u4e3b\u7ebf\u7a0b\u91cc\u5904\u7406\u4e86\uff0c\u8fd9\u65f6\u5019\u5c31\u4e0d\u5f97\u4e0d\u4f7f\u7528\u7ebf\u7a0b\uff0c\u800c\u4e14\u591a\u7ebf\u7a0b\u8fd8\u80fd\u5229\u7528\u591a\u6838\u7684\u80fd\u529b\u3002Node.js\u7684\u5b50\u7ebf\u7a0b\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u4f46\u662f\u5b50\u7ebf\u7a0b\u548cNode.js\u4e3b\u7ebf\u7a0b\u5171\u4eab\u4e00\u4e2aLibuv\u7ebf\u7a0b\u6c60\uff0c\u6240\u4ee5\u5982\u679c\u5728\u5b50\u7ebf\u7a0b\u91cc\u6709\u6587\u4ef6\u3001DNS\u7b49\u64cd\u4f5c\u5c31\u4f1a\u548c\u4e3b\u7ebf\u7a0b\u7ade\u4e89Libuv\u7ebf\u7a0b\u6c60\u3002\u5982\u56fe14-1\u6240\u793a\u3002 \u56fe14-1 \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u4f7f\u7528\u7ebf\u7a0b\u3002 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. if (isMainThread) { 3. const worker = new Worker(__filename); 4. worker.once('message', (message) => { 5. ... 6. }); 7. worker.postMessage('Hello, world!'); 8. } else { 9. // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 10. parentPort.once('message', (message) => { 11. parentPort.postMessage(message); 12. }); 13. } \u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\u4f1a\u88ab\u6267\u884c\u4e24\u6b21\uff0c\u4e00\u6b21\u662f\u5728\u4e3b\u7ebf\u7a0b\uff0c\u4e00\u6b21\u5728\u5b50\u7ebf\u7a0b\u3002\u6240\u4ee5\u9996\u5148\u901a\u8fc7isMainThread\u5224\u65ad\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u3002\u4e3b\u7ebf\u7a0b\u7684\u8bdd\uff0c\u5c31\u521b\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u76d1\u542c\u5b50\u7ebf\u7a0b\u53d1\u8fc7\u6765\u7684\u6d88\u606f\u3002\u5b50\u7ebf\u7a0b\u7684\u8bdd\uff0c\u9996\u5148\u6267\u884c\u4e1a\u52a1\u76f8\u5173\u7684\u4ee3\u7801\uff0c\u8fd8\u53ef\u4ee5\u76d1\u542c\u4e3b\u7ebf\u7a0b\u4f20\u8fc7\u6765\u7684\u6d88\u606f\u3002\u6211\u4eec\u5728\u5b50\u7ebf\u7a0b\u4e2d\u53ef\u4ee5\u505a\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u963b\u585e\u6027\u7684\u64cd\u4f5c\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u628a\u8fd9\u4e24\u4e2a\u903b\u8f91\u62c6\u5206\u5230\u4e24\u4e2a\u6587\u4ef6\u3002 \u4e3b\u7ebf\u7a0b 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. const worker = new Worker(\u2018\u5b50\u7ebf\u7a0b\u6587\u4ef6\u8def\u5f84\u2019); 3. worker.once('message', (message) => { 4. ... 5. }); 6. worker.postMessage('Hello, world!'); \u5b50\u7ebf\u7a0b 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. parentPort.once('message', (message) => { 3. parentPort.postMessage(message); 4. }); 14.2 \u7ebf\u7a0b\u95f4\u901a\u4fe1\u6570\u636e\u7ed3\u6784 \u00b6 \u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\u4e00\u822c\u9700\u8981\u501f\u52a9\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u516c\u5171\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u72ec\u7acb\u7684\uff0c\u548c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e0d\u4e00\u6837\u3002\u591a\u7ebf\u7a0b\u7684\u5185\u5b58\u662f\u5171\u4eab\u7684\uff0c\u540c\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\uff0c\u591a\u4e2a\u7ebf\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u6240\u4ee5\u7ebf\u7a0b\u95f4\u901a\u4fe1\u53ef\u4ee5\u57fa\u4e8e\u8fdb\u7a0b\u5185\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u5728Node.js\u4e2d\uff0c\u7ebf\u7a0b\u95f4\u901a\u4fe1\u4f7f\u7528\u7684\u662fMessageChannel\u5b9e\u73b0\u7684\uff0c\u5b83\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4efb\u610f\u4e00\u7aef\u90fd\u53ef\u4ee5\u968f\u65f6\u53d1\u9001\u4fe1\u606f\u3002MessageChannel\u7c7b\u4f3csocket\u901a\u4fe1\uff0c\u5b83\u5305\u62ec\u4e24\u4e2a\u7aef\u70b9\u3002\u5b9a\u4e49\u4e00\u4e2aMessageChannel\u76f8\u5f53\u4e8e\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5b83\u9996\u5148\u7533\u8bf7\u4e24\u4e2a\u7aef\u70b9\uff08MessagePort\uff09\uff0c\u7136\u540e\u628a\u5b83\u4eec\u5173\u8054\u8d77\u6765\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bd4\u8f83\u91cd\u8981\u7684\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\u3002 1 Message\u4ee3\u8868\u4e00\u4e2a\u6d88\u606f\u3002 2 MessagePortData\u662f\u5bf9\u64cd\u4f5cMessage\u7684\u5c01\u88c5\u548c\u5bf9\u6d88\u606f\u7684\u627f\u8f7d\u3002 3 MessagePort\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u7aef\u70b9\u3002 4 MessageChannel\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u4e24\u7aef\uff0c\u5373\u4e24\u4e2aMessagePort\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 14.2.1 Message Message\u7c7b\u4ee3\u8868\u7684\u662f\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u6761\u6d88\u606f\u3002 1. class Message : public MemoryRetainer { 2. public: 3. explicit Message(MallocedBuffer<char>&& payload = MallocedBuffer<char>()); 4. // \u662f\u5426\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f\uff0c\u7a7a\u6d88\u606f\u4ee3\u8868\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f 5. bool IsCloseMessage() const; 6. // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u9700\u8981\u901a\u8fc7\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u5904\u7406 7. v8::MaybeLocal<v8::Value> Deserialize(Environment* env, 8. v8::Local<v8::Context> context); 9. v8::Maybe<bool> Serialize(Environment* env, 10. v8::Local<v8::Context> context, 11. v8::Local<v8::Value> input, 12. const TransferList& transfer_list, 13. v8::Local<v8::Object> source_port = 14. v8::Local<v8::Object>()); 15. 16. // \u4f20\u9012SharedArrayBuffer\u578b\u53d8\u91cf 17. void AddSharedArrayBuffer(std::shared_ptr<v8::BackingStore> backing_store); 18. // \u4f20\u9012MessagePort\u578b\u53d8\u91cf 19. void AddMessagePort(std::unique_ptr<MessagePortData>&& data); 20. // \u6d88\u606f\u6240\u5c5e\u7aef\u53e3\uff0c\u7aef\u53e3\u662f\u6d88\u606f\u5230\u8fbe\u7684\u5730\u65b9 21. const std::vector<std::unique_ptr<MessagePortData>>& message_ports() const { 22. return message_ports_; 23. } 24. 25. private: 26. // \u4fdd\u5b58\u6d88\u606f\u7684\u5185\u5bb9 27. MallocedBuffer<char> main_message_buf_; 28. std::vector<std::shared_ptr<v8::BackingStore>> array_buffers_; 29. std::vector<std::shared_ptr<v8::BackingStore>> shared_array_buffers_; 30. std::vector<std::unique_ptr<MessagePortData>> message_ports_; 31. std::vector<v8::CompiledWasmModule> wasm_modules_; 32. }; 14.2.2 MessagePortData \u00b6 MessagePortData\u662f\u7ba1\u7406\u6d88\u606f\u53d1\u9001\u548c\u63a5\u6536\u7684\u7c7b\u3002 1. class MessagePortData : public MemoryRetainer { 2. public: 3. explicit MessagePortData(MessagePort* owner); 4. ~MessagePortData() override; 5. // \u65b0\u589e\u4e00\u4e2a\u6d88\u606f 6. void AddToIncomingQueue(Message&& message); 7. // \u5173\u8054/\u89e3\u5173\u8054\u901a\u4fe1\u4e24\u7aef\u7684\u7aef\u53e3 8. static void Entangle(MessagePortData* a, MessagePortData* b); 9. void Disentangle(); 10. 11. private: 12. // \u7528\u4e8e\u591a\u7ebf\u7a0b\u5f80\u5bf9\u7aef\u6d88\u606f\u961f\u5217\u63d2\u5165\u6d88\u606f\u65f6\u7684\u4e92\u65a5\u53d8\u91cf 13. mutable Mutex mutex_; 14. std::list<Message> incoming_messages_; 15. // \u6240\u5c5e\u7aef\u53e3 16. MessagePort* owner_ = nullptr; 17. // \u7528\u4e8e\u591a\u7ebf\u7a0b\u8bbf\u95ee\u5bf9\u7aefsibling_\u5c5e\u6027\u65f6\u7684\u4e92\u65a5\u53d8\u91cf 18. std::shared_ptr<Mutex> sibling_mutex_ = std::make_shared<Mutex>(); 19. // \u6307\u5411\u901a\u4fe1\u5bf9\u7aef\u7684\u6307\u9488 20. MessagePortData* sibling_ = nullptr; 21. }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1. MessagePortData::MessagePortData(MessagePort* owner) : owner_(owner) { } 2. 3. MessagePortData::~MessagePortData() { 4. // \u6790\u6784\u65f6\u89e3\u9664\u548c\u5bf9\u7aef\u7684\u5173\u7cfb 5. Disentangle(); 6. } 7. 8. // \u63d2\u5165\u4e00\u4e2amessage 9. void MessagePortData::AddToIncomingQueue(Message&& message) { 10. // \u5148\u52a0\u9501\uff0c\u4fdd\u8bc1\u591a\u7ebf\u7a0b\u5b89\u5168\uff0c\u4e92\u65a5\u8bbf\u95ee 11. Mutex::ScopedLock lock(mutex_); 12. // \u63d2\u5165\u6d88\u606f\u961f\u5217 13. incoming_messages_.emplace_back(std::move(message)); 14. // \u901a\u77e5owner 15. if (owner_ != nullptr) { 16. owner_->TriggerAsync(); 17. } 18. } 19. 20. // \u5173\u8054\u901a\u4fe1\u7684\u5bf9\u7aef\uff0c\u5e76\u4fdd\u6301\u5bf9\u7aef\u7684\u4e92\u65a5\u53d8\u91cf\uff0c\u8bbf\u95ee\u5bf9\u7aef\u65f6\u9700\u8981\u4f7f\u7528 21. void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) { 22. a->sibling_ = b; 23. b->sibling_ = a; 24. a->sibling_mutex_ = b->sibling_mutex_; 25. } 26. 27. // \u89e3\u9664\u5173\u8054 28. void MessagePortData::Disentangle() { 29. // \u52a0\u9501\u64cd\u4f5c\u5bf9\u7aef\u7684sibling\u5b57\u6bb5 30. std::shared_ptr<Mutex> sibling_mutex = sibling_mutex_; 31. Mutex::ScopedLock sibling_lock(*sibling_mutex); 32. sibling_mutex_ = std::make_shared<Mutex>(); 33. // \u5bf9\u7aef 34. MessagePortData* sibling = sibling_; 35. // \u5bf9\u7aef\u975e\u7a7a\uff0c\u5219\u628a\u5bf9\u7aef\u7684sibling\u4e5f\u6307\u5411\u7a7a\uff0c\u81ea\u5df1\u4e5f\u6307\u5411\u7a7a 36. if (sibling_ != nullptr) { 37. sibling_->sibling_ = nullptr; 38. sibling_ = nullptr; 39. } 40. 41. // \u63d2\u5165\u4e00\u4e2a\u7a7a\u7684\u6d88\u606f\u901a\u77e5\u5bf9\u7aef\u548c\u672c\u7aef 42. AddToIncomingQueue(Message()); 43. if (sibling != nullptr) { 44. sibling->AddToIncomingQueue(Message()); 45. } 46. } 14.2.3 MessagePort \u00b6 MessagePort\u8868\u793a\u7684\u662f\u901a\u4fe1\u7684\u4e00\u7aef\u3002 1. class MessagePort : public HandleWrap { 2. public: 3. MessagePort(Environment* env, 4. v8::Local<v8::Context> context, 5. v8::Local<v8::Object> wrap); 6. ~MessagePort() override; 7. 8. static MessagePort* New(Environment* env, 9. v8::Local<v8::Context> context, 10. std::unique_ptr<MessagePortData> data = nullptr); 11. // \u53d1\u9001\u6d88\u606f 12. v8::Maybe<bool> PostMessage(Environment* env, 13. v8::Local<v8::Value> message, 14. const TransferList& transfer); 15. 16. // \u5f00\u542f/\u5173\u95ed\u63a5\u6536\u6d88\u606f 17. void Start(); 18. void Stop(); 19. 20. static void New(const v8::FunctionCallbackInfo<v8::Value>& args); 21. // \u63d0\u4f9bJS\u5c42\u4f7f\u7528\u7684\u65b9\u6cd5 22. static void PostMessage(const v8::FunctionCallbackInfo<v8::Value>& args); 23. static void Start(const v8::FunctionCallbackInfo<v8::Value>& args); 24. static void Stop(const v8::FunctionCallbackInfo<v8::Value>& args); 25. static void Drain(const v8::FunctionCallbackInfo<v8::Value>& args); 26. static void ReceiveMessage(const v8::FunctionCallbackInfo<v8::Value>& args); 27. // \u5173\u8054\u5bf9\u7aef 28. static void Entangle(MessagePort* a, MessagePort* b); 29. static void Entangle(MessagePort* a, MessagePortData* b); 30. 31. // \u89e3\u9664MessagePortData\u548c\u7aef\u53e3\u7684\u5173\u7cfb 32. std::unique_ptr<MessagePortData> Detach(); 33. // \u5173\u95ed\u7aef\u53e3 34. void Close( 35. v8::Local<v8::Value> close_callback = v8::Local<v8::Value>()) override; 36. 37. inline bool IsDetached() const; 38. private: 39. void OnClose() override; 40. void OnMessage(); 41. void TriggerAsync(); 42. v8::MaybeLocal<v8::Value> ReceiveMessage(v8::Local<v8::Context> context, 43. bool only_if_receiving); 44. // MessagePortData\u7528\u4e8e\u7ba1\u7406\u6d88\u606f\u7684\u53d1\u9001\u548c\u63a5\u6536 45. std::unique_ptr<MessagePortData> data_ = nullptr; 46. // \u662f\u5426\u5f00\u542f\u63a5\u6536\u6d88\u606f\u6807\u8bb0 47. bool receiving_messages_ = false; 48. // \u7528\u4e8e\u6536\u5230\u6d88\u606f\u65f6\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\uff0c\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03\u5904\u7406\u6d88\u606f 49. uv_async_t async_; 50. }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u90e8\u5206\u51fd\u6570\u3002 1. // \u7aef\u53e3\u662f\u5426\u4e0d\u63a5\u6536\u6d88\u606f\u4e86 2. bool MessagePort::IsDetached() const { 3. return data_ == nullptr || IsHandleClosing(); 4. } 5. 6. // \u6709\u6d88\u606f\u5230\u8fbe\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03 7. void MessagePort::TriggerAsync() { 8. if (IsHandleClosing()) return; 9. CHECK_EQ(uv_async_send(&async_), 0); 10. } 11. 12. // \u5173\u95ed\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 13. void MessagePort::Close(v8::Local<v8::Value> close_callback) { 14. if (data_) { 15. // \u6301\u6709\u9501\uff0c\u9632\u6b62\u518d\u63a5\u6536\u6d88\u606f 16. Mutex::ScopedLock sibling_lock(data_->mutex_); 17. HandleWrap::Close(close_callback); 18. } else { 19. HandleWrap::Close(close_callback); 20. } 21. } 22. 23. // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u53ef\u4ee5\u6302\u8f7d\u4e00\u4e2aMessagePortData 24. MessagePort* MessagePort::New( 25. Environment* env, 26. Local<Context> context, 27. std::unique_ptr<MessagePortData> data) { 28. Context::Scope context_scope(context); 29. Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env); 30. 31. Local<Object> instance; 32. // JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 33. if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance)) 34. return nullptr; 35. // \u65b0\u5efa\u4e00\u4e2a\u6d88\u606f\u7aef\u53e3 36. MessagePort* port = new MessagePort(env, context, instance); 37. 38. // \u9700\u8981\u6302\u8f7dMessagePortData 39. if (data) { 40. port->Detach(); 41. port->data_ = std::move(data); 42. Mutex::ScopedLock lock(port->data_->mutex_); 43. // \u4fee\u6539data\u7684owner\u4e3a\u5f53\u524d\u6d88\u606f\u7aef\u53e3 44. port->data_->owner_ = port; 45. // data\u4e2d\u53ef\u80fd\u6709\u6d88\u606f 46. port->TriggerAsync(); 47. } 48. return port; 49. } 50. 51. // \u5f00\u59cb\u63a5\u6536\u6d88\u606f 52. void MessagePort::Start() { 53. Debug(this, \"Start receiving messages\"); 54. receiving_messages_ = true; 55. Mutex::ScopedLock lock(data_->mutex_); 56. // \u6709\u7f13\u5b58\u7684\u6d88\u606f\uff0c\u901a\u77e5\u4e0a\u5c42 57. if (!data_->incoming_messages_.empty()) 58. TriggerAsync(); 59. } 60. 61. // \u505c\u6b62\u63a5\u6536\u6d88\u606f 62. void MessagePort::Stop() { 63. Debug(this, \"Stop receiving messages\"); 64. receiving_messages_ = false; 65. } 66. // JS\u5c42\u8c03\u7528 67. void MessagePort::Start(const FunctionCallbackInfo<Value>& args) { 68. MessagePort* port; 69. ASSIGN_OR_RETURN_UNWRAP(&port, args.This()); 70. if (!port->data_) { 71. return; 72. } 73. port->Start(); 74. } 75. 76. void MessagePort::Stop(const FunctionCallbackInfo<Value>& args) { 77. MessagePort* port; 78. CHECK(args[0]->IsObject()); 79. ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>()); 80. if (!port->data_) { 81. return; 82. } 83. port->Stop(); 84. } 85. 86. // \u8bfb\u53d6\u6d88\u606f 87. void MessagePort::Drain(const FunctionCallbackInfo<Value>& args) { 88. MessagePort* port; 89. ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>()); 90. port->OnMessage(); 91. } 92. 93. // \u83b7\u53d6\u67d0\u4e2a\u7aef\u53e3\u7684\u6d88\u606f 94. void MessagePort::ReceiveMessage(const FunctionCallbackInfo<Value>& args) { 95. CHECK(args[0]->IsObject()); 96. // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u7aef\u53e3 97. MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>()); 98. // \u8c03\u7528\u5bf9\u8c61\u7684ReceiverMessage\u65b9\u6cd5 99. MaybeLocal<Value> payload = 100. port->ReceiveMessage(port->object()->CreationContext(), false); 101. if (!payload.IsEmpty()) 102. args.GetReturnValue().Set(payload.ToLocalChecked()); 103. } 104. 105. // \u5173\u8054\u4e24\u4e2a\u7aef\u53e3 106. void MessagePort::Entangle(MessagePort* a, MessagePort* b) { 107. Entangle(a, b->data_.get()); 108. } 109. 110. void MessagePort::Entangle(MessagePort* a, MessagePortData* b) { 111. MessagePortData::Entangle(a->data_.get(), b); 112. } 14.2.4 MessageChannel \u00b6 MessageChannel\u8868\u793a\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2a\u7aef\u3002 1. static void MessageChannel(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. Local<Context> context = args.This()->CreationContext(); 5. Context::Scope context_scope(context); 6. 7. MessagePort* port1 = MessagePort::New(env, context); 8. MessagePort* port2 = MessagePort::New(env, context); 9. MessagePort::Entangle(port1, port2); 10. // port1->object()\u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c\u5b83\u5173\u8054\u4e86MessagePort\u5bf9\u8c61 11. args.This()->Set(context, env->port1_string(), port1->object()) 12. .Check(); 13. args.This()->Set(context, env->port2_string(), port2->object()) 14. .Check(); 15. } MessageChannel\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e24\u4e2a\u6d88\u606f\u7aef\u53e3\uff0c\u5e76\u4e14\u5173\u8054\u8d77\u6765\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u57fa\u4e8e\u8fd9\u4e24\u4e2a\u7aef\u53e3\u8fdb\u884c\u901a\u4fe1\u4e86\u3002 Message\u3001MessagePortData\u3001MessagePort\u548cMessageChannel\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-2\u6240\u793a\u3002 \u56fe14-2 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u6a21\u5757\u5bfc\u51fa\u7684\u4e00\u4e9b\u529f\u80fd\u3002 1. static void InitMessaging(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. 7. { 8. // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053 9. Local<String> message_channel_string = FIXED_ONE_BYTE_STRING(env->isolate(), 10. \"MessageChannel\"); 11. Local<FunctionTemplate> templ = env->NewFunctionTemplate(MessageChannel); 12. templ->SetClassName(message_channel_string); 13. target->Set(context, 14. message_channel_string, 15. templ->GetFunction(context).ToLocalChecked()).Check(); 16. } 17. // \u65b0\u5efa\u6d88\u606f\u7aef\u53e3\u7684\u6784\u9020\u51fd\u6570 18. target->Set(context, 19. env->message_port_constructor_string(), 20. GetMessagePortConstructorTemplate(env) 21. ->GetFunction(context).ToLocalChecked()).Check(); 22. 23. env->SetMethod(target, \"stopMessagePort\", MessagePort::Stop); 24. env->SetMethod(target, \"drainMessagePort\", MessagePort::Drain); 25. env->SetMethod(target, \"receiveMessageOnPort\", MessagePort::ReceiveMessage); 26. env->SetMethod(target, \"moveMessagePortToContext\", 27. MessagePort::MoveToContext); 28. } 14.3 \u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0 \u00b6 \u672c\u8282\u6211\u4eec\u4eceworker_threads\u6a21\u5757\u5f00\u59cb\u5206\u6790\u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0\u3002\u8fd9\u662f\u4e00\u4e2aC++\u6a21\u5757\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u5bfc\u51fa\u7684\u529f\u80fd\u3002require(\"work_threads\")\u7684\u65f6\u5019\u5c31\u662f\u5f15\u7528\u4e86InitWorker\u51fd\u6570\u5bfc\u51fa\u7684\u529f\u80fd\u3002 1. void InitWorker(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. 7. { 8. Local<FunctionTemplate> w = env->NewFunctionTemplate(Worker::New); 9. w->InstanceTemplate()->SetInternalFieldCount(1); 10. w->Inherit(AsyncWrap::GetConstructorTemplate(env)); 11. // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5217\u4e3e 12. env->SetProtoMethod(w, \"setEnvVars\", Worker::SetEnvVars); 13. // \u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5 14. /* 15. \u5bfc\u51fa\u51fd\u6570\u6a21\u5757\u5bf9\u5e94\u7684\u51fd\u6570\uff0c\u5373\u6211\u4eec\u4ee3\u7801\u4e2d 16. const { Worker } = require(\"worker_threads\");\u4e2d\u7684Worker 17. */ 18. Local<String> workerString = FIXED_ONE_BYTE_STRING(env->isolate(), \"Worker\"); 19. w->SetClassName(workerString); 20. target->Set(env->context(), 21. workerString, 22. w->GetFunction(env->context()).ToLocalChecked()).Check(); 23. 24. /* 25. \u5bfc\u51fagetEnvMessagePort\u65b9\u6cd5\uff0c\u83b7\u53d6\u7ebf\u7a0b\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 26. const {getEnvMessagePort} = require(\"worker_threads\"); 27. */ 28. env->SetMethod(target, \"getEnvMessagePort\", GetEnvMessagePort); 29. /* 30. \u7ebf\u7a0bid\uff0c\u8fd9\u4e2a\u4e0d\u662f\u64cd\u4f5c\u7cfb\u7edf\u5206\u914d\u7684\u90a3\u4e2a\uff0c\u800c\u662fNode.js\u5206\u914d\u7684, 31. \u5728\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e 32. const { threadId } = require(\"worker_threads\"); 33. */ 34. target->Set(env->context(), 35. env->thread_id_string(), 36. Number::New(env->isolate(), 37. static_cast<double>(env->thread_id()))) 38. .Check(); 39. /* 40. \u662f\u5426\u662f\u4e3b\u7ebf\u7a0b\uff0c 41. const { isMainThread } = require(\"worker_threads\"); 42. \u8fd9\u8fb9\u53d8\u91cf\u5728Node.js\u542f\u52a8\u7684\u65f6\u5019\u8bbe\u7f6e\u4e3atrue\uff0c\u65b0\u5f00\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u6ca1\u6709\u8bbe 43. \u7f6e\uff0c\u6240\u4ee5\u662ffalse 44. */ 45. target->Set(env->context(), 46. FIXED_ONE_BYTE_STRING(env->isolate(), \"isMainThread\"), 47. Boolean::New(env->isolate(), env->is_main_thread())) 48. .Check(); 49. /* 50. \u5982\u679c\u4e0d\u662f\u4e3b\u7ebf\u7a0b\uff0c\u5bfc\u51fa\u8d44\u6e90\u9650\u5236\u7684\u914d\u7f6e\uff0c 51. \u5373\u5728\u5b50\u7ebf\u7a0b\u4e2d\u8c03\u7528 52. const { resourceLimits } = require(\"worker_threads\"); 53. */ 54. if (!env->is_main_thread()) { 55. target->Set(env->context(), 56. FIXED_ONE_BYTE_STRING(env->isolate(), 57. \"resourceLimits\"), 58. env->worker_context()->GetResourceLimits(env->isolate())).Check(); 59. } 60. // \u5bfc\u51fa\u51e0\u4e2a\u5e38\u91cf 61. NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb); 62. NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb); 63. NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb); 64. NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount); 65. } \u4e86\u89e3work_threads\u6a21\u5757\u5bfc\u51fa\u7684\u529f\u80fd\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u6267\u884cnew Worker\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002\u6839\u636e\u4e0a\u9762\u4ee3\u7801\u5bfc\u51fa\u7684\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\u8fd9\u65f6\u5019\u9996\u5148\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002\u7136\u540e\u6267\u884cNew\u56de\u8c03\uff0c\u5e76\u4f20\u5165\u65b0\u5efa\u7684C++\u5bf9\u8c61\u3002\u6211\u4eec\u770bNew\u51fd\u6570\u7684\u903b\u8f91\u3002\u6211\u4eec\u7701\u7565\u4e00\u7cfb\u5217\u7684\u53c2\u6570\u5904\u7406\uff0c\u4e3b\u8981\u4ee3\u7801\u5982\u4e0b\u3002 1. // args.This()\u5c31\u662f\u6211\u4eec\u521a\u624d\u4f20\u8fdb\u6765\u7684this 2. Worker* worker = new Worker(env, args.This(), 3. url, per_isolate_opts, 4. std::move(exec_argv_out)); \u6211\u4eec\u518d\u770bWorker\u7c7b\u7684\u58f0\u660e\u3002 1. class Worker : public AsyncWrap { 2. public: 3. // \u51fd\u6570\u58f0\u660e 4. 5. private: 6. 7. std::shared_ptr<PerIsolateOptions> per_isolate_opts_; 8. std::vector<std::string> exec_argv_; 9. std::vector<std::string> argv_; 10. MultiIsolatePlatform* platform_; 11. v8::Isolate* isolate_ = nullptr; 12. bool start_profiler_idle_notifier_; 13. // \u771f\u6b63\u7684\u7ebf\u7a0bid\uff0c\u5e95\u5c42\u8fd4\u56de\u7684 14. uv_thread_t tid_; 15. 16. // This mutex protects access to all variables listed below it. 17. mutable Mutex mutex_; 18. 19. bool thread_joined_ = true; 20. const char* custom_error_ = nullptr; 21. int exit_code_ = 0; 22. // \u7ebf\u7a0bid\uff0cNode.js\u5206\u914d\uff0c\u4e0d\u662f\u5e95\u5c42\u8fd4\u56de\u7684 23. uint64_t thread_id_ = -1; 24. uintptr_t stack_base_ = 0; 25. 26. // \u7ebf\u7a0b\u8d44\u6e90\u9650\u5236\u914d\u7f6e 27. double resource_limits_[kTotalResourceLimitCount]; 28. void UpdateResourceConstraints(v8::ResourceConstraints* constraints); 29. 30. // \u6808\u4fe1\u606f 31. static constexpr size_t kStackSize = 4 * 1024 * 1024; 32. static constexpr size_t kStackBufferSize = 192 * 1024; 33. 34. std::unique_ptr<MessagePortData> child_port_data_; 35. std::shared_ptr<KVStore> env_vars_; 36. // \u7528\u4e8e\u7ebf\u7a0b\u95f4\u901a\u4fe1 37. MessagePort* child_port_ = nullptr; 38. MessagePort* parent_port_ = nullptr; 39. // \u7ebf\u7a0b\u72b6\u6001 40. bool stopped_ = true; 41. // \u662f\u5426\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 42. bool has_ref_ = true; 43. // \u5b50\u7ebf\u7a0b\u6267\u884c\u65f6\u7684\u73af\u5883\u53d8\u91cf\uff0c\u57fa\u7c7b\u4e5f\u5b9a\u4e49\u4e86 44. Environment* env_ = nullptr; 45. }; \u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e0benv_\u7684\u5b9a\u4e49\uff0c\u56e0\u4e3a\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5730\u65b9\u3002\u6211\u4eec\u770b\u5230Worker\u7c7b\u7ee7\u627fAsyncWrap\uff0cAsyncWrap\u7ee7\u627f\u4e86BaseObject\u3002BaseObject\u4e2d\u4e5f\u5b9a\u4e49\u4e86env_\u5c5e\u6027\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5728C++\u4e2d\u5982\u679c\u5b50\u7c7b\u7236\u7c7b\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027\u65f6\u662f\u600e\u6837\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50 1. #include <iostream> 2. using namespace std; 3. 4. class A 5. { 6. public: 7. int value; 8. A() 9. { 10. value=1; 11. } 12. void console() 13. { 14. cout<<value<<endl; 15. } 16. 17. }; 18. class B: public A 19. { 20. public: 21. int value; 22. B():A() 23. { 24. value=2; 25. } 26. }; 27. int main() 28. { 29. B b; 30. // b.value = 3;\u53ea\u4f1a\u4fee\u6539\u5b50\u7c7b\u7684\uff0c\u4e0d\u4f1a\u4fee\u6539\u7236\u7c7b\u7684 31. b.console(); 32. cout<<b.value<<endl<<\"\u5185\u5b58\u5927\u5c0f\uff1a\"<<sizeof(b)<<endl; 33. return 0; 34. } \u4ee5\u4e0a\u4ee3\u7801\u6267\u884c\u65f6\u8f93\u51fa 1. 1 2. 2 3. \u5185\u5b58\u5927\u5c0f\uff1a8 \u7531\u8f93\u51fa\u7ed3\u679c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff0cb\u5185\u5b58\u5927\u5c0f\u662f8\u4e2a\u5b57\u8282\u3002\u5373\u4e24\u4e2aint\u3002\u6240\u4ee5b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\u4e24\u4e2aa\u5c5e\u6027\u90fd\u5206\u914d\u4e86\u5185\u5b58\u3002\u5f53\u6211\u4eec\u901a\u8fc7b.console\u8f93\u51favalue\u65f6\uff0c\u56e0\u4e3aconsole\u662f\u5728A\u4e0a\u5b9a\u4e49\u7684\uff0c\u6240\u4ee5\u8f93\u51fa1\uff0c\u4f46\u662f\u6211\u4eec\u901a\u8fc7b.value\u8bbf\u95ee\u65f6\uff0c\u8f93\u51fa\u7684\u662f2\u3002\u56e0\u4e3a\u8bbf\u95ee\u7684\u662fB\u4e2d\u5b9a\u4e49\u7684value\uff0c\u540c\u7406\u5982\u679c\u6211\u4eec\u5728B\u4e2d\u5b9a\u4e49console\uff0c\u8f93\u51fa\u4e5f\u4f1a\u662f2\u3002Worker\u4e2d\u5b9a\u4e49\u7684env_\u6211\u4eec\u540e\u7eed\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bWorker\u7c7b\u7684\u521d\u59cb\u5316\u903b\u8f91\u3002 1. Worker::Worker(Environment* env, 2. Local<Object> wrap,...) 3. : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER), 4. ... 5. // \u5206\u914d\u7ebf\u7a0bid 6. thread_id_(Environment::AllocateThreadId()), 7. // \u7ee7\u627f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u53d8\u91cf 8. env_vars_(env->env_vars()) { 9. 10. // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1 11. parent_port_ = MessagePort::New(env, env->context()); 12. /* 13. \u5173\u8054\u8d77\u6765\uff0c\u7528\u4e8e\u901a\u4fe1 14. const parent_port_ = {data: {sibling: null}}; 15. const child_port_data_ = {sibling: null}; 16. parent_port_.data.sibling = child_port_data_; 17. child_port_data_.sibling = parent_port_.data; 18. */ 19. child_port_data_ = std::make_unique<MessagePortData>(nullptr); 20. MessagePort::Entangle(parent_port_, child_port_data_.get()); 21. // \u8bbe\u7f6eJS\u5c42Worker\u5bf9\u8c61\u7684messagePort\u5c5e\u6027\u4e3aparent_port_ 22. object()->Set(env->context(), 23. env->message_port_string(), 24. parent_port_->object()).Check(); 25. // \u8bbe\u7f6eWorker\u5bf9\u8c61\u7684\u7ebf\u7a0bid\uff0c\u5373threadId\u5c5e\u6027 26. object()->Set(env->context(), 27. env->thread_id_string(), 28. Number::New(env->isolate(), static_cast<double>(thread_id_))) 29. .Check(); 30. } \u65b0\u5efa\u4e00\u4e2aWorker\uff0c\u7ed3\u6784\u5982\u56fe14-3\u6240\u793a\u3002 \u56fe14-3 \u4e86\u89e3\u4e86new Worker\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u6211\u4eec\u770bJS\u5c42Worker\u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 1. constructor(filename, options = {}) { 2. super(); 3. // \u5ffd\u7565\u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406\uff0cnew Worker\u5c31\u662f\u4e0a\u9762\u63d0\u5230\u7684C++\u5c42\u7684 4. this[kHandle] = new Worker(url, options.execArgv, parseResourceLimits(options.resourceLimits)); 5. // messagePort\u6307\u5411_parent_port 6. this[kPort] = this[kHandle].messagePort; 7. this[kPort].on('message', (data) => this[kOnMessage](data)); 8. // \u5f00\u59cb\u63a5\u6536\u6d88\u606f 9. this[kPort].start(); 10. // \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053\uff0c\u4e24\u4e2a\u7aef\u53e3 11. const { port1, port2 } = new MessageChannel(); 12. this[kPublicPort] = port1; 13. this[kPublicPort].on('message', (message) => this.emit('message', message)); 14. // \u5411\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f 15. this[kPort].postMessage({ 16. argv, 17. type: messageTypes.LOAD_SCRIPT, 18. filename, 19. doEval: !!options.eval, 20. cwdCounter: cwdCounter || workerIo.sharedCwdCounter, 21. workerData: options.workerData, 22. publicPort: port2, 23. manifestSrc: getOptionValue('--experimental-policy') ? 24. require('internal/process/policy').src : 25. null, 26. hasStdin: !!options.stdin 27. }, [port2]); 28. // \u5f00\u542f\u7ebf\u7a0b 29. this[kHandle].startThread(); 30. } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u4fdd\u5b58messagePort\uff0c\u76d1\u542c\u8be5\u7aef\u53e3\u7684message\u4e8b\u4ef6\uff0c\u7136\u540e\u7ed9messagePort\u7684\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u63a5\u6536\u7aef\u53e3\uff0c\u6240\u4ee5\u6d88\u606f\u4f1a\u7f13\u5b58\u5230MessagePortData\uff0c\u5373child_port_data_ \u4e2d\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u628a\u901a\u4fe1\u7aef\u53e3port2\u53d1\u9001\u7ed9\u4e86\u5b50\u7ebf\u7a0b\u3002 2 \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053port1\u548cport2\uff0c\u7528\u4e8e\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002_parent_port\u548cchild_port\u662f\u7ed9Node.js\u4f7f\u7528\u7684\uff0c\u65b0\u7533\u8bf7\u7684\u7aef\u53e3\u662f\u7ed9\u7528\u6237\u4f7f\u7528\u7684\u3002 3 \u521b\u5efa\u5b50\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u505a\u4e86\u4ec0\u4e48\u3002 1. void Worker::StartThread(const FunctionCallbackInfo<Value>& args) { 2. Worker* w; 3. ASSIGN_OR_RETURN_UNWRAP(&w, args.This()); 4. Mutex::ScopedLock lock(w->mutex_); 5. 6. // The object now owns the created thread and should not be garbage collected 7. // until that finishes. 8. w->ClearWeak(); 9. // \u52a0\u5165\u4e3b\u7ebf\u7a0b\u7ef4\u62a4\u7684\u5b50\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784 10. w->env()->add_sub_worker_context(w); 11. w->stopped_ = false; 12. w->thread_joined_ = false; 13. // \u662f\u5426\u9700\u8981\u963b\u585e\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u9ed8\u8ba4true 14. if (w->has_ref_) 15. w->env()->add_refs(1); 16. // \u662f\u5426\u9700\u8981\u6808\u548c\u6808\u5927\u5c0f 17. uv_thread_options_t thread_options; 18. thread_options.flags = UV_THREAD_HAS_STACK_SIZE; 19. thread_options.stack_size = kStackSize; 20. // \u521b\u5efa\u7ebf\u7a0b 21. CHECK_EQ(uv_thread_create_ex(&w->tid_, &thread_options, [](void* arg) { 22. 23. Worker* w = static_cast<Worker*>(arg); 24. const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg); 25. w->stack_base_ = stack_top - (kStackSize - kStackBufferSize); 26. // \u6267\u884c\u4e3b\u903b\u8f91 27. w->Run(); 28. 29. Mutex::ScopedLock lock(w->mutex_); 30. // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 31. w->env()->SetImmediateThreadsafe( 32. [w = std::unique_ptr<Worker>(w)](Environment* env) { 33. if (w->has_ref_) 34. env->add_refs(-1); 35. w->JoinThread(); 36. // implicitly delete w 37. }); 38. }, static_cast<void*>(w)), 0); 39. } StartThread\u65b0\u5efa\u4e86\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u5728\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cRun\uff0c\u6211\u4eec\u7ee7\u7eed\u770bRun 1. void Worker::Run() { 2. // \u7ebf\u7a0b\u6267\u884c\u6240\u9700\u8981\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982loop\uff0cisolate\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb 3. WorkerThreadData data(this); 4. 5. { 6. Locker locker(isolate_); 7. Isolate::Scope isolate_scope(isolate_); 8. SealHandleScope outer_seal(isolate_); 9. // std::unique_ptr<Environment, FreeEnvironment> env_; 10. DeleteFnPtr<Environment, FreeEnvironment> env_; 11. // \u7ebf\u7a0b\u6267\u884c\u5b8c\u540e\u6267\u884c\u7684\u6e05\u9664\u51fd\u6570 12. auto cleanup_env = OnScopeLeave([&]() { 13. // ... 14. }); 15. 16. { 17. HandleScope handle_scope(isolate_); 18. Local<Context> context; 19. // \u65b0\u5efa\u4e00\u4e2acontext\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb 20. context = NewContext(isolate_); 21. Context::Scope context_scope(context); 22. { 23. // \u65b0\u5efa\u4e00\u4e2aenv\u5e76\u521d\u59cb\u5316\uff0cenv\u4e2d\u4f1a\u548c\u65b0\u7684context\u5173\u8054 24. env_.reset(new Environment(data.isolate_data_.get(), 25. context, 26. std::move(argv_), 27. std::move(exec_argv_), 28. Environment::kNoFlags, 29. thread_id_)); 30. env_->set_env_vars(std::move(env_vars_)); 31. env_->set_abort_on_uncaught_exception(false); 32. env_->set_worker_context(this); 33. 34. env_->InitializeLibuv(start_profiler_idle_notifier_); 35. } 36. { 37. Mutex::ScopedLock lock(mutex_); 38. // \u66f4\u65b0\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env 39. this->env_ = env_.get(); 40. } 41. 42. { 43. if (!env_->RunBootstrapping().IsEmpty()) { 44. CreateEnvMessagePort(env_.get()); 45. USE(StartExecution(env_.get(), \"internal/main/worker_thread\")); 46. } 47. } 48. 49. { 50. SealHandleScope seal(isolate_); 51. bool more; 52. // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af 53. do { 54. if (is_stopped()) break; 55. uv_run(&data.loop_, UV_RUN_DEFAULT); 56. if (is_stopped()) break; 57. 58. platform_->DrainTasks(isolate_); 59. 60. more = uv_loop_alive(&data.loop_); 61. if (more && !is_stopped()) continue; 62. 63. EmitBeforeExit(env_.get()); 64. 65. more = uv_loop_alive(&data.loop_); 66. } while (more == true && !is_stopped()); 67. } 68. } 69. } \u6211\u4eec\u5206\u6b65\u9aa4\u5206\u6790\u4e0a\u9762\u7684\u4ee3\u7801 1 \u65b0\u5efaIsolate\u3001context\u548cEnvironment\uff0c\u5b50\u7ebf\u7a0b\u5728\u72ec\u7acb\u7684\u73af\u5883\u6267\u884c\u3002\u7136\u540e\u521d\u59cb\u5316Environment\u3002\u8fd9\u4e2a\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5206\u6790\u3002 2 \u66f4\u65b0\u5b50\u7ebf\u7a0b\u7684env_\u3002\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cWorker\u7c7b\u4e2d\u5b9a\u4e49\u4e86env_\u5c5e\u6027\uff0c\u6240\u4ee5\u8fd9\u91cc\u901a\u8fc7this.env_\u66f4\u65b0\u65f6\uff0c\u662f\u4e0d\u4f1a\u5f71\u54cd\u57fa\u7c7b\uff08BaseObject\uff09\u4e2d\u7684\u503c\u7684\u3002\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u662f\u5728\u65b0\u7684\u73af\u5883\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5728\u65b0\u73af\u5883\u4e2d\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u9700\u8981\u4f7f\u7528\u65b0\u7684\u73af\u5883\u53d8\u91cf\u3002\u800c\u5728\u4e3b\u7ebf\u7a0b\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u662f\u901a\u8fc7BaseObject\u7684env()\u8bbf\u95ee\u7684\u3002\u4ece\u800c\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u3002\u56e0\u4e3aWorker\u5b9e\u4f8b\u662f\u5728\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u4e4b\u95f4\u5171\u4eab\u7684\uff0cNode.js\u5728Worker\u7c7b\u4e2d\u91cd\u65b0\u5b9a\u4e49\u4e86\u4e00\u4e2aenv_\u5c5e\u6027\u6b63\u662f\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 3 CreateEnvMessagePort 1. void Worker::CreateEnvMessagePort(Environment* env) { 2. child_port_ = MessagePort::New(env, 3. env->context(), 4. std::move(child_port_data_)); 5. if (child_port_ != nullptr) 6. env->set_message_port(child_port_->object(isolate_)); 7. } child_port_data_\u8fd9\u4e2a\u53d8\u91cf\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u770b\u5230\u8fc7\uff0c\u5728\u8fd9\u91cc\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\u7aef\u53e3\u3002\u5e76\u4e14\u548cchild_port_data_\u4e92\u76f8\u5173\u8054\u8d77\u6765\u3002\u7136\u540e\u5728env\u7f13\u5b58\u8d77\u6765\u3002\u540e\u7eed\u4f1a\u4f7f\u7528\u3002\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-4\u6240\u793a\u3002 \u56fe14-4 4 \u6267\u884cinternal/main/worker_thread.js 1. // \u8bbe\u7f6eprocess\u5bf9\u8c61 2. patchProcessObject(); 3. // \u83b7\u53d6\u521a\u624d\u7f13\u5b58\u7684\u7aef\u53e3child_port_ 4. onst port = getEnvMessagePort(); 5. port.on('message', (message) => { 6. // \u52a0\u8f7d\u811a\u672c 7. if (message.type === LOAD_SCRIPT) { 8. const { 9. argv, 10. cwdCounter, 11. filename, 12. doEval, 13. workerData, 14. publicPort, 15. manifestSrc, 16. manifestURL, 17. hasStdin 18. } = message; 19. 20. const CJSLoader = require('internal/modules/cjs/loader'); 21. loadPreloadModules(); 22. /* 23. \u7531\u4e3b\u7ebf\u7a0b\u7533\u8bf7\u7684MessageChannel\u4e2d\u67d0\u4e00\u7aef\u7684\u7aef\u53e3\uff0c 24. \u4e3b\u7ebf\u7a0b\u4f20\u9012\u8fc7\u6765\u7684\uff0c\u4fdd\u5b58\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 25. */ 26. publicWorker.parentPort = publicPort; 27. // \u6267\u884c\u65f6\u4f7f\u7528\u7684\u6570\u636e 28. publicWorker.workerData = workerData; 29. // \u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u6b63\u5728\u6267\u884c\u811a\u672c 30. port.postMessage({ type: UP_AND_RUNNING }); 31. // \u6267\u884cnew Worker(filename)\u65f6\u4f20\u5165\u7684\u6587\u4ef6 32. CJSLoader.Module.runMain(filename); 33. }) 34. // \u5f00\u59cb\u63a5\u6536\u6d88\u606f 35. port.start() \u6211\u4eec\u770b\u5230worker_thread.js\u4e2d\u901a\u8fc7runMain\u5b8c\u6210\u4e86\u5b50\u7ebf\u7a0b\u7684\u4ee3\u7801\u6267\u884c\uff0c\u7136\u540e\u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\u65f6\uff0cNode.js\u7684\u903b\u8f91\u3002 1. // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 2. w->env()->SetImmediateThreadsafe( 3. [w = std::unique_ptr<Worker>(w)](Environment* env) { 4. if (w->has_ref_) 5. env->add_refs(-1); 6. w->JoinThread(); 7. // implicitly delete w 8. }); 9. }, static_cast<void*>(w)), 0); \u901a\u8fc7w->env()\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u73af\u5883\u3002\u6211\u4eec\u770b\u4e00\u4e0bSetImmediateThreadsafe\u3002 1. template <typename Fn> 2. void Environment::SetImmediateThreadsafe(Fn&& cb) { 3. auto callback = std::make_unique<NativeImmediateCallbackImpl<Fn>>( 4. std::move(cb), false); 5. { 6. Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_); 7. native_immediates_threadsafe_.Push(std::move(callback)); 8. } 9. uv_async_send(&task_queues_async_); 10. } SetImmediateThreadsafe\u7528\u4e8e\u901a\u77e5\u6267\u884c\u73af\u5883\u6240\u5728\u7684\u4e8b\u4ef6\u5faa\u73af\u6709\u5f02\u6b65\u4efb\u52a1\u5b8c\u6210\u3002\u5e76\u4e14\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002\u56e0\u4e3a\u53ef\u80fd\u6709\u591a\u4e2a\u7ebf\u7a0b\u4f1a\u64cd\u4f5cnative_immediates_threadsafe_\u3002\u5728\u4e3b\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884ctask_queues_async_\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0btask_queues_async_\u5bf9\u5e94\u7684\u56de\u8c03\u3002 1. uv_async_init( 2. event_loop(), 3. &task_queues_async_, 4. [](uv_async_t* async) { 5. Environment* env = ContainerOf( 6. &Environment::task_queues_async_, async); 7. env->CleanupFinalizationGroups(); 8. env->RunAndClearNativeImmediates(); 9. }); \u6240\u4ee5\u5728Poll IO\u9636\u6bb5\u6267\u884c\u7684\u56de\u8c03\u662fRunAndClearNativeImmediates 1. void Environment::RunAndClearNativeImmediates(bool only_refed) { 2. TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment), 3. \"RunAndClearNativeImmediates\", this); 4. size_t ref_count = 0; 5. 6. if (native_immediates_threadsafe_.size() > 0) { 7. Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_); 8. native_immediates_.ConcatMove(std::move(native_immediates_threadsafe_)); 9. } 10. 11. auto drain_list = [&]() { 12. TryCatchScope try_catch(this); 13. DebugSealHandleScope seal_handle_scope(isolate()); 14. while (std::unique_ptr<NativeImmediateCallback> head = 15. native_immediates_.Shift()) { 16. if (head->is_refed()) 17. ref_count++; 18. 19. if (head->is_refed() || !only_refed) 20. // \u6267\u884c\u56de\u8c03 21. head->Call(this); 22. 23. head.reset(); 24. }; 25. } RunAndClearNativeImmediates\u4f1a\u6267\u884c\u961f\u5217\u91cc\u7684\u56de\u8c03\u3002\u5bf9\u5e94Worker\u7684JoinThread 1. void Worker::JoinThread() { 2. // \u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u7ed3\u675f\uff0c\u6267\u884c\u5230\u8fd9\u5b50\u7ebf\u7a0b\u5df2\u7ecf\u7ed3\u675f\u4e86 3. CHECK_EQ(uv_thread_join(&tid_), 0); 4. thread_joined_ = true; 5. // \u4ece\u4e3b\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784\u4e2d\u5220\u9664\u8be5\u7ebf\u7a0b\u5bf9\u5e94\u7684\u5b9e\u4f8b 6. env()->remove_sub_worker_context(this); 7. 8. { 9. HandleScope handle_scope(env()->isolate()); 10. Context::Scope context_scope(env()->context()); 11. 12. // Reset the parent port as we're closing it now anyway. 13. object()->Set(env()->context(), 14. env()->message_port_string(), 15. Undefined(env()->isolate())).Check(); 16. // \u5b50\u7ebf\u7a0b\u9000\u51fa\u7801 17. Local<Value> args[] = { 18. Integer::New(env()->isolate(), exit_code_), 19. custom_error_ != nullptr ? 20. OneByteString(env()->isolate(), custom_error_).As<Value>() : 21. Null(env()->isolate()).As<Value>(), 22. }; 23. // \u6267\u884cJS\u5c42\u56de\u8c03\uff0c\u89e6\u53d1exit\u4e8b\u4ef6 24. MakeCallback(env()->onexit_string(), arraysize(args), args); 25. } 26. } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u679c\u7ed3\u675f\u6b63\u5728\u6267\u884c\u7684\u5b50\u7ebf\u7a0b\u3002\u5728JS\u4e2d\u6211\u80fd\u53ef\u4ee5\u901a\u8fc7terminate\u51fd\u6570\u7ec8\u6b62\u7ebf\u7a0b\u7684\u6267\u884c\u3002 1. terminate(callback) { 2. this[kHandle].stopThread(); 3. } Terminate\u662f\u5bf9C++\u6a21\u5757stopThread\u7684\u5c01\u88c5\u3002 1. void Worker::StopThread(const FunctionCallbackInfo<Value>& args) { 2. Worker* w; 3. ASSIGN_OR_RETURN_UNWRAP(&w, args.This()); 4. w->Exit(1); 5. } 6. 7. void Worker::Exit(int code) { 8. Mutex::ScopedLock lock(mutex_); 9. // env_\u662f\u5b50\u7ebf\u7a0b\u6267\u884c\u7684env 10. if (env_ != nullptr) { 11. exit_code_ = code; 12. Stop(env_); 13. } else { 14. stopped_ = true; 15. } 16. } 17. 18. 19. int Stop(Environment* env) { 20. env->ExitEnv(); 21. return 0; 22. } 23. 24. void Environment::ExitEnv() { 25. set_can_call_into_js(false); 26. set_stopping(true); 27. isolate_->TerminateExecution(); 28. SetImmediateThreadsafe([](Environment* env) { uv_stop(env->event_loop()); }); 29. } \u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u6700\u7ec8\u901a\u8fc7SetImmediateThreadsafe\u7ed9\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env\u63d0\u4ea4\u4e86\u4e00\u4e2a\u4efb\u52a1\u3002\u5b50\u7ebf\u7a0b\u5728Poll IO\u9636\u6bb5\u4f1a\u8bbe\u7f6e\u505c\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u6807\u8bb0\uff0c\u7b49\u5230\u4e0b\u4e00\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u8df3\u51fa\u4e8b\u4ef6\u5faa\u73af\u4ece\u800c\u7ed3\u675f\u5b50\u7ebf\u7a0b\u7684\u6267\u884c\u3002 14.4 \u7ebf\u7a0b\u95f4\u901a\u4fe1 \u00b6 \u672c\u8282\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u8fc7\u7a0b\u3002 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. if (isMainThread) { 3. const worker = new Worker(__filename); 4. worker.once('message', (message) => { 5. ... 6. }); 7. worker.postMessage('Hello, world!'); 8. } else { 9. // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 10. parentPort.once('message', (message) => { 11. parentPort.postMessage(message); 12. }); 13. } \u6211\u4eec\u77e5\u9053isMainThread\u5728\u5b50\u7ebf\u7a0b\u91cc\u662ffalse\uff0cparentPort\u5c31\u662fmessageChannel\u4e2d\u7684\u4e00\u7aef\u3002\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\uff0c\u6240\u4ee5parentPort.postMessage\u7ed9\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u5c31\u662f\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001\u6d88\u606f\uff0c\u6211\u4eec\u518d\u770b\u770bworker.postMessage('Hello, world!')\u3002 1. postMessage(...args) { 2. this[kPublicPort].postMessage(...args); 3. } kPublicPort\u6307\u5411\u7684\u5c31\u662fmessageChannel\u7684\u4e00\u7aef\u3002this[kPublicPort].postMessage(...args)\u5373\u7ed9\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0bpostMessage\u7684\u5b9e\u73b0\u3002 1. void MessagePort::PostMessage(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. Local<Object> obj = args.This(); 4. Local<Context> context = obj->CreationContext(); 5. 6. TransferList transfer_list; 7. if (args[1]->IsObject()) { 8. // \u5904\u7406transfer_list 9. } 10. // \u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u6240\u5173\u8054\u7684MessagePort 11. MessagePort* port = Unwrap<MessagePort>(args.This()); 12. 13. port->PostMessage(env, args[0], transfer_list); 14. } \u6211\u4eec\u63a5\u7740\u770bport->PostMessage 1. Maybe<bool> MessagePort::PostMessage(Environment* env, 2. Local<Value> message_v, 3. const TransferList& transfer_v) { 4. Isolate* isolate = env->isolate(); 5. Local<Object> obj = object(isolate); 6. Local<Context> context = obj->CreationContext(); 7. 8. Message msg; 9. 10. // \u5e8f\u5217\u5316 11. Maybe<bool> serialization_maybe = 12. msg.Serialize(env, context, message_v, transfer_v, obj); 13. // \u62ff\u5230\u64cd\u4f5c\u5bf9\u7aefsibling\u7684\u9501 14. Mutex::ScopedLock lock(*data_->sibling_mutex_); 15. 16. // \u628a\u6d88\u606f\u63d2\u5165\u5230\u5bf9\u7aef\u961f\u5217 17. data_->sibling_->AddToIncomingQueue(std::move(msg)); 18. return Just(true); 19. } PostMessage\u901a\u8fc7AddToIncomingQueue\u628a\u6d88\u606f\u63d2\u5165\u5bf9\u7aef\u7684\u6d88\u606f\u961f\u5217\u6211\u4eec\u770b\u4e00\u4e0bAddToIncomingQueue 1. void MessagePortData::AddToIncomingQueue(Message&& message) { 2. // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 3. Mutex::ScopedLock lock(mutex_); 4. incoming_messages_.emplace_back(std::move(message)); 5. // \u901a\u77e5owner 6. if (owner_ != nullptr) { 7. owner_->TriggerAsync(); 8. } 9. } \u63d2\u5165\u6d88\u606f\u961f\u5217\u540e\uff0c\u5982\u679c\u6709\u5173\u8054\u7684\u7aef\u53e3\uff0c\u5219\u4f1a\u901a\u77e5Libuv\u3002\u6211\u4eec\u7ee7\u7eed\u770bTriggerAsync\u3002 1. void MessagePort::TriggerAsync() { 2. if (IsHandleClosing()) return; 3. CHECK_EQ(uv_async_send(&async_), 0); 4. } Libuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u56de\u8c03\u662f\u5728new MessagePort\u65f6\u8bbe\u7f6e\u7684\u3002 1. auto onmessage = [](uv_async_t* handle) { 2. MessagePort* channel = ContainerOf(&MessagePort::async_, handle); 3. channel->OnMessage(); 4. }; 5. // \u521d\u59cb\u5316async\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1 6. CHECK_EQ(uv_async_init(env->event_loop(), 7. &async_, 8. onmessage), 0); \u6211\u4eec\u7ee7\u7eed\u770bOnMessage\u3002 1. void MessagePort::OnMessage() { 2. HandleScope handle_scope(env()->isolate()); 3. Local<Context> context = object(env()->isolate())->CreationContext(); 4. // \u63a5\u6536\u6d88\u606f\u6761\u6570\u7684\u9608\u503c 5. size_t processing_limit; 6. { 7. // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 8. Mutex::ScopedLock(data_->mutex_); 9. processing_limit = std::max(data_->incoming_messages_.size(), 10. static_cast<size_t>(1000)); 11. } 12. while (data_) { 13. // \u8bfb\u53d6\u7684\u6761\u6570\u8fbe\u5230\u9608\u503c\uff0c\u901a\u77e5Libuv\u4e0b\u4e00\u8f6ePoll IO\u9636\u6bb5\u7ee7\u7eed\u8bfb 14. if (processing_limit-- == 0) { 15. // \u901a\u77e5\u4e8b\u4ef6\u5faa\u73af 16. TriggerAsync(); 17. return; 18. } 19. 20. HandleScope handle_scope(env()->isolate()); 21. Context::Scope context_scope(context); 22. 23. Local<Value> payload; 24. // \u8bfb\u53d6\u6d88\u606f 25. if (!ReceiveMessage(context, true).ToLocal(&payload)) break; 26. // \u6ca1\u6709\u4e86 27. if (payload == env()->no_message_symbol()) break; 28. 29. Local<Object> event; 30. Local<Value> cb_args[1]; 31. // \u65b0\u5efa\u4e00\u4e2aMessageEvent\u5bf9\u8c61\uff0c\u56de\u8c03onmessage\u4e8b\u4ef6 32. if (!env()->message_event_object_template()->NewInstance(context) 33. .ToLocal(&event) || 34. event->Set(context, env()->data_string(), payload).IsNothing() || 35. event->Set(context, env()->target_string(), object()).IsNothing() || 36. (cb_args[0] = event, false) || 37. MakeCallback(env()->onmessage_string(), 38. arraysize(cb_args), 39. cb_args).IsEmpty()) { 40. // \u5982\u679c\u56de\u8c03\u5931\u8d25\uff0c\u901a\u77e5Libuv\u4e0b\u6b21\u7ee7\u7eed\u8bfb 41. if (data_) 42. TriggerAsync(); 43. return; 44. } 45. } 46. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u4e0d\u65ad\u5730\u8c03\u7528ReceiveMessage\u8bfb\u53d6\u6570\u636e\uff0c\u7136\u540e\u56de\u8c03JS\u5c42\u3002\u76f4\u5230\u8fbe\u5230\u9608\u503c\u6216\u8005\u56de\u8c03\u5931\u8d25\u3002\u6211\u4eec\u770b\u4e00\u4e0bReceiveMessage\u7684\u903b\u8f91\u3002 1. MaybeLocal<Value> MessagePort::ReceiveMessage(Local<Context> context, 2. bool only_if_receiving) { 3. Message received; 4. { 5. // Get the head of the message queue. 6. // \u4e92\u65a5\u8bbf\u95ee\u6d88\u606f\u961f\u5217 7. Mutex::ScopedLock lock(data_->mutex_); 8. 9. bool wants_message = receiving_messages_ || !only_if_receiving; 10. // \u6ca1\u6709\u6d88\u606f\u3001\u4e0d\u9700\u8981\u63a5\u6536\u6d88\u606f\u3001\u6d88\u606f\u662f\u5173\u95ed\u6d88\u606f 11. if (data_->incoming_messages_.empty() || 12. (!wants_message && 13. !data_->incoming_messages_.front().IsCloseMessage())) { 14. return env()->no_message_symbol(); 15. } 16. // \u83b7\u53d6\u961f\u5217\u7b2c\u4e00\u4e2a\u6d88\u606f 17. received = std::move(data_->incoming_messages_.front()); 18. data_->incoming_messages_.pop_front(); 19. } 20. // \u662f\u5173\u95ed\u6d88\u606f\u5219\u5173\u95ed\u7aef\u53e3 21. if (received.IsCloseMessage()) { 22. Close(); 23. return env()->no_message_symbol(); 24. } 25. 26. // \u53cd\u5e8f\u5217\u5316\u540e\u8fd4\u56de 27. return received.Deserialize(env(), context); 28. } ReceiveMessage\u4f1a\u6d88\u606f\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u8fd4\u56de\u3002\u4ee5\u4e0a\u5c31\u662f\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u5177\u4f53\u6b65\u9aa4\u5982\u56fe14-5\u6240\u793a\u3002 \u56fe14-5","title":"14-\u7ebf\u7a0b"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#141","text":"\u5bf9\u4e8e\u540c\u6b65\u6587\u4ef6\u64cd\u4f5c\u3001DNS\u89e3\u6790\u7b49\u64cd\u4f5c\uff0cNode.js\u4f7f\u7528\u4e86\u5185\u7f6e\u7684\u7ebf\u7a0b\u6c60\u652f\u6301\u4e86\u5f02\u6b65\u3002\u4f46\u662f\u4e00\u4e9b\u52a0\u89e3\u5bc6\u3001\u5b57\u7b26\u4e32\u8fd0\u7b97\u3001\u963b\u585e\u578bAPI\u7b49\u64cd\u4f5c\u3002\u6211\u4eec\u5c31\u4e0d\u80fd\u5728\u4e3b\u7ebf\u7a0b\u91cc\u5904\u7406\u4e86\uff0c\u8fd9\u65f6\u5019\u5c31\u4e0d\u5f97\u4e0d\u4f7f\u7528\u7ebf\u7a0b\uff0c\u800c\u4e14\u591a\u7ebf\u7a0b\u8fd8\u80fd\u5229\u7528\u591a\u6838\u7684\u80fd\u529b\u3002Node.js\u7684\u5b50\u7ebf\u7a0b\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u4f46\u662f\u5b50\u7ebf\u7a0b\u548cNode.js\u4e3b\u7ebf\u7a0b\u5171\u4eab\u4e00\u4e2aLibuv\u7ebf\u7a0b\u6c60\uff0c\u6240\u4ee5\u5982\u679c\u5728\u5b50\u7ebf\u7a0b\u91cc\u6709\u6587\u4ef6\u3001DNS\u7b49\u64cd\u4f5c\u5c31\u4f1a\u548c\u4e3b\u7ebf\u7a0b\u7ade\u4e89Libuv\u7ebf\u7a0b\u6c60\u3002\u5982\u56fe14-1\u6240\u793a\u3002 \u56fe14-1 \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u4f7f\u7528\u7ebf\u7a0b\u3002 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. if (isMainThread) { 3. const worker = new Worker(__filename); 4. worker.once('message', (message) => { 5. ... 6. }); 7. worker.postMessage('Hello, world!'); 8. } else { 9. // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 10. parentPort.once('message', (message) => { 11. parentPort.postMessage(message); 12. }); 13. } \u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\u4f1a\u88ab\u6267\u884c\u4e24\u6b21\uff0c\u4e00\u6b21\u662f\u5728\u4e3b\u7ebf\u7a0b\uff0c\u4e00\u6b21\u5728\u5b50\u7ebf\u7a0b\u3002\u6240\u4ee5\u9996\u5148\u901a\u8fc7isMainThread\u5224\u65ad\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u3002\u4e3b\u7ebf\u7a0b\u7684\u8bdd\uff0c\u5c31\u521b\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u76d1\u542c\u5b50\u7ebf\u7a0b\u53d1\u8fc7\u6765\u7684\u6d88\u606f\u3002\u5b50\u7ebf\u7a0b\u7684\u8bdd\uff0c\u9996\u5148\u6267\u884c\u4e1a\u52a1\u76f8\u5173\u7684\u4ee3\u7801\uff0c\u8fd8\u53ef\u4ee5\u76d1\u542c\u4e3b\u7ebf\u7a0b\u4f20\u8fc7\u6765\u7684\u6d88\u606f\u3002\u6211\u4eec\u5728\u5b50\u7ebf\u7a0b\u4e2d\u53ef\u4ee5\u505a\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u963b\u585e\u6027\u7684\u64cd\u4f5c\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u628a\u8fd9\u4e24\u4e2a\u903b\u8f91\u62c6\u5206\u5230\u4e24\u4e2a\u6587\u4ef6\u3002 \u4e3b\u7ebf\u7a0b 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. const worker = new Worker(\u2018\u5b50\u7ebf\u7a0b\u6587\u4ef6\u8def\u5f84\u2019); 3. worker.once('message', (message) => { 4. ... 5. }); 6. worker.postMessage('Hello, world!'); \u5b50\u7ebf\u7a0b 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. parentPort.once('message', (message) => { 3. parentPort.postMessage(message); 4. });","title":"14.1 \u4f7f\u7528\u591a\u7ebf\u7a0b"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#142","text":"\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\u4e00\u822c\u9700\u8981\u501f\u52a9\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u516c\u5171\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u72ec\u7acb\u7684\uff0c\u548c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e0d\u4e00\u6837\u3002\u591a\u7ebf\u7a0b\u7684\u5185\u5b58\u662f\u5171\u4eab\u7684\uff0c\u540c\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\uff0c\u591a\u4e2a\u7ebf\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u6240\u4ee5\u7ebf\u7a0b\u95f4\u901a\u4fe1\u53ef\u4ee5\u57fa\u4e8e\u8fdb\u7a0b\u5185\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u5728Node.js\u4e2d\uff0c\u7ebf\u7a0b\u95f4\u901a\u4fe1\u4f7f\u7528\u7684\u662fMessageChannel\u5b9e\u73b0\u7684\uff0c\u5b83\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4efb\u610f\u4e00\u7aef\u90fd\u53ef\u4ee5\u968f\u65f6\u53d1\u9001\u4fe1\u606f\u3002MessageChannel\u7c7b\u4f3csocket\u901a\u4fe1\uff0c\u5b83\u5305\u62ec\u4e24\u4e2a\u7aef\u70b9\u3002\u5b9a\u4e49\u4e00\u4e2aMessageChannel\u76f8\u5f53\u4e8e\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5b83\u9996\u5148\u7533\u8bf7\u4e24\u4e2a\u7aef\u70b9\uff08MessagePort\uff09\uff0c\u7136\u540e\u628a\u5b83\u4eec\u5173\u8054\u8d77\u6765\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bd4\u8f83\u91cd\u8981\u7684\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\u3002 1 Message\u4ee3\u8868\u4e00\u4e2a\u6d88\u606f\u3002 2 MessagePortData\u662f\u5bf9\u64cd\u4f5cMessage\u7684\u5c01\u88c5\u548c\u5bf9\u6d88\u606f\u7684\u627f\u8f7d\u3002 3 MessagePort\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u7aef\u70b9\u3002 4 MessageChannel\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u4e24\u7aef\uff0c\u5373\u4e24\u4e2aMessagePort\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 14.2.1 Message Message\u7c7b\u4ee3\u8868\u7684\u662f\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u6761\u6d88\u606f\u3002 1. class Message : public MemoryRetainer { 2. public: 3. explicit Message(MallocedBuffer<char>&& payload = MallocedBuffer<char>()); 4. // \u662f\u5426\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f\uff0c\u7a7a\u6d88\u606f\u4ee3\u8868\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f 5. bool IsCloseMessage() const; 6. // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u9700\u8981\u901a\u8fc7\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u5904\u7406 7. v8::MaybeLocal<v8::Value> Deserialize(Environment* env, 8. v8::Local<v8::Context> context); 9. v8::Maybe<bool> Serialize(Environment* env, 10. v8::Local<v8::Context> context, 11. v8::Local<v8::Value> input, 12. const TransferList& transfer_list, 13. v8::Local<v8::Object> source_port = 14. v8::Local<v8::Object>()); 15. 16. // \u4f20\u9012SharedArrayBuffer\u578b\u53d8\u91cf 17. void AddSharedArrayBuffer(std::shared_ptr<v8::BackingStore> backing_store); 18. // \u4f20\u9012MessagePort\u578b\u53d8\u91cf 19. void AddMessagePort(std::unique_ptr<MessagePortData>&& data); 20. // \u6d88\u606f\u6240\u5c5e\u7aef\u53e3\uff0c\u7aef\u53e3\u662f\u6d88\u606f\u5230\u8fbe\u7684\u5730\u65b9 21. const std::vector<std::unique_ptr<MessagePortData>>& message_ports() const { 22. return message_ports_; 23. } 24. 25. private: 26. // \u4fdd\u5b58\u6d88\u606f\u7684\u5185\u5bb9 27. MallocedBuffer<char> main_message_buf_; 28. std::vector<std::shared_ptr<v8::BackingStore>> array_buffers_; 29. std::vector<std::shared_ptr<v8::BackingStore>> shared_array_buffers_; 30. std::vector<std::unique_ptr<MessagePortData>> message_ports_; 31. std::vector<v8::CompiledWasmModule> wasm_modules_; 32. };","title":"14.2 \u7ebf\u7a0b\u95f4\u901a\u4fe1\u6570\u636e\u7ed3\u6784"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#1422-messageportdata","text":"MessagePortData\u662f\u7ba1\u7406\u6d88\u606f\u53d1\u9001\u548c\u63a5\u6536\u7684\u7c7b\u3002 1. class MessagePortData : public MemoryRetainer { 2. public: 3. explicit MessagePortData(MessagePort* owner); 4. ~MessagePortData() override; 5. // \u65b0\u589e\u4e00\u4e2a\u6d88\u606f 6. void AddToIncomingQueue(Message&& message); 7. // \u5173\u8054/\u89e3\u5173\u8054\u901a\u4fe1\u4e24\u7aef\u7684\u7aef\u53e3 8. static void Entangle(MessagePortData* a, MessagePortData* b); 9. void Disentangle(); 10. 11. private: 12. // \u7528\u4e8e\u591a\u7ebf\u7a0b\u5f80\u5bf9\u7aef\u6d88\u606f\u961f\u5217\u63d2\u5165\u6d88\u606f\u65f6\u7684\u4e92\u65a5\u53d8\u91cf 13. mutable Mutex mutex_; 14. std::list<Message> incoming_messages_; 15. // \u6240\u5c5e\u7aef\u53e3 16. MessagePort* owner_ = nullptr; 17. // \u7528\u4e8e\u591a\u7ebf\u7a0b\u8bbf\u95ee\u5bf9\u7aefsibling_\u5c5e\u6027\u65f6\u7684\u4e92\u65a5\u53d8\u91cf 18. std::shared_ptr<Mutex> sibling_mutex_ = std::make_shared<Mutex>(); 19. // \u6307\u5411\u901a\u4fe1\u5bf9\u7aef\u7684\u6307\u9488 20. MessagePortData* sibling_ = nullptr; 21. }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1. MessagePortData::MessagePortData(MessagePort* owner) : owner_(owner) { } 2. 3. MessagePortData::~MessagePortData() { 4. // \u6790\u6784\u65f6\u89e3\u9664\u548c\u5bf9\u7aef\u7684\u5173\u7cfb 5. Disentangle(); 6. } 7. 8. // \u63d2\u5165\u4e00\u4e2amessage 9. void MessagePortData::AddToIncomingQueue(Message&& message) { 10. // \u5148\u52a0\u9501\uff0c\u4fdd\u8bc1\u591a\u7ebf\u7a0b\u5b89\u5168\uff0c\u4e92\u65a5\u8bbf\u95ee 11. Mutex::ScopedLock lock(mutex_); 12. // \u63d2\u5165\u6d88\u606f\u961f\u5217 13. incoming_messages_.emplace_back(std::move(message)); 14. // \u901a\u77e5owner 15. if (owner_ != nullptr) { 16. owner_->TriggerAsync(); 17. } 18. } 19. 20. // \u5173\u8054\u901a\u4fe1\u7684\u5bf9\u7aef\uff0c\u5e76\u4fdd\u6301\u5bf9\u7aef\u7684\u4e92\u65a5\u53d8\u91cf\uff0c\u8bbf\u95ee\u5bf9\u7aef\u65f6\u9700\u8981\u4f7f\u7528 21. void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) { 22. a->sibling_ = b; 23. b->sibling_ = a; 24. a->sibling_mutex_ = b->sibling_mutex_; 25. } 26. 27. // \u89e3\u9664\u5173\u8054 28. void MessagePortData::Disentangle() { 29. // \u52a0\u9501\u64cd\u4f5c\u5bf9\u7aef\u7684sibling\u5b57\u6bb5 30. std::shared_ptr<Mutex> sibling_mutex = sibling_mutex_; 31. Mutex::ScopedLock sibling_lock(*sibling_mutex); 32. sibling_mutex_ = std::make_shared<Mutex>(); 33. // \u5bf9\u7aef 34. MessagePortData* sibling = sibling_; 35. // \u5bf9\u7aef\u975e\u7a7a\uff0c\u5219\u628a\u5bf9\u7aef\u7684sibling\u4e5f\u6307\u5411\u7a7a\uff0c\u81ea\u5df1\u4e5f\u6307\u5411\u7a7a 36. if (sibling_ != nullptr) { 37. sibling_->sibling_ = nullptr; 38. sibling_ = nullptr; 39. } 40. 41. // \u63d2\u5165\u4e00\u4e2a\u7a7a\u7684\u6d88\u606f\u901a\u77e5\u5bf9\u7aef\u548c\u672c\u7aef 42. AddToIncomingQueue(Message()); 43. if (sibling != nullptr) { 44. sibling->AddToIncomingQueue(Message()); 45. } 46. }","title":"14.2.2 MessagePortData"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#1423-messageport","text":"MessagePort\u8868\u793a\u7684\u662f\u901a\u4fe1\u7684\u4e00\u7aef\u3002 1. class MessagePort : public HandleWrap { 2. public: 3. MessagePort(Environment* env, 4. v8::Local<v8::Context> context, 5. v8::Local<v8::Object> wrap); 6. ~MessagePort() override; 7. 8. static MessagePort* New(Environment* env, 9. v8::Local<v8::Context> context, 10. std::unique_ptr<MessagePortData> data = nullptr); 11. // \u53d1\u9001\u6d88\u606f 12. v8::Maybe<bool> PostMessage(Environment* env, 13. v8::Local<v8::Value> message, 14. const TransferList& transfer); 15. 16. // \u5f00\u542f/\u5173\u95ed\u63a5\u6536\u6d88\u606f 17. void Start(); 18. void Stop(); 19. 20. static void New(const v8::FunctionCallbackInfo<v8::Value>& args); 21. // \u63d0\u4f9bJS\u5c42\u4f7f\u7528\u7684\u65b9\u6cd5 22. static void PostMessage(const v8::FunctionCallbackInfo<v8::Value>& args); 23. static void Start(const v8::FunctionCallbackInfo<v8::Value>& args); 24. static void Stop(const v8::FunctionCallbackInfo<v8::Value>& args); 25. static void Drain(const v8::FunctionCallbackInfo<v8::Value>& args); 26. static void ReceiveMessage(const v8::FunctionCallbackInfo<v8::Value>& args); 27. // \u5173\u8054\u5bf9\u7aef 28. static void Entangle(MessagePort* a, MessagePort* b); 29. static void Entangle(MessagePort* a, MessagePortData* b); 30. 31. // \u89e3\u9664MessagePortData\u548c\u7aef\u53e3\u7684\u5173\u7cfb 32. std::unique_ptr<MessagePortData> Detach(); 33. // \u5173\u95ed\u7aef\u53e3 34. void Close( 35. v8::Local<v8::Value> close_callback = v8::Local<v8::Value>()) override; 36. 37. inline bool IsDetached() const; 38. private: 39. void OnClose() override; 40. void OnMessage(); 41. void TriggerAsync(); 42. v8::MaybeLocal<v8::Value> ReceiveMessage(v8::Local<v8::Context> context, 43. bool only_if_receiving); 44. // MessagePortData\u7528\u4e8e\u7ba1\u7406\u6d88\u606f\u7684\u53d1\u9001\u548c\u63a5\u6536 45. std::unique_ptr<MessagePortData> data_ = nullptr; 46. // \u662f\u5426\u5f00\u542f\u63a5\u6536\u6d88\u606f\u6807\u8bb0 47. bool receiving_messages_ = false; 48. // \u7528\u4e8e\u6536\u5230\u6d88\u606f\u65f6\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\uff0c\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03\u5904\u7406\u6d88\u606f 49. uv_async_t async_; 50. }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u90e8\u5206\u51fd\u6570\u3002 1. // \u7aef\u53e3\u662f\u5426\u4e0d\u63a5\u6536\u6d88\u606f\u4e86 2. bool MessagePort::IsDetached() const { 3. return data_ == nullptr || IsHandleClosing(); 4. } 5. 6. // \u6709\u6d88\u606f\u5230\u8fbe\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03 7. void MessagePort::TriggerAsync() { 8. if (IsHandleClosing()) return; 9. CHECK_EQ(uv_async_send(&async_), 0); 10. } 11. 12. // \u5173\u95ed\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 13. void MessagePort::Close(v8::Local<v8::Value> close_callback) { 14. if (data_) { 15. // \u6301\u6709\u9501\uff0c\u9632\u6b62\u518d\u63a5\u6536\u6d88\u606f 16. Mutex::ScopedLock sibling_lock(data_->mutex_); 17. HandleWrap::Close(close_callback); 18. } else { 19. HandleWrap::Close(close_callback); 20. } 21. } 22. 23. // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u53ef\u4ee5\u6302\u8f7d\u4e00\u4e2aMessagePortData 24. MessagePort* MessagePort::New( 25. Environment* env, 26. Local<Context> context, 27. std::unique_ptr<MessagePortData> data) { 28. Context::Scope context_scope(context); 29. Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env); 30. 31. Local<Object> instance; 32. // JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 33. if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance)) 34. return nullptr; 35. // \u65b0\u5efa\u4e00\u4e2a\u6d88\u606f\u7aef\u53e3 36. MessagePort* port = new MessagePort(env, context, instance); 37. 38. // \u9700\u8981\u6302\u8f7dMessagePortData 39. if (data) { 40. port->Detach(); 41. port->data_ = std::move(data); 42. Mutex::ScopedLock lock(port->data_->mutex_); 43. // \u4fee\u6539data\u7684owner\u4e3a\u5f53\u524d\u6d88\u606f\u7aef\u53e3 44. port->data_->owner_ = port; 45. // data\u4e2d\u53ef\u80fd\u6709\u6d88\u606f 46. port->TriggerAsync(); 47. } 48. return port; 49. } 50. 51. // \u5f00\u59cb\u63a5\u6536\u6d88\u606f 52. void MessagePort::Start() { 53. Debug(this, \"Start receiving messages\"); 54. receiving_messages_ = true; 55. Mutex::ScopedLock lock(data_->mutex_); 56. // \u6709\u7f13\u5b58\u7684\u6d88\u606f\uff0c\u901a\u77e5\u4e0a\u5c42 57. if (!data_->incoming_messages_.empty()) 58. TriggerAsync(); 59. } 60. 61. // \u505c\u6b62\u63a5\u6536\u6d88\u606f 62. void MessagePort::Stop() { 63. Debug(this, \"Stop receiving messages\"); 64. receiving_messages_ = false; 65. } 66. // JS\u5c42\u8c03\u7528 67. void MessagePort::Start(const FunctionCallbackInfo<Value>& args) { 68. MessagePort* port; 69. ASSIGN_OR_RETURN_UNWRAP(&port, args.This()); 70. if (!port->data_) { 71. return; 72. } 73. port->Start(); 74. } 75. 76. void MessagePort::Stop(const FunctionCallbackInfo<Value>& args) { 77. MessagePort* port; 78. CHECK(args[0]->IsObject()); 79. ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>()); 80. if (!port->data_) { 81. return; 82. } 83. port->Stop(); 84. } 85. 86. // \u8bfb\u53d6\u6d88\u606f 87. void MessagePort::Drain(const FunctionCallbackInfo<Value>& args) { 88. MessagePort* port; 89. ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>()); 90. port->OnMessage(); 91. } 92. 93. // \u83b7\u53d6\u67d0\u4e2a\u7aef\u53e3\u7684\u6d88\u606f 94. void MessagePort::ReceiveMessage(const FunctionCallbackInfo<Value>& args) { 95. CHECK(args[0]->IsObject()); 96. // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u7aef\u53e3 97. MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>()); 98. // \u8c03\u7528\u5bf9\u8c61\u7684ReceiverMessage\u65b9\u6cd5 99. MaybeLocal<Value> payload = 100. port->ReceiveMessage(port->object()->CreationContext(), false); 101. if (!payload.IsEmpty()) 102. args.GetReturnValue().Set(payload.ToLocalChecked()); 103. } 104. 105. // \u5173\u8054\u4e24\u4e2a\u7aef\u53e3 106. void MessagePort::Entangle(MessagePort* a, MessagePort* b) { 107. Entangle(a, b->data_.get()); 108. } 109. 110. void MessagePort::Entangle(MessagePort* a, MessagePortData* b) { 111. MessagePortData::Entangle(a->data_.get(), b); 112. }","title":"14.2.3 MessagePort"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#1424-messagechannel","text":"MessageChannel\u8868\u793a\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2a\u7aef\u3002 1. static void MessageChannel(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. Local<Context> context = args.This()->CreationContext(); 5. Context::Scope context_scope(context); 6. 7. MessagePort* port1 = MessagePort::New(env, context); 8. MessagePort* port2 = MessagePort::New(env, context); 9. MessagePort::Entangle(port1, port2); 10. // port1->object()\u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c\u5b83\u5173\u8054\u4e86MessagePort\u5bf9\u8c61 11. args.This()->Set(context, env->port1_string(), port1->object()) 12. .Check(); 13. args.This()->Set(context, env->port2_string(), port2->object()) 14. .Check(); 15. } MessageChannel\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e24\u4e2a\u6d88\u606f\u7aef\u53e3\uff0c\u5e76\u4e14\u5173\u8054\u8d77\u6765\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u57fa\u4e8e\u8fd9\u4e24\u4e2a\u7aef\u53e3\u8fdb\u884c\u901a\u4fe1\u4e86\u3002 Message\u3001MessagePortData\u3001MessagePort\u548cMessageChannel\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-2\u6240\u793a\u3002 \u56fe14-2 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u6a21\u5757\u5bfc\u51fa\u7684\u4e00\u4e9b\u529f\u80fd\u3002 1. static void InitMessaging(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. 7. { 8. // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053 9. Local<String> message_channel_string = FIXED_ONE_BYTE_STRING(env->isolate(), 10. \"MessageChannel\"); 11. Local<FunctionTemplate> templ = env->NewFunctionTemplate(MessageChannel); 12. templ->SetClassName(message_channel_string); 13. target->Set(context, 14. message_channel_string, 15. templ->GetFunction(context).ToLocalChecked()).Check(); 16. } 17. // \u65b0\u5efa\u6d88\u606f\u7aef\u53e3\u7684\u6784\u9020\u51fd\u6570 18. target->Set(context, 19. env->message_port_constructor_string(), 20. GetMessagePortConstructorTemplate(env) 21. ->GetFunction(context).ToLocalChecked()).Check(); 22. 23. env->SetMethod(target, \"stopMessagePort\", MessagePort::Stop); 24. env->SetMethod(target, \"drainMessagePort\", MessagePort::Drain); 25. env->SetMethod(target, \"receiveMessageOnPort\", MessagePort::ReceiveMessage); 26. env->SetMethod(target, \"moveMessagePortToContext\", 27. MessagePort::MoveToContext); 28. }","title":"14.2.4 MessageChannel"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#143","text":"\u672c\u8282\u6211\u4eec\u4eceworker_threads\u6a21\u5757\u5f00\u59cb\u5206\u6790\u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0\u3002\u8fd9\u662f\u4e00\u4e2aC++\u6a21\u5757\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u5bfc\u51fa\u7684\u529f\u80fd\u3002require(\"work_threads\")\u7684\u65f6\u5019\u5c31\u662f\u5f15\u7528\u4e86InitWorker\u51fd\u6570\u5bfc\u51fa\u7684\u529f\u80fd\u3002 1. void InitWorker(Local<Object> target, 2. Local<Value> unused, 3. Local<Context> context, 4. void* priv) { 5. Environment* env = Environment::GetCurrent(context); 6. 7. { 8. Local<FunctionTemplate> w = env->NewFunctionTemplate(Worker::New); 9. w->InstanceTemplate()->SetInternalFieldCount(1); 10. w->Inherit(AsyncWrap::GetConstructorTemplate(env)); 11. // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5217\u4e3e 12. env->SetProtoMethod(w, \"setEnvVars\", Worker::SetEnvVars); 13. // \u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5 14. /* 15. \u5bfc\u51fa\u51fd\u6570\u6a21\u5757\u5bf9\u5e94\u7684\u51fd\u6570\uff0c\u5373\u6211\u4eec\u4ee3\u7801\u4e2d 16. const { Worker } = require(\"worker_threads\");\u4e2d\u7684Worker 17. */ 18. Local<String> workerString = FIXED_ONE_BYTE_STRING(env->isolate(), \"Worker\"); 19. w->SetClassName(workerString); 20. target->Set(env->context(), 21. workerString, 22. w->GetFunction(env->context()).ToLocalChecked()).Check(); 23. 24. /* 25. \u5bfc\u51fagetEnvMessagePort\u65b9\u6cd5\uff0c\u83b7\u53d6\u7ebf\u7a0b\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 26. const {getEnvMessagePort} = require(\"worker_threads\"); 27. */ 28. env->SetMethod(target, \"getEnvMessagePort\", GetEnvMessagePort); 29. /* 30. \u7ebf\u7a0bid\uff0c\u8fd9\u4e2a\u4e0d\u662f\u64cd\u4f5c\u7cfb\u7edf\u5206\u914d\u7684\u90a3\u4e2a\uff0c\u800c\u662fNode.js\u5206\u914d\u7684, 31. \u5728\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e 32. const { threadId } = require(\"worker_threads\"); 33. */ 34. target->Set(env->context(), 35. env->thread_id_string(), 36. Number::New(env->isolate(), 37. static_cast<double>(env->thread_id()))) 38. .Check(); 39. /* 40. \u662f\u5426\u662f\u4e3b\u7ebf\u7a0b\uff0c 41. const { isMainThread } = require(\"worker_threads\"); 42. \u8fd9\u8fb9\u53d8\u91cf\u5728Node.js\u542f\u52a8\u7684\u65f6\u5019\u8bbe\u7f6e\u4e3atrue\uff0c\u65b0\u5f00\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u6ca1\u6709\u8bbe 43. \u7f6e\uff0c\u6240\u4ee5\u662ffalse 44. */ 45. target->Set(env->context(), 46. FIXED_ONE_BYTE_STRING(env->isolate(), \"isMainThread\"), 47. Boolean::New(env->isolate(), env->is_main_thread())) 48. .Check(); 49. /* 50. \u5982\u679c\u4e0d\u662f\u4e3b\u7ebf\u7a0b\uff0c\u5bfc\u51fa\u8d44\u6e90\u9650\u5236\u7684\u914d\u7f6e\uff0c 51. \u5373\u5728\u5b50\u7ebf\u7a0b\u4e2d\u8c03\u7528 52. const { resourceLimits } = require(\"worker_threads\"); 53. */ 54. if (!env->is_main_thread()) { 55. target->Set(env->context(), 56. FIXED_ONE_BYTE_STRING(env->isolate(), 57. \"resourceLimits\"), 58. env->worker_context()->GetResourceLimits(env->isolate())).Check(); 59. } 60. // \u5bfc\u51fa\u51e0\u4e2a\u5e38\u91cf 61. NODE_DEFINE_CONSTANT(target, kMaxYoungGenerationSizeMb); 62. NODE_DEFINE_CONSTANT(target, kMaxOldGenerationSizeMb); 63. NODE_DEFINE_CONSTANT(target, kCodeRangeSizeMb); 64. NODE_DEFINE_CONSTANT(target, kTotalResourceLimitCount); 65. } \u4e86\u89e3work_threads\u6a21\u5757\u5bfc\u51fa\u7684\u529f\u80fd\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u6267\u884cnew Worker\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002\u6839\u636e\u4e0a\u9762\u4ee3\u7801\u5bfc\u51fa\u7684\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\u8fd9\u65f6\u5019\u9996\u5148\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002\u7136\u540e\u6267\u884cNew\u56de\u8c03\uff0c\u5e76\u4f20\u5165\u65b0\u5efa\u7684C++\u5bf9\u8c61\u3002\u6211\u4eec\u770bNew\u51fd\u6570\u7684\u903b\u8f91\u3002\u6211\u4eec\u7701\u7565\u4e00\u7cfb\u5217\u7684\u53c2\u6570\u5904\u7406\uff0c\u4e3b\u8981\u4ee3\u7801\u5982\u4e0b\u3002 1. // args.This()\u5c31\u662f\u6211\u4eec\u521a\u624d\u4f20\u8fdb\u6765\u7684this 2. Worker* worker = new Worker(env, args.This(), 3. url, per_isolate_opts, 4. std::move(exec_argv_out)); \u6211\u4eec\u518d\u770bWorker\u7c7b\u7684\u58f0\u660e\u3002 1. class Worker : public AsyncWrap { 2. public: 3. // \u51fd\u6570\u58f0\u660e 4. 5. private: 6. 7. std::shared_ptr<PerIsolateOptions> per_isolate_opts_; 8. std::vector<std::string> exec_argv_; 9. std::vector<std::string> argv_; 10. MultiIsolatePlatform* platform_; 11. v8::Isolate* isolate_ = nullptr; 12. bool start_profiler_idle_notifier_; 13. // \u771f\u6b63\u7684\u7ebf\u7a0bid\uff0c\u5e95\u5c42\u8fd4\u56de\u7684 14. uv_thread_t tid_; 15. 16. // This mutex protects access to all variables listed below it. 17. mutable Mutex mutex_; 18. 19. bool thread_joined_ = true; 20. const char* custom_error_ = nullptr; 21. int exit_code_ = 0; 22. // \u7ebf\u7a0bid\uff0cNode.js\u5206\u914d\uff0c\u4e0d\u662f\u5e95\u5c42\u8fd4\u56de\u7684 23. uint64_t thread_id_ = -1; 24. uintptr_t stack_base_ = 0; 25. 26. // \u7ebf\u7a0b\u8d44\u6e90\u9650\u5236\u914d\u7f6e 27. double resource_limits_[kTotalResourceLimitCount]; 28. void UpdateResourceConstraints(v8::ResourceConstraints* constraints); 29. 30. // \u6808\u4fe1\u606f 31. static constexpr size_t kStackSize = 4 * 1024 * 1024; 32. static constexpr size_t kStackBufferSize = 192 * 1024; 33. 34. std::unique_ptr<MessagePortData> child_port_data_; 35. std::shared_ptr<KVStore> env_vars_; 36. // \u7528\u4e8e\u7ebf\u7a0b\u95f4\u901a\u4fe1 37. MessagePort* child_port_ = nullptr; 38. MessagePort* parent_port_ = nullptr; 39. // \u7ebf\u7a0b\u72b6\u6001 40. bool stopped_ = true; 41. // \u662f\u5426\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 42. bool has_ref_ = true; 43. // \u5b50\u7ebf\u7a0b\u6267\u884c\u65f6\u7684\u73af\u5883\u53d8\u91cf\uff0c\u57fa\u7c7b\u4e5f\u5b9a\u4e49\u4e86 44. Environment* env_ = nullptr; 45. }; \u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e0benv_\u7684\u5b9a\u4e49\uff0c\u56e0\u4e3a\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5730\u65b9\u3002\u6211\u4eec\u770b\u5230Worker\u7c7b\u7ee7\u627fAsyncWrap\uff0cAsyncWrap\u7ee7\u627f\u4e86BaseObject\u3002BaseObject\u4e2d\u4e5f\u5b9a\u4e49\u4e86env_\u5c5e\u6027\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5728C++\u4e2d\u5982\u679c\u5b50\u7c7b\u7236\u7c7b\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027\u65f6\u662f\u600e\u6837\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50 1. #include <iostream> 2. using namespace std; 3. 4. class A 5. { 6. public: 7. int value; 8. A() 9. { 10. value=1; 11. } 12. void console() 13. { 14. cout<<value<<endl; 15. } 16. 17. }; 18. class B: public A 19. { 20. public: 21. int value; 22. B():A() 23. { 24. value=2; 25. } 26. }; 27. int main() 28. { 29. B b; 30. // b.value = 3;\u53ea\u4f1a\u4fee\u6539\u5b50\u7c7b\u7684\uff0c\u4e0d\u4f1a\u4fee\u6539\u7236\u7c7b\u7684 31. b.console(); 32. cout<<b.value<<endl<<\"\u5185\u5b58\u5927\u5c0f\uff1a\"<<sizeof(b)<<endl; 33. return 0; 34. } \u4ee5\u4e0a\u4ee3\u7801\u6267\u884c\u65f6\u8f93\u51fa 1. 1 2. 2 3. \u5185\u5b58\u5927\u5c0f\uff1a8 \u7531\u8f93\u51fa\u7ed3\u679c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff0cb\u5185\u5b58\u5927\u5c0f\u662f8\u4e2a\u5b57\u8282\u3002\u5373\u4e24\u4e2aint\u3002\u6240\u4ee5b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\u4e24\u4e2aa\u5c5e\u6027\u90fd\u5206\u914d\u4e86\u5185\u5b58\u3002\u5f53\u6211\u4eec\u901a\u8fc7b.console\u8f93\u51favalue\u65f6\uff0c\u56e0\u4e3aconsole\u662f\u5728A\u4e0a\u5b9a\u4e49\u7684\uff0c\u6240\u4ee5\u8f93\u51fa1\uff0c\u4f46\u662f\u6211\u4eec\u901a\u8fc7b.value\u8bbf\u95ee\u65f6\uff0c\u8f93\u51fa\u7684\u662f2\u3002\u56e0\u4e3a\u8bbf\u95ee\u7684\u662fB\u4e2d\u5b9a\u4e49\u7684value\uff0c\u540c\u7406\u5982\u679c\u6211\u4eec\u5728B\u4e2d\u5b9a\u4e49console\uff0c\u8f93\u51fa\u4e5f\u4f1a\u662f2\u3002Worker\u4e2d\u5b9a\u4e49\u7684env_\u6211\u4eec\u540e\u7eed\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bWorker\u7c7b\u7684\u521d\u59cb\u5316\u903b\u8f91\u3002 1. Worker::Worker(Environment* env, 2. Local<Object> wrap,...) 3. : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER), 4. ... 5. // \u5206\u914d\u7ebf\u7a0bid 6. thread_id_(Environment::AllocateThreadId()), 7. // \u7ee7\u627f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u53d8\u91cf 8. env_vars_(env->env_vars()) { 9. 10. // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1 11. parent_port_ = MessagePort::New(env, env->context()); 12. /* 13. \u5173\u8054\u8d77\u6765\uff0c\u7528\u4e8e\u901a\u4fe1 14. const parent_port_ = {data: {sibling: null}}; 15. const child_port_data_ = {sibling: null}; 16. parent_port_.data.sibling = child_port_data_; 17. child_port_data_.sibling = parent_port_.data; 18. */ 19. child_port_data_ = std::make_unique<MessagePortData>(nullptr); 20. MessagePort::Entangle(parent_port_, child_port_data_.get()); 21. // \u8bbe\u7f6eJS\u5c42Worker\u5bf9\u8c61\u7684messagePort\u5c5e\u6027\u4e3aparent_port_ 22. object()->Set(env->context(), 23. env->message_port_string(), 24. parent_port_->object()).Check(); 25. // \u8bbe\u7f6eWorker\u5bf9\u8c61\u7684\u7ebf\u7a0bid\uff0c\u5373threadId\u5c5e\u6027 26. object()->Set(env->context(), 27. env->thread_id_string(), 28. Number::New(env->isolate(), static_cast<double>(thread_id_))) 29. .Check(); 30. } \u65b0\u5efa\u4e00\u4e2aWorker\uff0c\u7ed3\u6784\u5982\u56fe14-3\u6240\u793a\u3002 \u56fe14-3 \u4e86\u89e3\u4e86new Worker\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u6211\u4eec\u770bJS\u5c42Worker\u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 1. constructor(filename, options = {}) { 2. super(); 3. // \u5ffd\u7565\u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406\uff0cnew Worker\u5c31\u662f\u4e0a\u9762\u63d0\u5230\u7684C++\u5c42\u7684 4. this[kHandle] = new Worker(url, options.execArgv, parseResourceLimits(options.resourceLimits)); 5. // messagePort\u6307\u5411_parent_port 6. this[kPort] = this[kHandle].messagePort; 7. this[kPort].on('message', (data) => this[kOnMessage](data)); 8. // \u5f00\u59cb\u63a5\u6536\u6d88\u606f 9. this[kPort].start(); 10. // \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053\uff0c\u4e24\u4e2a\u7aef\u53e3 11. const { port1, port2 } = new MessageChannel(); 12. this[kPublicPort] = port1; 13. this[kPublicPort].on('message', (message) => this.emit('message', message)); 14. // \u5411\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f 15. this[kPort].postMessage({ 16. argv, 17. type: messageTypes.LOAD_SCRIPT, 18. filename, 19. doEval: !!options.eval, 20. cwdCounter: cwdCounter || workerIo.sharedCwdCounter, 21. workerData: options.workerData, 22. publicPort: port2, 23. manifestSrc: getOptionValue('--experimental-policy') ? 24. require('internal/process/policy').src : 25. null, 26. hasStdin: !!options.stdin 27. }, [port2]); 28. // \u5f00\u542f\u7ebf\u7a0b 29. this[kHandle].startThread(); 30. } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u4fdd\u5b58messagePort\uff0c\u76d1\u542c\u8be5\u7aef\u53e3\u7684message\u4e8b\u4ef6\uff0c\u7136\u540e\u7ed9messagePort\u7684\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u63a5\u6536\u7aef\u53e3\uff0c\u6240\u4ee5\u6d88\u606f\u4f1a\u7f13\u5b58\u5230MessagePortData\uff0c\u5373child_port_data_ \u4e2d\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u628a\u901a\u4fe1\u7aef\u53e3port2\u53d1\u9001\u7ed9\u4e86\u5b50\u7ebf\u7a0b\u3002 2 \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053port1\u548cport2\uff0c\u7528\u4e8e\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002_parent_port\u548cchild_port\u662f\u7ed9Node.js\u4f7f\u7528\u7684\uff0c\u65b0\u7533\u8bf7\u7684\u7aef\u53e3\u662f\u7ed9\u7528\u6237\u4f7f\u7528\u7684\u3002 3 \u521b\u5efa\u5b50\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u505a\u4e86\u4ec0\u4e48\u3002 1. void Worker::StartThread(const FunctionCallbackInfo<Value>& args) { 2. Worker* w; 3. ASSIGN_OR_RETURN_UNWRAP(&w, args.This()); 4. Mutex::ScopedLock lock(w->mutex_); 5. 6. // The object now owns the created thread and should not be garbage collected 7. // until that finishes. 8. w->ClearWeak(); 9. // \u52a0\u5165\u4e3b\u7ebf\u7a0b\u7ef4\u62a4\u7684\u5b50\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784 10. w->env()->add_sub_worker_context(w); 11. w->stopped_ = false; 12. w->thread_joined_ = false; 13. // \u662f\u5426\u9700\u8981\u963b\u585e\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u9ed8\u8ba4true 14. if (w->has_ref_) 15. w->env()->add_refs(1); 16. // \u662f\u5426\u9700\u8981\u6808\u548c\u6808\u5927\u5c0f 17. uv_thread_options_t thread_options; 18. thread_options.flags = UV_THREAD_HAS_STACK_SIZE; 19. thread_options.stack_size = kStackSize; 20. // \u521b\u5efa\u7ebf\u7a0b 21. CHECK_EQ(uv_thread_create_ex(&w->tid_, &thread_options, [](void* arg) { 22. 23. Worker* w = static_cast<Worker*>(arg); 24. const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg); 25. w->stack_base_ = stack_top - (kStackSize - kStackBufferSize); 26. // \u6267\u884c\u4e3b\u903b\u8f91 27. w->Run(); 28. 29. Mutex::ScopedLock lock(w->mutex_); 30. // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 31. w->env()->SetImmediateThreadsafe( 32. [w = std::unique_ptr<Worker>(w)](Environment* env) { 33. if (w->has_ref_) 34. env->add_refs(-1); 35. w->JoinThread(); 36. // implicitly delete w 37. }); 38. }, static_cast<void*>(w)), 0); 39. } StartThread\u65b0\u5efa\u4e86\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u5728\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cRun\uff0c\u6211\u4eec\u7ee7\u7eed\u770bRun 1. void Worker::Run() { 2. // \u7ebf\u7a0b\u6267\u884c\u6240\u9700\u8981\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982loop\uff0cisolate\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb 3. WorkerThreadData data(this); 4. 5. { 6. Locker locker(isolate_); 7. Isolate::Scope isolate_scope(isolate_); 8. SealHandleScope outer_seal(isolate_); 9. // std::unique_ptr<Environment, FreeEnvironment> env_; 10. DeleteFnPtr<Environment, FreeEnvironment> env_; 11. // \u7ebf\u7a0b\u6267\u884c\u5b8c\u540e\u6267\u884c\u7684\u6e05\u9664\u51fd\u6570 12. auto cleanup_env = OnScopeLeave([&]() { 13. // ... 14. }); 15. 16. { 17. HandleScope handle_scope(isolate_); 18. Local<Context> context; 19. // \u65b0\u5efa\u4e00\u4e2acontext\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb 20. context = NewContext(isolate_); 21. Context::Scope context_scope(context); 22. { 23. // \u65b0\u5efa\u4e00\u4e2aenv\u5e76\u521d\u59cb\u5316\uff0cenv\u4e2d\u4f1a\u548c\u65b0\u7684context\u5173\u8054 24. env_.reset(new Environment(data.isolate_data_.get(), 25. context, 26. std::move(argv_), 27. std::move(exec_argv_), 28. Environment::kNoFlags, 29. thread_id_)); 30. env_->set_env_vars(std::move(env_vars_)); 31. env_->set_abort_on_uncaught_exception(false); 32. env_->set_worker_context(this); 33. 34. env_->InitializeLibuv(start_profiler_idle_notifier_); 35. } 36. { 37. Mutex::ScopedLock lock(mutex_); 38. // \u66f4\u65b0\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env 39. this->env_ = env_.get(); 40. } 41. 42. { 43. if (!env_->RunBootstrapping().IsEmpty()) { 44. CreateEnvMessagePort(env_.get()); 45. USE(StartExecution(env_.get(), \"internal/main/worker_thread\")); 46. } 47. } 48. 49. { 50. SealHandleScope seal(isolate_); 51. bool more; 52. // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af 53. do { 54. if (is_stopped()) break; 55. uv_run(&data.loop_, UV_RUN_DEFAULT); 56. if (is_stopped()) break; 57. 58. platform_->DrainTasks(isolate_); 59. 60. more = uv_loop_alive(&data.loop_); 61. if (more && !is_stopped()) continue; 62. 63. EmitBeforeExit(env_.get()); 64. 65. more = uv_loop_alive(&data.loop_); 66. } while (more == true && !is_stopped()); 67. } 68. } 69. } \u6211\u4eec\u5206\u6b65\u9aa4\u5206\u6790\u4e0a\u9762\u7684\u4ee3\u7801 1 \u65b0\u5efaIsolate\u3001context\u548cEnvironment\uff0c\u5b50\u7ebf\u7a0b\u5728\u72ec\u7acb\u7684\u73af\u5883\u6267\u884c\u3002\u7136\u540e\u521d\u59cb\u5316Environment\u3002\u8fd9\u4e2a\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5206\u6790\u3002 2 \u66f4\u65b0\u5b50\u7ebf\u7a0b\u7684env_\u3002\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cWorker\u7c7b\u4e2d\u5b9a\u4e49\u4e86env_\u5c5e\u6027\uff0c\u6240\u4ee5\u8fd9\u91cc\u901a\u8fc7this.env_\u66f4\u65b0\u65f6\uff0c\u662f\u4e0d\u4f1a\u5f71\u54cd\u57fa\u7c7b\uff08BaseObject\uff09\u4e2d\u7684\u503c\u7684\u3002\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u662f\u5728\u65b0\u7684\u73af\u5883\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5728\u65b0\u73af\u5883\u4e2d\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u9700\u8981\u4f7f\u7528\u65b0\u7684\u73af\u5883\u53d8\u91cf\u3002\u800c\u5728\u4e3b\u7ebf\u7a0b\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u662f\u901a\u8fc7BaseObject\u7684env()\u8bbf\u95ee\u7684\u3002\u4ece\u800c\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u3002\u56e0\u4e3aWorker\u5b9e\u4f8b\u662f\u5728\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u4e4b\u95f4\u5171\u4eab\u7684\uff0cNode.js\u5728Worker\u7c7b\u4e2d\u91cd\u65b0\u5b9a\u4e49\u4e86\u4e00\u4e2aenv_\u5c5e\u6027\u6b63\u662f\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 3 CreateEnvMessagePort 1. void Worker::CreateEnvMessagePort(Environment* env) { 2. child_port_ = MessagePort::New(env, 3. env->context(), 4. std::move(child_port_data_)); 5. if (child_port_ != nullptr) 6. env->set_message_port(child_port_->object(isolate_)); 7. } child_port_data_\u8fd9\u4e2a\u53d8\u91cf\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u770b\u5230\u8fc7\uff0c\u5728\u8fd9\u91cc\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\u7aef\u53e3\u3002\u5e76\u4e14\u548cchild_port_data_\u4e92\u76f8\u5173\u8054\u8d77\u6765\u3002\u7136\u540e\u5728env\u7f13\u5b58\u8d77\u6765\u3002\u540e\u7eed\u4f1a\u4f7f\u7528\u3002\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-4\u6240\u793a\u3002 \u56fe14-4 4 \u6267\u884cinternal/main/worker_thread.js 1. // \u8bbe\u7f6eprocess\u5bf9\u8c61 2. patchProcessObject(); 3. // \u83b7\u53d6\u521a\u624d\u7f13\u5b58\u7684\u7aef\u53e3child_port_ 4. onst port = getEnvMessagePort(); 5. port.on('message', (message) => { 6. // \u52a0\u8f7d\u811a\u672c 7. if (message.type === LOAD_SCRIPT) { 8. const { 9. argv, 10. cwdCounter, 11. filename, 12. doEval, 13. workerData, 14. publicPort, 15. manifestSrc, 16. manifestURL, 17. hasStdin 18. } = message; 19. 20. const CJSLoader = require('internal/modules/cjs/loader'); 21. loadPreloadModules(); 22. /* 23. \u7531\u4e3b\u7ebf\u7a0b\u7533\u8bf7\u7684MessageChannel\u4e2d\u67d0\u4e00\u7aef\u7684\u7aef\u53e3\uff0c 24. \u4e3b\u7ebf\u7a0b\u4f20\u9012\u8fc7\u6765\u7684\uff0c\u4fdd\u5b58\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 25. */ 26. publicWorker.parentPort = publicPort; 27. // \u6267\u884c\u65f6\u4f7f\u7528\u7684\u6570\u636e 28. publicWorker.workerData = workerData; 29. // \u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u6b63\u5728\u6267\u884c\u811a\u672c 30. port.postMessage({ type: UP_AND_RUNNING }); 31. // \u6267\u884cnew Worker(filename)\u65f6\u4f20\u5165\u7684\u6587\u4ef6 32. CJSLoader.Module.runMain(filename); 33. }) 34. // \u5f00\u59cb\u63a5\u6536\u6d88\u606f 35. port.start() \u6211\u4eec\u770b\u5230worker_thread.js\u4e2d\u901a\u8fc7runMain\u5b8c\u6210\u4e86\u5b50\u7ebf\u7a0b\u7684\u4ee3\u7801\u6267\u884c\uff0c\u7136\u540e\u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\u65f6\uff0cNode.js\u7684\u903b\u8f91\u3002 1. // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 2. w->env()->SetImmediateThreadsafe( 3. [w = std::unique_ptr<Worker>(w)](Environment* env) { 4. if (w->has_ref_) 5. env->add_refs(-1); 6. w->JoinThread(); 7. // implicitly delete w 8. }); 9. }, static_cast<void*>(w)), 0); \u901a\u8fc7w->env()\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u73af\u5883\u3002\u6211\u4eec\u770b\u4e00\u4e0bSetImmediateThreadsafe\u3002 1. template <typename Fn> 2. void Environment::SetImmediateThreadsafe(Fn&& cb) { 3. auto callback = std::make_unique<NativeImmediateCallbackImpl<Fn>>( 4. std::move(cb), false); 5. { 6. Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_); 7. native_immediates_threadsafe_.Push(std::move(callback)); 8. } 9. uv_async_send(&task_queues_async_); 10. } SetImmediateThreadsafe\u7528\u4e8e\u901a\u77e5\u6267\u884c\u73af\u5883\u6240\u5728\u7684\u4e8b\u4ef6\u5faa\u73af\u6709\u5f02\u6b65\u4efb\u52a1\u5b8c\u6210\u3002\u5e76\u4e14\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002\u56e0\u4e3a\u53ef\u80fd\u6709\u591a\u4e2a\u7ebf\u7a0b\u4f1a\u64cd\u4f5cnative_immediates_threadsafe_\u3002\u5728\u4e3b\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884ctask_queues_async_\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0btask_queues_async_\u5bf9\u5e94\u7684\u56de\u8c03\u3002 1. uv_async_init( 2. event_loop(), 3. &task_queues_async_, 4. [](uv_async_t* async) { 5. Environment* env = ContainerOf( 6. &Environment::task_queues_async_, async); 7. env->CleanupFinalizationGroups(); 8. env->RunAndClearNativeImmediates(); 9. }); \u6240\u4ee5\u5728Poll IO\u9636\u6bb5\u6267\u884c\u7684\u56de\u8c03\u662fRunAndClearNativeImmediates 1. void Environment::RunAndClearNativeImmediates(bool only_refed) { 2. TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment), 3. \"RunAndClearNativeImmediates\", this); 4. size_t ref_count = 0; 5. 6. if (native_immediates_threadsafe_.size() > 0) { 7. Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_); 8. native_immediates_.ConcatMove(std::move(native_immediates_threadsafe_)); 9. } 10. 11. auto drain_list = [&]() { 12. TryCatchScope try_catch(this); 13. DebugSealHandleScope seal_handle_scope(isolate()); 14. while (std::unique_ptr<NativeImmediateCallback> head = 15. native_immediates_.Shift()) { 16. if (head->is_refed()) 17. ref_count++; 18. 19. if (head->is_refed() || !only_refed) 20. // \u6267\u884c\u56de\u8c03 21. head->Call(this); 22. 23. head.reset(); 24. }; 25. } RunAndClearNativeImmediates\u4f1a\u6267\u884c\u961f\u5217\u91cc\u7684\u56de\u8c03\u3002\u5bf9\u5e94Worker\u7684JoinThread 1. void Worker::JoinThread() { 2. // \u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u7ed3\u675f\uff0c\u6267\u884c\u5230\u8fd9\u5b50\u7ebf\u7a0b\u5df2\u7ecf\u7ed3\u675f\u4e86 3. CHECK_EQ(uv_thread_join(&tid_), 0); 4. thread_joined_ = true; 5. // \u4ece\u4e3b\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784\u4e2d\u5220\u9664\u8be5\u7ebf\u7a0b\u5bf9\u5e94\u7684\u5b9e\u4f8b 6. env()->remove_sub_worker_context(this); 7. 8. { 9. HandleScope handle_scope(env()->isolate()); 10. Context::Scope context_scope(env()->context()); 11. 12. // Reset the parent port as we're closing it now anyway. 13. object()->Set(env()->context(), 14. env()->message_port_string(), 15. Undefined(env()->isolate())).Check(); 16. // \u5b50\u7ebf\u7a0b\u9000\u51fa\u7801 17. Local<Value> args[] = { 18. Integer::New(env()->isolate(), exit_code_), 19. custom_error_ != nullptr ? 20. OneByteString(env()->isolate(), custom_error_).As<Value>() : 21. Null(env()->isolate()).As<Value>(), 22. }; 23. // \u6267\u884cJS\u5c42\u56de\u8c03\uff0c\u89e6\u53d1exit\u4e8b\u4ef6 24. MakeCallback(env()->onexit_string(), arraysize(args), args); 25. } 26. } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u679c\u7ed3\u675f\u6b63\u5728\u6267\u884c\u7684\u5b50\u7ebf\u7a0b\u3002\u5728JS\u4e2d\u6211\u80fd\u53ef\u4ee5\u901a\u8fc7terminate\u51fd\u6570\u7ec8\u6b62\u7ebf\u7a0b\u7684\u6267\u884c\u3002 1. terminate(callback) { 2. this[kHandle].stopThread(); 3. } Terminate\u662f\u5bf9C++\u6a21\u5757stopThread\u7684\u5c01\u88c5\u3002 1. void Worker::StopThread(const FunctionCallbackInfo<Value>& args) { 2. Worker* w; 3. ASSIGN_OR_RETURN_UNWRAP(&w, args.This()); 4. w->Exit(1); 5. } 6. 7. void Worker::Exit(int code) { 8. Mutex::ScopedLock lock(mutex_); 9. // env_\u662f\u5b50\u7ebf\u7a0b\u6267\u884c\u7684env 10. if (env_ != nullptr) { 11. exit_code_ = code; 12. Stop(env_); 13. } else { 14. stopped_ = true; 15. } 16. } 17. 18. 19. int Stop(Environment* env) { 20. env->ExitEnv(); 21. return 0; 22. } 23. 24. void Environment::ExitEnv() { 25. set_can_call_into_js(false); 26. set_stopping(true); 27. isolate_->TerminateExecution(); 28. SetImmediateThreadsafe([](Environment* env) { uv_stop(env->event_loop()); }); 29. } \u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u6700\u7ec8\u901a\u8fc7SetImmediateThreadsafe\u7ed9\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env\u63d0\u4ea4\u4e86\u4e00\u4e2a\u4efb\u52a1\u3002\u5b50\u7ebf\u7a0b\u5728Poll IO\u9636\u6bb5\u4f1a\u8bbe\u7f6e\u505c\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u6807\u8bb0\uff0c\u7b49\u5230\u4e0b\u4e00\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u8df3\u51fa\u4e8b\u4ef6\u5faa\u73af\u4ece\u800c\u7ed3\u675f\u5b50\u7ebf\u7a0b\u7684\u6267\u884c\u3002","title":"14.3 \u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#144","text":"\u672c\u8282\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u8fc7\u7a0b\u3002 1. const { Worker, isMainThread, parentPort } = require('worker_threads'); 2. if (isMainThread) { 3. const worker = new Worker(__filename); 4. worker.once('message', (message) => { 5. ... 6. }); 7. worker.postMessage('Hello, world!'); 8. } else { 9. // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 10. parentPort.once('message', (message) => { 11. parentPort.postMessage(message); 12. }); 13. } \u6211\u4eec\u77e5\u9053isMainThread\u5728\u5b50\u7ebf\u7a0b\u91cc\u662ffalse\uff0cparentPort\u5c31\u662fmessageChannel\u4e2d\u7684\u4e00\u7aef\u3002\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\uff0c\u6240\u4ee5parentPort.postMessage\u7ed9\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u5c31\u662f\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001\u6d88\u606f\uff0c\u6211\u4eec\u518d\u770b\u770bworker.postMessage('Hello, world!')\u3002 1. postMessage(...args) { 2. this[kPublicPort].postMessage(...args); 3. } kPublicPort\u6307\u5411\u7684\u5c31\u662fmessageChannel\u7684\u4e00\u7aef\u3002this[kPublicPort].postMessage(...args)\u5373\u7ed9\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0bpostMessage\u7684\u5b9e\u73b0\u3002 1. void MessagePort::PostMessage(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. Local<Object> obj = args.This(); 4. Local<Context> context = obj->CreationContext(); 5. 6. TransferList transfer_list; 7. if (args[1]->IsObject()) { 8. // \u5904\u7406transfer_list 9. } 10. // \u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u6240\u5173\u8054\u7684MessagePort 11. MessagePort* port = Unwrap<MessagePort>(args.This()); 12. 13. port->PostMessage(env, args[0], transfer_list); 14. } \u6211\u4eec\u63a5\u7740\u770bport->PostMessage 1. Maybe<bool> MessagePort::PostMessage(Environment* env, 2. Local<Value> message_v, 3. const TransferList& transfer_v) { 4. Isolate* isolate = env->isolate(); 5. Local<Object> obj = object(isolate); 6. Local<Context> context = obj->CreationContext(); 7. 8. Message msg; 9. 10. // \u5e8f\u5217\u5316 11. Maybe<bool> serialization_maybe = 12. msg.Serialize(env, context, message_v, transfer_v, obj); 13. // \u62ff\u5230\u64cd\u4f5c\u5bf9\u7aefsibling\u7684\u9501 14. Mutex::ScopedLock lock(*data_->sibling_mutex_); 15. 16. // \u628a\u6d88\u606f\u63d2\u5165\u5230\u5bf9\u7aef\u961f\u5217 17. data_->sibling_->AddToIncomingQueue(std::move(msg)); 18. return Just(true); 19. } PostMessage\u901a\u8fc7AddToIncomingQueue\u628a\u6d88\u606f\u63d2\u5165\u5bf9\u7aef\u7684\u6d88\u606f\u961f\u5217\u6211\u4eec\u770b\u4e00\u4e0bAddToIncomingQueue 1. void MessagePortData::AddToIncomingQueue(Message&& message) { 2. // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 3. Mutex::ScopedLock lock(mutex_); 4. incoming_messages_.emplace_back(std::move(message)); 5. // \u901a\u77e5owner 6. if (owner_ != nullptr) { 7. owner_->TriggerAsync(); 8. } 9. } \u63d2\u5165\u6d88\u606f\u961f\u5217\u540e\uff0c\u5982\u679c\u6709\u5173\u8054\u7684\u7aef\u53e3\uff0c\u5219\u4f1a\u901a\u77e5Libuv\u3002\u6211\u4eec\u7ee7\u7eed\u770bTriggerAsync\u3002 1. void MessagePort::TriggerAsync() { 2. if (IsHandleClosing()) return; 3. CHECK_EQ(uv_async_send(&async_), 0); 4. } Libuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u56de\u8c03\u662f\u5728new MessagePort\u65f6\u8bbe\u7f6e\u7684\u3002 1. auto onmessage = [](uv_async_t* handle) { 2. MessagePort* channel = ContainerOf(&MessagePort::async_, handle); 3. channel->OnMessage(); 4. }; 5. // \u521d\u59cb\u5316async\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1 6. CHECK_EQ(uv_async_init(env->event_loop(), 7. &async_, 8. onmessage), 0); \u6211\u4eec\u7ee7\u7eed\u770bOnMessage\u3002 1. void MessagePort::OnMessage() { 2. HandleScope handle_scope(env()->isolate()); 3. Local<Context> context = object(env()->isolate())->CreationContext(); 4. // \u63a5\u6536\u6d88\u606f\u6761\u6570\u7684\u9608\u503c 5. size_t processing_limit; 6. { 7. // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 8. Mutex::ScopedLock(data_->mutex_); 9. processing_limit = std::max(data_->incoming_messages_.size(), 10. static_cast<size_t>(1000)); 11. } 12. while (data_) { 13. // \u8bfb\u53d6\u7684\u6761\u6570\u8fbe\u5230\u9608\u503c\uff0c\u901a\u77e5Libuv\u4e0b\u4e00\u8f6ePoll IO\u9636\u6bb5\u7ee7\u7eed\u8bfb 14. if (processing_limit-- == 0) { 15. // \u901a\u77e5\u4e8b\u4ef6\u5faa\u73af 16. TriggerAsync(); 17. return; 18. } 19. 20. HandleScope handle_scope(env()->isolate()); 21. Context::Scope context_scope(context); 22. 23. Local<Value> payload; 24. // \u8bfb\u53d6\u6d88\u606f 25. if (!ReceiveMessage(context, true).ToLocal(&payload)) break; 26. // \u6ca1\u6709\u4e86 27. if (payload == env()->no_message_symbol()) break; 28. 29. Local<Object> event; 30. Local<Value> cb_args[1]; 31. // \u65b0\u5efa\u4e00\u4e2aMessageEvent\u5bf9\u8c61\uff0c\u56de\u8c03onmessage\u4e8b\u4ef6 32. if (!env()->message_event_object_template()->NewInstance(context) 33. .ToLocal(&event) || 34. event->Set(context, env()->data_string(), payload).IsNothing() || 35. event->Set(context, env()->target_string(), object()).IsNothing() || 36. (cb_args[0] = event, false) || 37. MakeCallback(env()->onmessage_string(), 38. arraysize(cb_args), 39. cb_args).IsEmpty()) { 40. // \u5982\u679c\u56de\u8c03\u5931\u8d25\uff0c\u901a\u77e5Libuv\u4e0b\u6b21\u7ee7\u7eed\u8bfb 41. if (data_) 42. TriggerAsync(); 43. return; 44. } 45. } 46. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u4e0d\u65ad\u5730\u8c03\u7528ReceiveMessage\u8bfb\u53d6\u6570\u636e\uff0c\u7136\u540e\u56de\u8c03JS\u5c42\u3002\u76f4\u5230\u8fbe\u5230\u9608\u503c\u6216\u8005\u56de\u8c03\u5931\u8d25\u3002\u6211\u4eec\u770b\u4e00\u4e0bReceiveMessage\u7684\u903b\u8f91\u3002 1. MaybeLocal<Value> MessagePort::ReceiveMessage(Local<Context> context, 2. bool only_if_receiving) { 3. Message received; 4. { 5. // Get the head of the message queue. 6. // \u4e92\u65a5\u8bbf\u95ee\u6d88\u606f\u961f\u5217 7. Mutex::ScopedLock lock(data_->mutex_); 8. 9. bool wants_message = receiving_messages_ || !only_if_receiving; 10. // \u6ca1\u6709\u6d88\u606f\u3001\u4e0d\u9700\u8981\u63a5\u6536\u6d88\u606f\u3001\u6d88\u606f\u662f\u5173\u95ed\u6d88\u606f 11. if (data_->incoming_messages_.empty() || 12. (!wants_message && 13. !data_->incoming_messages_.front().IsCloseMessage())) { 14. return env()->no_message_symbol(); 15. } 16. // \u83b7\u53d6\u961f\u5217\u7b2c\u4e00\u4e2a\u6d88\u606f 17. received = std::move(data_->incoming_messages_.front()); 18. data_->incoming_messages_.pop_front(); 19. } 20. // \u662f\u5173\u95ed\u6d88\u606f\u5219\u5173\u95ed\u7aef\u53e3 21. if (received.IsCloseMessage()) { 22. Close(); 23. return env()->no_message_symbol(); 24. } 25. 26. // \u53cd\u5e8f\u5217\u5316\u540e\u8fd4\u56de 27. return received.Deserialize(env(), context); 28. } ReceiveMessage\u4f1a\u6d88\u606f\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u8fd4\u56de\u3002\u4ee5\u4e0a\u5c31\u662f\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u5177\u4f53\u6b65\u9aa4\u5982\u56fe14-5\u6240\u793a\u3002 \u56fe14-5","title":"14.4 \u7ebf\u7a0b\u95f4\u901a\u4fe1"},{"location":"chapter15-Cluster/","text":"Node.js\u662f\u5355\u8fdb\u7a0b\u5355\u7ebf\u7a0b\u7684\u5e94\u7528\uff0c\u8fd9\u79cd\u67b6\u6784\u5e26\u6765\u7684\u7f3a\u70b9\u662f\u4e0d\u80fd\u5f88\u597d\u5730\u5229\u7528\u591a\u6838\u7684\u80fd\u529b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u7ebf\u7a0b\u540c\u65f6\u53ea\u80fd\u5728\u4e00\u4e2a\u6838\u4e0a\u6267\u884c\u3002child_process\u6a21\u5757\u4e00\u5b9a\u7a0b\u5ea6\u5730\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0cchild_process\u6a21\u5757\u4f7f\u5f97Node.js\u5e94\u7528\u53ef\u4ee5\u5728\u591a\u4e2a\u6838\u4e0a\u6267\u884c\uff0c\u800ccluster\u6a21\u5757\u5728child_process\u6a21\u5757\u7684\u57fa\u7840\u4e0a\u4f7f\u5f97\u591a\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u76d1\u542c\u7684\u540c\u4e00\u4e2a\u7aef\u53e3\uff0c\u5b9e\u73b0\u670d\u52a1\u5668\u7684\u591a\u8fdb\u7a0b\u67b6\u6784\u3002\u672c\u7ae0\u5206\u6790cluster\u6a21\u5757\u7684\u4f7f\u7528\u548c\u539f\u7406\u3002 15.1 cluster\u4f7f\u7528\u4f8b\u5b50 \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcluster\u7684\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u3002 1. const cluster = require('cluster'); 2. const http = require('http'); 3. const numCPUs = require('os').cpus().length; 4. 5. if (cluster.isMaster) { 6. for (let i = 0; i < numCPUs; i++) { 7. cluster.fork(); 8. } 9. } else { 10. http.createServer((req, res) => { 11. res.writeHead(200); 12. res.end('hello world\\n'); 13. }).listen(8888); 14. } \u4ee5\u4e0a\u4ee3\u7801\u5728\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0ccluster.isMaster\u4e3atrue\uff0c\u8bf4\u660e\u662f\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u901a\u8fc7fork\u8c03\u7528\u521b\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5728\u5b50\u8fdb\u7a0b\u91cc\u540c\u6837\u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u4f46\u662fcluster.isMaster\u4e3afalse\uff0c\u4ece\u800c\u6267\u884celse\u7684\u903b\u8f91\uff0c\u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u76d1\u542c8888\u8fd9\u4e2a\u7aef\u53e3\u4f46\u662f\u53c8\u4e0d\u4f1a\u5f15\u8d77EADDRINUSE\u9519\u8bef\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 15.2 \u4e3b\u8fdb\u7a0b\u521d\u59cb\u5316 \u00b6 \u6211\u4eec\u5148\u770b\u4e3b\u8fdb\u7a0b\u65f6\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0brequire(\u2018cluster\u2019)\u7684\u65f6\u5019\uff0cNode.js\u662f\u600e\u4e48\u5904\u7406\u7684\u3002 1. const childOrMaster = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'master'; 2. module.exports = require(`internal/cluster/${childOrMaster}`) \u6211\u4eec\u770b\u5230Node.js\u4f1a\u6839\u636e\u5f53\u524d\u73af\u5883\u53d8\u91cf\u7684\u503c\u52a0\u8f7d\u4e0d\u540c\u7684\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230NODE_UNIQUE_ID\u662f\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u8bbe\u7f6e\u7684\uff0c\u5728\u4e3b\u8fdb\u7a0b\u4e2d\uff0cNODE_UNIQUE_ID\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dmaster\u6a21\u5757\u3002 1. cluster.isWorker = false; 2. cluster.isMaster = true; 3. // \u8c03\u5ea6\u7b56\u7565 4. cluster.SCHED_NONE = SCHED_NONE; 5. cluster.SCHED_RR = SCHED_RR; 6. // \u8c03\u5ea6\u7b56\u7565\u7684\u9009\u62e9 7. let schedulingPolicy = { 8. 'none': SCHED_NONE, 9. 'rr': SCHED_RR 10. }[process.env.NODE_CLUSTER_SCHED_POLICY]; 11. 12. if (schedulingPolicy === undefined) { 13. schedulingPolicy = (process.platform === 'win32') ? 14. SCHED_NONE : SCHED_RR; 15. } 16. 17. cluster.schedulingPolicy = schedulingPolicy; 18. // \u521b\u5efa\u5b50\u8fdb\u7a0b 19. cluster.fork = function(env) { 20. // \u53c2\u6570\u5904\u7406 21. cluster.setupMaster(); 22. const id = ++ids; 23. // \u8c03\u7528child_process\u6a21\u5757\u7684fork 24. const workerProcess = createWorkerProcess(id, env); 25. const worker = new Worker({ 26. id: id, 27. process: workerProcess 28. }); 29. // ... 30. worker.process.on('internalMessage', internal(worker, onmessage)); 31. process.nextTick(emitForkNT, worker); 32. cluster.workers[worker.id] = worker; 33. return worker; 34. }; 35. 36. cluster.fork\u662f\u5bf9child_process\u6a21\u5757fork\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21cluster.fork\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u6240\u4ee5cluster\u4e0b\u9762\u4f1a\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\uff0cNode.js\u63d0\u4f9b\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u8f6e\u8be2\u548c\u5171\u4eab\u4e24\u79cd\uff0c\u4e0b\u9762\u4f1a\u5177\u4f53\u4ecb\u7ecd\u3002Worker\u662f\u5bf9\u5b50\u8fdb\u7a0b\u7684\u5c01\u88c5\uff0c\u901a\u8fc7process\u6301\u6709\u5b50\u8fdb\u7a0b\u7684\u5b9e\u4f8b\uff0c\u5e76\u901a\u8fc7\u76d1\u542cinternalMessage\u548cmessage\u4e8b\u4ef6\u5b8c\u6210\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u7684\u901a\u4fe1\uff0cinternalMessage\u8fd9\u662fNode.js\u5b9a\u4e49\u7684\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6\uff0c\u5904\u7406\u51fd\u6570\u662finternal(worker, onmessage)\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0binternal\u3002 1. const callbacks = new Map(); 2. let seq = 0; 3. 4. function internal(worker, cb) { 5. return function onInternalMessage(message, handle) { 6. if (message.cmd !== 'NODE_CLUSTER') 7. return; 8. 9. let fn = cb; 10. 11. if (message.ack !== undefined) { 12. const callback = callbacks.get(message.ack); 13. 14. if (callback !== undefined) { 15. fn = callback; 16. callbacks.delete(message.ack); 17. } 18. } 19. 20. fn.apply(worker, arguments); 21. }; 22. } internal\u51fd\u6570\u5bf9\u5f02\u6b65\u6d88\u606f\u901a\u4fe1\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\uff0c\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u5f02\u6b65\u7684\uff0c\u5f53\u6211\u4eec\u53d1\u9001\u591a\u4e2a\u6d88\u606f\u540e\uff0c\u5982\u679c\u6536\u5230\u4e00\u4e2a\u56de\u590d\uff0c\u6211\u4eec\u65e0\u6cd5\u8fa8\u522b\u51fa\u8be5\u56de\u590d\u662f\u9488\u5bf9\u54ea\u4e00\u4e2a\u8bf7\u6c42\u7684\uff0cNode.js\u901a\u8fc7seq\u7684\u65b9\u5f0f\u5bf9\u6bcf\u4e00\u4e2a\u8bf7\u6c42\u548c\u54cd\u5e94\u505a\u4e86\u4e00\u4e2a\u7f16\u53f7\uff0c\u4ece\u800c\u533a\u5206\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bmessage\u7684\u5b9e\u73b0\u3002 1. function onmessage(message, handle) { 2. const worker = this; 3. 4. if (message.act === 'online') 5. online(worker); 6. else if (message.act === 'queryServer') 7. queryServer(worker, message); 8. else if (message.act === 'listening') 9. listening(worker, message); 10. else if (message.act === 'exitedAfterDisconnect') 11. exitedAfterDisconnect(worker, message); 12. else if (message.act === 'close') 13. close(worker, message); 14. } onmessage\u6839\u636e\u6536\u5230\u6d88\u606f\u7684\u4e0d\u540c\u7c7b\u578b\u8fdb\u884c\u76f8\u5e94\u7684\u5904\u7406\u3002\u540e\u9762\u6211\u4eec\u518d\u5177\u4f53\u5206\u6790\u3002\u81f3\u6b64\uff0c\u4e3b\u8fdb\u7a0b\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\u3002 15.3 \u5b50\u8fdb\u7a0b\u521d\u59cb\u5316 \u00b6 \u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002\u5f53\u6267\u884c\u5b50\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dchild\u6a21\u5757\u3002 1. const cluster = new EventEmitter(); 2. const handles = new Map(); 3. const indexes = new Map(); 4. const noop = () => {}; 5. 6. module.exports = cluster; 7. 8. cluster.isWorker = true; 9. cluster.isMaster = false; 10. cluster.worker = null; 11. cluster.Worker = Worker; 12. 13. cluster._setupWorker = function() { 14. const worker = new Worker({ 15. id: +process.env.NODE_UNIQUE_ID | 0, 16. process: process, 17. state: 'online' 18. }); 19. 20. cluster.worker = worker; 21. 22. process.on('internalMessage', internal(worker, onmessage)); 23. // \u901a\u77e5\u4e3b\u8fdb\u7a0b\u5b50\u8fdb\u7a0b\u542f\u52a8\u6210\u529f 24. send({ act: 'online' }); 25. 26. function onmessage(message, handle) { 27. if (message.act === 'newconn') 28. onconnection(message, handle); 29. else if (message.act === 'disconnect') 30. _disconnect.call(worker, true); 31. } 32. }; _setupWorker\u51fd\u6570\u5728\u5b50\u8fdb\u7a0b\u521d\u59cb\u5316\u65f6\u88ab\u6267\u884c\uff0c\u548c\u4e3b\u8fdb\u7a0b\u7c7b\u4f3c\uff0c\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e5f\u4e0d\u591a\uff0c\u76d1\u542cinternalMessage\u4e8b\u4ef6\uff0c\u5e76\u4e14\u901a\u77e5\u4e3b\u7ebf\u7a0b\u81ea\u5df1\u542f\u52a8\u6210\u529f\u3002 15.4 http.createServer\u7684\u5904\u7406 \u00b6 \u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u6267\u884c\u5b8c\u521d\u59cb\u5316\u4ee3\u7801\u540e\uff0c\u5b50\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\u4e1a\u52a1\u4ee3\u7801http.createServer\uff0c\u5728HTTP\u6a21\u5757\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7http.createServer\u7684\u8fc7\u7a0b\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053http.createServer\u6700\u540e\u4f1a\u8c03\u7528net\u6a21\u5757\u7684listen\uff0c\u7136\u540e\u8c03\u7528listenIncluster\u3002\u6211\u4eec\u4ece\u8be5\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002 1. function listenIncluster(server, address, port, addressType, 2. backlog, fd, exclusive, flags) { 3. 4. const serverQuery = { 5. address: address, 6. port: port, 7. addressType: addressType, 8. fd: fd, 9. flags, 10. }; 11. 12. cluster._getServer(server, serverQuery, listenOnMasterHandle); 13. function listenOnMasterHandle(err, handle) { 14. err = checkBindError(err, port, handle); 15. 16. if (err) { 17. const ex = exceptionWithHostPort(err, 18. 'bind', 19. address, 20. port); 21. return server.emit('error', ex); 22. } 23. 24. server._handle = handle; 25. server._listen2(address, 26. port, 27. addressType, 28. backlog, 29. fd, 30. flags); 31. } 32. } listenIncluster\u51fd\u6570\u4f1a\u8c03\u7528\u5b50\u8fdb\u7a0bcluster\u6a21\u5757\u7684_getServer\u3002 1. cluster._getServer = function(obj, options, cb) { 2. let address = options.address; 3. 4. // \u5ffd\u7565index\u7684\u5904\u7406\u903b\u8f91 5. 6. const message = { 7. act: 'queryServer', 8. index, 9. data: null, 10. ...options 11. }; 12. 13. message.address = address; 14. // \u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u6d88\u606f 15. send(message, (reply, handle) => { 16. // \u6839\u636e\u4e0d\u540c\u6a21\u5f0f\u505a\u5904\u7406 17. if (handle) 18. shared(reply, handle, indexesKey, cb); 19. else 20. rr(reply, indexesKey, cb); 21. }); 22. }; _getServer\u4f1a\u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aqueryServer\u7684\u8bf7\u6c42\u3002\u6211\u4eec\u770b\u4e00\u4e0bsend\u51fd\u6570\u3002 1. function send(message, cb) { 2. return sendHelper(process, message, null, cb); 3. } 4. 5. function sendHelper(proc, message, handle, cb) { 6. if (!proc.connected) 7. return false; 8. 9. message = { cmd: 'NODE_CLUSTER', ...message, seq }; 10. 11. if (typeof cb === 'function') 12. callbacks.set(seq, cb); 13. 14. seq += 1; 15. return proc.send(message, handle); 16. } send\u8c03\u7528\u4e86sendHelper\uff0csendHelper\u662f\u5bf9\u5f02\u6b65\u8bf7\u6c42\u505a\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406queryServer\u8bf7\u6c42\u7684\u3002 1. function queryServer(worker, message) { 2. const key = `${message.address}:${message.port}:${message.addressType}:` + `${message.fd}:${message.index}`; 3. let handle = handles.get(key); 4. 5. if (handle === undefined) { 6. let address = message.address; 7. let constructor = RoundRobinHandle; 8. // \u6839\u636e\u7b56\u7565\u9009\u53d6\u4e0d\u540c\u7684\u6784\u9020\u51fd\u6570 9. if (schedulingPolicy !== SCHED_RR || 10. message.addressType === 'udp4' || 11. message.addressType === 'udp6') { 12. constructor = SharedHandle; 13. } 14. 15. handle = new constructor(key, 16. address, 17. message.port, 18. message.addressType, 19. message.fd, 20. message.flags); 21. handles.set(key, handle); 22. } 23. handle.add(worker, (errno, reply, handle) => { 24. const { data } = handles.get(key); 25. 26. send(worker, { 27. errno, 28. key, 29. ack: message.seq, 30. data, 31. ...reply 32. }, handle); 33. }); 34. } queryServer\u9996\u5148\u6839\u636e\u8c03\u5ea6\u7b56\u7565\u9009\u62e9\u6784\u9020\u51fd\u6570\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684add\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770b\u4e0d\u540c\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002 15.5 \u5171\u4eab\u6a21\u5f0f \u00b6 \u4e0b\u9762\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-1\u6240\u793a\u3002 \u56fe19-1 1. function SharedHandle(key, address, port, addressType, fd, flags) { 2. this.key = key; 3. this.workers = []; 4. this.handle = null; 5. this.errno = 0; 6. 7. let rval; 8. if (addressType === 'udp4' || addressType === 'udp6') 9. rval = dgram._createSocketHandle(address, 10. port, 11. addressType, 12. fd, 13. flags); 14. else 15. rval = net._createServerHandle(address, 16. port, 17. addressType, 18. fd, 19. flags); 20. 21. if (typeof rval === 'number') 22. this.errno = rval; 23. else 24. this.handle = rval; 25. } SharedHandle\u662f\u5171\u4eab\u6a21\u5f0f\uff0c\u5373\u4e3b\u8fdb\u7a0b\u521b\u5efa\u597dhandle\uff0c\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\u3002 1. SharedHandle.prototype.add = function(worker, send) { 2. this.workers.push(worker); 3. send(this.errno, null, this.handle); 4. }; SharedHandle\u7684add\u628aSharedHandle\u4e2d\u521b\u5efa\u7684handle\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u62ff\u5230handle\u540e\u7684\u5904\u7406 1. function shared(message, handle, indexesKey, cb) { 2. const key = message.key; 3. 4. const close = handle.close; 5. 6. handle.close = function() { 7. send({ act: 'close', key }); 8. handles.delete(key); 9. indexes.delete(indexesKey); 10. return close.apply(handle, arguments); 11. }; 12. handles.set(key, handle); 13. // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 14. cb(message.errno, handle); 15. } Shared\u51fd\u6570\u628a\u63a5\u6536\u5230\u7684handle\u518d\u56de\u4f20\u5230\u8c03\u7528\u65b9\u3002\u5373net\u6a21\u5757\u3002net\u6a21\u5757\u4f1a\u6267\u884clisten\u5f00\u59cb\u76d1\u542c\u5730\u5740\uff0c\u4f46\u662f\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u7cfb\u7edf\u53ea\u4f1a\u6709\u4e00\u4e2a\u8fdb\u7a0b\u62ff\u5230\u8be5\u8fde\u63a5\u3002\u6240\u4ee5\u6240\u6709\u5b50\u8fdb\u7a0b\u5b58\u5728\u7ade\u4e89\u5173\u7cfb\u5bfc\u81f4\u8d1f\u8f7d\u4e0d\u5747\u8861\uff0c\u8fd9\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 \u5171\u4eab\u6a21\u5f0f\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\u4e3b\u8fdb\u7a0b\u5728_createServerHandle\u521b\u5efahandle\u65f6\u6267\u884cbind\u7ed1\u5b9a\u4e86\u5730\u5740\uff08\u4f46\u6ca1\u6709listen\uff09\uff0c\u7136\u540e\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u6267\u884clisten\u7684\u65f6\u5019\u5c31\u4e0d\u4f1a\u62a5\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u7684\u9519\u8bef\u4e86\u3002\u56e0\u4e3a\u7aef\u53e3\u88ab\u76d1\u542c\u7684\u9519\u8bef\u662f\u6267\u884cbind\u7684\u65f6\u5019\u8fd4\u56de\u7684\u3002 15.6 \u8f6e\u8be2\u6a21\u5f0f \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-2\u6240\u793a\u3002 \u56fe19-2 1. function RoundRobinHandle(key, address, port, addressType, fd, flags) { 2. this.key = key; 3. this.all = new Map(); 4. this.free = []; 5. this.handles = []; 6. this.handle = null; 7. this.server = net.createServer(assert.fail); 8. 9. if (fd >= 0) 10. this.server.listen({ fd }); 11. else if (port >= 0) { 12. this.server.listen({ 13. port, 14. host: address, 15. ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY), 16. }); 17. } else 18. this.server.listen(address); // UNIX socket path. 19. // \u76d1\u542c\u6210\u529f\u540e\uff0c\u6ce8\u518conconnection\u56de\u8c03\uff0c\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c 20. this.server.once('listening', () => { 21. this.handle = this.server._handle; 22. this.handle.onconnection = (err, handle) => this.distribute(err, handle); 23. this.server._handle = null; 24. this.server = null; 25. }); 26. } RoundRobinHandle\u7684\u5de5\u4f5c\u6a21\u5f0f\u662f\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\uff0c\u6536\u5230\u8fde\u63a5\u540e\u5206\u53d1\u7ed9\u5b50\u8fdb\u7a0b\u3002\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684add 1. RoundRobinHandle.prototype.add = function(worker, send) { 2. this.all.set(worker.id, worker); 3. 4. const done = () => { 5. if (this.handle.getsockname) { 6. const out = {}; 7. this.handle.getsockname(out); 8. send(null, { sockname: out }, null); 9. } else { 10. send(null, null, null); // UNIX socket. 11. } 12. 13. // In case there are connections pending. 14. this.handoff(worker); 15. }; 16. // \u8bf4\u660elisten\u6210\u529f\u4e86 17. if (this.server === null) 18. return done(); 19. // \u5426\u5219\u7b49\u5f85listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 20. this.server.once('listening', done); 21. this.server.once('error', (err) => { 22. send(err.errno, null); 23. }); 24. }; RoundRobinHandle\u4f1a\u5728listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u56de\u987e\u4e00\u4e0b\u6267\u884cadd\u51fd\u6570\u65f6\u7684\u56de\u8c03\u3002 1. handle.add(worker, (errno, reply, handle) => { 2. const { data } = handles.get(key); 3. 4. send(worker, { 5. errno, 6. key, 7. ack: message.seq, 8. data, 9. ...reply 10. }, handle); 11. }); \u56de\u8c03\u51fd\u6570\u4f1a\u628ahandle\u7b49\u4fe1\u606f\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4f46\u662f\u5728RoundRobinHandle\u548cSharedHandle\u4e2d\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\u3002\u5206\u522b\u662fnull\u548cnet.createServer\u5b9e\u4f8b\u3002\u63a5\u7740\u6211\u4eec\u56de\u5230\u5b50\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\u3002\u770b\u5b50\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406\u54cd\u5e94\u7684\u3002\u521a\u624d\u6211\u4eec\u8bb2\u8fc7\uff0c\u4e0d\u540c\u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u770b\u8f6e\u8be2\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002 1. function rr(message, indexesKey, cb) { 2. let key = message.key; 3. function listen(backlog) { 4. return 0; 5. } 6. 7. function close() { 8. // ... 9. } 10. 11. const handle = { close, listen, ref: noop, unref: noop }; 12. 13. if (message.sockname) { 14. handle.getsockname = getsockname; // TCP handles only. 15. } 16. 17. handles.set(key, handle); 18. // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 19. cb(0, handle); 20. } round-robin\u6a21\u5f0f\u4e0b\uff0c\u6784\u9020\u4e00\u4e2a\u5047\u7684handle\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\uff0c\u56e0\u4e3a\u8c03\u7528\u65b9\u4f1a\u8c03\u7528\u8fd9\u4e9b\u51fd\u6570\u3002\u6700\u540e\u56de\u5230net\u6a21\u5757\u3002net\u6a21\u5757\u9996\u5148\u4fdd\u5b58handle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0cround-bobin\u6a21\u5757\u4f1a\u6267\u884cdistribute\u5206\u53d1\u8bf7\u6c42\u7ed9\u5b50\u8fdb\u7a0b\u3002 1. RoundRobinHandle.prototype.distribute = function(err, handle) { 2. // \u9996\u5148\u4fdd\u5b58handle\u5230\u961f\u5217 3. this.handles.push(handle); 4. // \u4ece\u7a7a\u95f2\u961f\u5217\u83b7\u53d6\u4e00\u4e2a\u5b50\u8fdb\u7a0b 5. const worker = this.free.shift(); 6. // \u5206\u53d1 7. if (worker) 8. this.handoff(worker); 9. }; 10. 11. RoundRobinHandle.prototype.handoff = function(worker) { 12. // \u62ff\u5230\u4e00\u4e2ahandle 13. const handle = this.handles.shift(); 14. // \u6ca1\u6709handle\uff0c\u5219\u5b50\u8fdb\u7a0b\u91cd\u65b0\u5165\u961f 15. if (handle === undefined) { 16. this.free.push(worker); // Add to ready queue again. 17. return; 18. } 19. // \u901a\u77e5\u5b50\u8fdb\u7a0b\u6709\u65b0\u8fde\u63a5 20. const message = { act: 'newconn', key: this.key }; 21. 22. sendHelper(worker.process, message, handle, (reply) => { 23. // \u63a5\u6536\u6210\u529f 24. if (reply.accepted) 25. handle.close(); 26. else 27. // \u7ed3\u675f\u5931\u8d25\uff0c\u5219\u91cd\u65b0\u5206\u53d1 28. this.distribute(0, handle); // Worker is shutting down. Send to another. 29. 30. this.handoff(worker); 31. }); 32. }; \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u662f\u600e\u4e48\u5904\u7406\u8be5\u8bf7\u6c42\u7684\u3002 1. function onmessage(message, handle) { 2. if (message.act === 'newconn') 3. onconnection(message, handle); 4. } 5. 6. function onconnection(message, handle) { 7. const key = message.key; 8. const server = handles.get(key); 9. const accepted = server !== undefined; 10. // \u56de\u590d\u63a5\u6536\u6210\u529f 11. send({ ack: message.seq, accepted }); 12. 13. if (accepted) 14. // \u5728net\u6a21\u5757\u8bbe\u7f6e 15. server.onconnection(0, handle); 16. } \u6211\u4eec\u770b\u5230\u5b50\u8fdb\u7a0b\u4f1a\u6267\u884cserver.onconnection\uff0c\u8fd9\u4e2a\u548c\u6211\u4eec\u5206\u6790net\u6a21\u5757\u65f6\u89e6\u53d1onconnection\u4e8b\u4ef6\u662f\u4e00\u6837\u7684\u3002 15.7\u5b9e\u73b0\u81ea\u5df1\u7684cluster\u6a21\u5757 \u00b6 Node.js\u7684cluster\u5728\u8bf7\u6c42\u5206\u53d1\u65f6\u662f\u6309\u7167\u8f6e\u8be2\u7684\uff0c\u65e0\u6cd5\u6839\u636e\u8fdb\u7a0b\u5f53\u524d\u60c5\u51b5\u505a\u76f8\u5e94\u7684\u5904\u7406\u3002\u4e86\u89e3\u4e86cluster\u6a21\u5757\u7684\u539f\u7406\u540e\uff0c\u6211\u4eec\u81ea\u5df1\u6765\u5b9e\u73b0\u4e00\u4e2acluster\u6a21\u5757\u3002 15.7.1 \u8f6e\u8be2\u6a21\u5f0f \u00b6 \u6574\u4f53\u67b6\u6784\u5982\u56fe15-3\u6240\u793a\u3002 \u56fe15-3 Parent.js 1. const childProcess = require('child_process'); 2. const net = require('net'); 3. const workers = []; 4. const workerNum = 10; 5. let index = 0; 6. for (let i = 0; i < workerNum; i++) { 7. workers.push(childProcess.fork('child.js', {env: {index: i}})); 8. } 9. 10. const server = net.createServer((client) => { 11. workers[index].send(null, client); 12. console.log('dispatch to', index); 13. index = (index + 1) % workerNum; 14. }); 15. server.listen(11111); child.js 1. process.on('message', (message, client) => { 2. console.log('receive connection from master'); 3. }); \u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\u8bf7\u6c42\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u8bf7\u6c42\u540e\uff0c\u6309\u7167\u4e00\u5b9a\u7684\u7b97\u6cd5\u628a\u8bf7\u6c42\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65b9\u5f0f\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u4e86\u3002\u5728\u5206\u53d1\u7b97\u6cd5\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u81ea\u5b9a\u4e49\uff0c\u6bd4\u5982\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u7684\u8d1f\u8f7d\uff0c\u6b63\u5728\u5904\u7406\u7684\u8fde\u63a5\u6570\u3002 15.7.2 \u5171\u4eab\u6a21\u5f0f \u00b6 \u6574\u4f53\u67b6\u6784\u5982\u56fe15-4\u6240\u793a\u3002 \u56fe15-4 Parent.js 1. const childProcess = require('child_process'); 2. const net = require('net'); 3. const workers = []; 4. const workerNum = 10 ; 5. const handle = net._createServerHandle('127.0.0.1', 11111, 4); 6. 7. for (let i = 0; i < workerNum; i++) { 8. const worker = childProcess.fork('child.js', {env: {index: i}}); 9. workers.push(worker); 10. worker.send(null ,handle); 11. /* 12. \u9632\u6b62\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u4f46\u662f\u91cd\u65b0fork\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u5c31\u65e0\u6cd5 13. \u518d\u4f20\u9012\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e86 14. */ 15. handle.close(); 16. } Child.js 1. const net = require('net'); 2. process.on('message', (message, handle) => { 3. net.createServer(() => { 4. console.log(process.env.index, 'receive connection'); 5. }).listen({handle}); 6. }); \u6211\u4eec\u770b\u5230\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u7ed1\u5b9a\u7aef\u53e3\uff0c\u7136\u540e\u628ahandle\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u76d1\u542csocket\u3002\u5f53\u6709\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u9009\u62e9\u67d0\u4e00\u4e2aworker\u8fdb\u7a0b\u5904\u7406\u8be5\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u67b6\u6784\uff0c\u5982\u56fe15-5\u6240\u793a\u3002 \u56fe15-5 \u5b9e\u73b0\u5171\u4eab\u6a21\u5f0f\u7684\u91cd\u70b9\u5728\u4e8e\u7406\u89e3EADDRINUSE\u9519\u8bef\u662f\u600e\u4e48\u6765\u7684\u3002\u5f53\u4e3b\u8fdb\u7a0b\u6267\u884cbind\u7684\u65f6\u5019\uff0c\u7ed3\u6784\u5982\u56fe15-6\u6240\u793a\u3002 \u56fe15-6 \u5982\u679c\u5176\u5b83\u8fdb\u7a0b\u4e5f\u6267\u884cbind\u5e76\u4e14\u7aef\u53e3\u4e5f\u4e00\u6837\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u544a\u8bc9\u6211\u4eec\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u4e86\uff08EADDRINUSE\uff09\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u91cc\u4e0d\u6267\u884cbind\u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002\u90a3\u4e48\u91cd\u70b9\u5728\u4e8e\uff0c\u5982\u4f55\u5728\u5b50\u8fdb\u7a0b\u4e2d\u4e0d\u6267\u884cbind\uff0c\u4f46\u662f\u53c8\u53ef\u4ee5\u7ed1\u5b9a\u5230\u540c\u6837\u7684\u7aef\u53e3\u5462\uff1f\u6709\u4e24\u79cd\u65b9\u5f0f\u3002 1 fork \u6211\u4eec\u77e5\u9053fork\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe15-7\u6240\u793a\u3002 \u56fe15-7 \u8fd9\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u53ef\u4ee5\u6267\u884cbind\u548clisten\uff0c\u7136\u540efork\u5b50\u8fdb\u7a0b\uff0c\u6700\u540eclose\u6389\u81ea\u5df1\u7684fd\uff0c\u8ba9\u6240\u6709\u7684\u8fde\u63a5\u90fd\u7531\u5b50\u8fdb\u7a0b\u5904\u7406\u5c31\u884c\u3002\u4f46\u662f\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u65e0\u6cd5\u5b9e\u73b0\uff0c\u6240\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u4e0d\u80fd\u6ee1\u8db3\u9700\u6c42\u3002 2 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 Node.js\u7684\u5b50\u8fdb\u7a0b\u662f\u901a\u8fc7fork+exec\u6a21\u5f0f\u521b\u5efa\u7684\uff0c\u5e76\u4e14Node.js\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86close_on_exec\u6807\u8bb0\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728Node.js\u4e2d\uff0c\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u7ed3\u6784\u4f53\u5982\u56fe15-8\u6240\u793a\uff08\u6709\u6807\u51c6\u8f93\u5165\u3001\u6807\u51c6\u8f93\u51fa\u3001\u6807\u51c6\u9519\u8bef\u4e09\u4e2afd\uff09\u3002 \u56fe15-8 \u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u3002\u628a\u65b9\u5f0f1\u4e2d\u62ff\u4e0d\u5230\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u56e0\u4e3a\u5728Node.js\u4e2d\uff0c\u867d\u7136\u6211\u4eec\u62ff\u4e0d\u5230fd\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u62ff\u5f97\u5230fd\u5bf9\u5e94\u7684handle\uff0c\u6211\u4eec\u901a\u8fc7IPC\u4f20\u8f93handle\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406fd\u7684\u95ee\u9898\u3002\u6700\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5904\u7406\u3002\u7ed3\u6784\u5982\u56fe15-9\u6240\u793a\u3002 \u56fe15-9 \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\uff0c\u6211\u4eec\u5c31\u7ed5\u8fc7\u4e86bind\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\u3002\u901a\u8fc7\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u77e5\u9053\u7ed5\u8fc7bind\u7684\u95ee\u9898\u91cd\u70b9\u5728\u4e8e\u8ba9\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u5171\u4eabsocket\u800c\u4e0d\u662f\u5355\u72ec\u6267\u884cbind\u3002\u5bf9\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cNode.js\u4e2d\u652f\u6301\u5f88\u591a\u79cd\u65b9\u5f0f\u3002\u4e0a\u9762\u7684\u65b9\u5f0f\u662f\u5b50\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u3002\u8fd8\u6709\u53e6\u4e00\u79cd\u6a21\u5f0f\u5982\u4e0b parent.js 1. const childProcess = require('child_process'); 2. const net = require('net'); 3. const workers = []; 4. const workerNum = 10; 5. const server = net.createServer(() => { 6. console.log('master receive connection'); 7. }) 8. server.listen(11111); 9. for (let i = 0; i < workerNum; i++) { 10. const worker = childProcess.fork('child.js', {env: {index: i}}); 11. workers.push(worker); 12. worker.send(null, server); 13. } 14. child.js 1. const net = require('net'); 2. process.on('message', (message, server) => { 3. server.on('connection', () => { 4. console.log(process.env.index, 'receive connection'); 5. }) 6. }); \u4e0a\u9762\u7684\u65b9\u5f0f\u4e2d\uff0c\u4e3b\u8fdb\u7a0b\u5b8c\u6210\u4e86bind\u548clisten\u3002\u7136\u540e\u628aserver\u5b9e\u4f8b\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u76d1\u542c\u8fde\u63a5\u7684\u5230\u6765\u4e86\u3002\u8fd9\u65f6\u5019\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u3002 \u6700\u540e\u5199\u4e00\u4e2a\u5ba2\u6237\u7aef\u6d4b\u8bd5\u3002 \u5ba2\u6237\u7aef 1. const net = require('net'); 2. for (let i = 0; i < 50; i++) { 3. net.connect({port: 11111}); 4. } \u6267\u884cclient\u6211\u4eec\u5c31\u53ef\u4ee5\u770b\u5230\u591a\u8fdb\u7a0b\u5904\u7406\u8fde\u63a5\u7684\u60c5\u51b5\u3002","title":"15-Cluster"},{"location":"chapter15-Cluster/#151-cluster","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcluster\u7684\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u3002 1. const cluster = require('cluster'); 2. const http = require('http'); 3. const numCPUs = require('os').cpus().length; 4. 5. if (cluster.isMaster) { 6. for (let i = 0; i < numCPUs; i++) { 7. cluster.fork(); 8. } 9. } else { 10. http.createServer((req, res) => { 11. res.writeHead(200); 12. res.end('hello world\\n'); 13. }).listen(8888); 14. } \u4ee5\u4e0a\u4ee3\u7801\u5728\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0ccluster.isMaster\u4e3atrue\uff0c\u8bf4\u660e\u662f\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u901a\u8fc7fork\u8c03\u7528\u521b\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5728\u5b50\u8fdb\u7a0b\u91cc\u540c\u6837\u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u4f46\u662fcluster.isMaster\u4e3afalse\uff0c\u4ece\u800c\u6267\u884celse\u7684\u903b\u8f91\uff0c\u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u76d1\u542c8888\u8fd9\u4e2a\u7aef\u53e3\u4f46\u662f\u53c8\u4e0d\u4f1a\u5f15\u8d77EADDRINUSE\u9519\u8bef\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002","title":"15.1 cluster\u4f7f\u7528\u4f8b\u5b50"},{"location":"chapter15-Cluster/#152","text":"\u6211\u4eec\u5148\u770b\u4e3b\u8fdb\u7a0b\u65f6\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0brequire(\u2018cluster\u2019)\u7684\u65f6\u5019\uff0cNode.js\u662f\u600e\u4e48\u5904\u7406\u7684\u3002 1. const childOrMaster = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'master'; 2. module.exports = require(`internal/cluster/${childOrMaster}`) \u6211\u4eec\u770b\u5230Node.js\u4f1a\u6839\u636e\u5f53\u524d\u73af\u5883\u53d8\u91cf\u7684\u503c\u52a0\u8f7d\u4e0d\u540c\u7684\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230NODE_UNIQUE_ID\u662f\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u8bbe\u7f6e\u7684\uff0c\u5728\u4e3b\u8fdb\u7a0b\u4e2d\uff0cNODE_UNIQUE_ID\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dmaster\u6a21\u5757\u3002 1. cluster.isWorker = false; 2. cluster.isMaster = true; 3. // \u8c03\u5ea6\u7b56\u7565 4. cluster.SCHED_NONE = SCHED_NONE; 5. cluster.SCHED_RR = SCHED_RR; 6. // \u8c03\u5ea6\u7b56\u7565\u7684\u9009\u62e9 7. let schedulingPolicy = { 8. 'none': SCHED_NONE, 9. 'rr': SCHED_RR 10. }[process.env.NODE_CLUSTER_SCHED_POLICY]; 11. 12. if (schedulingPolicy === undefined) { 13. schedulingPolicy = (process.platform === 'win32') ? 14. SCHED_NONE : SCHED_RR; 15. } 16. 17. cluster.schedulingPolicy = schedulingPolicy; 18. // \u521b\u5efa\u5b50\u8fdb\u7a0b 19. cluster.fork = function(env) { 20. // \u53c2\u6570\u5904\u7406 21. cluster.setupMaster(); 22. const id = ++ids; 23. // \u8c03\u7528child_process\u6a21\u5757\u7684fork 24. const workerProcess = createWorkerProcess(id, env); 25. const worker = new Worker({ 26. id: id, 27. process: workerProcess 28. }); 29. // ... 30. worker.process.on('internalMessage', internal(worker, onmessage)); 31. process.nextTick(emitForkNT, worker); 32. cluster.workers[worker.id] = worker; 33. return worker; 34. }; 35. 36. cluster.fork\u662f\u5bf9child_process\u6a21\u5757fork\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21cluster.fork\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u6240\u4ee5cluster\u4e0b\u9762\u4f1a\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\uff0cNode.js\u63d0\u4f9b\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u8f6e\u8be2\u548c\u5171\u4eab\u4e24\u79cd\uff0c\u4e0b\u9762\u4f1a\u5177\u4f53\u4ecb\u7ecd\u3002Worker\u662f\u5bf9\u5b50\u8fdb\u7a0b\u7684\u5c01\u88c5\uff0c\u901a\u8fc7process\u6301\u6709\u5b50\u8fdb\u7a0b\u7684\u5b9e\u4f8b\uff0c\u5e76\u901a\u8fc7\u76d1\u542cinternalMessage\u548cmessage\u4e8b\u4ef6\u5b8c\u6210\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u7684\u901a\u4fe1\uff0cinternalMessage\u8fd9\u662fNode.js\u5b9a\u4e49\u7684\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6\uff0c\u5904\u7406\u51fd\u6570\u662finternal(worker, onmessage)\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0binternal\u3002 1. const callbacks = new Map(); 2. let seq = 0; 3. 4. function internal(worker, cb) { 5. return function onInternalMessage(message, handle) { 6. if (message.cmd !== 'NODE_CLUSTER') 7. return; 8. 9. let fn = cb; 10. 11. if (message.ack !== undefined) { 12. const callback = callbacks.get(message.ack); 13. 14. if (callback !== undefined) { 15. fn = callback; 16. callbacks.delete(message.ack); 17. } 18. } 19. 20. fn.apply(worker, arguments); 21. }; 22. } internal\u51fd\u6570\u5bf9\u5f02\u6b65\u6d88\u606f\u901a\u4fe1\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\uff0c\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u5f02\u6b65\u7684\uff0c\u5f53\u6211\u4eec\u53d1\u9001\u591a\u4e2a\u6d88\u606f\u540e\uff0c\u5982\u679c\u6536\u5230\u4e00\u4e2a\u56de\u590d\uff0c\u6211\u4eec\u65e0\u6cd5\u8fa8\u522b\u51fa\u8be5\u56de\u590d\u662f\u9488\u5bf9\u54ea\u4e00\u4e2a\u8bf7\u6c42\u7684\uff0cNode.js\u901a\u8fc7seq\u7684\u65b9\u5f0f\u5bf9\u6bcf\u4e00\u4e2a\u8bf7\u6c42\u548c\u54cd\u5e94\u505a\u4e86\u4e00\u4e2a\u7f16\u53f7\uff0c\u4ece\u800c\u533a\u5206\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bmessage\u7684\u5b9e\u73b0\u3002 1. function onmessage(message, handle) { 2. const worker = this; 3. 4. if (message.act === 'online') 5. online(worker); 6. else if (message.act === 'queryServer') 7. queryServer(worker, message); 8. else if (message.act === 'listening') 9. listening(worker, message); 10. else if (message.act === 'exitedAfterDisconnect') 11. exitedAfterDisconnect(worker, message); 12. else if (message.act === 'close') 13. close(worker, message); 14. } onmessage\u6839\u636e\u6536\u5230\u6d88\u606f\u7684\u4e0d\u540c\u7c7b\u578b\u8fdb\u884c\u76f8\u5e94\u7684\u5904\u7406\u3002\u540e\u9762\u6211\u4eec\u518d\u5177\u4f53\u5206\u6790\u3002\u81f3\u6b64\uff0c\u4e3b\u8fdb\u7a0b\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\u3002","title":"15.2 \u4e3b\u8fdb\u7a0b\u521d\u59cb\u5316"},{"location":"chapter15-Cluster/#153","text":"\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002\u5f53\u6267\u884c\u5b50\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dchild\u6a21\u5757\u3002 1. const cluster = new EventEmitter(); 2. const handles = new Map(); 3. const indexes = new Map(); 4. const noop = () => {}; 5. 6. module.exports = cluster; 7. 8. cluster.isWorker = true; 9. cluster.isMaster = false; 10. cluster.worker = null; 11. cluster.Worker = Worker; 12. 13. cluster._setupWorker = function() { 14. const worker = new Worker({ 15. id: +process.env.NODE_UNIQUE_ID | 0, 16. process: process, 17. state: 'online' 18. }); 19. 20. cluster.worker = worker; 21. 22. process.on('internalMessage', internal(worker, onmessage)); 23. // \u901a\u77e5\u4e3b\u8fdb\u7a0b\u5b50\u8fdb\u7a0b\u542f\u52a8\u6210\u529f 24. send({ act: 'online' }); 25. 26. function onmessage(message, handle) { 27. if (message.act === 'newconn') 28. onconnection(message, handle); 29. else if (message.act === 'disconnect') 30. _disconnect.call(worker, true); 31. } 32. }; _setupWorker\u51fd\u6570\u5728\u5b50\u8fdb\u7a0b\u521d\u59cb\u5316\u65f6\u88ab\u6267\u884c\uff0c\u548c\u4e3b\u8fdb\u7a0b\u7c7b\u4f3c\uff0c\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e5f\u4e0d\u591a\uff0c\u76d1\u542cinternalMessage\u4e8b\u4ef6\uff0c\u5e76\u4e14\u901a\u77e5\u4e3b\u7ebf\u7a0b\u81ea\u5df1\u542f\u52a8\u6210\u529f\u3002","title":"15.3 \u5b50\u8fdb\u7a0b\u521d\u59cb\u5316"},{"location":"chapter15-Cluster/#154-httpcreateserver","text":"\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u6267\u884c\u5b8c\u521d\u59cb\u5316\u4ee3\u7801\u540e\uff0c\u5b50\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\u4e1a\u52a1\u4ee3\u7801http.createServer\uff0c\u5728HTTP\u6a21\u5757\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7http.createServer\u7684\u8fc7\u7a0b\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053http.createServer\u6700\u540e\u4f1a\u8c03\u7528net\u6a21\u5757\u7684listen\uff0c\u7136\u540e\u8c03\u7528listenIncluster\u3002\u6211\u4eec\u4ece\u8be5\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002 1. function listenIncluster(server, address, port, addressType, 2. backlog, fd, exclusive, flags) { 3. 4. const serverQuery = { 5. address: address, 6. port: port, 7. addressType: addressType, 8. fd: fd, 9. flags, 10. }; 11. 12. cluster._getServer(server, serverQuery, listenOnMasterHandle); 13. function listenOnMasterHandle(err, handle) { 14. err = checkBindError(err, port, handle); 15. 16. if (err) { 17. const ex = exceptionWithHostPort(err, 18. 'bind', 19. address, 20. port); 21. return server.emit('error', ex); 22. } 23. 24. server._handle = handle; 25. server._listen2(address, 26. port, 27. addressType, 28. backlog, 29. fd, 30. flags); 31. } 32. } listenIncluster\u51fd\u6570\u4f1a\u8c03\u7528\u5b50\u8fdb\u7a0bcluster\u6a21\u5757\u7684_getServer\u3002 1. cluster._getServer = function(obj, options, cb) { 2. let address = options.address; 3. 4. // \u5ffd\u7565index\u7684\u5904\u7406\u903b\u8f91 5. 6. const message = { 7. act: 'queryServer', 8. index, 9. data: null, 10. ...options 11. }; 12. 13. message.address = address; 14. // \u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u6d88\u606f 15. send(message, (reply, handle) => { 16. // \u6839\u636e\u4e0d\u540c\u6a21\u5f0f\u505a\u5904\u7406 17. if (handle) 18. shared(reply, handle, indexesKey, cb); 19. else 20. rr(reply, indexesKey, cb); 21. }); 22. }; _getServer\u4f1a\u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aqueryServer\u7684\u8bf7\u6c42\u3002\u6211\u4eec\u770b\u4e00\u4e0bsend\u51fd\u6570\u3002 1. function send(message, cb) { 2. return sendHelper(process, message, null, cb); 3. } 4. 5. function sendHelper(proc, message, handle, cb) { 6. if (!proc.connected) 7. return false; 8. 9. message = { cmd: 'NODE_CLUSTER', ...message, seq }; 10. 11. if (typeof cb === 'function') 12. callbacks.set(seq, cb); 13. 14. seq += 1; 15. return proc.send(message, handle); 16. } send\u8c03\u7528\u4e86sendHelper\uff0csendHelper\u662f\u5bf9\u5f02\u6b65\u8bf7\u6c42\u505a\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406queryServer\u8bf7\u6c42\u7684\u3002 1. function queryServer(worker, message) { 2. const key = `${message.address}:${message.port}:${message.addressType}:` + `${message.fd}:${message.index}`; 3. let handle = handles.get(key); 4. 5. if (handle === undefined) { 6. let address = message.address; 7. let constructor = RoundRobinHandle; 8. // \u6839\u636e\u7b56\u7565\u9009\u53d6\u4e0d\u540c\u7684\u6784\u9020\u51fd\u6570 9. if (schedulingPolicy !== SCHED_RR || 10. message.addressType === 'udp4' || 11. message.addressType === 'udp6') { 12. constructor = SharedHandle; 13. } 14. 15. handle = new constructor(key, 16. address, 17. message.port, 18. message.addressType, 19. message.fd, 20. message.flags); 21. handles.set(key, handle); 22. } 23. handle.add(worker, (errno, reply, handle) => { 24. const { data } = handles.get(key); 25. 26. send(worker, { 27. errno, 28. key, 29. ack: message.seq, 30. data, 31. ...reply 32. }, handle); 33. }); 34. } queryServer\u9996\u5148\u6839\u636e\u8c03\u5ea6\u7b56\u7565\u9009\u62e9\u6784\u9020\u51fd\u6570\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684add\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770b\u4e0d\u540c\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002","title":"15.4 http.createServer\u7684\u5904\u7406"},{"location":"chapter15-Cluster/#155","text":"\u4e0b\u9762\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-1\u6240\u793a\u3002 \u56fe19-1 1. function SharedHandle(key, address, port, addressType, fd, flags) { 2. this.key = key; 3. this.workers = []; 4. this.handle = null; 5. this.errno = 0; 6. 7. let rval; 8. if (addressType === 'udp4' || addressType === 'udp6') 9. rval = dgram._createSocketHandle(address, 10. port, 11. addressType, 12. fd, 13. flags); 14. else 15. rval = net._createServerHandle(address, 16. port, 17. addressType, 18. fd, 19. flags); 20. 21. if (typeof rval === 'number') 22. this.errno = rval; 23. else 24. this.handle = rval; 25. } SharedHandle\u662f\u5171\u4eab\u6a21\u5f0f\uff0c\u5373\u4e3b\u8fdb\u7a0b\u521b\u5efa\u597dhandle\uff0c\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\u3002 1. SharedHandle.prototype.add = function(worker, send) { 2. this.workers.push(worker); 3. send(this.errno, null, this.handle); 4. }; SharedHandle\u7684add\u628aSharedHandle\u4e2d\u521b\u5efa\u7684handle\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u62ff\u5230handle\u540e\u7684\u5904\u7406 1. function shared(message, handle, indexesKey, cb) { 2. const key = message.key; 3. 4. const close = handle.close; 5. 6. handle.close = function() { 7. send({ act: 'close', key }); 8. handles.delete(key); 9. indexes.delete(indexesKey); 10. return close.apply(handle, arguments); 11. }; 12. handles.set(key, handle); 13. // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 14. cb(message.errno, handle); 15. } Shared\u51fd\u6570\u628a\u63a5\u6536\u5230\u7684handle\u518d\u56de\u4f20\u5230\u8c03\u7528\u65b9\u3002\u5373net\u6a21\u5757\u3002net\u6a21\u5757\u4f1a\u6267\u884clisten\u5f00\u59cb\u76d1\u542c\u5730\u5740\uff0c\u4f46\u662f\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u7cfb\u7edf\u53ea\u4f1a\u6709\u4e00\u4e2a\u8fdb\u7a0b\u62ff\u5230\u8be5\u8fde\u63a5\u3002\u6240\u4ee5\u6240\u6709\u5b50\u8fdb\u7a0b\u5b58\u5728\u7ade\u4e89\u5173\u7cfb\u5bfc\u81f4\u8d1f\u8f7d\u4e0d\u5747\u8861\uff0c\u8fd9\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 \u5171\u4eab\u6a21\u5f0f\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\u4e3b\u8fdb\u7a0b\u5728_createServerHandle\u521b\u5efahandle\u65f6\u6267\u884cbind\u7ed1\u5b9a\u4e86\u5730\u5740\uff08\u4f46\u6ca1\u6709listen\uff09\uff0c\u7136\u540e\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u6267\u884clisten\u7684\u65f6\u5019\u5c31\u4e0d\u4f1a\u62a5\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u7684\u9519\u8bef\u4e86\u3002\u56e0\u4e3a\u7aef\u53e3\u88ab\u76d1\u542c\u7684\u9519\u8bef\u662f\u6267\u884cbind\u7684\u65f6\u5019\u8fd4\u56de\u7684\u3002","title":"15.5 \u5171\u4eab\u6a21\u5f0f"},{"location":"chapter15-Cluster/#156","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-2\u6240\u793a\u3002 \u56fe19-2 1. function RoundRobinHandle(key, address, port, addressType, fd, flags) { 2. this.key = key; 3. this.all = new Map(); 4. this.free = []; 5. this.handles = []; 6. this.handle = null; 7. this.server = net.createServer(assert.fail); 8. 9. if (fd >= 0) 10. this.server.listen({ fd }); 11. else if (port >= 0) { 12. this.server.listen({ 13. port, 14. host: address, 15. ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY), 16. }); 17. } else 18. this.server.listen(address); // UNIX socket path. 19. // \u76d1\u542c\u6210\u529f\u540e\uff0c\u6ce8\u518conconnection\u56de\u8c03\uff0c\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c 20. this.server.once('listening', () => { 21. this.handle = this.server._handle; 22. this.handle.onconnection = (err, handle) => this.distribute(err, handle); 23. this.server._handle = null; 24. this.server = null; 25. }); 26. } RoundRobinHandle\u7684\u5de5\u4f5c\u6a21\u5f0f\u662f\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\uff0c\u6536\u5230\u8fde\u63a5\u540e\u5206\u53d1\u7ed9\u5b50\u8fdb\u7a0b\u3002\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684add 1. RoundRobinHandle.prototype.add = function(worker, send) { 2. this.all.set(worker.id, worker); 3. 4. const done = () => { 5. if (this.handle.getsockname) { 6. const out = {}; 7. this.handle.getsockname(out); 8. send(null, { sockname: out }, null); 9. } else { 10. send(null, null, null); // UNIX socket. 11. } 12. 13. // In case there are connections pending. 14. this.handoff(worker); 15. }; 16. // \u8bf4\u660elisten\u6210\u529f\u4e86 17. if (this.server === null) 18. return done(); 19. // \u5426\u5219\u7b49\u5f85listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 20. this.server.once('listening', done); 21. this.server.once('error', (err) => { 22. send(err.errno, null); 23. }); 24. }; RoundRobinHandle\u4f1a\u5728listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u56de\u987e\u4e00\u4e0b\u6267\u884cadd\u51fd\u6570\u65f6\u7684\u56de\u8c03\u3002 1. handle.add(worker, (errno, reply, handle) => { 2. const { data } = handles.get(key); 3. 4. send(worker, { 5. errno, 6. key, 7. ack: message.seq, 8. data, 9. ...reply 10. }, handle); 11. }); \u56de\u8c03\u51fd\u6570\u4f1a\u628ahandle\u7b49\u4fe1\u606f\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4f46\u662f\u5728RoundRobinHandle\u548cSharedHandle\u4e2d\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\u3002\u5206\u522b\u662fnull\u548cnet.createServer\u5b9e\u4f8b\u3002\u63a5\u7740\u6211\u4eec\u56de\u5230\u5b50\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\u3002\u770b\u5b50\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406\u54cd\u5e94\u7684\u3002\u521a\u624d\u6211\u4eec\u8bb2\u8fc7\uff0c\u4e0d\u540c\u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u770b\u8f6e\u8be2\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002 1. function rr(message, indexesKey, cb) { 2. let key = message.key; 3. function listen(backlog) { 4. return 0; 5. } 6. 7. function close() { 8. // ... 9. } 10. 11. const handle = { close, listen, ref: noop, unref: noop }; 12. 13. if (message.sockname) { 14. handle.getsockname = getsockname; // TCP handles only. 15. } 16. 17. handles.set(key, handle); 18. // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 19. cb(0, handle); 20. } round-robin\u6a21\u5f0f\u4e0b\uff0c\u6784\u9020\u4e00\u4e2a\u5047\u7684handle\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\uff0c\u56e0\u4e3a\u8c03\u7528\u65b9\u4f1a\u8c03\u7528\u8fd9\u4e9b\u51fd\u6570\u3002\u6700\u540e\u56de\u5230net\u6a21\u5757\u3002net\u6a21\u5757\u9996\u5148\u4fdd\u5b58handle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0cround-bobin\u6a21\u5757\u4f1a\u6267\u884cdistribute\u5206\u53d1\u8bf7\u6c42\u7ed9\u5b50\u8fdb\u7a0b\u3002 1. RoundRobinHandle.prototype.distribute = function(err, handle) { 2. // \u9996\u5148\u4fdd\u5b58handle\u5230\u961f\u5217 3. this.handles.push(handle); 4. // \u4ece\u7a7a\u95f2\u961f\u5217\u83b7\u53d6\u4e00\u4e2a\u5b50\u8fdb\u7a0b 5. const worker = this.free.shift(); 6. // \u5206\u53d1 7. if (worker) 8. this.handoff(worker); 9. }; 10. 11. RoundRobinHandle.prototype.handoff = function(worker) { 12. // \u62ff\u5230\u4e00\u4e2ahandle 13. const handle = this.handles.shift(); 14. // \u6ca1\u6709handle\uff0c\u5219\u5b50\u8fdb\u7a0b\u91cd\u65b0\u5165\u961f 15. if (handle === undefined) { 16. this.free.push(worker); // Add to ready queue again. 17. return; 18. } 19. // \u901a\u77e5\u5b50\u8fdb\u7a0b\u6709\u65b0\u8fde\u63a5 20. const message = { act: 'newconn', key: this.key }; 21. 22. sendHelper(worker.process, message, handle, (reply) => { 23. // \u63a5\u6536\u6210\u529f 24. if (reply.accepted) 25. handle.close(); 26. else 27. // \u7ed3\u675f\u5931\u8d25\uff0c\u5219\u91cd\u65b0\u5206\u53d1 28. this.distribute(0, handle); // Worker is shutting down. Send to another. 29. 30. this.handoff(worker); 31. }); 32. }; \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u662f\u600e\u4e48\u5904\u7406\u8be5\u8bf7\u6c42\u7684\u3002 1. function onmessage(message, handle) { 2. if (message.act === 'newconn') 3. onconnection(message, handle); 4. } 5. 6. function onconnection(message, handle) { 7. const key = message.key; 8. const server = handles.get(key); 9. const accepted = server !== undefined; 10. // \u56de\u590d\u63a5\u6536\u6210\u529f 11. send({ ack: message.seq, accepted }); 12. 13. if (accepted) 14. // \u5728net\u6a21\u5757\u8bbe\u7f6e 15. server.onconnection(0, handle); 16. } \u6211\u4eec\u770b\u5230\u5b50\u8fdb\u7a0b\u4f1a\u6267\u884cserver.onconnection\uff0c\u8fd9\u4e2a\u548c\u6211\u4eec\u5206\u6790net\u6a21\u5757\u65f6\u89e6\u53d1onconnection\u4e8b\u4ef6\u662f\u4e00\u6837\u7684\u3002","title":"15.6 \u8f6e\u8be2\u6a21\u5f0f"},{"location":"chapter15-Cluster/#157cluster","text":"Node.js\u7684cluster\u5728\u8bf7\u6c42\u5206\u53d1\u65f6\u662f\u6309\u7167\u8f6e\u8be2\u7684\uff0c\u65e0\u6cd5\u6839\u636e\u8fdb\u7a0b\u5f53\u524d\u60c5\u51b5\u505a\u76f8\u5e94\u7684\u5904\u7406\u3002\u4e86\u89e3\u4e86cluster\u6a21\u5757\u7684\u539f\u7406\u540e\uff0c\u6211\u4eec\u81ea\u5df1\u6765\u5b9e\u73b0\u4e00\u4e2acluster\u6a21\u5757\u3002","title":"15.7\u5b9e\u73b0\u81ea\u5df1\u7684cluster\u6a21\u5757"},{"location":"chapter15-Cluster/#1571","text":"\u6574\u4f53\u67b6\u6784\u5982\u56fe15-3\u6240\u793a\u3002 \u56fe15-3 Parent.js 1. const childProcess = require('child_process'); 2. const net = require('net'); 3. const workers = []; 4. const workerNum = 10; 5. let index = 0; 6. for (let i = 0; i < workerNum; i++) { 7. workers.push(childProcess.fork('child.js', {env: {index: i}})); 8. } 9. 10. const server = net.createServer((client) => { 11. workers[index].send(null, client); 12. console.log('dispatch to', index); 13. index = (index + 1) % workerNum; 14. }); 15. server.listen(11111); child.js 1. process.on('message', (message, client) => { 2. console.log('receive connection from master'); 3. }); \u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\u8bf7\u6c42\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u8bf7\u6c42\u540e\uff0c\u6309\u7167\u4e00\u5b9a\u7684\u7b97\u6cd5\u628a\u8bf7\u6c42\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65b9\u5f0f\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u4e86\u3002\u5728\u5206\u53d1\u7b97\u6cd5\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u81ea\u5b9a\u4e49\uff0c\u6bd4\u5982\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u7684\u8d1f\u8f7d\uff0c\u6b63\u5728\u5904\u7406\u7684\u8fde\u63a5\u6570\u3002","title":"15.7.1 \u8f6e\u8be2\u6a21\u5f0f"},{"location":"chapter15-Cluster/#1572","text":"\u6574\u4f53\u67b6\u6784\u5982\u56fe15-4\u6240\u793a\u3002 \u56fe15-4 Parent.js 1. const childProcess = require('child_process'); 2. const net = require('net'); 3. const workers = []; 4. const workerNum = 10 ; 5. const handle = net._createServerHandle('127.0.0.1', 11111, 4); 6. 7. for (let i = 0; i < workerNum; i++) { 8. const worker = childProcess.fork('child.js', {env: {index: i}}); 9. workers.push(worker); 10. worker.send(null ,handle); 11. /* 12. \u9632\u6b62\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u4f46\u662f\u91cd\u65b0fork\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u5c31\u65e0\u6cd5 13. \u518d\u4f20\u9012\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e86 14. */ 15. handle.close(); 16. } Child.js 1. const net = require('net'); 2. process.on('message', (message, handle) => { 3. net.createServer(() => { 4. console.log(process.env.index, 'receive connection'); 5. }).listen({handle}); 6. }); \u6211\u4eec\u770b\u5230\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u7ed1\u5b9a\u7aef\u53e3\uff0c\u7136\u540e\u628ahandle\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u76d1\u542csocket\u3002\u5f53\u6709\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u9009\u62e9\u67d0\u4e00\u4e2aworker\u8fdb\u7a0b\u5904\u7406\u8be5\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u67b6\u6784\uff0c\u5982\u56fe15-5\u6240\u793a\u3002 \u56fe15-5 \u5b9e\u73b0\u5171\u4eab\u6a21\u5f0f\u7684\u91cd\u70b9\u5728\u4e8e\u7406\u89e3EADDRINUSE\u9519\u8bef\u662f\u600e\u4e48\u6765\u7684\u3002\u5f53\u4e3b\u8fdb\u7a0b\u6267\u884cbind\u7684\u65f6\u5019\uff0c\u7ed3\u6784\u5982\u56fe15-6\u6240\u793a\u3002 \u56fe15-6 \u5982\u679c\u5176\u5b83\u8fdb\u7a0b\u4e5f\u6267\u884cbind\u5e76\u4e14\u7aef\u53e3\u4e5f\u4e00\u6837\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u544a\u8bc9\u6211\u4eec\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u4e86\uff08EADDRINUSE\uff09\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u91cc\u4e0d\u6267\u884cbind\u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002\u90a3\u4e48\u91cd\u70b9\u5728\u4e8e\uff0c\u5982\u4f55\u5728\u5b50\u8fdb\u7a0b\u4e2d\u4e0d\u6267\u884cbind\uff0c\u4f46\u662f\u53c8\u53ef\u4ee5\u7ed1\u5b9a\u5230\u540c\u6837\u7684\u7aef\u53e3\u5462\uff1f\u6709\u4e24\u79cd\u65b9\u5f0f\u3002 1 fork \u6211\u4eec\u77e5\u9053fork\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe15-7\u6240\u793a\u3002 \u56fe15-7 \u8fd9\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u53ef\u4ee5\u6267\u884cbind\u548clisten\uff0c\u7136\u540efork\u5b50\u8fdb\u7a0b\uff0c\u6700\u540eclose\u6389\u81ea\u5df1\u7684fd\uff0c\u8ba9\u6240\u6709\u7684\u8fde\u63a5\u90fd\u7531\u5b50\u8fdb\u7a0b\u5904\u7406\u5c31\u884c\u3002\u4f46\u662f\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u65e0\u6cd5\u5b9e\u73b0\uff0c\u6240\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u4e0d\u80fd\u6ee1\u8db3\u9700\u6c42\u3002 2 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 Node.js\u7684\u5b50\u8fdb\u7a0b\u662f\u901a\u8fc7fork+exec\u6a21\u5f0f\u521b\u5efa\u7684\uff0c\u5e76\u4e14Node.js\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86close_on_exec\u6807\u8bb0\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728Node.js\u4e2d\uff0c\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u7ed3\u6784\u4f53\u5982\u56fe15-8\u6240\u793a\uff08\u6709\u6807\u51c6\u8f93\u5165\u3001\u6807\u51c6\u8f93\u51fa\u3001\u6807\u51c6\u9519\u8bef\u4e09\u4e2afd\uff09\u3002 \u56fe15-8 \u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u3002\u628a\u65b9\u5f0f1\u4e2d\u62ff\u4e0d\u5230\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u56e0\u4e3a\u5728Node.js\u4e2d\uff0c\u867d\u7136\u6211\u4eec\u62ff\u4e0d\u5230fd\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u62ff\u5f97\u5230fd\u5bf9\u5e94\u7684handle\uff0c\u6211\u4eec\u901a\u8fc7IPC\u4f20\u8f93handle\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406fd\u7684\u95ee\u9898\u3002\u6700\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5904\u7406\u3002\u7ed3\u6784\u5982\u56fe15-9\u6240\u793a\u3002 \u56fe15-9 \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\uff0c\u6211\u4eec\u5c31\u7ed5\u8fc7\u4e86bind\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\u3002\u901a\u8fc7\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u77e5\u9053\u7ed5\u8fc7bind\u7684\u95ee\u9898\u91cd\u70b9\u5728\u4e8e\u8ba9\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u5171\u4eabsocket\u800c\u4e0d\u662f\u5355\u72ec\u6267\u884cbind\u3002\u5bf9\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cNode.js\u4e2d\u652f\u6301\u5f88\u591a\u79cd\u65b9\u5f0f\u3002\u4e0a\u9762\u7684\u65b9\u5f0f\u662f\u5b50\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u3002\u8fd8\u6709\u53e6\u4e00\u79cd\u6a21\u5f0f\u5982\u4e0b parent.js 1. const childProcess = require('child_process'); 2. const net = require('net'); 3. const workers = []; 4. const workerNum = 10; 5. const server = net.createServer(() => { 6. console.log('master receive connection'); 7. }) 8. server.listen(11111); 9. for (let i = 0; i < workerNum; i++) { 10. const worker = childProcess.fork('child.js', {env: {index: i}}); 11. workers.push(worker); 12. worker.send(null, server); 13. } 14. child.js 1. const net = require('net'); 2. process.on('message', (message, server) => { 3. server.on('connection', () => { 4. console.log(process.env.index, 'receive connection'); 5. }) 6. }); \u4e0a\u9762\u7684\u65b9\u5f0f\u4e2d\uff0c\u4e3b\u8fdb\u7a0b\u5b8c\u6210\u4e86bind\u548clisten\u3002\u7136\u540e\u628aserver\u5b9e\u4f8b\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u76d1\u542c\u8fde\u63a5\u7684\u5230\u6765\u4e86\u3002\u8fd9\u65f6\u5019\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u3002 \u6700\u540e\u5199\u4e00\u4e2a\u5ba2\u6237\u7aef\u6d4b\u8bd5\u3002 \u5ba2\u6237\u7aef 1. const net = require('net'); 2. for (let i = 0; i < 50; i++) { 3. net.connect({port: 11111}); 4. } \u6267\u884cclient\u6211\u4eec\u5c31\u53ef\u4ee5\u770b\u5230\u591a\u8fdb\u7a0b\u5904\u7406\u8fde\u63a5\u7684\u60c5\u51b5\u3002","title":"15.7.2 \u5171\u4eab\u6a21\u5f0f"},{"location":"chapter16-UDP/","text":"\u672c\u7ae0\u4ecb\u7ecdNode.js\u4e2d\u7684UDP\u6a21\u5757\uff0cUDP\u662f\u4f20\u8f93\u5c42\u975e\u9762\u5411\u8fde\u63a5\u7684\u4e0d\u53ef\u9760\u534f\u8bae\uff0c\u4f7f\u7528UDP\u65f6,\u4e0d\u9700\u8981\u5efa\u7acb\u8fde\u63a5\u5c31\u53ef\u4ee5\u5f80\u5bf9\u7aef\u76f4\u63a5\u53d1\u9001\u6570\u636e\uff0c\u51cf\u5c11\u4e86\u4e09\u6b21\u63e1\u624b\u5e26\u6765\u7684\u65f6\u5ef6\uff0c\u4f46\u662fUDP\u7684\u4e0d\u53ef\u9760\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6570\u636e\u4e22\u5931\uff0c\u6240\u4ee5\u6bd4\u8f83\u9002\u5408\u8981\u6c42\u65f6\u5ef6\u4f4e\uff0c\u5c11\u91cf\u4e22\u5305\u4e0d\u5f71\u54cd\u6574\u4f53\u529f\u80fd\u7684\u573a\u666f\uff0c\u53e6\u5916UDP\u652f\u6301\u591a\u64ad\u3001\u7aef\u53e3\u590d\u7528\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4e00\u6b21\u7ed9\u591a\u4e2a\u4e3b\u673a\u7684\u591a\u4e2a\u8fdb\u7a0b\u53d1\u9001\u6570\u636e\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790\u4e00\u4e0bUDP\u7684\u76f8\u5173\u5185\u5bb9\u3002 16.1 \u5728C\u8bed\u8a00\u4e2d\u4f7f\u7528UDP \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728C\u8bed\u8a00\u4e2d\u5982\u4f55\u4f7f\u7528UDP\u529f\u80fd\uff0c\u8fd9\u662fNode.js\u7684\u5e95\u5c42\u57fa\u7840\u3002 16.1.1 \u670d\u52a1\u5668\u6d41\u7a0b\uff08\u4f2a\u4ee3\u7801\uff09 \u00b6 1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. // \u7ed1\u5b9a\u4e00\u4e2a\u4f17\u6240\u5468\u77e5\u7684\u5730\u5740\uff0c\u50cfTCP\u4e00\u6837 4. bind(fd, ip\uff0c port); 5. // \u76f4\u63a5\u963b\u585e\u7b49\u5f85\u6d88\u606f\u7684\u5230\u6765\uff0cUDP\u4e0d\u9700\u8981listen 6. recvmsg()\uff1b 16.1.2 \u5ba2\u6237\u7aef\u6d41\u7a0b \u00b6 \u5ba2\u6237\u7aef\u7684\u6d41\u7a0b\u6709\u591a\u79cd\u65b9\u5f0f\uff0c\u539f\u56e0\u5728\u4e8e\u6e90IP\u3001\u7aef\u53e3\u548c\u76ee\u7684IP\u3001\u7aef\u53e3\u53ef\u4ee5\u6709\u591a\u79cd\u8bbe\u7f6e\u65b9\u5f0f\u3002\u4e0d\u50cf\u670d\u52a1\u5668\u4e00\u6837\uff0c\u670d\u52a1\u5668\u7aef\u53e3\u662f\u9700\u8981\u5bf9\u5916\u516c\u5e03\u7684\uff0c\u5426\u5219\u5ba2\u6237\u7aef\u5c31\u65e0\u6cd5\u627e\u5230\u76ee\u7684\u5730\u8fdb\u884c\u901a\u4fe1\u3002\u8fd9\u5c31\u610f\u5473\u7740\u670d\u52a1\u5668\u7684\u7aef\u53e3\u662f\u9700\u8981\u7528\u6237\u663e\u5f0f\u6307\u5b9a\u7684\uff0c\u800c\u5ba2\u6237\u7aef\u5219\u4e0d\u7136\uff0c\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u6307\u5b9a\uff0c\u4e5f\u53ef\u4ee5\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770b\u5404\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 16.1.2.1 \u663e\u5f0f\u6307\u5b9a\u6e90IP\u548c\u7aef\u53e3 \u00b6 1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. // \u7ed1\u5b9a\u4e00\u4e2a\u5ba2\u6237\u7aef\u7684\u5730\u5740 4. bind(fd, ip\uff0c port); 5. // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e 6. sendto(fd, \u670d\u52a1\u5668ip,\u670d\u52a1\u5668\u7aef\u53e3, data); \u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u6240\u4ee5\u4f7f\u7528UDP\u65f6\uff0c\u4e0d\u9700\u8981\u8c03\u7528connect\u5efa\u7acb\u8fde\u63a5\uff0c\u53ea\u8981\u6211\u4eec\u77e5\u9053\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u76f4\u63a5\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u5373\u53ef\u3002\u800c\u9762\u5411\u8fde\u63a5\u7684TCP\uff0c\u9996\u5148\u9700\u8981\u901a\u8fc7connect\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u5efa\u7acb\u8fde\u63a5\uff0c\u5efa\u7acb\u8fde\u63a5\u7684\u672c\u8d28\u662f\u5728\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u8bb0\u5f55\u5bf9\u7aef\u7684\u4fe1\u606f\uff0c\u8fd9\u662f\u540e\u9762\u901a\u4fe1\u7684\u901a\u884c\u8bc1\u3002 16.1.2.2 \u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u6e90ip\u548c\u7aef\u53e3 \u00b6 1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e 4. sendto(fd, \u670d\u52a1\u5668ip,\u670d\u52a1\u5668\u7aef\u53e3, data) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u7684\u6e90ip\u548c\u7aef\u53e3\uff0c\u800c\u662f\u76f4\u63a5\u5c31\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u3002\u5982\u679c\u7528\u6237\u4e0d\u6307\u5b9aip\u548c\u7aef\u53e3\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u63d0\u4f9b\u9ed8\u8ba4\u7684\u6e90ip\u548c\u7aef\u53e3\u3002\u5bf9\u4e8eip\uff0c\u5982\u679c\u662f\u591a\u5bbf\u4e3b\u4e3b\u673a\uff0c\u6bcf\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u52a8\u6001\u9009\u62e9\u6e90ip\u3002\u5bf9\u4e8e\u7aef\u53e3\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5728\u7b2c\u4e00\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u4e0d\u80fd\u4fee\u6539\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. connect(fd, \u670d\u52a1\u5668ip\uff0c\u670d\u52a1\u5668\u7aef\u53e3); 4. /* 5. \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e,\u6216\u8005sendto(fd, null,null, data)\uff0c 6. \u8c03\u7528sendto\u5219\u4e0d\u9700\u8981\u518d\u6307\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3 7. */ 8. write(fd, data); \u6211\u4eec\u53ef\u4ee5\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3\u5230fd\uff0c\u7136\u540e\u76f4\u63a5\u8c03\u7528write\u53d1\u9001\u6570\u636e\u3002 \u867d\u7136\u4f7f\u7528\u65b9\u5f0f\u5f88\u591a\uff0c\u4f46\u662f\u5f52\u6839\u5230\u5e95\u8fd8\u662f\u5bf9\u56db\u5143\u7ec4\u8bbe\u7f6e\u7684\u7ba1\u7406\u3002bind\u662f\u7ed1\u5b9a\u6e90ip\u7aef\u53e3\u5230fd\uff0cconnect\u662f\u7ed1\u5b9a\u670d\u52a1\u5668ip\u7aef\u53e3\u5230fd\u3002\u5bf9\u4e8e\u6e90ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u8ba9\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u3002\u5bf9\u4e8e\u76ee\u7684ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u524d\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u65f6\u8bbe\u7f6e\u3002\u8fd9\u5c31\u5f62\u6210\u4e86\u591a\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 16.1.3 \u53d1\u9001\u6570\u636e \u00b6 \u6211\u4eec\u521a\u624d\u770b\u5230\u4f7f\u7528UDP\u4e4b\u524d\u90fd\u9700\u8981\u8c03\u7528socket\u51fd\u6570\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u867d\u7136\u8c03\u7528socket\u51fd\u6570\u8fd4\u56de\u7684\u662f\u4e00\u4e2afd\uff0c\u4f46\u662f\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u7684\u786e\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u7ed3\u6784\u4f53\uff0cfd\u53ea\u662f\u4e00\u4e2a\u7d22\u5f15\uff0c\u64cd\u4f5c\u8fd9\u4e2afd\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u8fd9\u4e2afd\u627e\u5230\u5bf9\u5e94\u7684socket\u3002socket\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u4e3a\u4e00\u4e2a\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4e2d\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662f\u8bfb\u7f13\u51b2\u533a\u5927\u5c0f\uff0c\u4e00\u4e2a\u662f\u5199\u7f13\u51b2\u533a\u5927\u5c0f\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u867d\u7136\u7406\u8bba\u4e0a\u53ef\u4ee5\u53d1\u9001\u4efb\u610f\u5927\u5c0f\u7684\u6570\u636e\uff0c\u4f46\u662f\u56e0\u4e3a\u53d7\u9650\u4e8e\u53d1\u9001\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff0c\u5982\u679c\u9700\u8981\u53d1\u9001\u7684\u6570\u636e\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\u5219\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u95ee\u9898\uff0c\u6211\u4eec\u5206\u60c5\u51b5\u5206\u6790\u4e00\u4e0b\u3002 1 \u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u8fd4\u56deEAGAIN\uff0c\u5982\u679c\u662f\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u4f1a\u5f15\u8d77\u8fdb\u7a0b\u7684\u963b\u585e\u3002 2 \u5982\u679c\u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u7f13\u51b2\u533a\u7684\u6700\u5927\u503c\u8fd8\u5927\uff0c\u5219\u4f1a\u5bfc\u81f4\u62a5\u9519EMSGSIZE\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u5206\u5305\u53d1\u9001\u3002\u6211\u4eec\u53ef\u80fd\u4f1a\u60f3\u5230\u4fee\u6539\u7f13\u51b2\u533a\u6700\u5927\u503c\u7684\u5927\u5c0f\uff0c\u4f46\u662f\u8fd9\u4e2a\u5927\u5c0f\u4e5f\u662f\u6709\u9650\u5236\u7684\u3002 \u8bb2\u5b8c\u4e00\u4e9b\u8fb9\u754c\u60c5\u51b5\uff0c\u6211\u4eec\u518d\u6765\u770b\u770b\u6b63\u5e38\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u770b\u770b\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u6d41\u7a0b 1 \u9996\u5148\u5728socket\u7684\u5199\u7f13\u51b2\u533a\u7533\u8bf7\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u6570\u636e\u53d1\u9001\u3002 2 \u8c03\u7528IP\u5c42\u53d1\u9001\u63a5\u53e3\uff0c\u5982\u679c\u6570\u636e\u5305\u5927\u5c0f\u8d85\u8fc7\u4e86IP\u5c42\u7684\u9650\u5236\uff0c\u5219\u9700\u8981\u5206\u5305\u3002 3 \u7ee7\u7eed\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u628a\u6570\u636e\u53d1\u5230\u7f51\u7edc\u4e0a\u3002 \u56e0\u4e3aUDP\u4e0d\u662f\u53ef\u9760\u7684\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff08TCP\u534f\u8bae\u5219\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff0c\u7528\u4e8e\u8d85\u65f6\u91cd\u4f20\uff09\u3002 \u8fd9\u5c31\u662fUDP\u53d1\u9001\u6570\u636e\u7684\u6d41\u7a0b\u3002 16.1.4 \u63a5\u6536\u6570\u636e \u00b6 \u5f53\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u4f1a\u628a\u8fd9\u4e2a\u6570\u636e\u5305\u7f13\u5b58\u5230socket\u7684\u7f13\u51b2\u533a\uff0c\u5982\u679c\u6536\u5230\u7684\u6570\u636e\u5305\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\uff0c\u5219\u4e22\u5f03\u6570\u636e\u5305\uff0c\u5426\u5219\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230\u63a5\u6536\u961f\u5217\uff0c\u7b49\u7528\u6237\u6765\u8bfb\u53d6\u7684\u65f6\u5019\uff0c\u5c31\u9010\u4e2a\u6458\u4e0b\u63a5\u6536\u961f\u5217\u7684\u8282\u70b9\u3002UDP\u548cTCP\u4e0d\u4e00\u6837\uff0c\u867d\u7136\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u7f13\u5b58\u4e86\u6d88\u606f\u7684\u961f\u5217\uff0c\u4f46\u662f\u5f53\u7528\u6237\u8bfb\u53d6\u6570\u636e\u65f6\uff0cUDP\u6bcf\u6b21\u53ea\u4f1a\u8fd4\u56de\u4e00\u4e2aUDP\u6570\u636e\u5305\uff0c\u800cTCP\u662f\u4f1a\u6839\u636e\u7528\u6237\u8bbe\u7f6e\u7684\u5927\u5c0f\u8fd4\u56de\u4e00\u4e2a\u6216\u591a\u4e2a\u5305\u91cc\u7684\u6570\u636e\u3002\u56e0\u4e3aTCP\u662f\u9762\u5411\u5b57\u8282\u6d41\u7684\uff0c\u800cUDP\u662f\u9762\u5411\u6570\u636e\u5305\u7684\u3002 16.2 UDP\u6a21\u5757\u5728Node.js\u4e2d\u7684\u5b9e\u73b0 \u00b6 \u4e86\u89e3\u4e86UDP\u7684\u4e00\u4e9b\u57fa\u7840\u548c\u4f7f\u7528\u540e\uff0c\u6211\u4eec\u5f00\u59cb\u5206\u6790\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528UDP\u7684\uff0cNode.js\u53c8\u662f\u5982\u4f55\u5b9e\u73b0UDP\u6a21\u5757\u7684\u3002 16.2.1 \u670d\u52a1\u5668 \u00b6 \u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u770b\u770bUDP\u6a21\u5757\u7684\u4f7f\u7528\u3002 1. const dgram = require('dgram'); 2. // \u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668 3. const server = dgram.createSocket('udp4'); 4. // \u76d1\u542cUDP\u6570\u636e\u7684\u5230\u6765 5. server.on('message', (msg, rinfo) => { 6. // \u5904\u7406\u6570\u636e 7. }); 8. // \u7ed1\u5b9a\u7aef\u53e3 9. server.bind(41234); \u6211\u4eec\u770b\u5230\u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668\u5f88\u7b80\u5355\uff0c\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\u5bf9\u8c61\uff0c\u5728Node.js\u4e2d\u548c\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4e00\u6837\uff0csocket\u662f\u5bf9\u7f51\u7edc\u901a\u4fe1\u7684\u4e00\u4e2a\u62bd\u8c61\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5b83\u7406\u89e3\u6210\u5bf9\u4f20\u8f93\u5c42\u7684\u62bd\u8c61\uff0c\u5b83\u53ef\u4ee5\u4ee3\u8868TCP\u4e5f\u53ef\u4ee5\u4ee3\u8868UDP\u3002\u6211\u4eec\u770b\u4e00\u4e0bcreateSocket\u505a\u4e86\u4ec0\u4e48\u3002 1. function createSocket(type, listener) { 2. return new Socket(type, listener); 3. } 4. function Socket(type, listener) { 5. EventEmitter.call(this); 6. let lookup; 7. let recvBufferSize; 8. let sendBufferSize; 9. 10. let options; 11. if (type !== null && typeof type === 'object') { 12. options = type; 13. type = options.type; 14. lookup = options.lookup; 15. recvBufferSize = options.recvBufferSize; 16. sendBufferSize = options.sendBufferSize; 17. } 18. const handle = newHandle(type, lookup); 19. this.type = type; 20. if (typeof listener === 'function') 21. this.on('message', listener); 22. // \u4fdd\u5b58\u4e0a\u4e0b\u6587 23. this[kStateSymbol] = { 24. handle, 25. receiving: false, 26. // \u8fd8\u6ca1\u6709\u6267\u884cbind 27. bindState: BIND_STATE_UNBOUND, 28. connectState: CONNECT_STATE_DISCONNECTED, 29. queue: undefined, 30. // \u7aef\u53e3\u590d\u7528\uff0c\u53ea\u4f7f\u4e8e\u591a\u64ad 31. reuseAddr: options && options.reuseAddr, 32. ipv6Only: options && options.ipv6Only, 33. // \u53d1\u9001\u7f13\u51b2\u533a\u548c\u63a5\u6536\u7f13\u51b2\u533a\u5927\u5c0f 34. recvBufferSize, 35. sendBufferSize 36. }; 37. } \u6211\u4eec\u770b\u5230\u4e00\u4e2asocket\u5bf9\u8c61\u662f\u5bf9handle\u7684\u4e00\u4e2a\u5c01\u88c5\u3002\u6211\u4eec\u770b\u770bhandle\u662f\u4ec0\u4e48\u3002 1. function newHandle(type, lookup) { 2. // \u7528\u4e8edns\u89e3\u6790\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u6211\u4eec\u8c03send\u7684\u65f6\u5019\uff0c\u4f20\u7684\u662f\u4e00\u4e2a\u57df\u540d 3. if (lookup === undefined) { 4. if (dns === undefined) { 5. dns = require('dns'); 6. } 7. lookup = dns.lookup; 8. } 9. 10. if (type === 'udp4') { 11. const handle = new UDP(); 12. handle.lookup = lookup4.bind(handle, lookup); 13. return handle; 14. } 15. // \u5ffd\u7565ipv6\u7684\u5904\u7406 16. } handle\u53c8\u662f\u5bf9UDP\u6a21\u5757\u7684\u5c01\u88c5\uff0cUDP\u662fC++\u6a21\u5757\uff0c\u5728\u4e4b\u524d\u7ae0\u8282\u4e2d\u6211\u4eec\u8bb2\u8fc7\u76f8\u5173\u7684\u77e5\u8bc6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8be6\u7ec6\u8bb2\u8ff0\u4e86\uff0c\u5f53\u6211\u4eec\u5728JS\u5c42new UDP\u7684\u65f6\u5019\uff0c\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002 1. UDPWrap::UDPWrap(Environment* env, Local<Object> object) 2. : HandleWrap(env, 3. object, 4. reinterpret_cast<uv_handle_t*>(&handle_), 5. AsyncWrap::PROVIDER_UDPWRAP) { 6. int r = uv_udp_init(env->event_loop(), &handle_); 7. } \u6267\u884c\u4e86uv_udp_init\u521d\u59cb\u5316udp\u5bf9\u5e94\u7684handle\uff08uv_udp_t\uff09\u3002\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u7684\u5b9a\u4e49\u3002 1. int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) { 2. int domain; 3. int err; 4. int fd; 5. 6. /* Use the lower 8 bits for the domain */ 7. domain = flags & 0xFF; 8. // \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u8fd4\u56de\u4e00\u4e2afd 9. fd = uv__socket(domain, SOCK_DGRAM, 0); 10. uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP); 11. handle->alloc_cb = NULL; 12. handle->recv_cb = NULL; 13. handle->send_queue_size = 0; 14. handle->send_queue_count = 0; 15. /* 16. \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff08\u8fd8\u6ca1\u6709\u6ce8\u518c\u5230\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\uff09\uff0c 17. \u76d1\u542c\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662ffd\uff0c\u56de\u8c03\u662fuv__udp_io 18. */ 19. uv__io_init(&handle->io_watcher, uv__udp_io, fd); 20. // \u521d\u59cb\u5316\u5199\u961f\u5217 21. QUEUE_INIT(&handle->write_queue); 22. QUEUE_INIT(&handle->write_completed_queue); 23. return 0; 24. } \u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u6267\u884cdgram.createSocket('udp4')\u7684\u65f6\u5019\uff0c\u5728Node.js\u4e2d\u4e3b\u8981\u7684\u6267\u884c\u8fc7\u7a0b\u3002\u56de\u5230\u6700\u5f00\u59cb\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884cbind\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002 1. Socket.prototype.bind = function(port_, address_ /* , callback */) { 2. let port = port_; 3. // socket\u7684\u4e0a\u4e0b\u6587 4. const state = this[kStateSymbol]; 5. // \u5df2\u7ecf\u7ed1\u5b9a\u8fc7\u4e86\u5219\u62a5\u9519 6. if (state.bindState !== BIND_STATE_UNBOUND) 7. throw new ERR_SOCKET_ALREADY_BOUND(); 8. // \u5426\u5219\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u4e86 9. state.bindState = BIND_STATE_BINDING; 10. // \u6ca1\u4f20\u5730\u5740\u5219\u9ed8\u8ba4\u7ed1\u5b9a\u6240\u6709\u5730\u5740 11. if (!address) { 12. if (this.type === 'udp4') 13. address = '0.0.0.0'; 14. else 15. address = '::'; 16. } 17. // dns\u89e3\u6790\u540e\u5728\u7ed1\u5b9a\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd 18. state.handle.lookup(address, (err, ip) => { 19. if (err) { 20. state.bindState = BIND_STATE_UNBOUND; 21. this.emit('error', err); 22. return; 23. } 24. const err = state.handle.bind(ip, port || 0, flags); 25. if (err) { 26. const ex = exceptionWithHostPort(err, 'bind', ip, port); 27. state.bindState = BIND_STATE_UNBOUND; 28. this.emit('error', ex); 29. // Todo: close? 30. return; 31. } 32. 33. startListening(this); 34. return this; 35. } bind\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u662fhandle.bind\u548cstartListening\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u770b\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u7684bind\u3002 1. void UDPWrap::DoBind(const FunctionCallbackInfo<Value>& args, int family) { 2. UDPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. 7. // bind(ip, port, flags) 8. CHECK_EQ(args.Length(), 3); 9. node::Utf8Value address(args.GetIsolate(), args[0]); 10. Local<Context> ctx = args.GetIsolate()->GetCurrentContext(); 11. uint32_t port, flags; 12. struct sockaddr_storage addr_storage; 13. int err = sockaddr_for_family(family, 14. address.out(), 15. port, 16. &addr_storage); 17. if (err == 0) { 18. err = uv_udp_bind(&wrap->handle_, 19. reinterpret_cast<const sockaddr*>(&addr_storage), 20. flags); 21. } 22. 23. args.GetReturnValue().Set(err); 24. } \u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u5904\u7406\u53c2\u6570\u7136\u540e\u6267\u884cuv_udp_bind\u8bbe\u7f6e\u4e00\u4e9b\u6807\u8bb0\u3001\u5c5e\u6027\u548c\u7aef\u53e3\u590d\u7528\uff08\u7aef\u53e3\u590d\u7528\u540e\u7eed\u4f1a\u5355\u72ec\u5206\u6790\uff09\uff0c\u7136\u540e\u6267\u884c\u64cd\u4f5c\u7cfb\u7edfbind\u7684\u51fd\u6570\u628a\u672c\u7aef\u7684ip\u548c\u7aef\u53e3\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6211\u4eec\u7ee7\u7eed\u770bstartListening\u3002 1. function startListening(socket) { 2. const state = socket[kStateSymbol]; 3. // \u6709\u6570\u636e\u65f6\u7684\u56de\u8c03\uff0c\u89e6\u53d1message\u4e8b\u4ef6 4. state.handle.onmessage = onMessage; 5. // \u91cd\u70b9\uff0c\u5f00\u59cb\u76d1\u542c\u6570\u636e 6. state.handle.recvStart(); 7. state.receiving = true; 8. state.bindState = BIND_STATE_BOUND; 9. // \u8bbe\u7f6e\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u6536\u548c\u53d1\u9001\u7f13\u51b2\u533a\u5927\u5c0f 10. if (state.recvBufferSize) 11. bufferSize(socket, state.recvBufferSize, RECV_BUFFER); 12. 13. if (state.sendBufferSize) 14. bufferSize(socket, state.sendBufferSize, SEND_BUFFER); 15. 16. socket.emit('listening'); 17. } \u91cd\u70b9\u662frecvStart\u51fd\u6570\uff0c\u6211\u4eec\u770bC++\u7684\u5b9e\u73b0\u3002 1. void UDPWrap::RecvStart(const FunctionCallbackInfo<Value>& args) { 2. UDPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. int err = uv_udp_recv_start(&wrap->handle_, OnAlloc, OnRecv); 7. // UV_EALREADY means that the socket is already bound but that's okay 8. if (err == UV_EALREADY) 9. err = 0; 10. args.GetReturnValue().Set(err); 11. } OnAlloc, OnRecv\u5206\u522b\u662f\u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u548c\u6570\u636e\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u7ee7\u7eed\u770bLibuv 1. int uv__udp_recv_start(uv_udp_t* handle, 2. uv_alloc_cb alloc_cb, 3. uv_udp_recv_cb recv_cb) { 4. int err; 5. 6. 7. err = uv__udp_maybe_deferred_bind(handle, AF_INET, 0); 8. if (err) 9. return err; 10. // \u4fdd\u5b58\u4e00\u4e9b\u4e0a\u4e0b\u6587 11. handle->alloc_cb = alloc_cb; 12. handle->recv_cb = recv_cb; 13. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u5982\u679c\u4e8b\u4ef6\u5230\u6765\uff0c\u7b49\u5230Poll IO\u9636\u6bb5\u5904\u7406 14. uv__io_start(handle->loop, &handle->io_watcher, POLLIN); 15. uv__handle_start(handle); 16. 17. return 0; 18. } uv__udp_recv_start\u4e3b\u8981\u662f\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u7b49\u5f85\u4e8b\u4ef6\u5230\u6765\u7684\u65f6\u5019\uff0c\u5230\u8fd9\uff0c\u670d\u52a1\u5668\u5c31\u542f\u52a8\u4e86\u3002 16.2.2 \u5ba2\u6237\u7aef \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5ba2\u6237\u7aef\u7684\u4f7f\u7528\u65b9\u5f0f\u548c\u6d41\u7a0b 1. const dgram = require('dgram'); 2. const message = Buffer.from('Some bytes'); 3. const client = dgram.createSocket('udp4'); 4. client.connect(41234, 'localhost', (err) => { 5. client.send(message, (err) => { 6. client.close(); 7. }); 8. }); \u6211\u4eec\u770b\u5230Node.js\u9996\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u7136\u540e\u8c03\u7528send\u53d1\u9001\u4fe1\u606f\uff0c\u6700\u540e\u8c03\u7528close\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002\u9996\u5148\u770bconnect\u3002 1. Socket.prototype.connect = function(port, address, callback) { 2. port = validatePort(port); 3. // \u53c2\u6570\u5904\u7406 4. if (typeof address === 'function') { 5. callback = address; 6. address = ''; 7. } else if (address === undefined) { 8. address = ''; 9. } 10. 11. const state = this[kStateSymbol]; 12. // \u4e0d\u662f\u521d\u59cb\u5316\u72b6\u6001 13. if (state.connectState !== CONNECT_STATE_DISCONNECTED) 14. throw new ERR_SOCKET_DGRAM_IS_CONNECTED(); 15. // \u8bbe\u7f6esocket\u72b6\u6001 16. state.connectState = CONNECT_STATE_CONNECTING; 17. // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u5148\u7ed1\u5b9a\u968f\u673a\u5730\u5740\uff08\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff09 18. if (state.bindState === BIND_STATE_UNBOUND) 19. this.bind({ port: 0, exclusive: true }, null); 20. // \u6267\u884cbind\u7684\u65f6\u5019\uff0cstate.bindState\u4e0d\u662f\u540c\u6b65\u8bbe\u7f6e\u7684 21. if (state.bindState !== BIND_STATE_BOUND) { 22. enqueue(this, _connect.bind(this, port, address, callback)); 23. return; 24. } 25. 26. _connect.call(this, port, address, callback); 27. }; \u8fd9\u91cc\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u5728connect\u4e4b\u524d\u5df2\u7ecf\u8c03\u7528\u4e86bind\uff0c\u7b2c\u4e8c\u79cd\u662f\u6ca1\u6709\u8c03\u7528bind\uff0c\u5982\u679c\u6ca1\u6709\u8c03\u7528bind\uff0c\u5219\u5728connect\u4e4b\u524d\u5148\u8981\u8c03\u7528bind\uff08\u56e0\u4e3abind\u4e2d\u4e0d\u4ec5\u4ec5\u7ed1\u5b9a\u4e86ip\u7aef\u53e3\uff0c\u8fd8\u6709\u7aef\u53e3\u590d\u7528\u7684\u5904\u7406\uff09\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u6ca1\u6709\u8c03\u7528bind\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u8fd9\u662f\u6700\u957f\u7684\u8def\u5f84\u3002bind\u521a\u624d\u6211\u4eec\u5206\u6790\u8fc7\u4e86\uff0c\u6211\u4eec\u4ece\u4ee5\u4e0b\u4ee3\u7801\u7ee7\u7eed\u5206\u6790 1. if (state.bindState !== BIND_STATE_BOUND) { 2. enqueue(this, _connect.bind(this, port, address, callback)); 3. return; 4. } enqueue\u628a\u4efb\u52a1\u52a0\u5165\u4efb\u52a1\u961f\u5217\uff0c\u5e76\u4e14\u76d1\u542c\u4e86listening\u4e8b\u4ef6\uff08\u8be5\u4e8b\u4ef6\u5728bind\u6210\u529f\u540e\u89e6\u53d1\uff09\u3002 1. function enqueue(self, toEnqueue) { 2. const state = self[kStateSymbol]; 3. if (state.queue === undefined) { 4. state.queue = []; 5. self.once('error', onListenError); 6. self.once('listening', onListenSuccess); 7. } 8. state.queue.push(toEnqueue); 9. } \u8fd9\u65f6\u5019connect\u51fd\u6570\u5c31\u6267\u884c\u5b8c\u4e86\uff0c\u7b49\u5f85bind\u6210\u529f\u540e\uff08nextTick\uff09\u4f1a\u6267\u884c startListening\u51fd\u6570\u3002 1. function startListening(socket) { 2. const state = socket[kStateSymbol]; 3. state.handle.onmessage = onMessage; 4. // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 5. state.handle.recvStart(); 6. state.receiving = true; 7. // \u6807\u8bb0\u5df2bind\u6210\u529f 8. state.bindState = BIND_STATE_BOUND; 9. // \u8bbe\u7f6e\u8bfb\u5199\u7f13\u51b2\u533a\u5927\u5c0f 10. if (state.recvBufferSize) 11. bufferSize(socket, state.recvBufferSize, RECV_BUFFER); 12. 13. if (state.sendBufferSize) 14. bufferSize(socket, state.sendBufferSize, SEND_BUFFER); 15. // \u89e6\u53d1listening\u4e8b\u4ef6 16. socket.emit('listening'); 17. } \u6211\u4eec\u770b\u5230startListening\u89e6\u53d1\u4e86listening\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884c\u6211\u4eec\u521a\u624d\u5165\u961f\u7684\u56de\u8c03onListenSuccess\u3002 1. function onListenSuccess() { 2. this.removeListener('error', onListenError); 3. clearQueue.call(this); 4. } 5. 6. function clearQueue() { 7. const state = this[kStateSymbol]; 8. const queue = state.queue; 9. state.queue = undefined; 10. 11. for (const queueEntry of queue) 12. queueEntry(); 13. } \u56de\u8c03\u5c31\u662f\u628a\u961f\u5217\u4e2d\u7684\u56de\u8c03\u6267\u884c\u4e00\u904d\uff0cconnect\u51fd\u6570\u8bbe\u7f6e\u7684\u56de\u8c03\u662f_connect\u3002 1. function _connect(port, address, callback) { 2. const state = this[kStateSymbol]; 3. if (callback) 4. this.once('connect', callback); 5. 6. const afterDns = (ex, ip) => { 7. defaultTriggerAsyncIdScope( 8. this[async_id_symbol], 9. doConnect, 10. ex, this, ip, address, port, callback 11. ); 12. }; 13. 14. state.handle.lookup(address, afterDns); 15. } \u8fd9\u91cc\u7684address\u662f\u670d\u52a1\u5668\u5730\u5740\uff0c_connect\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u662f 1 \u76d1\u542cconnect\u4e8b\u4ef6 2 \u5bf9\u670d\u52a1\u5668\u5730\u5740\u8fdb\u884cdns\u89e3\u6790\uff08\u53ea\u80fd\u662f\u672c\u5730\u7684\u914d\u7684\u57df\u540d\uff09\u3002\u89e3\u6790\u6210\u529f\u540e\u6267\u884cafterDns\uff0c\u6700\u540e\u6267\u884cdoConnect\uff0c\u5e76\u4f20\u5165\u89e3\u6790\u51fa\u6765\u7684ip\u3002\u6211\u4eec\u770b\u770bdoConnect 1. function doConnect(ex, self, ip, address, port, callback) { 2. const state = self[kStateSymbol]; 3. // dns\u89e3\u6790\u6210\u529f\uff0c\u6267\u884c\u5e95\u5c42\u7684connect 4. if (!ex) { 5. const err = state.handle.connect(ip, port); 6. if (err) { 7. ex = exceptionWithHostPort(err, 'connect', address, port); 8. } 9. } 10. 11. // connect\u6210\u529f\uff0c\u89e6\u53d1connect\u4e8b\u4ef6 12. state.connectState = CONNECT_STATE_CONNECTED; 13. process.nextTick(() => self.emit('connect')); 14. } connect\u51fd\u6570\u901a\u8fc7C++\u5c42\uff0c\u7136\u540e\u8c03\u7528Libuv\uff0c\u5230\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u3002\u4f5c\u7528\u662f\u628a\u670d\u52a1\u5668\u5730\u5740\u4fdd\u5b58\u5230socket\u4e2d\u3002connect\u7684\u6d41\u7a0b\u5c31\u8d70\u5b8c\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u53ef\u4ee5\u8c03\u7528send\u548crecv\u53d1\u9001\u548c\u63a5\u6536\u6570\u636e\u3002 16.2.3 \u53d1\u9001\u6570\u636e \u00b6 \u53d1\u9001\u6570\u636e\u63a5\u53e3\u662fsendto\uff0c\u5b83\u662f\u5bf9send\u7684\u5c01\u88c5\u3002 1. Socket.prototype.send = function(buffer, 2. offset, 3. length, 4. port, 5. address, 6. callback) { 7. 8. let list; 9. const state = this[kStateSymbol]; 10. const connected = state.connectState === CONNECT_STATE_CONNECTED; 11. // \u6ca1\u6709\u8c03\u7528connect\u7ed1\u5b9a\u8fc7\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u9700\u8981\u4f20\u670d\u52a1\u7aef\u5730\u5740\u4fe1\u606f 12. if (!connected) { 13. if (address || (port && typeof port !== 'function')) { 14. buffer = sliceBuffer(buffer, offset, length); 15. } else { 16. callback = port; 17. port = offset; 18. address = length; 19. } 20. } else { 21. if (typeof length === 'number') { 22. buffer = sliceBuffer(buffer, offset, length); 23. if (typeof port === 'function') { 24. callback = port; 25. port = null; 26. } 27. } else { 28. callback = offset; 29. } 30. // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u4e0d\u80fd\u518d\u4f20\u4e86 31. if (port || address) 32. throw new ERR_SOCKET_DGRAM_IS_CONNECTED(); 33. } 34. // \u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u5668\u7aef\u53e3\uff0c\u5219\u8fd9\u91cc\u9700\u8981\u4f20\uff0c\u5e76\u4e14\u6821\u9a8c 35. if (!connected) 36. port = validatePort(port); 37. // \u5ffd\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u903b\u8f91 38. // \u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u9700\u8981\u5148\u7ed1\u5b9a\uff0c\u503c\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a 39. if (state.bindState === BIND_STATE_UNBOUND) 40. this.bind({ port: 0, exclusive: true }, null); 41. // bind\u8fd8\u6ca1\u6709\u5b8c\u6210\uff0c\u5219\u5148\u5165\u961f\uff0c\u7b49\u5f85bind\u5b8c\u6210\u518d\u6267\u884c 42. if (state.bindState !== BIND_STATE_BOUND) { 43. enqueue(this, this.send.bind(this, 44. list, 45. port, 46. address, 47. callback)); 48. return; 49. } 50. // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\uff0c\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\u540e\u53d1\u9001\u6570\u636e 51. const afterDns = (ex, ip) => { 52. defaultTriggerAsyncIdScope( 53. this[async_id_symbol], 54. doSend, 55. ex, this, ip, list, address, port, callback 56. ); 57. }; 58. // \u4f20\u4e86\u5730\u5740\u5219\u53ef\u80fd\u9700\u8981dns\u89e3\u6790 59. if (!connected) { 60. state.handle.lookup(address, afterDns); 61. } else { 62. afterDns(null, null); 63. } 64. } \u6211\u4eec\u7ee7\u7eed\u770bdoSend\u51fd\u6570\u3002 1. function doSend(ex, self, ip, list, address, port, callback) { 2. const state = self[kStateSymbol]; 3. // dns\u89e3\u6790\u51fa\u9519 4. if (ex) { 5. if (typeof callback === 'function') { 6. process.nextTick(callback, ex); 7. return; 8. } 9. process.nextTick(() => self.emit('error', ex)); 10. return; 11. } 12. // \u5b9a\u4e49\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61 13. const req = new SendWrap(); 14. req.list = list; // Keep reference alive. 15. req.address = address; 16. req.port = port; 17. /* 18. \u8bbe\u7f6eNode.js\u548c\u7528\u6237\u7684\u56de\u8c03\uff0concomplete\u7531C++\u5c42\u8c03\u7528\uff0c 19. callback\u7531oncomplete\u8c03\u7528 20. */ 21. if (callback) { 22. req.callback = callback; 23. req.oncomplete = afterSend; 24. } 25. 26. let err; 27. // \u6839\u636e\u662f\u5426\u9700\u8981\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\uff0c\u8c03C++\u5c42\u51fd\u6570 28. if (port) 29. err = state.handle.send(req, list, list.length, port, ip, !!callback); 30. else 31. err = state.handle.send(req, list, list.length, !!callback); 32. /* 33. err\u5927\u4e8e\u7b49\u4e8e1\u8bf4\u660e\u540c\u6b65\u53d1\u9001\u6210\u529f\u4e86\uff0c\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c 34. \u5426\u5219\u7b49\u5f85\u5f02\u6b65\u56de\u8c03 35. */ 36. if (err >= 1) { 37. if (callback) 38. process.nextTick(callback, null, err - 1); 39. return; 40. } 41. // \u53d1\u9001\u5931\u8d25 42. if (err && callback) { 43. const ex=exceptionWithHostPort(err, 'send', address, port); 44. process.nextTick(callback, ex); 45. } 46. } \u6211\u4eec\u7a7f\u8fc7C++\u5c42\uff0c\u76f4\u63a5\u770bLibuv\u7684\u4ee3\u7801\u3002 1. int uv__udp_send(uv_udp_send_t* req, 2. uv_udp_t* handle, 3. const uv_buf_t bufs[], 4. unsigned int nbufs, 5. const struct sockaddr* addr, 6. unsigned int addrlen, 7. uv_udp_send_cb send_cb) { 8. int err; 9. int empty_queue; 10. 11. assert(nbufs > 0); 12. // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u7ed1\u5b9a 13. if (addr) { 14. err = uv__udp_maybe_deferred_bind(handle, 15. addr->sa_family, 16. 0); 17. if (err) 18. return err; 19. } 20. // \u5f53\u524d\u5199\u961f\u5217\u662f\u5426\u4e3a\u7a7a 21. empty_queue = (handle->send_queue_count == 0); 22. // \u521d\u59cb\u5316\u4e00\u4e2a\u5199\u8bf7\u6c42 23. uv__req_init(handle->loop, req, UV_UDP_SEND); 24. if (addr == NULL) 25. req->addr.ss_family = AF_UNSPEC; 26. else 27. memcpy(&req->addr, addr, addrlen); 28. // \u4fdd\u5b58\u4e0a\u4e0b\u6587 29. req->send_cb = send_cb; 30. req->handle = handle; 31. req->nbufs = nbufs; 32. // \u521d\u59cb\u5316\u6570\u636e\uff0c\u9884\u5206\u914d\u7684\u5185\u5b58\u4e0d\u591f\uff0c\u5219\u5206\u914d\u65b0\u7684\u5806\u5185\u5b58 33. req->bufs = req->bufsml; 34. if (nbufs > ARRAY_SIZE(req->bufsml)) 35. req->bufs = uv__malloc(nbufs * sizeof(bufs[0])); 36. // \u590d\u5236\u8fc7\u53bb\u5806\u4e2d 37. memcpy(req->bufs, bufs, nbufs * sizeof(bufs[0])); 38. // \u66f4\u65b0\u5199\u961f\u5217\u6570\u636e 39. handle->send_queue_size += uv__count_bufs(req->bufs, 40. req->nbufs); 41. handle->send_queue_count++; 42. // \u63d2\u5165\u5199\u961f\u5217\uff0c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u53d1\u751f 43. QUEUE_INSERT_TAIL(&handle->write_queue, &req->queue); 44. uv__handle_start(handle); 45. // \u5f53\u524d\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u5f00\u59cb\u5199\uff0c\u5426\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u961f\u5217 46. if (empty_queue && 47. !(handle->flags & UV_HANDLE_UDP_PROCESSING)) { 48. // \u53d1\u9001\u6570\u636e 49. uv__udp_sendmsg(handle); 50. // \u5199\u961f\u5217\u662f\u5426\u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u53ef\u5199\u7684\u65f6\u5019\u63a5\u7740\u5199 51. if (!QUEUE_EMPTY(&handle->write_queue)) 52. uv__io_start(handle->loop, &handle->io_watcher, POLLOUT); 53. } else { 54. uv__io_start(handle->loop, &handle->io_watcher, POLLOUT); 55. } 56. return 0; 57. } \u8be5\u51fd\u6570\u9996\u5148\u8bb0\u5f55\u5199\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u628a\u5199\u8bf7\u6c42\u63d2\u5165\u5199\u961f\u5217\u4e2d\uff0c\u5f53\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u6267\u884cuv__udp_sendmsg\u8fdb\u884c\u5199\u64cd\u4f5c\uff0c\u5426\u5219\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u5230\u6765\uff0c\u5f53\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 1. static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) { 2. uv_udp_t* handle; 3. if (revents & POLLOUT) { 4. uv__udp_sendmsg(handle); 5. uv__udp_run_completed(handle); 6. } 7. } \u6211\u4eec\u5148\u770buv__udp_sendmsg 1. static void uv__udp_sendmsg(uv_udp_t* handle) { 2. uv_udp_send_t* req; 3. QUEUE* q; 4. struct msghdr h; 5. ssize_t size; 6. // \u9010\u4e2a\u8282\u70b9\u53d1\u9001 7. while (!QUEUE_EMPTY(&handle->write_queue)) { 8. q = QUEUE_HEAD(&handle->write_queue); 9. req = QUEUE_DATA(q, uv_udp_send_t, queue); 10. memset(&h, 0, sizeof h); 11. // \u5ffd\u7565\u53c2\u6570\u5904\u7406 12. h.msg_iov = (struct iovec*) req->bufs; 13. h.msg_iovlen = req->nbufs; 14. 15. do { 16. size = sendmsg(handle->io_watcher.fd, &h, 0); 17. } while (size == -1 && errno == EINTR); 18. 19. if (size == -1) { 20. // \u7e41\u5fd9\u5219\u5148\u4e0d\u53d1\u4e86\uff0c\u7b49\u5230\u53ef\u5199\u4e8b\u4ef6 21. if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS) 22. break; 23. } 24. // \u8bb0\u5f55\u53d1\u9001\u7ed3\u679c 25. req->status = (size == -1 ? UV__ERR(errno) : size); 26. // \u53d1\u9001\u201c\u5b8c\u201d\u79fb\u51fa\u5199\u961f\u5217 27. QUEUE_REMOVE(&req->queue); 28. // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 29. QUEUE_INSERT_TAIL(&handle->write_completed_queue, &req->queue); 30. /* 31. \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c 32. pending\u9636\u6bb5\u6267\u884c\u56de\u8c03uv__udp_io 33. */ 34. uv__io_feed(handle->loop, &handle->io_watcher); 35. } 36. } \u8be5\u51fd\u6570\u904d\u5386\u5199\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u53d1\u9001\u8282\u70b9\u4e2d\u7684\u6570\u636e\uff0c\u5e76\u8bb0\u5f55\u53d1\u9001\u7ed3\u679c\u3002 1 \u5982\u679c\u5199\u7e41\u5fd9\u5219\u7ed3\u675f\u5199\u903b\u8f91\uff0c\u7b49\u5f85\u4e0b\u4e00\u6b21\u5199\u4e8b\u4ef6\u89e6\u53d1\u3002 2 \u5982\u679c\u5199\u6210\u529f\u5219\u628a\u8282\u70b9\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\u3002 \u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 \u6211\u4eec\u518d\u6b21\u56de\u5230uv__udp_io\u4e2d 1. if (revents & POLLOUT) { 2. uv__udp_sendmsg(handle); 3. uv__udp_run_completed(handle); 4. } \u6211\u4eec\u770b\u5230\u8fd9\u65f6\u5019\u4f1a\u7ee7\u7eed\u6267\u884c\u6570\u636e\u53d1\u9001\u7684\u903b\u8f91\uff0c\u7136\u540e\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u3002\u6211\u4eec\u770buv__udp_run_completed\u3002 1. static void uv__udp_run_completed(uv_udp_t* handle) { 2. uv_udp_send_t* req; 3. QUEUE* q; 4. handle->flags |= UV_HANDLE_UDP_PROCESSING; 5. // \u9010\u4e2a\u8282\u70b9\u5904\u7406 6. while (!QUEUE_EMPTY(&handle->write_completed_queue)) { 7. q = QUEUE_HEAD(&handle->write_completed_queue); 8. QUEUE_REMOVE(q); 9. req = QUEUE_DATA(q, uv_udp_send_t, queue); 10. uv__req_unregister(handle->loop, req); 11. // \u66f4\u65b0\u5f85\u5199\u6570\u636e\u5927\u5c0f 12. handle->send_queue_size -= uv__count_bufs(req->bufs, req->nbufs); 13. handle->send_queue_count--; 14. // \u5982\u679c\u91cd\u65b0\u7533\u8bf7\u4e86\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e 15. if (req->bufs != req->bufsml) 16. uv__free(req->bufs); 17. req->bufs = NULL; 18. if (req->send_cb == NULL) 19. continue; 20. // \u6267\u884c\u56de\u8c03 21. if (req->status >= 0) 22. req->send_cb(req, 0); 23. else 24. req->send_cb(req, req->status); 25. } 26. // \u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 27. if (QUEUE_EMPTY(&handle->write_queue)) { 28. uv__io_stop(handle->loop, &handle->io_watcher, POLLOUT); 29. if (!uv__io_active(&handle->io_watcher, POLLIN)) 30. uv__handle_stop(handle); 31. } 32. handle->flags &= ~UV_HANDLE_UDP_PROCESSING; 33. } \u8fd9\u5c31\u662f\u53d1\u9001\u7684\u903b\u8f91\uff0c\u53d1\u9001\u5b8c\u540eLibuv\u4f1a\u8c03\u7528C++\u56de\u8c03\uff0c\u6700\u540e\u56de\u8c03JS\u5c42\u56de\u8c03\u3002\u5177\u4f53\u5230\u64cd\u4f5c\u7cfb\u7edf\u4e5f\u662f\u7c7b\u4f3c\u7684\u5b9e\u73b0\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u5224\u65ad\u6570\u636e\u7684\u5927\u5c0f\u662f\u5426\u5c0f\u4e8e\u5199\u7f13\u51b2\u533a\uff0c\u662f\u7684\u8bdd\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u6784\u9020UDP\u534f\u8bae\u6570\u636e\u5305\uff0c\u518d\u9010\u5c42\u5f80\u4e0b\u8c03\uff0c\u6700\u540e\u53d1\u9001\u51fa\u6765\uff0c\u4f46\u662f\u5982\u679c\u6570\u636e\u8d85\u8fc7\u4e86\u5e95\u5c42\u7684\u62a5\u6587\u5927\u5c0f\u9650\u5236\uff0c\u5219\u4f1a\u88ab\u5206\u7247\u3002 16.2.4 \u63a5\u6536\u6570\u636e \u00b6 UDP\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u6ce8\u518c\u4e86\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u7684\u53d1\u9001\uff0c\u5982\u679c\u6536\u5230\u4e86\u6570\u636e\uff0c\u5219\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u88ab\u5904\u7406\u3002\u524d\u9762\u6211\u4eec\u8bb2\u8fc7\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__udp_io\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8be5\u51fd\u6570\u600e\u4e48\u5904\u7406\u7684\u3002 1. static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) { 2. uv_udp_t* handle; 3. 4. handle = container_of(w, uv_udp_t, io_watcher); 5. // \u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1 6. if (revents & POLLIN) 7. uv__udp_recvmsg(handle); 8. } \u6211\u4eec\u770buv__udp_recvmsg\u7684\u903b\u8f91\u3002 1. static void uv__udp_recvmsg(uv_udp_t* handle) { 2. struct sockaddr_storage peer; 3. struct msghdr h; 4. ssize_t nread; 5. uv_buf_t buf; 6. int flags; 7. int count; 8. 9. count = 32; 10. 11. do { 12. // \u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\uff0cC++\u5c42\u8bbe\u7f6e\u7684 13. buf = uv_buf_init(NULL, 0); 14. handle->alloc_cb((uv_handle_t*) handle, 64 * 1024, &buf); 15. memset(&h, 0, sizeof(h)); 16. memset(&peer, 0, sizeof(peer)); 17. h.msg_name = &peer; 18. h.msg_namelen = sizeof(peer); 19. h.msg_iov = (void*) &buf; 20. h.msg_iovlen = 1; 21. // \u8c03\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u8bfb\u53d6\u6570\u636e 22. do { 23. nread = recvmsg(handle->io_watcher.fd, &h, 0); 24. } 25. while (nread == -1 && errno == EINTR); 26. // \u8c03\u7528C++\u5c42\u56de\u8c03 27. handle->recv_cb(handle, 28. nread, 29. &buf, 30. (const struct sockaddr*) &peer, 31. flags); 32. } 33. } \u6700\u7ec8\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u8c03\u7528recvmsg\u8bfb\u53d6\u6570\u636e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2audp\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\uff0c\u5982\u679c\u63a5\u6536\u961f\u5217\u6ee1\u4e86\u5219\u4f1a\u4e22\u5f03\uff0c\u5f53\u7528\u6237\u8c03\u7528recvmsg\u51fd\u6570\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u628a\u63a5\u6536\u961f\u5217\u4e2d\u8282\u70b9\u9010\u4e2a\u8fd4\u56de\u7ed9\u7528\u6237\u3002\u8bfb\u53d6\u5b8c\u540e\uff0cLibuv\u4f1a\u56de\u8c03C++\u5c42\uff0c\u7136\u540eC++\u5c42\u56de\u8c03\u5230JS\u5c42\uff0c\u6700\u540e\u89e6\u53d1message\u4e8b\u4ef6\uff0c\u8fd9\u5c31\u662f\u5bf9\u5e94\u5f00\u59cb\u90a3\u6bb5\u4ee3\u7801\u7684message\u4e8b\u4ef6\u3002 16.2.5 \u591a\u64ad \u00b6 \u6211\u4eec\u77e5\u9053\uff0cTCP\u662f\u57fa\u4e8e\u8fde\u63a5\u548c\u53ef\u9760\u7684\uff0c\u591a\u64ad\u5219\u4f1a\u5e26\u6765\u8fc7\u591a\u7684\u8fde\u63a5\u548c\u6d41\u91cf\uff0c\u6240\u4ee5TCP\u662f\u4e0d\u652f\u6301\u591a\u64ad\u7684\uff0c\u800cUDP\u5219\u652f\u6301\u591a\u64ad\u3002\u591a\u64ad\u5206\u4e3a\u5c40\u57df\u7f51\u591a\u64ad\u548c\u5e7f\u57df\u7f51\u591a\u64ad\uff0c\u6211\u4eec\u77e5\u9053\u5728\u5c40\u57df\u7f51\u5185\u53d1\u751f\u4e00\u4e2a\u6570\u636e\uff0c\u662f\u4f1a\u4ee5\u5e7f\u64ad\u7684\u5f62\u5f0f\u53d1\u9001\u5230\u5404\u4e2a\u4e3b\u673a\u7684\uff0c\u4e3b\u673a\u6839\u636e\u76ee\u7684\u5730\u5740\u5224\u65ad\u662f\u5426\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u5355\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u53ea\u4f1a\u6709\u4e00\u4e2a\u4e3b\u673a\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u591a\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u6709\u591a\u4e2a\u4e3b\u673a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u591a\u64ad\u7684\u65f6\u5019\uff0c\u5b58\u5728\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u6982\u5ff5\uff0c\u8fd9\u5c31\u662fIGMP\u505a\u7684\u4e8b\u60c5\u3002\u5b83\u5b9a\u4e49\u4e86\u7ec4\u7684\u6982\u5ff5\u3002\u53ea\u6709\u52a0\u5165\u8fd9\u4e2a\u7ec4\u7684\u4e3b\u673a\u624d\u80fd\u5904\u7406\u8be5\u7ec4\u7684\u6570\u636e\u5305\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5c40\u57df\u7f51\uff0c\u5982\u56fe16-1\u6240\u793a\u3002 \u56fe16-1 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e3b\u673a4\u53ef\u4ee5\u6536\u5230\uff0c\u4e3b\u673a2\uff0c3\u5219\u65e0\u6cd5\u6536\u5230\u3002 \u6211\u4eec\u518d\u6765\u770b\u770b\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u3002\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u9700\u8981\u8def\u7531\u5668\u7684\u652f\u6301\uff0c\u591a\u4e2a\u8def\u7531\u5668\u4e4b\u95f4\u4f1a\u4f7f\u7528\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u591a\u64ad\u7ec4\u7684\u4fe1\u606f\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5e7f\u57df\u7f51\uff0c\u5982\u56fe16-2\u6240\u793a\u3002 \u56fe16-2 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u8def\u7531\u56681\u4f1a\u7ed9\u8def\u7531\u56682\u53d1\u9001\u4e00\u4efd\u6570\u636e\uff08\u901a\u8fc7\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u4e86\u4fe1\u606f\uff0c\u8def\u75311\u77e5\u9053\u8def\u7531\u56682\u7684\u4e3b\u673a7\u5728\u591a\u64ad\u7ec41\u4e2d\uff09\uff0c\u4f46\u662f\u8def\u7531\u56682\u4e0d\u4f1a\u7ed9\u8def\u7531\u56683\u53d1\u9001\u6570\u636e\uff0c\u56e0\u4e3a\u5b83\u77e5\u9053\u8def\u7531\u56683\u5bf9\u5e94\u7684\u7f51\u7edc\u4e2d\u6ca1\u6709\u4e3b\u673a\u5728\u591a\u64ad\u7ec41\u3002 \u4ee5\u4e0a\u662f\u591a\u64ad\u7684\u4e00\u4e9b\u6982\u5ff5\u3002Node.js\u4e2d\u5173\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\uff0c\u57fa\u672c\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u6240\u4ee5\u5c31\u4e0d\u6253\u7b97\u8bb2\u89e3\uff0c\u6211\u4eec\u76f4\u63a5\u770b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5bf9\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\u3002 16.2.5.1 \u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4 \u00b6 \u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u63a5\u53e3\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002 1. setsockopt(fd, 2. IPPROTO_IP, 3. IP_ADD_MEMBERSHIP, 4. &mreq, // \u8bb0\u5f55\u51fa\u53e3ip\u548c\u52a0\u5165\u591a\u64ad\u7ec4\u7684ip 5. sizeof(mreq)); mreq\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b 1. struct ip_mreq 2. { 3. // \u52a0\u5165\u7684\u591a\u64ad\u7ec4ip 4. struct in_addr imr_multiaddr; 5. // \u51fa\u53e3ip 6. struct in_addr imr_interface; 7. }; \u6211\u4eec\u770b\u4e00\u4e0bsetsockopt\u7684\u5b9e\u73b0\uff08\u53ea\u5217\u51fa\u76f8\u5173\u90e8\u5206\u4ee3\u7801\uff09 1. case IP_ADD_MEMBERSHIP: 2. { 3. struct ip_mreq mreq; 4. static struct options optmem; 5. unsigned long route_src; 6. struct rtable *rt; 7. struct device *dev=NULL; 8. err=verify_area(VERIFY_READ, optval, sizeof(mreq)); 9. memcpy_fromfs(&mreq,optval,sizeof(mreq)); 10. // \u6ca1\u6709\u8bbe\u7f6edevice\u5219\u6839\u636e\u591a\u64ad\u7ec4ip\u9009\u62e9\u4e00\u4e2adevice 11. if(mreq.imr_interface.s_addr==INADDR_ANY) 12. { 13. if((rt=ip_rt_route(mreq.imr_multiaddr.s_addr, 14. &optmem, &route_src))!=NULL) 15. { 16. dev=rt->rt_dev; 17. rt->rt_use--; 18. } 19. } 20. else 21. { 22. // \u6839\u636e\u8bbe\u7f6e\u7684ip\u627e\u5230\u5bf9\u5e94\u7684device 23. for(dev = dev_base; dev; dev = dev->next) 24. { 25. // \u5728\u5de5\u4f5c\u72b6\u6001\u3001\u652f\u6301\u591a\u64ad\uff0cip\u4e00\u6837 26. if((dev->flags&IFF_UP)&& 27. (dev->flags&IFF_MULTICAST)&& 28. (dev->pa_addr==mreq.imr_interface.s_addr 29. )) 30. break; 31. } 32. } 33. // \u52a0\u5165\u591a\u64ad\u7ec4 34. return ip_mc_join_group(sk, 35. dev, 36. mreq.imr_multiaddr.s_addr); 37. } 38. \u9996\u5148\u62ff\u5230\u52a0\u5165\u7684\u591a\u64ad\u7ec4IP\u548c\u51fa\u53e3IP\u5bf9\u5e94\u7684device\u540e\uff0c\u8c03\u7528ip_mc_join_group\uff0c\u5728socket\u7ed3\u6784\u4f53\u4e2d\uff0c\u6709\u4e00\u4e2a\u5b57\u6bb5\u7ef4\u62a4\u4e86\u8be5socket\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-3\u6240\u793a\u3002 \u56fe16-3 \u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bip_mc_join_group 1. int ip_mc_join_group(struct sock *sk , 2. struct device *dev, 3. unsigned long addr) 4. { 5. int unused= -1; 6. int i; 7. // \u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u591a\u64ad\u7ec4\u5219\u5206\u914d\u4e00\u4e2aip_mc_socklist\u7ed3\u6784\u4f53 8. if(sk->ip_mc_list==NULL) 9. { 10. if((sk->ip_mc_list=(struct ip_mc_socklist *)kmalloc(sizeof(*sk->ip_mc_list), GFP_KERNEL))==NULL) 11. return -ENOMEM; 12. memset(sk->ip_mc_list,'\\0',sizeof(*sk->ip_mc_list)); 13. } 14. // \u904d\u5386\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u52a0\u5165\u8fc7 15. for(i=0;i<IP_MAX_MEMBERSHIPS;i++) 16. { 17. if(sk->ip_mc_list->multiaddr[i]==addr && 18. sk->ip_mc_list->multidev[i]==dev) 19. return -EADDRINUSE; 20. if(sk->ip_mc_list->multidev[i]==NULL) 21. // \u8bb0\u5f55\u53ef\u7528\u4f4d\u7f6e\u7684\u7d22\u5f15 22. unused=i; 23. } 24. // \u5230\u8fd9\u8bf4\u660e\u6ca1\u6709\u52a0\u5165\u8fc7\u5f53\u524d\u8bbe\u7f6e\u7684\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u4e14\u52a0\u5165 25. if(unused==-1) 26. return -ENOBUFS; 27. sk->ip_mc_list->multiaddr[unused]=addr; 28. sk->ip_mc_list->multidev[unused]=dev; 29. // addr\u4e3a\u591a\u64ad\u7ec4ip 30. ip_mc_inc_group(dev,addr); 31. return 0; 32. } ip_mc_join_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u628asocket\u60f3\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\u8bb0\u5f55\u5230socket\u7684ip_mc_list\u5b57\u6bb5\u4e2d\uff08\u5982\u679c\u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\u7684\u8bdd\uff09\u3002\u63a5\u7740\u8c03ip_mc_inc_group\u5f80\u4e0b\u8d70\u3002device\u7684ip_mc_list\u5b57\u6bb5\u7ef4\u62a4\u4e86\u4e3b\u673a\u4e2d\u4f7f\u7528\u4e86\u8be5device\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-4\u6240\u793a\u3002 \u56fe16-4 1. static void ip_mc_inc_group(struct device *dev, 2. unsigned long addr) 3. { 4. struct ip_mc_list *i; 5. /* 6. \u904d\u5386\u8be5\u8bbe\u5907\u7ef4\u62a4\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c 7. \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\uff0c\u662f\u5219\u5f15\u7528\u6570\u52a0\u4e00 8. */ 9. for(i=dev->ip_mc_list;i!=NULL;i=i->next) 10. { 11. if(i->multiaddr==addr) 12. { 13. i->users++; 14. return; 15. } 16. } 17. // \u5230\u8fd9\u8bf4\u660e\uff0c\u8fd8\u6ca1\u6709socket\u52a0\u5165\u8fc7\u5f53\u524d\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u52a0\u5165 18. i=(struct ip_mc_list *)kmalloc(sizeof(*i), GFP_KERNEL); 19. if(!i) 20. return; 21. i->users=1; 22. i->interface=dev; 23. i->multiaddr=addr; 24. i->next=dev->ip_mc_list; 25. // \u901a\u8fc7igmp\u901a\u77e5\u5176\u5b83\u65b9 26. igmp_group_added(i); 27. dev->ip_mc_list=i; 28. } ip_mc_inc_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u5224\u65adsocket\u60f3\u8981\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u662f\u4e0d\u662f\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524ddevice\u4e2d\uff0c\u5982\u679c\u4e0d\u662f\u5219\u65b0\u589e\u4e00\u4e2a\u8282\u70b9\u3002\u7ee7\u7eed\u8c03\u7528igmp_group_added 1. static void igmp_group_added(struct ip_mc_list *im) 2. { 3. // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 4. igmp_init_timer(im); 5. /* 6. \u53d1\u9001\u4e00\u4e2aigmp\u6570\u636e\u5305\uff0c\u540c\u6b65\u591a\u64ad\u7ec4\u4fe1\u606f\uff08socket\u52a0\u5165 7. \u4e86\u4e00\u4e2a\u65b0\u7684\u591a\u64ad\u7ec4\uff09 8. */ 9. igmp_send_report(im->interface, 10. im->multiaddr, 11. IGMP_HOST_MEMBERSHIP_REPORT); 12. // \u8f6c\u6362\u591a\u64ad\u7ec4ip\u5230\u591a\u64admac\u5730\u5740\uff0c\u5e76\u8bb0\u5f55\u5230device\u4e2d 13. ip_mc_filter_add(im->interface, im->multiaddr); 14. } \u6211\u4eec\u770b\u770bigmp_send_report\u548cip_mc_filter_add\u7684\u5177\u4f53\u903b\u8f91\u3002 1. static void igmp_send_report(struct device *dev, 2. unsigned long address, 3. int type) 4. { 5. // \u7533\u8bf7\u4e00\u4e2askb\u8868\u793a\u4e00\u4e2a\u6570\u636e\u5305 6. struct sk_buff *skb=alloc_skb(MAX_IGMP_SIZE, GFP_ATOMIC); 7. int tmp; 8. struct igmphdr *igh; 9. /* 10. \u6784\u5efaip\u5934\uff0cip\u534f\u8bae\u5934\u7684\u6e90ip\u662fINADDR_ANY\uff0c 11. \u5373\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u672c\u673a\u7684\uff0c\u76ee\u7684ip\u4e3a\u591a\u64ad\u7ec4ip\uff08address\uff09 12. */ 13. tmp=ip_build_header(skb, 14. INADDR_ANY, 15. address, 16. &dev, 17. IPPROTO_IGMP, 18. NULL, 19. skb->mem_len, 0, 1); 20. /* 21. data\u8868\u793a\u6240\u6709\u7684\u6570\u636e\u90e8\u5206\uff0ctmp\u8868\u793aip\u5934\u5927\u5c0f\uff0c\u6240\u4ee5igh 22. \u5c31\u662fip\u534f\u8bae\u7684\u6570\u636e\u90e8\u5206\uff0c\u5373igmp\u62a5\u6587\u7684\u5185\u5bb9 23. */ 24. igh=(struct igmphdr *)(skb->data+tmp); 25. skb->len=tmp+sizeof(*igh); 26. igh->csum=0; 27. igh->unused=0; 28. igh->type=type; 29. igh->group=address; 30. igh->csum=ip_compute_csum((void *)igh,sizeof(*igh)); 31. // \u8c03\u7528ip\u5c42\u53d1\u9001\u51fa\u53bb 32. ip_queue_xmit(NULL,dev,skb,1); 33. } igmp_send_report\u5176\u5b9e\u5c31\u662f\u6784\u9020\u4e00\u4e2aIGMP\u534f\u8bae\u6570\u636e\u5305\uff0c\u7136\u540e\u53d1\u9001\u51fa\u53bb\uff0c\u544a\u8bc9\u8def\u7531\u5668\u67d0\u4e2a\u4e3b\u673a\u52a0\u5165\u4e86\u591a\u64ad\u7ec4\uff0cIGMP\u7684\u534f\u8bae\u683c\u5f0f\u5982\u4e0b 1. struct igmphdr 2. { 3. // \u7c7b\u578b 4. unsigned char type; 5. unsigned char unused; 6. // \u6821\u9a8c\u548c 7. unsigned short csum; 8. // igmp\u7684\u6570\u636e\u90e8\u5206\uff0c\u6bd4\u5982\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0cgroup\u8868\u793a\u591a\u64ad\u7ec4ip 9. unsigned long group; 10. }; \u63a5\u7740\u6211\u4eec\u770bip_mc_filter_add 1. void ip_mc_filter_add(struct device *dev, unsigned long addr) 2. { 3. char buf[6]; 4. // \u628a\u591a\u64ad\u7ec4ip\u8f6c\u6210mac\u591a\u64ad\u5730\u5740 5. addr=ntohl(addr); 6. buf[0]=0x01; 7. buf[1]=0x00; 8. buf[2]=0x5e; 9. buf[5]=addr&0xFF; 10. addr>>=8; 11. buf[4]=addr&0xFF; 12. addr>>=8; 13. buf[3]=addr&0x7F; 14. dev_mc_add(dev,buf,ETH_ALEN,0); 15. } \u6211\u4eec\u77e5\u9053IP\u5730\u5740\u662f32\u4f4d\uff0cmac\u5730\u5740\u662f48\u4f4d\uff0c\u4f46\u662fIANA\u89c4\u5b9a\uff0cIP V4\u7ec4\u64adMAC\u5730\u5740\u7684\u9ad824\u4f4d\u662f0x01005E\uff0c\u7b2c25\u4f4d\u662f0\uff0c\u4f4e23\u4f4d\u662fipv4\u7ec4\u64ad\u5730\u5740\u7684\u4f4e23\u4f4d\u3002\u800c\u591a\u64ad\u7684IP\u5730\u5740\u9ad8\u56db\u4f4d\u56fa\u5b9a\u662f1110\u3002\u53e6\u5916\u4f4e23\u4f4d\u88ab\u6620\u5c04\u5230MAC\u591a\u64ad\u5730\u5740\u768423\u4f4d\uff0c\u6240\u4ee5\u591a\u64adIP\u5730\u5740\u4e2d\uff0c\u67095\u4f4d\u662f\u53ef\u4ee5\u968f\u673a\u7ec4\u5408\u7684\u3002\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u6bcf32\u4e2a\u591a\u64adIP\u5730\u5740\uff0c\u6620\u5c04\u5230\u4e00\u4e2aMAC\u5730\u5740\u3002\u8fd9\u4f1a\u5e26\u6765\u4e00\u4e9b\u95ee\u9898\uff0c\u5047\u8bbe\u4e3b\u673ax\u52a0\u5165\u4e86\u591a\u64ad\u7ec4a\uff0c\u4e3b\u673ay\u52a0\u5165\u4e86\u591a\u64ad\u7ec4b\uff0c\u800ca\u548cb\u5bf9\u5e94\u7684mac\u591a\u64ad\u5730\u5740\u662f\u4e00\u6837\u7684\u3002\u5f53\u4e3b\u673az\u7ed9\u591a\u64ad\u7ec4a\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8fd9\u65f6\u5019\u4e3b\u673ax\u548cy\u7684\u7f51\u5361\u90fd\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\uff0c\u5e76\u4e0a\u62a5\u5230\u4e0a\u5c42\uff0c\u4f46\u662f\u591a\u64ad\u7ec4a\u5bf9\u5e94\u7684MAC\u591a\u64ad\u5730\u5740\u548c\u591a\u64ad\u7ec4b\u662f\u4e00\u6837\u7684\u3002\u6211\u4eec\u62ff\u5230\u4e00\u4e2a\u591a\u64ad\u7ec4ip\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u8ba1\u7b97\u51fa\u5b83\u7684\u591a\u64adMAC\u5730\u5740\uff0c\u4f46\u662f\u53cd\u8fc7\u6765\u5c31\u4e0d\u884c\uff0c\u56e0\u4e3a\u4e00\u4e2a\u591a\u64admac\u5730\u5740\u5bf9\u5e94\u4e8632\u4e2a\u591a\u64adip\u5730\u5740\u3002\u90a3\u4e3b\u673ax\u548cy\u600e\u4e48\u5224\u65ad\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff1f\u56e0\u4e3adevice\u7ef4\u62a4\u4e86\u4e00\u4e2a\u672cdevice\u4e0a\u7684\u591a\u64adIP\u5217\u8868\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u6536\u5230\u7684\u6570\u636e\u5305\u4e2d\u7684IP\u76ee\u7684\u5730\u5740\u548cdevice\u7684\u591a\u64adIP\u5217\u8868\u5bf9\u6bd4\u3002\u5982\u679c\u5728\u5217\u8868\u4e2d\uff0c\u5219\u8bf4\u660e\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u770bdev_mc_add\u3002device\u4e2d\u7ef4\u62a4\u4e86\u5f53\u524d\u7684mac\u591a\u64ad\u5730\u5740\u5217\u8868\uff0c\u5b83\u4f1a\u628a\u8fd9\u4e2a\u5217\u8868\u4fe1\u606f\u540c\u6b65\u5230\u7f51\u5361\u4e2d\uff0c\u4f7f\u5f97\u7f51\u5361\u53ef\u4ee5\u5904\u7406\u8be5\u5217\u8868\u4e2d\u591a\u64admac\u5730\u5740\u7684\u6570\u636e\u5305\uff0c\u5982\u56fe16-5\u6240\u793a\u3002 \u56fe16-5 1. void dev_mc_add(struct device *dev, void *addr, int alen, int newonly) 2. { 3. struct dev_mc_list *dmi; 4. // device\u7ef4\u62a4\u7684\u591a\u64admac\u5730\u5740\u5217\u8868 5. for(dmi=dev->mc_list;dmi!=NULL;dmi=dmi->next) 6. { 7. // \u5df2\u5b58\u5728\uff0c\u5219\u5f15\u7528\u8ba1\u6570\u52a0\u4e00 8. if(memcmp(dmi->dmi_addr,addr,dmi->dmi_addrlen)==0 && 9. dmi->dmi_addrlen==alen) 10. { 11. if(!newonly) 12. dmi->dmi_users++; 13. return; 14. } 15. } 16. // \u4e0d\u5b58\u5728\u5219\u65b0\u589e\u4e00\u4e2a\u9879\u5230device\u5217\u8868\u4e2d 17. dmi=(struct dev_mc_list *)kmalloc(sizeof(*dmi),GFP_KERNEL); 18. memcpy(dmi->dmi_addr, addr, alen); 19. dmi->dmi_addrlen=alen; 20. dmi->next=dev->mc_list; 21. dmi->dmi_users=1; 22. dev->mc_list=dmi; 23. dev->mc_count++; 24. // \u901a\u77e5\u7f51\u5361\u9700\u8981\u5904\u7406\u8be5\u591a\u64admac\u5730\u5740 25. dev_mc_upload(dev); 26. } \u7f51\u5361\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u51e0\u79cd\uff0c\u5206\u522b\u662f\u6b63\u5e38\u6a21\u5f0f\uff08\u53ea\u63a5\u6536\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff09\u3001\u6df7\u6742\u6a21\u5f0f\uff08\u63a5\u6536\u6240\u6709\u6570\u636e\u5305\uff09\u3001\u591a\u64ad\u6a21\u5f0f\uff08\u63a5\u6536\u4e00\u822c\u6570\u636e\u5305\u548c\u591a\u64ad\u6570\u636e\u5305\uff09\u3002\u7f51\u5361\u9ed8\u8ba4\u662f\u53ea\u5904\u7406\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u7f51\u5361\uff0c\u5f53\u6536\u5230\u8be5\u591a\u64ad\u7ec4\u7684\u6570\u636e\u5305\u65f6\uff0c\u9700\u8981\u5904\u7406\uff0c\u800c\u4e0d\u662f\u5ffd\u7565\u3002dev_mc_upload\u51fd\u6570\u5c31\u662f\u901a\u77e5\u7f51\u5361\u3002 1. void dev_mc_upload(struct device *dev) 2. { 3. struct dev_mc_list *dmi; 4. char *data, *tmp; 5. // \u4e0d\u5de5\u4f5c\u4e86 6. if(!(dev->flags&IFF_UP)) 7. return; 8. /* 9. \u5f53\u524d\u662f\u6df7\u6742\u6a21\u5f0f\uff0c\u5219\u4e0d\u9700\u8981\u8bbe\u7f6e\u591a\u64ad\u4e86\uff0c\u56e0\u4e3a\u7f51\u5361\u4f1a\u5904\u7406\u6240\u6709 10. \u6536\u5230\u7684\u6570\u636e\uff0c\u4e0d\u7ba1\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684 11. */ 12. if(dev->flags&IFF_PROMISC) 13. { 14. dev->set_multicast_list(dev, -1, NULL); 15. return; 16. } 17. /* 18. \u591a\u64ad\u5730\u5740\u4e2a\u6570\uff0c\u4e3a0\uff0c\u5219\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u4e3a\u6b63\u5e38\u6a21\u5f0f\uff0c 19. \u56e0\u4e3a\u4e0d\u9700\u8981\u5904\u7406\u591a\u64ad\u4e86 20. */ 21. if(dev->mc_count==0) 22. { 23. dev->set_multicast_list(dev,0,NULL); 24. return; 25. } 26. 27. data=kmalloc(dev->mc_count*dev->addr_len, GFP_KERNEL); 28. // \u590d\u5236\u6240\u6709\u7684\u591a\u64admac\u5730\u5740\u4fe1\u606f 29. for(tmp = data, dmi=dev->mc_list;dmi!=NULL;dmi=dmi->next) 30. { 31. memcpy(tmp,dmi->dmi_addr, dmi->dmi_addrlen); 32. tmp+=dev->addr_len; 33. } 34. // \u544a\u8bc9\u7f51\u5361 35. dev->set_multicast_list(dev,dev->mc_count,data); 36. kfree(data); 37. } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bset_multicast_list 1. static void set_multicast_list(struct device *dev, int num_addrs, void *addrs) 2. { 3. int ioaddr = dev->base_addr; 4. // \u591a\u64ad\u6a21\u5f0f 5. if (num_addrs > 0) { 6. outb(RX_MULT, RX_CMD); 7. inb(RX_STATUS); /* Clear status. */ 8. } else if (num_addrs < 0) { // \u6df7\u6742\u6a21\u5f0f 9. outb(RX_PROM, RX_CMD); 10. inb(RX_STATUS); 11. } else { // \u6b63\u5e38\u6a21\u5f0f 12. outb(RX_NORM, RX_CMD); 13. inb(RX_STATUS); 14. } 15. } set_multicast_list\u5c31\u662f\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u7684\u51fd\u6570\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u6210\u529f\u52a0\u5165\u4e86\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002\u79bb\u5f00\u4e00\u4e2a\u591a\u64ad\u7ec4\u4e5f\u662f\u7c7b\u4f3c\u7684\u8fc7\u7a0b\u3002 16.2.5.2 \u7ef4\u62a4\u591a\u64ad\u7ec4\u4fe1\u606f \u00b6 \u52a0\u5165\u591a\u64ad\u7ec4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u9000\u51fa\u591a\u64ad\u7ec4\uff0c\u4f46\u662f\u5982\u679c\u4e3b\u673a\u6302\u4e86\uff0c\u5c31\u65e0\u6cd5\u4e3b\u52a8\u9000\u51fa\u4e86\uff0c\u6240\u4ee5\u591a\u64ad\u8def\u7531\u4e5f\u4f1a\u5b9a\u671f\u5411\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\uff0c\u6240\u4ee5\u4e3b\u673a\u9700\u8981\u76d1\u542c\u6765\u81ea\u591a\u64ad\u8def\u7531\u7684\u63a2\u6d4b\u62a5\u6587\u3002 1. void ip_mc_allhost(struct device *dev) 2. { 3. struct ip_mc_list *i; 4. for(i=dev->ip_mc_list;i!=NULL;i=i->next) 5. if(i->multiaddr==IGMP_ALL_HOSTS) 6. return; 7. i=(struct ip_mc_list *)kmalloc(sizeof(*i), GFP_KERNEL); 8. if(!i) 9. return; 10. I ->users=1; 11. i->interface=dev; 12. i->multiaddr=IGMP_ALL_HOSTS; 13. i->next=dev->ip_mc_list; 14. dev->ip_mc_list=i; 15. ip_mc_filter_add(i->interface, i->multiaddr); 16. } \u8bbe\u5907\u542f\u52a8\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8bbe\u7f6e\u7f51\u5361\u76d1\u542c\u76ee\u7684IP\u662f224.0.0.1\u7684\u62a5\u6587\uff0c\u4f7f\u5f97\u53ef\u4ee5\u5904\u7406\u76ee\u7684IP\u662f224.0.0.1\u7684\u591a\u64ad\u6d88\u606f\u3002\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u662f\u591a\u64ad\u8def\u7531\u7528\u4e8e\u67e5\u8be2\u5c40\u57df\u7f51\u5f53\u524d\u591a\u64ad\u7ec4\u60c5\u51b5\u7684\uff0c\u6bd4\u5982\u67e5\u8be2\u54ea\u4e9b\u591a\u64ad\u7ec4\u5df2\u7ecf\u6ca1\u6709\u6210\u5458\u4e86\uff0c\u5982\u679c\u6ca1\u6709\u6210\u5458\u5219\u5220\u9664\u8def\u7531\u4fe1\u606f\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u5904\u7406\u67d0\u8bbe\u5907\u7684IGMP\u62a5\u6587\u3002 1. int igmp_rcv(struct sk_buff *skb, struct device *dev, struct options *opt, 2. unsigned long daddr, unsigned short len, unsigned long saddr, int redo, 3. struct inet_protocol *protocol) 4. { 5. // IGMP\u62a5\u5934 6. struct igmphdr *igh=(struct igmphdr *)skb->h.raw; 7. // \u8be5\u6570\u636e\u5305\u662f\u53d1\u7ed9\u6240\u6709\u591a\u64ad\u4e3b\u673a\u7684\uff0c\u7528\u4e8e\u67e5\u8be2\u672c\u591a\u64ad\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458 8. if(igh->type==IGMP_HOST_MEMBERSHIP_QUERY && daddr==IGMP_ALL_HOSTS) 9. igmp_heard_query(dev); 10. // \u8be5\u6570\u636e\u5305\u662f\u5176\u5b83\u6210\u5458\u5bf9\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u4e5f\u4f1a\u6536\u5230 11. if(igh->type==IGMP_HOST_MEMBERSHIP_REPORT && daddr==igh->group) 12. igmp_heard_report(dev,igh->group); 13. kfree_skb(skb, FREE_READ); 14. return 0; 15. } IGMP V1\u53ea\u5904\u7406\u4e24\u79cd\u62a5\u6587\uff0c\u5206\u522b\u662f\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\uff08\u67e5\u8be2\u7ec4\u662f\u5426\u6709\u6210\u5458\uff09\uff0c\u5176\u5b83\u6210\u5458\u56de\u590d\u591a\u64ad\u8def\u7531\u7684\u62a5\u544a\u62a5\u6587\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7531\u591a\u64ad\u8def\u7531\u53d1\u51fa\uff0c\u6240\u6709\u7684\u591a\u64ad\u7ec4\u4e2d\u7684\u6240\u6709\u4e3b\u673a\u90fd\u53ef\u4ee5\u6536\u5230\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7684IP\u534f\u8bae\u5934\u7684\u76ee\u7684\u5730\u5740\u662f224.0.0.1\uff08IGMP_ALL_HOSTS\uff09\uff0c\u4ee3\u8868\u6240\u6709\u7684\u7ec4\u64ad\u4e3b\u673a\u90fd\u53ef\u4ee5\u5904\u7406\u8be5\u62a5\u6587\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u79cd\u62a5\u6587\u7684\u5177\u4f53\u5b9e\u73b0\u3002 1. static void igmp_heard_query(struct device *dev) 2. { 3. struct ip_mc_list *im; 4. for(im=dev->ip_mc_list;im!=NULL;im=im->next) 5. // IGMP_ALL_HOSTS\u8868\u793a\u6240\u6709\u7ec4\u64ad\u4e3b\u673a 6. if(!im->tm_running && im->multiaddr!=IGMP_ALL_HOSTS) 7. igmp_start_timer(im); 8. } \u8be5\u51fd\u6570\u7528\u4e8e\u5904\u7406\u7ec4\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\uff0cdev->ip_mc_list\u662f\u8be5\u8bbe\u5907\u5bf9\u5e94\u7684\u6240\u6709\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u8fd9\u91cc\u9488\u5bf9\u8be5\u8bbe\u5907\u4e2d\u7684\u6bcf\u4e00\u4e2a\u591a\u64ad\u7ec4\uff0c\u5f00\u542f\u5bf9\u5e94\u7684\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u4f1a\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f00\u542f\u5b9a\u65f6\u5668\u7684\u903b\u8f91\u3002 1. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668 2. static void igmp_start_timer(struct ip_mc_list *im) 3. { 4. int tv; 5. if(im->tm_running) 6. return; 7. tv=random()%(10*HZ); /* Pick a number any number 8) */ 8. im->timer.expires=tv; 9. im->tm_running=1; 10. add_timer(&im->timer); 11. } \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u7136\u540e\u63d2\u5165\u7cfb\u7edf\u7ef4\u62a4\u7684\u5b9a\u65f6\u5668\u961f\u5217\u3002\u4e3a\u4ec0\u4e48\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u800c\u4e0d\u662f\u7acb\u5373\u56de\u590d\u5462\uff1f\u56e0\u4e3a\u591a\u64ad\u8def\u7531\u53ea\u9700\u8981\u77e5\u9053\u67d0\u4e2a\u591a\u64ad\u7ec4\u662f\u5426\u81f3\u5c11\u8fd8\u6709\u4e00\u4e2a\u6210\u5458\uff0c\u5982\u679c\u6709\u7684\u8bdd\u5c31\u4fdd\u5b58\u8be5\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5426\u5219\u5c31\u5220\u9664\u8def\u7531\u9879\u3002\u5982\u679c\u67d0\u591a\u64ad\u7ec4\u5728\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u6210\u5458\uff0c\u90a3\u4e48\u591a\u4e2a\u6210\u5458\u90fd\u4f1a\u5904\u7406\u8be5\u62a5\u6587\uff0c\u5982\u679c\u90fd\u7acb\u5373\u54cd\u5e94\uff0c\u5219\u4f1a\u5f15\u8d77\u8fc7\u591a\u6ca1\u6709\u5fc5\u8981\u7684\u6d41\u91cf\uff0c\u56e0\u4e3a\u7ec4\u64ad\u8def\u7531\u53ea\u9700\u8981\u6536\u5230\u4e00\u4e2a\u54cd\u5e94\u5c31\u884c\u3002\u6211\u4eec\u770b\u770b\u8d85\u65f6\u65f6\u7684\u903b\u8f91\u3002 1. static void igmp_init_timer(struct ip_mc_list *im) 2. { 3. im->tm_running=0; 4. init_timer(&im->timer); 5. im->timer.data=(unsigned long)im; 6. im->timer.function=&igmp_timer_expire; 7. } 8. 9. static void igmp_timer_expire(unsigned long data) 10. { 11. struct ip_mc_list *im=(struct ip_mc_list *)data; 12. igmp_stop_timer(im); 13. igmp_send_report(im->interface, im->multiaddr, IGMP_HOST_MEMBERSHIP_REPORT); 14. } \u6211\u4eec\u770b\u5230\uff0c\u8d85\u65f6\u540e\u4f1a\u6267\u884cigmp_send_report\u53d1\u9001\u4e00\u4e2a\u7c7b\u578b\u662fIGMP_HOST_MEMBERSHIP_REPORT\u7684IGMP\u3001\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\u7684\u62a5\u6587\uff0c\u8bf4\u660e\u8be5\u591a\u64ad\u7ec4\u8fd8\u6709\u6210\u5458\u3002\u8be5\u62a5\u6587\u4e0d\u4ec5\u4f1a\u53d1\u9001\u7ed9\u591a\u64ad\u8def\u7531\uff0c\u8fd8\u4f1a\u53d1\u7ed9\u540c\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u3002\u5176\u5b83\u4e3b\u673a\u4e5f\u662f\u7c7b\u4f3c\u7684\u903b\u8f91\uff0c\u5373\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u6240\u4ee5\u6700\u5feb\u5230\u671f\u7684\u4e3b\u673a\u4f1a\u5148\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u548c\u540c\u591a\u64ad\u7ec4\u7684\u6210\u5458\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5176\u5b83\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u62a5\u6587\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1. // \u6210\u5458\u62a5\u544a\u62a5\u6587\u5e76\u4e14\u591a\u64ad\u7ec4\u662f\u5f53\u524d\u8bbe\u7f6e\u5173\u8054\u7684\u591a\u64ad\u7ec4 2. if(igh->type==IGMP_HOST_MEMBERSHIP_REPORT && daddr==igh->group) 3. igmp_heard_report(dev,igh->group); \u5f53\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u9488\u5bf9\u591a\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\u4f5c\u4e86\u54cd\u5e94\uff0c\u56e0\u4e3a\u8be5\u54cd\u5e94\u62a5\u6587\u7684\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\uff0c\u6240\u4ee5\u8be5\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u4e5f\u80fd\u6536\u5230\u8be5\u62a5\u6587\u3002\u5f53\u67d0\u4e2a\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u7684\u65f6\u5019\uff0c\u5c31\u77e5\u9053\u540c\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u5df2\u7ecf\u56de\u590d\u4e86\u591a\u64ad\u8def\u7531\u4e86\uff0c\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u56de\u590d\u4e86\u3002 1. /* 2. \u6536\u5230\u5176\u5b83\u7ec4\u6210\u5458\uff0c\u5bf9\u4e8e\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u5219\u81ea\u5df1\u5c31\u4e0d\u7528\u56de\u590d\u4e86\uff0c 3. \u56e0\u4e3a\u591a\u64ad\u8def\u7531\u77e5\u9053\u8be5\u7ec4\u8fd8\u6709\u6210\u5458\uff0c\u4e0d\u4f1a\u5220\u9664\u8def\u7531\u4fe1\u606f\uff0c\u51cf\u5c11\u7f51\u7edc\u6d41\u91cf 4. */ 5. static void igmp_heard_report(struct device *dev, unsigned long address) 6. { 7. struct ip_mc_list *im; 8. for(im=dev->ip_mc_list;im!=NULL;im=im->next) 9. if(im->multiaddr==address) 10. igmp_stop_timer(im); 11. } \u6211\u4eec\u770b\u5230\uff0c\u8fd9\u91cc\u4f1a\u5220\u9664\u5b9a\u65f6\u5668\u3002\u5373\u4e0d\u4f1a\u4f5c\u4e3a\u54cd\u5e94\u4e86\u3002 2.3 \u5176\u5b83 socket\u5173\u95ed\uff0c \u9000\u51fa\u5b83\u4e4b\u524d\u52a0\u5165\u8fc7\u7684\u591a\u64ad 1. void ip_mc_drop_socket(struct sock *sk) 2. { 3. int i; 4. 5. if(sk->ip_mc_list==NULL) 6. return; 7. 8. for(i=0;i<IP_MAX_MEMBERSHIPS;i++) 9. { 10. if(sk->ip_mc_list->multidev[i]) 11. { 12. ip_mc_dec_group(sk->ip_mc_list->multidev[i], sk->ip_mc_list->multiaddr[i]); 13. sk->ip_mc_list->multidev[i]=NULL; 14. } 15. } 16. kfree_s(sk->ip_mc_list,sizeof(*sk->ip_mc_list)); 17. sk->ip_mc_list=NULL; 18. } \u8bbe\u5907\u505c\u6b62\u5de5\u4f5c\u4e86\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u591a\u64ad\u4fe1\u606f 1. void ip_mc_drop_device(struct device *dev) 2. { 3. struct ip_mc_list *i; 4. struct ip_mc_list *j; 5. for(i=dev->ip_mc_list;i!=NULL;i=j) 6. { 7. j=i->next; 8. kfree_s(i,sizeof(*i)); 9. } 10. dev->ip_mc_list=NULL; 11. } \u4ee5\u4e0a\u662fIGMP V1\u7248\u672c\u7684\u5b9e\u73b0\uff0c\u5728\u540e\u7eedV2 V3\u7248\u672c\u4e86\u53c8\u589e\u52a0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u6bd4\u5982\u79bb\u5f00\u7ec4\u62a5\u6587\uff0c\u9488\u5bf9\u79bb\u5f00\u62a5\u6587\u4e2d\u7684\u591a\u64ad\u7ec4\uff0c\u589e\u52a0\u7279\u5b9a\u7ec4\u67e5\u8be2\u62a5\u6587\uff0c\u7528\u4e8e\u67e5\u8be2\u67d0\u4e2a\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458\uff0c\u53e6\u5916\u8fd8\u6709\u8def\u7531\u9009\u4e3e\uff0c\u5f53\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u591a\u64ad\u8def\u7531\uff0c\u591a\u64ad\u8def\u7531\u4e4b\u95f4\u901a\u8fc7\u534f\u8bae\u9009\u4e3e\u51faIP\u6700\u5c0f\u7684\u8def\u7531\u4e3a\u67e5\u8be2\u8def\u7531\uff0c\u5b9a\u65f6\u7ed9\u591a\u64ad\u7ec4\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\u3002\u7136\u540e\u6210\u4e3a\u67e5\u8be2\u5668\u7684\u591a\u64ad\u8def\u7531\uff0c\u4f1a\u5b9a\u671f\u7ed9\u5176\u5b83\u591a\u64ad\u8def\u7531\u540c\u6b65\u5fc3\u8df3\u3002\u5426\u5219\u5176\u5b83\u591a\u64ad\u8def\u7531\u4f1a\u5728\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\u8ba4\u4e3a\u5f53\u524d\u67e5\u8be2\u8def\u7531\u5df2\u7ecf\u6302\u4e86\uff0c\u91cd\u65b0\u9009\u4e3e\u3002 16.2.5.3 \u5f00\u542f\u591a\u64ad \u00b6 UDP\u7684\u591a\u64ad\u80fd\u529b\u662f\u9700\u8981\u7528\u6237\u4e3b\u52a8\u5f00\u542f\u7684\uff0c\u539f\u56e0\u662f\u9632\u6b62\u7528\u6237\u53d1\u9001UDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8bef\u4f20\u4e86\u4e00\u4e2a\u591a\u64ad\u5730\u5740\uff0c\u4f46\u5176\u5b9e\u7528\u6237\u662f\u60f3\u53d1\u9001\u4e00\u4e2a\u5355\u64ad\u7684\u6570\u636e\u5305\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setBroadcast\u5f00\u542f\u591a\u64ad\u80fd\u529b\u3002\u6211\u4eec\u770bLibuv\u7684\u4ee3\u7801\u3002 1. int uv_udp_set_broadcast(uv_udp_t* handle, int on) { 2. if (setsockopt(handle->io_watcher.fd, 3. SOL_SOCKET, 4. SO_BROADCAST, 5. &on, 6. sizeof(on))) { 7. return UV__ERR(errno); 8. } 9. 10. return 0; 11. } \u518d\u770b\u770b\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 1. int sock_setsockopt(struct sock *sk, int level, int optname, 2. char *optval, int optlen){ 3. ... 4. case SO_BROADCAST: 5. sk->broadcast=val?1:0; 6. } \u6211\u4eec\u770b\u5230\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u6807\u8bb0\u4f4d\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6d88\u606f\u7684\u65f6\u5019\uff0c\u5982\u679c\u76ee\u7684\u5730\u5740\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u53c8\u6ca1\u6709\u8bbe\u7f6e\u8fd9\u4e2a\u6807\u8bb0\uff0c\u5219\u4f1a\u62a5\u9519\u3002 1. if(!sk->broadcast && ip_chk_addr(sin.sin_addr.s_addr)==IS_BROADCAST) 2. return -EACCES; \u4e0a\u9762\u4ee3\u7801\u6765\u81ea\u8c03\u7528udp\u7684\u53d1\u9001\u51fd\u6570\uff08\u4f8b\u5982sendto\uff09\u65f6\uff0c\u8fdb\u884c\u7684\u6821\u9a8c\uff0c\u5982\u679c\u53d1\u9001\u7684\u76ee\u7684ip\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u6ca1\u6709\u8bbe\u7f6e\u591a\u64ad\u6807\u8bb0\uff0c\u5219\u62a5\u9519\u3002 16.2.5.4 \u591a\u64ad\u7684\u95ee\u9898 \u00b6 \u670d\u52a1\u5668 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket('udp4'); 3. 4. udp.bind(1234, () => { 5. // \u5c40\u57df\u7f51\u591a\u64ad\u5730\u5740\uff08224.0.0.0~224.0.0.255\uff0c\u8be5\u8303\u56f4\u7684\u591a\u64ad\u6570\u636e\u5305\uff0c\u8def\u7531\u5668\u4e0d\u4f1a\u8f6c\u53d1\uff09 6. udp.addMembership('224.0.0.114'); 7. }); 8. 9. udp.on('message', (msg, rinfo) => { 10. console.log(`receive msg: ${msg} from ${rinfo.address}:${rinfo.port}`); 11. }); \u670d\u52a1\u5668\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u52a0\u5165\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u7b49\u5f85\u591a\u64ad\u6570\u636e\u7684\u5230\u6765\u3002 \u5ba2\u6237\u7aef 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket('udp4'); 3. udp.bind(1234, () => { 4. udp.addMembership('224.0.0.114'); 5. }); 6. udp.send('test', 1234, '224.0.0.114', (err) => {}); \u5ba2\u6237\u7aef\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u4e5f\u52a0\u5165\u4e86\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\uff0c\u4f46\u662f\u53d1\u73b0\u670d\u52a1\u7aef\u6ca1\u6709\u6536\u5230\u6570\u636e\uff0c\u5ba2\u6237\u7aef\u6253\u5370\u4e86receive msg test from 169.254.167.41:1234\u3002\u8fd9\u600e\u4e48\u591a\u4e86\u4e00\u4e2aIP\u51fa\u6765\uff1f\u539f\u6765\u6211\u4e3b\u673a\u6709\u4e24\u4e2a\u5c40\u57df\u7f51\u5730\u5740\u3002\u5f53\u6211\u4eec\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u4e0d\u4ec5\u53ef\u4ee5\u8bbe\u7f6e\u52a0\u5165\u54ea\u4e2a\u591a\u64ad\u7ec4\uff0c\u8fd8\u80fd\u8bbe\u7f6e\u51fa\u53e3\u7684\u8bbe\u5907\u548cIP\u3002\u5f53\u6211\u4eec\u8c03\u7528udp.addMembership('224.0.0.114')\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u662f\u8bbe\u7f6e\u4e86\u6211\u4eec\u52a0\u5165\u7684\u591a\u64ad\u7ec4\uff0c\u6ca1\u6709\u8bbe\u7f6e\u51fa\u53e3\u3002\u8fd9\u65f6\u5019\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u6211\u4eec\u9009\u62e9\u4e00\u4e2a\u3002\u6839\u636e\u8f93\u51fa\uff0c\u6211\u4eec\u53d1\u73b0\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u662f169.254.167.41\uff08\u5b50\u7f51\u63a9\u7801\u662f255.255.0.0\uff09\u3002\u56e0\u4e3a\u8fd9\u4e2aIP\u548c192\u5f00\u5934\u7684\u90a3\u4e2a\u4e0d\u662f\u540c\u4e00\u5b50\u7f51\uff0c\u4f46\u662f\u6211\u4eec\u52a0\u5165\u7684\u662f\u5c40\u57df\u7f51\u7684\u591a\u64adIP\uff0c\u6240\u6709\u670d\u52a1\u7aef\u65e0\u6cd5\u6536\u5230\u5ba2\u6237\u7aef\u53d1\u51fa\u7684\u6570\u636e\u5305\u3002\u4e0b\u9762\u662fNode.js\u6587\u6863\u7684\u89e3\u91ca\u3002 Tells the kernel to join a multicast group at the given multicastAddress and multicastInterface using the IP_ADD_MEMBERSHIP socket option. If the multicastInterface argument is not specified, the operating system will choose one interface and will add membership to it. To add membership to every available interface, call addMembership multiple times, once per interface. \u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u76f8\u5173\u903b\u8f91\u3002 1. if(MULTICAST(daddr) && *dev==NULL && skb->sk && *skb->sk->ip_mc_name) 2. *dev=dev_get(skb->sk->ip_mc_name); \u4e0a\u9762\u7684\u4ee3\u7801\u6765\u81ea\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001IP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\uff0c\u5982\u679c\u76ee\u7684IP\u4f3c\u4e4e\u591a\u64ad\u5730\u5740\u5e76\u4e14ip_mc_name\u975e\u7a7a\uff08\u5373\u6211\u4eec\u901a\u8fc7addMembership\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8bbe\u7f6e\u7684\u503c\uff09\uff0c\u5219\u51fa\u53e3\u8bbe\u5907\u5c31\u662f\u6211\u4eec\u8bbe\u7f6e\u7684\u503c\u3002\u5426\u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u663e\u793a\u6307\u5b9a\u8fd9\u4e2a\u51fa\u53e3\uff0c\u628a\u4ee3\u7801\u6539\u6210udp.addMembership('224.0.0.114', '192.168.8.164');\u91cd\u65b0\u6267\u884c\u53d1\u73b0\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u90fd\u663e\u793a\u4e86receive msg test from 192.168.8.164:1234\u3002\u4e3a\u4ec0\u4e48\u5ba2\u6237\u7aef\u81ea\u5df1\u4e5f\u4f1a\u6536\u5230\u5462\uff1f\u539f\u6765\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001\u591a\u64ad\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e5f\u4f1a\u7ed9\u81ea\u5df1\u53d1\u9001\u4e00\u4efd\u3002\u6211\u4eec\u770b\u770b\u76f8\u5173\u903b\u8f91 1. // \u76ee\u7684\u5730\u662f\u591a\u64ad\u5730\u5740\uff0c\u5e76\u4e14\u4e0d\u662f\u56de\u73af\u8bbe\u5907 2. if (MULTICAST(iph->daddr) && !(dev->flags&IFF_LOOPBACK)) 3. { 4. // \u662f\u5426\u9700\u8981\u7ed9\u81ea\u5df1\u4e00\u4efd\uff0c\u9ed8\u8ba4\u4e3atrue 5. if(sk==NULL || sk->ip_mc_loop) 6. { 7. // \u7ed9\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u7684\u6570\u636e\u5305\uff0c\u5219\u76f4\u63a5\u7ed9\u81ea\u5df1\u4e00\u4efd 8. if(iph->daddr==IGMP_ALL_HOSTS) 9. ip_loopback(dev,skb); 10. else 11. { 12. // \u5224\u65ad\u76ee\u7684ip\u662f\u5426\u5728\u5f53\u524d\u8bbe\u5907\u7684\u591a\u64adip\u5217\u8868\u4e2d\uff0c\u662f\u7684\u56de\u4f20\u4e00\u4efd 13. struct ip_mc_list *imc=dev->ip_mc_list; 14. while(imc!=NULL) 15. { 16. if(imc->multiaddr==iph->daddr) 17. { 18. ip_loopback(dev,skb); 19. break; 20. } 21. imc=imc->next; 22. } 23. } 24. } 25. } \u4ee5\u4e0a\u4ee3\u7801\u6765\u81eaIP\u5c42\u53d1\u9001\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86sk->ip_mc_loop\u5b57\u6bb5\u4e3a1\uff0c\u5e76\u4e14\u6570\u636e\u5305\u7684\u76ee\u7684IP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u9700\u8981\u7ed9\u81ea\u5df1\u56de\u4f20\u4e00\u4efd\u3002\u90a3\u4e48\u6211\u4eec\u5982\u4f55\u5173\u95ed\u8fd9\u4e2a\u7279\u6027\u5462\uff1f\u8c03\u7528udp.setMulticastLoopback(false)\u5c31\u53ef\u4ee5\u4e86\u3002 16.2.5.5 \u5176\u5b83\u529f\u80fd \u00b6 UDP\u6a21\u5757\u8fd8\u63d0\u4f9b\u4e86\u5176\u5b83\u4e00\u4e9b\u529f\u80fd 1 \u83b7\u53d6\u672c\u7aef\u5730\u5740address \u5982\u679c\u7528\u6237\u6ca1\u6709\u663e\u793a\u8c03\u7528bind\u7ed1\u5b9a\u81ea\u5df1\u8bbe\u7f6e\u7684IP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u968f\u673a\u9009\u62e9\u3002\u901a\u8fc7address\u51fd\u6570\u5c31\u53ef\u4ee5\u83b7\u53d6\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u6e90IP\u548c\u7aef\u53e3\u3002 2 \u83b7\u53d6\u5bf9\u7aef\u7684\u5730\u5740 \u901a\u8fc7remoteAddress\u51fd\u6570\u53ef\u4ee5\u83b7\u53d6\u5bf9\u7aef\u5730\u5740\u3002\u8be5\u5730\u5740\u7531\u7528\u6237\u8c03\u7528connect\u6216sendto\u51fd\u6570\u65f6\u8bbe\u7f6e\u3002 3 \u83b7\u53d6/\u8bbe\u7f6e\u7f13\u51b2\u533a\u5927\u5c0fget/setRecvBufferSize\uff0cget/setSendBufferSize 4 setMulticastLoopback \u53d1\u9001\u591a\u64ad\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5982\u679c\u591a\u64adIP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u7ed9\u56de\u73af\u8bbe\u5907\u4e5f\u53d1\u4e00\u4efd\u3002 5 setMulticastInterface \u8bbe\u7f6e\u591a\u64ad\u6570\u636e\u7684\u51fa\u53e3\u8bbe\u5907 6 \u52a0\u5165\u6216\u9000\u51fa\u591a\u64ad\u7ec4addMembership/dropMembership 7 addSourceSpecificMembership/dropSourceSpecificMembership \u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u8bbe\u7f6e\u672c\u7aef\u53ea\u63a5\u6536\u7279\u6027\u6e90\uff08\u4e3b\u673a\uff09\u7684\u591a\u64ad\u6570\u636e\u5305\u3002 8 setTTL \u5355\u64adttl\uff08\u5355\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u5934\u4e2d\u7684ttl\u5b57\u6bb5\uff09\u3002 9 setMulticastTTL \u591a\u64adttl\uff08\u591a\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u7684ttl\u5b57\u6bb5\uff09\u3002 10 ref/unref \u8fd9\u4e24\u4e2a\u51fd\u6570\u8bbe\u7f6e\u5982\u679cNode.js\u4e3b\u8fdb\u7a0b\u4e2d\u53ea\u6709UDP\u5bf9\u5e94\u7684handle\u65f6\uff0c\u662f\u5426\u5141\u8bb8Node.js\u9000\u51fa\u3002Node.js\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u7684\u6761\u4ef6\u4e4b\u4e00\u662f\u662f\u5426\u8fd8\u6709ref\u72b6\u6001\u7684handle\u3002 \u8fd9\u4e9b\u90fd\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002 16.2.6 \u7aef\u53e3\u590d\u7528 \u00b6 \u6211\u4eec\u5728\u7f51\u7edc\u7f16\u7a0b\u4e2d\u7ecf\u5e38\u4f1a\u9047\u5230\u7aef\u53e3\u91cd\u590d\u7ed1\u5b9a\u7684\u9519\u8bef\uff0c\u6839\u636e\u5230\u5e95\u662f\u6211\u4eec\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u548cIP\u4e24\u6b21\u3002\u4f46\u662f\u5728UDP\u4e2d\uff0c\u8fd9\u662f\u5141\u8bb8\u7684\uff0c\u8fd9\u5c31\u662f\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u5728TCP\u4e2d\uff0c\u6211\u4eec\u901a\u8fc7\u7aef\u53e3\u590d\u7528\u6765\u89e3\u51b3\u670d\u52a1\u5668\u91cd\u542f\u65f6\u91cd\u65b0\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\u7aef\u53e3\u6709\u4e00\u4e2a2msl\u7684\u7b49\u5f85\u65f6\u95f4\uff0c\u91cd\u542f\u670d\u52a1\u5668\u91cd\u65b0\u7ed1\u5b9a\u5230\u8fd9\u4e2a\u7aef\u53e3\u65f6\uff0c\u9ed8\u8ba4\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff08Node.js\u81ea\u52a8\u5e2e\u6211\u4eec\u8bbe\u7f6e\u4e86\uff09\uff0c\u5219\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002UDP\u4e2d\u4e5f\u652f\u6301\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u4f46\u662f\u529f\u80fd\u3001\u7528\u9014\u548cTCP\u7684\u4e0d\u592a\u4e00\u6837\u3002\u56e0\u4e3a\u591a\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\u3002\u4f46\u662f\u4e00\u822c\u53ea\u7528\u4e8e\u591a\u64ad\u7684\u60c5\u51b5\u4e0b\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0budp\u7aef\u53e3\u590d\u7528\u7684\u903b\u8f91\u3002\u5728Node.js\u4e2d\uff0c\u4f7f\u7528UDP\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u901a\u8fc7reuseAddr\u9009\u9879\u4f7f\u5f97\u8fdb\u7a0b\u53ef\u4ee5\u590d\u7528\u7aef\u53e3\uff0c\u5e76\u4e14\u6bcf\u4e00\u4e2a\u60f3\u590d\u7528\u7aef\u53e3\u7684socket\u90fd\u9700\u8981\u8bbe\u7f6ereuseAddr\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u5173\u4e8ereuseAddr\u7684\u903b\u8f91\u3002 1. Socket.prototype.bind = function(port_, address_ /* , callback */) { 2. let flags = 0; 3. if (state.reuseAddr) 4. flags |= UV_UDP_REUSEADDR; 5. state.handle.bind(ip, port || 0, flags); 6. }; \u6211\u4eec\u770b\u5230Node.js\u5728bind\u7684\u65f6\u5019\u4f1a\u5904\u7406reuseAddr\u5b57\u6bb5\u3002\u6211\u4eec\u76f4\u63a5\u770bLibuv\u7684\u903b\u8f91\u3002 1. int uv__udp_bind(uv_udp_t* handle, 2. const struct sockaddr* addr, 3. unsigned int addrlen, 4. unsigned int flags) { 5. if (flags & UV_UDP_REUSEADDR) { 6. err = uv__set_reuse(fd); 7. } 8. bind(fd, addr, addrlen)) 9. return 0; 10. } 11. 12. static int uv__set_reuse(int fd) { 13. int yes; 14. yes = 1; 15. 16. if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes))) 17. return UV__ERR(errno); 18. return 0; 19. } \u6211\u4eec\u770b\u5230Libuv\u901a\u8fc7\u6700\u7ec8\u901a\u8fc7setsockopt\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff0c\u5e76\u4e14\u662f\u5728bind\u4e4b\u524d\u3002\u6211\u4eec\u4e0d\u59a8\u518d\u6df1\u5165\u4e00\u70b9\uff0c\u770b\u4e00\u4e0bLinux\u5185\u6838\u7684\u5b9e\u73b0\u3002 1. asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen) 2. { 3. int err; 4. struct socket *sock; 5. 6. if (optlen < 0) 7. return -EINVAL; 8. 9. if ((sock = sockfd_lookup(fd, &err))!=NULL) 10. { 11. if (level == SOL_SOCKET) 12. err=sock_setsockopt(sock,level,optname,optval,optlen); 13. else 14. err=sock->ops->setsockopt(sock, level, optname, optval, optlen); 15. sockfd_put(sock); 16. } 17. return err; 18. } sys_setsockopt\u662fsetsockopt\u5bf9\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u6211\u4eec\u770b\u5230sys_setsockopt\u4e5f\u53ea\u662f\u4e2a\u5165\u53e3\u51fd\u6570\uff0c\u5177\u4f53\u51fd\u6570\u662fsock_setsockopt\u3002 1. int sock_setsockopt(struct socket *sock, int level, int optname, 2. char __user *optval, int optlen) 3. { 4. struct sock *sk=sock->sk; 5. int val; 6. int valbool; 7. int ret = 0; 8. 9. if (get_user(val, (int __user *)optval)) 10. return -EFAULT; 11. 12. valbool = val?1:0; 13. 14. lock_sock(sk); 15. 16. switch(optname) 17. { 18. case SO_REUSEADDR: 19. sk->sk_reuse = valbool; 20. break; 21. // ... 22. release_sock(sk); 23. return ret; 24. } \u64cd\u4f5c\u7cfb\u7edf\u7684\u5904\u7406\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u505a\u4e86\u4e00\u4e2a\u6807\u8bb0\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bbind\u7684\u65f6\u5019\u662f\u600e\u4e48\u5904\u7406\u7684\uff0c\u56e0\u4e3a\u7aef\u53e3\u662f\u5426\u91cd\u590d\u548c\u80fd\u5426\u590d\u7528\u662f\u5728bind\u7684\u65f6\u5019\u5224\u65ad\u7684\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u5728TCP\u4e2d\uff0c\u5373\u4f7f\u4e24\u4e2a\u8fdb\u7a0b\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u4e3b\u8fdb\u7a0b\u91cc\u6267\u884c\u4e86bind\u4e4b\u540e\uff0c\u518dfork\u51fd\u6570\u65f6\uff0c\u662f\u53ef\u4ee5\u5b9e\u73b0\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u7aef\u53e3\u7684\u3002\u8a00\u5f52\u6b63\u4f20\u6211\u4eec\u770b\u4e00\u4e0bUDP\u4e2d\u6267\u884cbind\u65f6\u7684\u903b\u8f91\u3002 1. int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len) 2. { 3. if (sk->sk_prot->get_port(sk, snum)) { 4. inet->saddr = inet->rcv_saddr = 0; 5. err = -EADDRINUSE; 6. goto out_release_sock; 7. } 8. 9. } \u6bcf\u4e2a\u534f\u8bae\u90fd\u53ef\u4ee5\u5b9e\u73b0\u81ea\u5df1\u7684get_port\u94a9\u5b50\u51fd\u6570\u3002\u7528\u6765\u5224\u65ad\u5f53\u524d\u7684\u7aef\u53e3\u662f\u5426\u5141\u8bb8\u88ab\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u5141\u8bb8\u5219\u8fd4\u56deEADDRINUSE\uff0c\u6211\u4eec\u770b\u770bUDP\u534f\u8bae\u7684\u5b9e\u73b0\u3002 1. static int udp_v4_get_port(struct sock *sk, unsigned short snum) 2. { 3. struct hlist_node *node; 4. struct sock *sk2; 5. struct inet_sock *inet = inet_sk(sk); 6. // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u94fe\u8868 7. sk_for_each(sk2, node, &udp_hash[snum & (UDP_HTABLE_SIZE - 1)]) { 8. struct inet_sock *inet2 = inet_sk(sk2); 9. // \u7aef\u53e3\u5df2\u4f7f\u7528\uff0c\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528 10. if (inet2->num == snum && 11. sk2 != sk && 12. (!inet2->rcv_saddr || 13. !inet->rcv_saddr || 14. inet2->rcv_saddr == inet->rcv_saddr) && 15. // \u6bcf\u4e2asocket\u90fd\u9700\u8981\u8bbe\u7f6e\u7aef\u53e3\u590d\u7528\u6807\u8bb0 16. (!sk2->sk_reuse || !sk->sk_reuse)) 17. // \u4e0d\u53ef\u4ee5\u590d\u7528\uff0c\u62a5\u9519 18. goto fail; 19. } 20. // \u53ef\u4ee5\u590d\u7528 21. inet->num = snum; 22. if (sk_unhashed(sk)) { 23. // \u627e\u5230\u7aef\u53e3\u5bf9\u5e94\u7684\u4f4d\u7f6e 24. struct hlist_head *h = &udp_hash[snum & (UDP_HTABLE_SIZE - 1)]; 25. // \u63d2\u5165\u94fe\u8868 26. sk_add_node(sk, h); 27. sock_prot_inc_use(sk->sk_prot); 28. } 29. return 0; 30. 31. fail: 32. write_unlock_bh(&udp_hash_lock); 33. return 1; 34. } \u5206\u6790\u4e4b\u524d\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0cUDP\u534f\u8bae\u7684\u5b9e\u73b0\u4e2d\uff0c\u4f1a\u4f7f\u7528\u5982\u4e0b\u7684\u6570\u636e\u7ed3\u6784\u8bb0\u5f55\u6bcf\u4e00\u4e2aUDP socket\uff0c\u5982\u56fe16-6\u6240\u793a\u3002 \u56fe16-6 \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u4f5c\u4e3a\u54c8\u5e0c\u8868\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e00\u4e2asocket\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u6839\u636esocket\u7684\u6e90\u7aef\u53e3\u548c\u54c8\u5e0c\u7b97\u6cd5\u8ba1\u7b97\u5f97\u5230\u4e00\u4e2a\u6570\u7ec4\u7d22\u5f15\uff0c\u7136\u540e\u628asocket\u63d2\u5165\u7d22\u5f15\u9501\u5bf9\u5e94\u7684\u94fe\u8868\u4e2d\uff0c\u5373\u54c8\u5e0c\u51b2\u7a81\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u94fe\u5730\u5740\u6cd5\u3002\u56de\u5230\u4ee3\u7801\u7684\u903b\u8f91\uff0c\u5f53\u7528\u6237\u60f3\u7ed1\u5b9a\u4e00\u4e2a\u7aef\u53e3\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u7aef\u53e3\u62ff\u5230\u5bf9\u5e94\u7684socket\u94fe\u8868\uff0c\u7136\u540e\u9010\u4e2a\u5224\u65ad\u662f\u5426\u6709\u76f8\u7b49\u7684\u7aef\u53e3\uff0c\u5982\u679c\u6709\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528\u3002\u4f8b\u5982\u4e24\u4e2asocket\u90fd\u8bbe\u7f6e\u4e86\u590d\u7528\u6807\u8bb0\u5219\u53ef\u4ee5\u590d\u7528\u3002\u6700\u540e\u628asocket\u63d2\u5165\u5230\u94fe\u8868\u4e2d\u3002 1. static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h) 2. { 3. // \u5934\u7ed3\u70b9 4. struct hlist_node *first = h->first; 5. n->next = first; 6. if (first) 7. first->pprev = &n->next; 8. h->first = n; 9. n->pprev = &h->first; 10. } \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u662f\u4ee5\u5934\u63d2\u6cd5\u7684\u65b9\u5f0f\u63d2\u5165\u65b0\u8282\u70b9\u7684\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\u7684\u3002 16.2.6.1 \u591a\u64ad \u00b6 \u6211\u4eec\u5148\u770b\u4e00\u4e2a\u4f8b\u5b50\uff0c\u6211\u4eec\u5728\u540c\u4e3b\u673a\u4e0a\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\uff08\u5ba2\u6237\u7aef\uff09\uff0c\u4ee3\u7801\u5982\u4e0b 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4', reuseAddr: true}); 3. udp.bind(1234, \u2018192.168.8.164\u2018, () => { 4. udp.addMembership('224.0.0.114', '192.168.8.164'); 5. }); 6. udp.on('message', (msg) => { 7. console.log(msg) 8. }); \u4e0a\u9762\u4ee3\u7801\u4f7f\u5f97\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u6837\u7684IP\u548c\u7aef\u53e3\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5199\u4e00\u4e2aUDP\u670d\u52a1\u5668\u3002 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4'}); 3. const socket = udp.bind(5678); 4. socket.send('hi', 1234, '224.0.0.114', (err) => { 5. console.log(err) 6. }); \u4e0a\u9762\u7684\u4ee3\u7801\u7ed9\u4e00\u4e2a\u591a\u64ad\u7ec4\u53d1\u9001\u4e86\u4e00\u4e2a\u6570\u636e\uff0c\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u6536\u5230\u4e86\u6570\u636e\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6536\u5230\u6570\u636e\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u628a\u6570\u636e\u5206\u53d1\u7ed9\u6bcf\u4e2a\u76d1\u542c\u4e86\u540c\u6837IP\u548c\u7aef\u53e3\u7684\u8fdb\u7a0b\u7684\u3002\u4e0b\u9762\u662f\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002 1. int udp_rcv(struct sk_buff *skb) 2. { 3. struct sock *sk; 4. struct udphdr *uh; 5. unsigned short ulen; 6. struct rtable *rt = (struct rtable*)skb->dst; 7. // ip\u5934\u4e2d\u8bb0\u5f55\u7684\u6e90ip\u548c\u76ee\u7684ip 8. u32 saddr = skb->nh.iph->saddr; 9. u32 daddr = skb->nh.iph->daddr; 10. int len = skb->len; 11. // udp\u534f\u8bae\u5934\u7ed3\u6784\u4f53 12. uh = skb->h.uh; 13. ulen = ntohs(uh->len); 14. // \u5e7f\u64ad\u6216\u591a\u64ad\u5305 15. if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST)) 16. return udp_v4_mcast_deliver(skb, uh, saddr, daddr); 17. // \u5355\u64ad 18. sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex); 19. // \u627e\u5230\u5bf9\u5e94\u7684socket 20. if (sk != NULL) { 21. // \u628a\u6570\u636e\u63d2\u5230socket\u7684\u6d88\u606f\u961f\u5217 22. int ret = udp_queue_rcv_skb(sk, skb); 23. sock_put(sk); 24. if (ret > 0) 25. return -ret; 26. return 0; 27. } 28. return(0); 29. } \u6211\u4eec\u770b\u5230\u5355\u64ad\u548c\u975e\u5355\u64ad\u65f6\u5904\u7406\u903b\u8f91\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u975e\u5355\u64ad\u7684\u60c5\u51b5 1. static int udp_v4_mcast_deliver(struct sk_buff *skb, struct udphdr *uh, 2. u32 saddr, u32 daddr) 3. { 4. struct sock *sk; 5. int dif; 6. 7. read_lock(&udp_hash_lock); 8. // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868 9. sk = sk_head(&udp_hash[ntohs(uh->dest) & (UDP_HTABLE_SIZE - 1)]); 10. dif = skb->dev->ifindex; 11. sk = udp_v4_mcast_next(sk, uh->dest, daddr, uh->source, saddr, dif); 12. if (sk) { 13. struct sock *sknext = NULL; 14. // \u904d\u5386\u6bcf\u4e00\u4e2a\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u7684socket 15. do { 16. struct sk_buff *skb1 = skb; 17. sknext = udp_v4_mcast_next(sk_next(sk), 18. uh->dest, daddr, 19. uh->source, 20. saddr, 21. dif); 22. if(sknext) 23. // \u590d\u5236\u4e00\u4efd 24. skb1 = skb_clone(skb, GFP_ATOMIC); 25. // \u63d2\u5165\u6bcf\u4e00\u4e2asocket\u7684\u6570\u636e\u5305\u961f\u5217 26. if(skb1) { 27. int ret = udp_queue_rcv_skb(sk, skb1); 28. if (ret > 0) 29. kfree_skb(skb1); 30. } 31. sk = sknext; 32. } while(sknext); 33. } else 34. kfree_skb(skb); 35. read_unlock(&udp_hash_lock); 36. return 0; 37. } \u5728\u975e\u5355\u64ad\u7684\u60c5\u51b5\u4e0b\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u904d\u5386\u94fe\u8868\u627e\u5230\u6bcf\u4e00\u4e2a\u53ef\u4ee5\u63a5\u6536\u8be5\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u590d\u5236\u4e00\u4efd\uff0c\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u3002\u8fd9\u5c31\u89e3\u91ca\u4e86\u672c\u8282\u5f00\u5934\u7684\u4f8b\u5b50\uff0c\u5373\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u4f1a\u6536\u5230UDP\u6570\u636e\u5305\u3002 16.2.6.2 \u5355\u64ad \u00b6 \u63a5\u7740\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b\u5355\u64ad\u7684\u60c5\u51b5\u3002\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002\u6211\u4eec\u540c\u6837\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u5ba2\u6237\u7aef\u3002 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4', reuseAddr: true}); 3. const socket = udp.bind(5678); 4. socket.on('message', (msg) => { 5. console.log(msg) 6. }) \u7136\u540e\u518d\u65b0\u5efa\u4e00\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u670d\u52a1\u5668\u3002 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4'}); 3. const socket = udp.bind(1234); 4. udp.send('hi', 5678) \u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u9996\u5148\u6267\u884c\u5ba2\u6237\u7aef\uff0c\u518d\u6267\u884c\u670d\u52a1\u5668\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u5177\u4f53\u7684\u539f\u56e0\uff0c\u5355\u64ad\u65f6\u6536\u5230\u4f1a\u8c03\u7528udp_v4_lookup\u51fd\u6570\u627e\u5230\u63a5\u6536\u8be5UDP\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u4e2d\u3002\u6211\u4eec\u770b\u770budp_v4_lookup\u3002 1. static __inline__ struct sock *udp_v4_lookup(u32 saddr, u16 sport, 2. u32 daddr, u16 dport, int dif) 3. { 4. struct sock *sk; 5. sk = udp_v4_lookup_longway(saddr, sport, daddr, dport, dif); 6. return sk; 7. } 8. 9. static struct sock *udp_v4_lookup_longway(u32 saddr, u16 sport, 10. u32 daddr, u16 dport, int dif) 11. { 12. struct sock *sk, *result = NULL; 13. struct hlist_node *node; 14. unsigned short hnum = ntohs(dport); 15. int badness = -1; 16. // \u904d\u5386\u7aef\u53e3\u5bf9\u5e94\u7684\u94fe\u8868 17. sk_for_each(sk, node, &udp_hash[hnum & (UDP_HTABLE_SIZE - 1)]) { 18. struct inet_sock *inet = inet_sk(sk); 19. 20. if (inet->num == hnum && !ipv6_only_sock(sk)) { 21. int score = (sk->sk_family == PF_INET ? 1 : 0); 22. if (inet->rcv_saddr) { 23. if (inet->rcv_saddr != daddr) 24. continue; 25. score+=2; 26. } 27. if (inet->daddr) { 28. if (inet->daddr != saddr) 29. continue; 30. score+=2; 31. } 32. if (inet->dport) { 33. if (inet->dport != sport) 34. continue; 35. score+=2; 36. } 37. if (sk->sk_bound_dev_if) { 38. if (sk->sk_bound_dev_if != dif) 39. continue; 40. score+=2; 41. } 42. // \u5168\u5339\u914d\uff0c\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u8bb0\u5f55\u5f53\u524d\u6700\u597d\u7684\u5339\u914d\u7ed3\u679c 43. if(score == 9) { 44. result = sk; 45. break; 46. } else if(score > badness) { 47. result = sk; 48. badness = score; 49. } 50. } 51. } 52. return result; 53. } \u6211\u4eec\u770b\u5230\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u6839\u636e\u7aef\u53e3\u4ece\u54c8\u5e0c\u8868\u4e2d\u62ff\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u8be5\u94fe\u8868\u627e\u51fa\u6700\u5339\u914d\u7684socket\u3002\u7136\u540e\u628a\u6570\u636e\u6302\u8f7d\u5230socket\u4e0a\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u7ec6\u8282\u9700\u8981\u6ce8\u610f\uff0c\u5982\u679c\u6709\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u54ea\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u5462\uff1f\u8fd9\u4e2a\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\uff0c\u4eceLinux\u6e90\u7801\u6211\u4eec\u770b\u5230\uff0c\u63d2\u5165socket\u7684\u65f6\u5019\u662f\u4f7f\u7528\u5934\u63d2\u6cd5\uff0c\u67e5\u627e\u7684\u65f6\u5019\u662f\u4ece\u5934\u5f00\u59cb\u627e\u6700\u5339\u914d\u7684socket\u3002\u5373\u540e\u9762\u63d2\u5165\u7684socket\u4f1a\u5148\u88ab\u641c\u7d22\u5230\u3002\u4f46\u662fWindows\u4e0b\u7ed3\u6784\u5374\u76f8\u53cd\uff0c\u5148\u76d1\u542c\u4e86\u8be5IP\u7aef\u53e3\u7684\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002 \u7b2c","title":"16-UDP"},{"location":"chapter16-UDP/#161-cudp","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728C\u8bed\u8a00\u4e2d\u5982\u4f55\u4f7f\u7528UDP\u529f\u80fd\uff0c\u8fd9\u662fNode.js\u7684\u5e95\u5c42\u57fa\u7840\u3002","title":"16.1 \u5728C\u8bed\u8a00\u4e2d\u4f7f\u7528UDP"},{"location":"chapter16-UDP/#1611","text":"1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. // \u7ed1\u5b9a\u4e00\u4e2a\u4f17\u6240\u5468\u77e5\u7684\u5730\u5740\uff0c\u50cfTCP\u4e00\u6837 4. bind(fd, ip\uff0c port); 5. // \u76f4\u63a5\u963b\u585e\u7b49\u5f85\u6d88\u606f\u7684\u5230\u6765\uff0cUDP\u4e0d\u9700\u8981listen 6. recvmsg()\uff1b","title":"16.1.1 \u670d\u52a1\u5668\u6d41\u7a0b\uff08\u4f2a\u4ee3\u7801\uff09"},{"location":"chapter16-UDP/#1612","text":"\u5ba2\u6237\u7aef\u7684\u6d41\u7a0b\u6709\u591a\u79cd\u65b9\u5f0f\uff0c\u539f\u56e0\u5728\u4e8e\u6e90IP\u3001\u7aef\u53e3\u548c\u76ee\u7684IP\u3001\u7aef\u53e3\u53ef\u4ee5\u6709\u591a\u79cd\u8bbe\u7f6e\u65b9\u5f0f\u3002\u4e0d\u50cf\u670d\u52a1\u5668\u4e00\u6837\uff0c\u670d\u52a1\u5668\u7aef\u53e3\u662f\u9700\u8981\u5bf9\u5916\u516c\u5e03\u7684\uff0c\u5426\u5219\u5ba2\u6237\u7aef\u5c31\u65e0\u6cd5\u627e\u5230\u76ee\u7684\u5730\u8fdb\u884c\u901a\u4fe1\u3002\u8fd9\u5c31\u610f\u5473\u7740\u670d\u52a1\u5668\u7684\u7aef\u53e3\u662f\u9700\u8981\u7528\u6237\u663e\u5f0f\u6307\u5b9a\u7684\uff0c\u800c\u5ba2\u6237\u7aef\u5219\u4e0d\u7136\uff0c\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u6307\u5b9a\uff0c\u4e5f\u53ef\u4ee5\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770b\u5404\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002","title":"16.1.2 \u5ba2\u6237\u7aef\u6d41\u7a0b"},{"location":"chapter16-UDP/#16121-ip","text":"1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. // \u7ed1\u5b9a\u4e00\u4e2a\u5ba2\u6237\u7aef\u7684\u5730\u5740 4. bind(fd, ip\uff0c port); 5. // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e 6. sendto(fd, \u670d\u52a1\u5668ip,\u670d\u52a1\u5668\u7aef\u53e3, data); \u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u6240\u4ee5\u4f7f\u7528UDP\u65f6\uff0c\u4e0d\u9700\u8981\u8c03\u7528connect\u5efa\u7acb\u8fde\u63a5\uff0c\u53ea\u8981\u6211\u4eec\u77e5\u9053\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u76f4\u63a5\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u5373\u53ef\u3002\u800c\u9762\u5411\u8fde\u63a5\u7684TCP\uff0c\u9996\u5148\u9700\u8981\u901a\u8fc7connect\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u5efa\u7acb\u8fde\u63a5\uff0c\u5efa\u7acb\u8fde\u63a5\u7684\u672c\u8d28\u662f\u5728\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u8bb0\u5f55\u5bf9\u7aef\u7684\u4fe1\u606f\uff0c\u8fd9\u662f\u540e\u9762\u901a\u4fe1\u7684\u901a\u884c\u8bc1\u3002","title":"16.1.2.1 \u663e\u5f0f\u6307\u5b9a\u6e90IP\u548c\u7aef\u53e3"},{"location":"chapter16-UDP/#16122-ip","text":"1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e 4. sendto(fd, \u670d\u52a1\u5668ip,\u670d\u52a1\u5668\u7aef\u53e3, data) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u7684\u6e90ip\u548c\u7aef\u53e3\uff0c\u800c\u662f\u76f4\u63a5\u5c31\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u3002\u5982\u679c\u7528\u6237\u4e0d\u6307\u5b9aip\u548c\u7aef\u53e3\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u63d0\u4f9b\u9ed8\u8ba4\u7684\u6e90ip\u548c\u7aef\u53e3\u3002\u5bf9\u4e8eip\uff0c\u5982\u679c\u662f\u591a\u5bbf\u4e3b\u4e3b\u673a\uff0c\u6bcf\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u52a8\u6001\u9009\u62e9\u6e90ip\u3002\u5bf9\u4e8e\u7aef\u53e3\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5728\u7b2c\u4e00\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u4e0d\u80fd\u4fee\u6539\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 1. // \u7533\u8bf7\u4e00\u4e2asocket 2. int fd = socket(...); 3. connect(fd, \u670d\u52a1\u5668ip\uff0c\u670d\u52a1\u5668\u7aef\u53e3); 4. /* 5. \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e,\u6216\u8005sendto(fd, null,null, data)\uff0c 6. \u8c03\u7528sendto\u5219\u4e0d\u9700\u8981\u518d\u6307\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3 7. */ 8. write(fd, data); \u6211\u4eec\u53ef\u4ee5\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3\u5230fd\uff0c\u7136\u540e\u76f4\u63a5\u8c03\u7528write\u53d1\u9001\u6570\u636e\u3002 \u867d\u7136\u4f7f\u7528\u65b9\u5f0f\u5f88\u591a\uff0c\u4f46\u662f\u5f52\u6839\u5230\u5e95\u8fd8\u662f\u5bf9\u56db\u5143\u7ec4\u8bbe\u7f6e\u7684\u7ba1\u7406\u3002bind\u662f\u7ed1\u5b9a\u6e90ip\u7aef\u53e3\u5230fd\uff0cconnect\u662f\u7ed1\u5b9a\u670d\u52a1\u5668ip\u7aef\u53e3\u5230fd\u3002\u5bf9\u4e8e\u6e90ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u8ba9\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u3002\u5bf9\u4e8e\u76ee\u7684ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u524d\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u65f6\u8bbe\u7f6e\u3002\u8fd9\u5c31\u5f62\u6210\u4e86\u591a\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002","title":"16.1.2.2 \u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u6e90ip\u548c\u7aef\u53e3"},{"location":"chapter16-UDP/#1613","text":"\u6211\u4eec\u521a\u624d\u770b\u5230\u4f7f\u7528UDP\u4e4b\u524d\u90fd\u9700\u8981\u8c03\u7528socket\u51fd\u6570\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u867d\u7136\u8c03\u7528socket\u51fd\u6570\u8fd4\u56de\u7684\u662f\u4e00\u4e2afd\uff0c\u4f46\u662f\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u7684\u786e\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u7ed3\u6784\u4f53\uff0cfd\u53ea\u662f\u4e00\u4e2a\u7d22\u5f15\uff0c\u64cd\u4f5c\u8fd9\u4e2afd\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u8fd9\u4e2afd\u627e\u5230\u5bf9\u5e94\u7684socket\u3002socket\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u4e3a\u4e00\u4e2a\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4e2d\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662f\u8bfb\u7f13\u51b2\u533a\u5927\u5c0f\uff0c\u4e00\u4e2a\u662f\u5199\u7f13\u51b2\u533a\u5927\u5c0f\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u867d\u7136\u7406\u8bba\u4e0a\u53ef\u4ee5\u53d1\u9001\u4efb\u610f\u5927\u5c0f\u7684\u6570\u636e\uff0c\u4f46\u662f\u56e0\u4e3a\u53d7\u9650\u4e8e\u53d1\u9001\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff0c\u5982\u679c\u9700\u8981\u53d1\u9001\u7684\u6570\u636e\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\u5219\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u95ee\u9898\uff0c\u6211\u4eec\u5206\u60c5\u51b5\u5206\u6790\u4e00\u4e0b\u3002 1 \u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u8fd4\u56deEAGAIN\uff0c\u5982\u679c\u662f\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u4f1a\u5f15\u8d77\u8fdb\u7a0b\u7684\u963b\u585e\u3002 2 \u5982\u679c\u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u7f13\u51b2\u533a\u7684\u6700\u5927\u503c\u8fd8\u5927\uff0c\u5219\u4f1a\u5bfc\u81f4\u62a5\u9519EMSGSIZE\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u5206\u5305\u53d1\u9001\u3002\u6211\u4eec\u53ef\u80fd\u4f1a\u60f3\u5230\u4fee\u6539\u7f13\u51b2\u533a\u6700\u5927\u503c\u7684\u5927\u5c0f\uff0c\u4f46\u662f\u8fd9\u4e2a\u5927\u5c0f\u4e5f\u662f\u6709\u9650\u5236\u7684\u3002 \u8bb2\u5b8c\u4e00\u4e9b\u8fb9\u754c\u60c5\u51b5\uff0c\u6211\u4eec\u518d\u6765\u770b\u770b\u6b63\u5e38\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u770b\u770b\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u6d41\u7a0b 1 \u9996\u5148\u5728socket\u7684\u5199\u7f13\u51b2\u533a\u7533\u8bf7\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u6570\u636e\u53d1\u9001\u3002 2 \u8c03\u7528IP\u5c42\u53d1\u9001\u63a5\u53e3\uff0c\u5982\u679c\u6570\u636e\u5305\u5927\u5c0f\u8d85\u8fc7\u4e86IP\u5c42\u7684\u9650\u5236\uff0c\u5219\u9700\u8981\u5206\u5305\u3002 3 \u7ee7\u7eed\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u628a\u6570\u636e\u53d1\u5230\u7f51\u7edc\u4e0a\u3002 \u56e0\u4e3aUDP\u4e0d\u662f\u53ef\u9760\u7684\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff08TCP\u534f\u8bae\u5219\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff0c\u7528\u4e8e\u8d85\u65f6\u91cd\u4f20\uff09\u3002 \u8fd9\u5c31\u662fUDP\u53d1\u9001\u6570\u636e\u7684\u6d41\u7a0b\u3002","title":"16.1.3 \u53d1\u9001\u6570\u636e"},{"location":"chapter16-UDP/#1614","text":"\u5f53\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u4f1a\u628a\u8fd9\u4e2a\u6570\u636e\u5305\u7f13\u5b58\u5230socket\u7684\u7f13\u51b2\u533a\uff0c\u5982\u679c\u6536\u5230\u7684\u6570\u636e\u5305\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\uff0c\u5219\u4e22\u5f03\u6570\u636e\u5305\uff0c\u5426\u5219\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230\u63a5\u6536\u961f\u5217\uff0c\u7b49\u7528\u6237\u6765\u8bfb\u53d6\u7684\u65f6\u5019\uff0c\u5c31\u9010\u4e2a\u6458\u4e0b\u63a5\u6536\u961f\u5217\u7684\u8282\u70b9\u3002UDP\u548cTCP\u4e0d\u4e00\u6837\uff0c\u867d\u7136\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u7f13\u5b58\u4e86\u6d88\u606f\u7684\u961f\u5217\uff0c\u4f46\u662f\u5f53\u7528\u6237\u8bfb\u53d6\u6570\u636e\u65f6\uff0cUDP\u6bcf\u6b21\u53ea\u4f1a\u8fd4\u56de\u4e00\u4e2aUDP\u6570\u636e\u5305\uff0c\u800cTCP\u662f\u4f1a\u6839\u636e\u7528\u6237\u8bbe\u7f6e\u7684\u5927\u5c0f\u8fd4\u56de\u4e00\u4e2a\u6216\u591a\u4e2a\u5305\u91cc\u7684\u6570\u636e\u3002\u56e0\u4e3aTCP\u662f\u9762\u5411\u5b57\u8282\u6d41\u7684\uff0c\u800cUDP\u662f\u9762\u5411\u6570\u636e\u5305\u7684\u3002","title":"16.1.4 \u63a5\u6536\u6570\u636e"},{"location":"chapter16-UDP/#162-udpnodejs","text":"\u4e86\u89e3\u4e86UDP\u7684\u4e00\u4e9b\u57fa\u7840\u548c\u4f7f\u7528\u540e\uff0c\u6211\u4eec\u5f00\u59cb\u5206\u6790\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528UDP\u7684\uff0cNode.js\u53c8\u662f\u5982\u4f55\u5b9e\u73b0UDP\u6a21\u5757\u7684\u3002","title":"16.2 UDP\u6a21\u5757\u5728Node.js\u4e2d\u7684\u5b9e\u73b0"},{"location":"chapter16-UDP/#1621","text":"\u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u770b\u770bUDP\u6a21\u5757\u7684\u4f7f\u7528\u3002 1. const dgram = require('dgram'); 2. // \u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668 3. const server = dgram.createSocket('udp4'); 4. // \u76d1\u542cUDP\u6570\u636e\u7684\u5230\u6765 5. server.on('message', (msg, rinfo) => { 6. // \u5904\u7406\u6570\u636e 7. }); 8. // \u7ed1\u5b9a\u7aef\u53e3 9. server.bind(41234); \u6211\u4eec\u770b\u5230\u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668\u5f88\u7b80\u5355\uff0c\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\u5bf9\u8c61\uff0c\u5728Node.js\u4e2d\u548c\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4e00\u6837\uff0csocket\u662f\u5bf9\u7f51\u7edc\u901a\u4fe1\u7684\u4e00\u4e2a\u62bd\u8c61\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5b83\u7406\u89e3\u6210\u5bf9\u4f20\u8f93\u5c42\u7684\u62bd\u8c61\uff0c\u5b83\u53ef\u4ee5\u4ee3\u8868TCP\u4e5f\u53ef\u4ee5\u4ee3\u8868UDP\u3002\u6211\u4eec\u770b\u4e00\u4e0bcreateSocket\u505a\u4e86\u4ec0\u4e48\u3002 1. function createSocket(type, listener) { 2. return new Socket(type, listener); 3. } 4. function Socket(type, listener) { 5. EventEmitter.call(this); 6. let lookup; 7. let recvBufferSize; 8. let sendBufferSize; 9. 10. let options; 11. if (type !== null && typeof type === 'object') { 12. options = type; 13. type = options.type; 14. lookup = options.lookup; 15. recvBufferSize = options.recvBufferSize; 16. sendBufferSize = options.sendBufferSize; 17. } 18. const handle = newHandle(type, lookup); 19. this.type = type; 20. if (typeof listener === 'function') 21. this.on('message', listener); 22. // \u4fdd\u5b58\u4e0a\u4e0b\u6587 23. this[kStateSymbol] = { 24. handle, 25. receiving: false, 26. // \u8fd8\u6ca1\u6709\u6267\u884cbind 27. bindState: BIND_STATE_UNBOUND, 28. connectState: CONNECT_STATE_DISCONNECTED, 29. queue: undefined, 30. // \u7aef\u53e3\u590d\u7528\uff0c\u53ea\u4f7f\u4e8e\u591a\u64ad 31. reuseAddr: options && options.reuseAddr, 32. ipv6Only: options && options.ipv6Only, 33. // \u53d1\u9001\u7f13\u51b2\u533a\u548c\u63a5\u6536\u7f13\u51b2\u533a\u5927\u5c0f 34. recvBufferSize, 35. sendBufferSize 36. }; 37. } \u6211\u4eec\u770b\u5230\u4e00\u4e2asocket\u5bf9\u8c61\u662f\u5bf9handle\u7684\u4e00\u4e2a\u5c01\u88c5\u3002\u6211\u4eec\u770b\u770bhandle\u662f\u4ec0\u4e48\u3002 1. function newHandle(type, lookup) { 2. // \u7528\u4e8edns\u89e3\u6790\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u6211\u4eec\u8c03send\u7684\u65f6\u5019\uff0c\u4f20\u7684\u662f\u4e00\u4e2a\u57df\u540d 3. if (lookup === undefined) { 4. if (dns === undefined) { 5. dns = require('dns'); 6. } 7. lookup = dns.lookup; 8. } 9. 10. if (type === 'udp4') { 11. const handle = new UDP(); 12. handle.lookup = lookup4.bind(handle, lookup); 13. return handle; 14. } 15. // \u5ffd\u7565ipv6\u7684\u5904\u7406 16. } handle\u53c8\u662f\u5bf9UDP\u6a21\u5757\u7684\u5c01\u88c5\uff0cUDP\u662fC++\u6a21\u5757\uff0c\u5728\u4e4b\u524d\u7ae0\u8282\u4e2d\u6211\u4eec\u8bb2\u8fc7\u76f8\u5173\u7684\u77e5\u8bc6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8be6\u7ec6\u8bb2\u8ff0\u4e86\uff0c\u5f53\u6211\u4eec\u5728JS\u5c42new UDP\u7684\u65f6\u5019\uff0c\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002 1. UDPWrap::UDPWrap(Environment* env, Local<Object> object) 2. : HandleWrap(env, 3. object, 4. reinterpret_cast<uv_handle_t*>(&handle_), 5. AsyncWrap::PROVIDER_UDPWRAP) { 6. int r = uv_udp_init(env->event_loop(), &handle_); 7. } \u6267\u884c\u4e86uv_udp_init\u521d\u59cb\u5316udp\u5bf9\u5e94\u7684handle\uff08uv_udp_t\uff09\u3002\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u7684\u5b9a\u4e49\u3002 1. int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) { 2. int domain; 3. int err; 4. int fd; 5. 6. /* Use the lower 8 bits for the domain */ 7. domain = flags & 0xFF; 8. // \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u8fd4\u56de\u4e00\u4e2afd 9. fd = uv__socket(domain, SOCK_DGRAM, 0); 10. uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP); 11. handle->alloc_cb = NULL; 12. handle->recv_cb = NULL; 13. handle->send_queue_size = 0; 14. handle->send_queue_count = 0; 15. /* 16. \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff08\u8fd8\u6ca1\u6709\u6ce8\u518c\u5230\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\uff09\uff0c 17. \u76d1\u542c\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662ffd\uff0c\u56de\u8c03\u662fuv__udp_io 18. */ 19. uv__io_init(&handle->io_watcher, uv__udp_io, fd); 20. // \u521d\u59cb\u5316\u5199\u961f\u5217 21. QUEUE_INIT(&handle->write_queue); 22. QUEUE_INIT(&handle->write_completed_queue); 23. return 0; 24. } \u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u6267\u884cdgram.createSocket('udp4')\u7684\u65f6\u5019\uff0c\u5728Node.js\u4e2d\u4e3b\u8981\u7684\u6267\u884c\u8fc7\u7a0b\u3002\u56de\u5230\u6700\u5f00\u59cb\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884cbind\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002 1. Socket.prototype.bind = function(port_, address_ /* , callback */) { 2. let port = port_; 3. // socket\u7684\u4e0a\u4e0b\u6587 4. const state = this[kStateSymbol]; 5. // \u5df2\u7ecf\u7ed1\u5b9a\u8fc7\u4e86\u5219\u62a5\u9519 6. if (state.bindState !== BIND_STATE_UNBOUND) 7. throw new ERR_SOCKET_ALREADY_BOUND(); 8. // \u5426\u5219\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u4e86 9. state.bindState = BIND_STATE_BINDING; 10. // \u6ca1\u4f20\u5730\u5740\u5219\u9ed8\u8ba4\u7ed1\u5b9a\u6240\u6709\u5730\u5740 11. if (!address) { 12. if (this.type === 'udp4') 13. address = '0.0.0.0'; 14. else 15. address = '::'; 16. } 17. // dns\u89e3\u6790\u540e\u5728\u7ed1\u5b9a\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd 18. state.handle.lookup(address, (err, ip) => { 19. if (err) { 20. state.bindState = BIND_STATE_UNBOUND; 21. this.emit('error', err); 22. return; 23. } 24. const err = state.handle.bind(ip, port || 0, flags); 25. if (err) { 26. const ex = exceptionWithHostPort(err, 'bind', ip, port); 27. state.bindState = BIND_STATE_UNBOUND; 28. this.emit('error', ex); 29. // Todo: close? 30. return; 31. } 32. 33. startListening(this); 34. return this; 35. } bind\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u662fhandle.bind\u548cstartListening\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u770b\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u7684bind\u3002 1. void UDPWrap::DoBind(const FunctionCallbackInfo<Value>& args, int family) { 2. UDPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. 7. // bind(ip, port, flags) 8. CHECK_EQ(args.Length(), 3); 9. node::Utf8Value address(args.GetIsolate(), args[0]); 10. Local<Context> ctx = args.GetIsolate()->GetCurrentContext(); 11. uint32_t port, flags; 12. struct sockaddr_storage addr_storage; 13. int err = sockaddr_for_family(family, 14. address.out(), 15. port, 16. &addr_storage); 17. if (err == 0) { 18. err = uv_udp_bind(&wrap->handle_, 19. reinterpret_cast<const sockaddr*>(&addr_storage), 20. flags); 21. } 22. 23. args.GetReturnValue().Set(err); 24. } \u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u5904\u7406\u53c2\u6570\u7136\u540e\u6267\u884cuv_udp_bind\u8bbe\u7f6e\u4e00\u4e9b\u6807\u8bb0\u3001\u5c5e\u6027\u548c\u7aef\u53e3\u590d\u7528\uff08\u7aef\u53e3\u590d\u7528\u540e\u7eed\u4f1a\u5355\u72ec\u5206\u6790\uff09\uff0c\u7136\u540e\u6267\u884c\u64cd\u4f5c\u7cfb\u7edfbind\u7684\u51fd\u6570\u628a\u672c\u7aef\u7684ip\u548c\u7aef\u53e3\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6211\u4eec\u7ee7\u7eed\u770bstartListening\u3002 1. function startListening(socket) { 2. const state = socket[kStateSymbol]; 3. // \u6709\u6570\u636e\u65f6\u7684\u56de\u8c03\uff0c\u89e6\u53d1message\u4e8b\u4ef6 4. state.handle.onmessage = onMessage; 5. // \u91cd\u70b9\uff0c\u5f00\u59cb\u76d1\u542c\u6570\u636e 6. state.handle.recvStart(); 7. state.receiving = true; 8. state.bindState = BIND_STATE_BOUND; 9. // \u8bbe\u7f6e\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u6536\u548c\u53d1\u9001\u7f13\u51b2\u533a\u5927\u5c0f 10. if (state.recvBufferSize) 11. bufferSize(socket, state.recvBufferSize, RECV_BUFFER); 12. 13. if (state.sendBufferSize) 14. bufferSize(socket, state.sendBufferSize, SEND_BUFFER); 15. 16. socket.emit('listening'); 17. } \u91cd\u70b9\u662frecvStart\u51fd\u6570\uff0c\u6211\u4eec\u770bC++\u7684\u5b9e\u73b0\u3002 1. void UDPWrap::RecvStart(const FunctionCallbackInfo<Value>& args) { 2. UDPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. int err = uv_udp_recv_start(&wrap->handle_, OnAlloc, OnRecv); 7. // UV_EALREADY means that the socket is already bound but that's okay 8. if (err == UV_EALREADY) 9. err = 0; 10. args.GetReturnValue().Set(err); 11. } OnAlloc, OnRecv\u5206\u522b\u662f\u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u548c\u6570\u636e\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u7ee7\u7eed\u770bLibuv 1. int uv__udp_recv_start(uv_udp_t* handle, 2. uv_alloc_cb alloc_cb, 3. uv_udp_recv_cb recv_cb) { 4. int err; 5. 6. 7. err = uv__udp_maybe_deferred_bind(handle, AF_INET, 0); 8. if (err) 9. return err; 10. // \u4fdd\u5b58\u4e00\u4e9b\u4e0a\u4e0b\u6587 11. handle->alloc_cb = alloc_cb; 12. handle->recv_cb = recv_cb; 13. // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u5982\u679c\u4e8b\u4ef6\u5230\u6765\uff0c\u7b49\u5230Poll IO\u9636\u6bb5\u5904\u7406 14. uv__io_start(handle->loop, &handle->io_watcher, POLLIN); 15. uv__handle_start(handle); 16. 17. return 0; 18. } uv__udp_recv_start\u4e3b\u8981\u662f\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u7b49\u5f85\u4e8b\u4ef6\u5230\u6765\u7684\u65f6\u5019\uff0c\u5230\u8fd9\uff0c\u670d\u52a1\u5668\u5c31\u542f\u52a8\u4e86\u3002","title":"16.2.1 \u670d\u52a1\u5668"},{"location":"chapter16-UDP/#1622","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5ba2\u6237\u7aef\u7684\u4f7f\u7528\u65b9\u5f0f\u548c\u6d41\u7a0b 1. const dgram = require('dgram'); 2. const message = Buffer.from('Some bytes'); 3. const client = dgram.createSocket('udp4'); 4. client.connect(41234, 'localhost', (err) => { 5. client.send(message, (err) => { 6. client.close(); 7. }); 8. }); \u6211\u4eec\u770b\u5230Node.js\u9996\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u7136\u540e\u8c03\u7528send\u53d1\u9001\u4fe1\u606f\uff0c\u6700\u540e\u8c03\u7528close\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002\u9996\u5148\u770bconnect\u3002 1. Socket.prototype.connect = function(port, address, callback) { 2. port = validatePort(port); 3. // \u53c2\u6570\u5904\u7406 4. if (typeof address === 'function') { 5. callback = address; 6. address = ''; 7. } else if (address === undefined) { 8. address = ''; 9. } 10. 11. const state = this[kStateSymbol]; 12. // \u4e0d\u662f\u521d\u59cb\u5316\u72b6\u6001 13. if (state.connectState !== CONNECT_STATE_DISCONNECTED) 14. throw new ERR_SOCKET_DGRAM_IS_CONNECTED(); 15. // \u8bbe\u7f6esocket\u72b6\u6001 16. state.connectState = CONNECT_STATE_CONNECTING; 17. // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u5148\u7ed1\u5b9a\u968f\u673a\u5730\u5740\uff08\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff09 18. if (state.bindState === BIND_STATE_UNBOUND) 19. this.bind({ port: 0, exclusive: true }, null); 20. // \u6267\u884cbind\u7684\u65f6\u5019\uff0cstate.bindState\u4e0d\u662f\u540c\u6b65\u8bbe\u7f6e\u7684 21. if (state.bindState !== BIND_STATE_BOUND) { 22. enqueue(this, _connect.bind(this, port, address, callback)); 23. return; 24. } 25. 26. _connect.call(this, port, address, callback); 27. }; \u8fd9\u91cc\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u5728connect\u4e4b\u524d\u5df2\u7ecf\u8c03\u7528\u4e86bind\uff0c\u7b2c\u4e8c\u79cd\u662f\u6ca1\u6709\u8c03\u7528bind\uff0c\u5982\u679c\u6ca1\u6709\u8c03\u7528bind\uff0c\u5219\u5728connect\u4e4b\u524d\u5148\u8981\u8c03\u7528bind\uff08\u56e0\u4e3abind\u4e2d\u4e0d\u4ec5\u4ec5\u7ed1\u5b9a\u4e86ip\u7aef\u53e3\uff0c\u8fd8\u6709\u7aef\u53e3\u590d\u7528\u7684\u5904\u7406\uff09\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u6ca1\u6709\u8c03\u7528bind\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u8fd9\u662f\u6700\u957f\u7684\u8def\u5f84\u3002bind\u521a\u624d\u6211\u4eec\u5206\u6790\u8fc7\u4e86\uff0c\u6211\u4eec\u4ece\u4ee5\u4e0b\u4ee3\u7801\u7ee7\u7eed\u5206\u6790 1. if (state.bindState !== BIND_STATE_BOUND) { 2. enqueue(this, _connect.bind(this, port, address, callback)); 3. return; 4. } enqueue\u628a\u4efb\u52a1\u52a0\u5165\u4efb\u52a1\u961f\u5217\uff0c\u5e76\u4e14\u76d1\u542c\u4e86listening\u4e8b\u4ef6\uff08\u8be5\u4e8b\u4ef6\u5728bind\u6210\u529f\u540e\u89e6\u53d1\uff09\u3002 1. function enqueue(self, toEnqueue) { 2. const state = self[kStateSymbol]; 3. if (state.queue === undefined) { 4. state.queue = []; 5. self.once('error', onListenError); 6. self.once('listening', onListenSuccess); 7. } 8. state.queue.push(toEnqueue); 9. } \u8fd9\u65f6\u5019connect\u51fd\u6570\u5c31\u6267\u884c\u5b8c\u4e86\uff0c\u7b49\u5f85bind\u6210\u529f\u540e\uff08nextTick\uff09\u4f1a\u6267\u884c startListening\u51fd\u6570\u3002 1. function startListening(socket) { 2. const state = socket[kStateSymbol]; 3. state.handle.onmessage = onMessage; 4. // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 5. state.handle.recvStart(); 6. state.receiving = true; 7. // \u6807\u8bb0\u5df2bind\u6210\u529f 8. state.bindState = BIND_STATE_BOUND; 9. // \u8bbe\u7f6e\u8bfb\u5199\u7f13\u51b2\u533a\u5927\u5c0f 10. if (state.recvBufferSize) 11. bufferSize(socket, state.recvBufferSize, RECV_BUFFER); 12. 13. if (state.sendBufferSize) 14. bufferSize(socket, state.sendBufferSize, SEND_BUFFER); 15. // \u89e6\u53d1listening\u4e8b\u4ef6 16. socket.emit('listening'); 17. } \u6211\u4eec\u770b\u5230startListening\u89e6\u53d1\u4e86listening\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884c\u6211\u4eec\u521a\u624d\u5165\u961f\u7684\u56de\u8c03onListenSuccess\u3002 1. function onListenSuccess() { 2. this.removeListener('error', onListenError); 3. clearQueue.call(this); 4. } 5. 6. function clearQueue() { 7. const state = this[kStateSymbol]; 8. const queue = state.queue; 9. state.queue = undefined; 10. 11. for (const queueEntry of queue) 12. queueEntry(); 13. } \u56de\u8c03\u5c31\u662f\u628a\u961f\u5217\u4e2d\u7684\u56de\u8c03\u6267\u884c\u4e00\u904d\uff0cconnect\u51fd\u6570\u8bbe\u7f6e\u7684\u56de\u8c03\u662f_connect\u3002 1. function _connect(port, address, callback) { 2. const state = this[kStateSymbol]; 3. if (callback) 4. this.once('connect', callback); 5. 6. const afterDns = (ex, ip) => { 7. defaultTriggerAsyncIdScope( 8. this[async_id_symbol], 9. doConnect, 10. ex, this, ip, address, port, callback 11. ); 12. }; 13. 14. state.handle.lookup(address, afterDns); 15. } \u8fd9\u91cc\u7684address\u662f\u670d\u52a1\u5668\u5730\u5740\uff0c_connect\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u662f 1 \u76d1\u542cconnect\u4e8b\u4ef6 2 \u5bf9\u670d\u52a1\u5668\u5730\u5740\u8fdb\u884cdns\u89e3\u6790\uff08\u53ea\u80fd\u662f\u672c\u5730\u7684\u914d\u7684\u57df\u540d\uff09\u3002\u89e3\u6790\u6210\u529f\u540e\u6267\u884cafterDns\uff0c\u6700\u540e\u6267\u884cdoConnect\uff0c\u5e76\u4f20\u5165\u89e3\u6790\u51fa\u6765\u7684ip\u3002\u6211\u4eec\u770b\u770bdoConnect 1. function doConnect(ex, self, ip, address, port, callback) { 2. const state = self[kStateSymbol]; 3. // dns\u89e3\u6790\u6210\u529f\uff0c\u6267\u884c\u5e95\u5c42\u7684connect 4. if (!ex) { 5. const err = state.handle.connect(ip, port); 6. if (err) { 7. ex = exceptionWithHostPort(err, 'connect', address, port); 8. } 9. } 10. 11. // connect\u6210\u529f\uff0c\u89e6\u53d1connect\u4e8b\u4ef6 12. state.connectState = CONNECT_STATE_CONNECTED; 13. process.nextTick(() => self.emit('connect')); 14. } connect\u51fd\u6570\u901a\u8fc7C++\u5c42\uff0c\u7136\u540e\u8c03\u7528Libuv\uff0c\u5230\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u3002\u4f5c\u7528\u662f\u628a\u670d\u52a1\u5668\u5730\u5740\u4fdd\u5b58\u5230socket\u4e2d\u3002connect\u7684\u6d41\u7a0b\u5c31\u8d70\u5b8c\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u53ef\u4ee5\u8c03\u7528send\u548crecv\u53d1\u9001\u548c\u63a5\u6536\u6570\u636e\u3002","title":"16.2.2 \u5ba2\u6237\u7aef"},{"location":"chapter16-UDP/#1623","text":"\u53d1\u9001\u6570\u636e\u63a5\u53e3\u662fsendto\uff0c\u5b83\u662f\u5bf9send\u7684\u5c01\u88c5\u3002 1. Socket.prototype.send = function(buffer, 2. offset, 3. length, 4. port, 5. address, 6. callback) { 7. 8. let list; 9. const state = this[kStateSymbol]; 10. const connected = state.connectState === CONNECT_STATE_CONNECTED; 11. // \u6ca1\u6709\u8c03\u7528connect\u7ed1\u5b9a\u8fc7\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u9700\u8981\u4f20\u670d\u52a1\u7aef\u5730\u5740\u4fe1\u606f 12. if (!connected) { 13. if (address || (port && typeof port !== 'function')) { 14. buffer = sliceBuffer(buffer, offset, length); 15. } else { 16. callback = port; 17. port = offset; 18. address = length; 19. } 20. } else { 21. if (typeof length === 'number') { 22. buffer = sliceBuffer(buffer, offset, length); 23. if (typeof port === 'function') { 24. callback = port; 25. port = null; 26. } 27. } else { 28. callback = offset; 29. } 30. // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u4e0d\u80fd\u518d\u4f20\u4e86 31. if (port || address) 32. throw new ERR_SOCKET_DGRAM_IS_CONNECTED(); 33. } 34. // \u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u5668\u7aef\u53e3\uff0c\u5219\u8fd9\u91cc\u9700\u8981\u4f20\uff0c\u5e76\u4e14\u6821\u9a8c 35. if (!connected) 36. port = validatePort(port); 37. // \u5ffd\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u903b\u8f91 38. // \u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u9700\u8981\u5148\u7ed1\u5b9a\uff0c\u503c\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a 39. if (state.bindState === BIND_STATE_UNBOUND) 40. this.bind({ port: 0, exclusive: true }, null); 41. // bind\u8fd8\u6ca1\u6709\u5b8c\u6210\uff0c\u5219\u5148\u5165\u961f\uff0c\u7b49\u5f85bind\u5b8c\u6210\u518d\u6267\u884c 42. if (state.bindState !== BIND_STATE_BOUND) { 43. enqueue(this, this.send.bind(this, 44. list, 45. port, 46. address, 47. callback)); 48. return; 49. } 50. // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\uff0c\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\u540e\u53d1\u9001\u6570\u636e 51. const afterDns = (ex, ip) => { 52. defaultTriggerAsyncIdScope( 53. this[async_id_symbol], 54. doSend, 55. ex, this, ip, list, address, port, callback 56. ); 57. }; 58. // \u4f20\u4e86\u5730\u5740\u5219\u53ef\u80fd\u9700\u8981dns\u89e3\u6790 59. if (!connected) { 60. state.handle.lookup(address, afterDns); 61. } else { 62. afterDns(null, null); 63. } 64. } \u6211\u4eec\u7ee7\u7eed\u770bdoSend\u51fd\u6570\u3002 1. function doSend(ex, self, ip, list, address, port, callback) { 2. const state = self[kStateSymbol]; 3. // dns\u89e3\u6790\u51fa\u9519 4. if (ex) { 5. if (typeof callback === 'function') { 6. process.nextTick(callback, ex); 7. return; 8. } 9. process.nextTick(() => self.emit('error', ex)); 10. return; 11. } 12. // \u5b9a\u4e49\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61 13. const req = new SendWrap(); 14. req.list = list; // Keep reference alive. 15. req.address = address; 16. req.port = port; 17. /* 18. \u8bbe\u7f6eNode.js\u548c\u7528\u6237\u7684\u56de\u8c03\uff0concomplete\u7531C++\u5c42\u8c03\u7528\uff0c 19. callback\u7531oncomplete\u8c03\u7528 20. */ 21. if (callback) { 22. req.callback = callback; 23. req.oncomplete = afterSend; 24. } 25. 26. let err; 27. // \u6839\u636e\u662f\u5426\u9700\u8981\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\uff0c\u8c03C++\u5c42\u51fd\u6570 28. if (port) 29. err = state.handle.send(req, list, list.length, port, ip, !!callback); 30. else 31. err = state.handle.send(req, list, list.length, !!callback); 32. /* 33. err\u5927\u4e8e\u7b49\u4e8e1\u8bf4\u660e\u540c\u6b65\u53d1\u9001\u6210\u529f\u4e86\uff0c\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c 34. \u5426\u5219\u7b49\u5f85\u5f02\u6b65\u56de\u8c03 35. */ 36. if (err >= 1) { 37. if (callback) 38. process.nextTick(callback, null, err - 1); 39. return; 40. } 41. // \u53d1\u9001\u5931\u8d25 42. if (err && callback) { 43. const ex=exceptionWithHostPort(err, 'send', address, port); 44. process.nextTick(callback, ex); 45. } 46. } \u6211\u4eec\u7a7f\u8fc7C++\u5c42\uff0c\u76f4\u63a5\u770bLibuv\u7684\u4ee3\u7801\u3002 1. int uv__udp_send(uv_udp_send_t* req, 2. uv_udp_t* handle, 3. const uv_buf_t bufs[], 4. unsigned int nbufs, 5. const struct sockaddr* addr, 6. unsigned int addrlen, 7. uv_udp_send_cb send_cb) { 8. int err; 9. int empty_queue; 10. 11. assert(nbufs > 0); 12. // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u7ed1\u5b9a 13. if (addr) { 14. err = uv__udp_maybe_deferred_bind(handle, 15. addr->sa_family, 16. 0); 17. if (err) 18. return err; 19. } 20. // \u5f53\u524d\u5199\u961f\u5217\u662f\u5426\u4e3a\u7a7a 21. empty_queue = (handle->send_queue_count == 0); 22. // \u521d\u59cb\u5316\u4e00\u4e2a\u5199\u8bf7\u6c42 23. uv__req_init(handle->loop, req, UV_UDP_SEND); 24. if (addr == NULL) 25. req->addr.ss_family = AF_UNSPEC; 26. else 27. memcpy(&req->addr, addr, addrlen); 28. // \u4fdd\u5b58\u4e0a\u4e0b\u6587 29. req->send_cb = send_cb; 30. req->handle = handle; 31. req->nbufs = nbufs; 32. // \u521d\u59cb\u5316\u6570\u636e\uff0c\u9884\u5206\u914d\u7684\u5185\u5b58\u4e0d\u591f\uff0c\u5219\u5206\u914d\u65b0\u7684\u5806\u5185\u5b58 33. req->bufs = req->bufsml; 34. if (nbufs > ARRAY_SIZE(req->bufsml)) 35. req->bufs = uv__malloc(nbufs * sizeof(bufs[0])); 36. // \u590d\u5236\u8fc7\u53bb\u5806\u4e2d 37. memcpy(req->bufs, bufs, nbufs * sizeof(bufs[0])); 38. // \u66f4\u65b0\u5199\u961f\u5217\u6570\u636e 39. handle->send_queue_size += uv__count_bufs(req->bufs, 40. req->nbufs); 41. handle->send_queue_count++; 42. // \u63d2\u5165\u5199\u961f\u5217\uff0c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u53d1\u751f 43. QUEUE_INSERT_TAIL(&handle->write_queue, &req->queue); 44. uv__handle_start(handle); 45. // \u5f53\u524d\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u5f00\u59cb\u5199\uff0c\u5426\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u961f\u5217 46. if (empty_queue && 47. !(handle->flags & UV_HANDLE_UDP_PROCESSING)) { 48. // \u53d1\u9001\u6570\u636e 49. uv__udp_sendmsg(handle); 50. // \u5199\u961f\u5217\u662f\u5426\u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u53ef\u5199\u7684\u65f6\u5019\u63a5\u7740\u5199 51. if (!QUEUE_EMPTY(&handle->write_queue)) 52. uv__io_start(handle->loop, &handle->io_watcher, POLLOUT); 53. } else { 54. uv__io_start(handle->loop, &handle->io_watcher, POLLOUT); 55. } 56. return 0; 57. } \u8be5\u51fd\u6570\u9996\u5148\u8bb0\u5f55\u5199\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u628a\u5199\u8bf7\u6c42\u63d2\u5165\u5199\u961f\u5217\u4e2d\uff0c\u5f53\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u6267\u884cuv__udp_sendmsg\u8fdb\u884c\u5199\u64cd\u4f5c\uff0c\u5426\u5219\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u5230\u6765\uff0c\u5f53\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 1. static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) { 2. uv_udp_t* handle; 3. if (revents & POLLOUT) { 4. uv__udp_sendmsg(handle); 5. uv__udp_run_completed(handle); 6. } 7. } \u6211\u4eec\u5148\u770buv__udp_sendmsg 1. static void uv__udp_sendmsg(uv_udp_t* handle) { 2. uv_udp_send_t* req; 3. QUEUE* q; 4. struct msghdr h; 5. ssize_t size; 6. // \u9010\u4e2a\u8282\u70b9\u53d1\u9001 7. while (!QUEUE_EMPTY(&handle->write_queue)) { 8. q = QUEUE_HEAD(&handle->write_queue); 9. req = QUEUE_DATA(q, uv_udp_send_t, queue); 10. memset(&h, 0, sizeof h); 11. // \u5ffd\u7565\u53c2\u6570\u5904\u7406 12. h.msg_iov = (struct iovec*) req->bufs; 13. h.msg_iovlen = req->nbufs; 14. 15. do { 16. size = sendmsg(handle->io_watcher.fd, &h, 0); 17. } while (size == -1 && errno == EINTR); 18. 19. if (size == -1) { 20. // \u7e41\u5fd9\u5219\u5148\u4e0d\u53d1\u4e86\uff0c\u7b49\u5230\u53ef\u5199\u4e8b\u4ef6 21. if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS) 22. break; 23. } 24. // \u8bb0\u5f55\u53d1\u9001\u7ed3\u679c 25. req->status = (size == -1 ? UV__ERR(errno) : size); 26. // \u53d1\u9001\u201c\u5b8c\u201d\u79fb\u51fa\u5199\u961f\u5217 27. QUEUE_REMOVE(&req->queue); 28. // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 29. QUEUE_INSERT_TAIL(&handle->write_completed_queue, &req->queue); 30. /* 31. \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c 32. pending\u9636\u6bb5\u6267\u884c\u56de\u8c03uv__udp_io 33. */ 34. uv__io_feed(handle->loop, &handle->io_watcher); 35. } 36. } \u8be5\u51fd\u6570\u904d\u5386\u5199\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u53d1\u9001\u8282\u70b9\u4e2d\u7684\u6570\u636e\uff0c\u5e76\u8bb0\u5f55\u53d1\u9001\u7ed3\u679c\u3002 1 \u5982\u679c\u5199\u7e41\u5fd9\u5219\u7ed3\u675f\u5199\u903b\u8f91\uff0c\u7b49\u5f85\u4e0b\u4e00\u6b21\u5199\u4e8b\u4ef6\u89e6\u53d1\u3002 2 \u5982\u679c\u5199\u6210\u529f\u5219\u628a\u8282\u70b9\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\u3002 \u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 \u6211\u4eec\u518d\u6b21\u56de\u5230uv__udp_io\u4e2d 1. if (revents & POLLOUT) { 2. uv__udp_sendmsg(handle); 3. uv__udp_run_completed(handle); 4. } \u6211\u4eec\u770b\u5230\u8fd9\u65f6\u5019\u4f1a\u7ee7\u7eed\u6267\u884c\u6570\u636e\u53d1\u9001\u7684\u903b\u8f91\uff0c\u7136\u540e\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u3002\u6211\u4eec\u770buv__udp_run_completed\u3002 1. static void uv__udp_run_completed(uv_udp_t* handle) { 2. uv_udp_send_t* req; 3. QUEUE* q; 4. handle->flags |= UV_HANDLE_UDP_PROCESSING; 5. // \u9010\u4e2a\u8282\u70b9\u5904\u7406 6. while (!QUEUE_EMPTY(&handle->write_completed_queue)) { 7. q = QUEUE_HEAD(&handle->write_completed_queue); 8. QUEUE_REMOVE(q); 9. req = QUEUE_DATA(q, uv_udp_send_t, queue); 10. uv__req_unregister(handle->loop, req); 11. // \u66f4\u65b0\u5f85\u5199\u6570\u636e\u5927\u5c0f 12. handle->send_queue_size -= uv__count_bufs(req->bufs, req->nbufs); 13. handle->send_queue_count--; 14. // \u5982\u679c\u91cd\u65b0\u7533\u8bf7\u4e86\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e 15. if (req->bufs != req->bufsml) 16. uv__free(req->bufs); 17. req->bufs = NULL; 18. if (req->send_cb == NULL) 19. continue; 20. // \u6267\u884c\u56de\u8c03 21. if (req->status >= 0) 22. req->send_cb(req, 0); 23. else 24. req->send_cb(req, req->status); 25. } 26. // \u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 27. if (QUEUE_EMPTY(&handle->write_queue)) { 28. uv__io_stop(handle->loop, &handle->io_watcher, POLLOUT); 29. if (!uv__io_active(&handle->io_watcher, POLLIN)) 30. uv__handle_stop(handle); 31. } 32. handle->flags &= ~UV_HANDLE_UDP_PROCESSING; 33. } \u8fd9\u5c31\u662f\u53d1\u9001\u7684\u903b\u8f91\uff0c\u53d1\u9001\u5b8c\u540eLibuv\u4f1a\u8c03\u7528C++\u56de\u8c03\uff0c\u6700\u540e\u56de\u8c03JS\u5c42\u56de\u8c03\u3002\u5177\u4f53\u5230\u64cd\u4f5c\u7cfb\u7edf\u4e5f\u662f\u7c7b\u4f3c\u7684\u5b9e\u73b0\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u5224\u65ad\u6570\u636e\u7684\u5927\u5c0f\u662f\u5426\u5c0f\u4e8e\u5199\u7f13\u51b2\u533a\uff0c\u662f\u7684\u8bdd\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u6784\u9020UDP\u534f\u8bae\u6570\u636e\u5305\uff0c\u518d\u9010\u5c42\u5f80\u4e0b\u8c03\uff0c\u6700\u540e\u53d1\u9001\u51fa\u6765\uff0c\u4f46\u662f\u5982\u679c\u6570\u636e\u8d85\u8fc7\u4e86\u5e95\u5c42\u7684\u62a5\u6587\u5927\u5c0f\u9650\u5236\uff0c\u5219\u4f1a\u88ab\u5206\u7247\u3002","title":"16.2.3 \u53d1\u9001\u6570\u636e"},{"location":"chapter16-UDP/#1624","text":"UDP\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u6ce8\u518c\u4e86\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u7684\u53d1\u9001\uff0c\u5982\u679c\u6536\u5230\u4e86\u6570\u636e\uff0c\u5219\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u88ab\u5904\u7406\u3002\u524d\u9762\u6211\u4eec\u8bb2\u8fc7\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__udp_io\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8be5\u51fd\u6570\u600e\u4e48\u5904\u7406\u7684\u3002 1. static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) { 2. uv_udp_t* handle; 3. 4. handle = container_of(w, uv_udp_t, io_watcher); 5. // \u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1 6. if (revents & POLLIN) 7. uv__udp_recvmsg(handle); 8. } \u6211\u4eec\u770buv__udp_recvmsg\u7684\u903b\u8f91\u3002 1. static void uv__udp_recvmsg(uv_udp_t* handle) { 2. struct sockaddr_storage peer; 3. struct msghdr h; 4. ssize_t nread; 5. uv_buf_t buf; 6. int flags; 7. int count; 8. 9. count = 32; 10. 11. do { 12. // \u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\uff0cC++\u5c42\u8bbe\u7f6e\u7684 13. buf = uv_buf_init(NULL, 0); 14. handle->alloc_cb((uv_handle_t*) handle, 64 * 1024, &buf); 15. memset(&h, 0, sizeof(h)); 16. memset(&peer, 0, sizeof(peer)); 17. h.msg_name = &peer; 18. h.msg_namelen = sizeof(peer); 19. h.msg_iov = (void*) &buf; 20. h.msg_iovlen = 1; 21. // \u8c03\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u8bfb\u53d6\u6570\u636e 22. do { 23. nread = recvmsg(handle->io_watcher.fd, &h, 0); 24. } 25. while (nread == -1 && errno == EINTR); 26. // \u8c03\u7528C++\u5c42\u56de\u8c03 27. handle->recv_cb(handle, 28. nread, 29. &buf, 30. (const struct sockaddr*) &peer, 31. flags); 32. } 33. } \u6700\u7ec8\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u8c03\u7528recvmsg\u8bfb\u53d6\u6570\u636e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2audp\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\uff0c\u5982\u679c\u63a5\u6536\u961f\u5217\u6ee1\u4e86\u5219\u4f1a\u4e22\u5f03\uff0c\u5f53\u7528\u6237\u8c03\u7528recvmsg\u51fd\u6570\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u628a\u63a5\u6536\u961f\u5217\u4e2d\u8282\u70b9\u9010\u4e2a\u8fd4\u56de\u7ed9\u7528\u6237\u3002\u8bfb\u53d6\u5b8c\u540e\uff0cLibuv\u4f1a\u56de\u8c03C++\u5c42\uff0c\u7136\u540eC++\u5c42\u56de\u8c03\u5230JS\u5c42\uff0c\u6700\u540e\u89e6\u53d1message\u4e8b\u4ef6\uff0c\u8fd9\u5c31\u662f\u5bf9\u5e94\u5f00\u59cb\u90a3\u6bb5\u4ee3\u7801\u7684message\u4e8b\u4ef6\u3002","title":"16.2.4 \u63a5\u6536\u6570\u636e"},{"location":"chapter16-UDP/#1625","text":"\u6211\u4eec\u77e5\u9053\uff0cTCP\u662f\u57fa\u4e8e\u8fde\u63a5\u548c\u53ef\u9760\u7684\uff0c\u591a\u64ad\u5219\u4f1a\u5e26\u6765\u8fc7\u591a\u7684\u8fde\u63a5\u548c\u6d41\u91cf\uff0c\u6240\u4ee5TCP\u662f\u4e0d\u652f\u6301\u591a\u64ad\u7684\uff0c\u800cUDP\u5219\u652f\u6301\u591a\u64ad\u3002\u591a\u64ad\u5206\u4e3a\u5c40\u57df\u7f51\u591a\u64ad\u548c\u5e7f\u57df\u7f51\u591a\u64ad\uff0c\u6211\u4eec\u77e5\u9053\u5728\u5c40\u57df\u7f51\u5185\u53d1\u751f\u4e00\u4e2a\u6570\u636e\uff0c\u662f\u4f1a\u4ee5\u5e7f\u64ad\u7684\u5f62\u5f0f\u53d1\u9001\u5230\u5404\u4e2a\u4e3b\u673a\u7684\uff0c\u4e3b\u673a\u6839\u636e\u76ee\u7684\u5730\u5740\u5224\u65ad\u662f\u5426\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u5355\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u53ea\u4f1a\u6709\u4e00\u4e2a\u4e3b\u673a\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u591a\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u6709\u591a\u4e2a\u4e3b\u673a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u591a\u64ad\u7684\u65f6\u5019\uff0c\u5b58\u5728\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u6982\u5ff5\uff0c\u8fd9\u5c31\u662fIGMP\u505a\u7684\u4e8b\u60c5\u3002\u5b83\u5b9a\u4e49\u4e86\u7ec4\u7684\u6982\u5ff5\u3002\u53ea\u6709\u52a0\u5165\u8fd9\u4e2a\u7ec4\u7684\u4e3b\u673a\u624d\u80fd\u5904\u7406\u8be5\u7ec4\u7684\u6570\u636e\u5305\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5c40\u57df\u7f51\uff0c\u5982\u56fe16-1\u6240\u793a\u3002 \u56fe16-1 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e3b\u673a4\u53ef\u4ee5\u6536\u5230\uff0c\u4e3b\u673a2\uff0c3\u5219\u65e0\u6cd5\u6536\u5230\u3002 \u6211\u4eec\u518d\u6765\u770b\u770b\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u3002\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u9700\u8981\u8def\u7531\u5668\u7684\u652f\u6301\uff0c\u591a\u4e2a\u8def\u7531\u5668\u4e4b\u95f4\u4f1a\u4f7f\u7528\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u591a\u64ad\u7ec4\u7684\u4fe1\u606f\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5e7f\u57df\u7f51\uff0c\u5982\u56fe16-2\u6240\u793a\u3002 \u56fe16-2 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u8def\u7531\u56681\u4f1a\u7ed9\u8def\u7531\u56682\u53d1\u9001\u4e00\u4efd\u6570\u636e\uff08\u901a\u8fc7\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u4e86\u4fe1\u606f\uff0c\u8def\u75311\u77e5\u9053\u8def\u7531\u56682\u7684\u4e3b\u673a7\u5728\u591a\u64ad\u7ec41\u4e2d\uff09\uff0c\u4f46\u662f\u8def\u7531\u56682\u4e0d\u4f1a\u7ed9\u8def\u7531\u56683\u53d1\u9001\u6570\u636e\uff0c\u56e0\u4e3a\u5b83\u77e5\u9053\u8def\u7531\u56683\u5bf9\u5e94\u7684\u7f51\u7edc\u4e2d\u6ca1\u6709\u4e3b\u673a\u5728\u591a\u64ad\u7ec41\u3002 \u4ee5\u4e0a\u662f\u591a\u64ad\u7684\u4e00\u4e9b\u6982\u5ff5\u3002Node.js\u4e2d\u5173\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\uff0c\u57fa\u672c\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u6240\u4ee5\u5c31\u4e0d\u6253\u7b97\u8bb2\u89e3\uff0c\u6211\u4eec\u76f4\u63a5\u770b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5bf9\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\u3002","title":"16.2.5 \u591a\u64ad"},{"location":"chapter16-UDP/#16251","text":"\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u63a5\u53e3\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002 1. setsockopt(fd, 2. IPPROTO_IP, 3. IP_ADD_MEMBERSHIP, 4. &mreq, // \u8bb0\u5f55\u51fa\u53e3ip\u548c\u52a0\u5165\u591a\u64ad\u7ec4\u7684ip 5. sizeof(mreq)); mreq\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b 1. struct ip_mreq 2. { 3. // \u52a0\u5165\u7684\u591a\u64ad\u7ec4ip 4. struct in_addr imr_multiaddr; 5. // \u51fa\u53e3ip 6. struct in_addr imr_interface; 7. }; \u6211\u4eec\u770b\u4e00\u4e0bsetsockopt\u7684\u5b9e\u73b0\uff08\u53ea\u5217\u51fa\u76f8\u5173\u90e8\u5206\u4ee3\u7801\uff09 1. case IP_ADD_MEMBERSHIP: 2. { 3. struct ip_mreq mreq; 4. static struct options optmem; 5. unsigned long route_src; 6. struct rtable *rt; 7. struct device *dev=NULL; 8. err=verify_area(VERIFY_READ, optval, sizeof(mreq)); 9. memcpy_fromfs(&mreq,optval,sizeof(mreq)); 10. // \u6ca1\u6709\u8bbe\u7f6edevice\u5219\u6839\u636e\u591a\u64ad\u7ec4ip\u9009\u62e9\u4e00\u4e2adevice 11. if(mreq.imr_interface.s_addr==INADDR_ANY) 12. { 13. if((rt=ip_rt_route(mreq.imr_multiaddr.s_addr, 14. &optmem, &route_src))!=NULL) 15. { 16. dev=rt->rt_dev; 17. rt->rt_use--; 18. } 19. } 20. else 21. { 22. // \u6839\u636e\u8bbe\u7f6e\u7684ip\u627e\u5230\u5bf9\u5e94\u7684device 23. for(dev = dev_base; dev; dev = dev->next) 24. { 25. // \u5728\u5de5\u4f5c\u72b6\u6001\u3001\u652f\u6301\u591a\u64ad\uff0cip\u4e00\u6837 26. if((dev->flags&IFF_UP)&& 27. (dev->flags&IFF_MULTICAST)&& 28. (dev->pa_addr==mreq.imr_interface.s_addr 29. )) 30. break; 31. } 32. } 33. // \u52a0\u5165\u591a\u64ad\u7ec4 34. return ip_mc_join_group(sk, 35. dev, 36. mreq.imr_multiaddr.s_addr); 37. } 38. \u9996\u5148\u62ff\u5230\u52a0\u5165\u7684\u591a\u64ad\u7ec4IP\u548c\u51fa\u53e3IP\u5bf9\u5e94\u7684device\u540e\uff0c\u8c03\u7528ip_mc_join_group\uff0c\u5728socket\u7ed3\u6784\u4f53\u4e2d\uff0c\u6709\u4e00\u4e2a\u5b57\u6bb5\u7ef4\u62a4\u4e86\u8be5socket\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-3\u6240\u793a\u3002 \u56fe16-3 \u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bip_mc_join_group 1. int ip_mc_join_group(struct sock *sk , 2. struct device *dev, 3. unsigned long addr) 4. { 5. int unused= -1; 6. int i; 7. // \u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u591a\u64ad\u7ec4\u5219\u5206\u914d\u4e00\u4e2aip_mc_socklist\u7ed3\u6784\u4f53 8. if(sk->ip_mc_list==NULL) 9. { 10. if((sk->ip_mc_list=(struct ip_mc_socklist *)kmalloc(sizeof(*sk->ip_mc_list), GFP_KERNEL))==NULL) 11. return -ENOMEM; 12. memset(sk->ip_mc_list,'\\0',sizeof(*sk->ip_mc_list)); 13. } 14. // \u904d\u5386\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u52a0\u5165\u8fc7 15. for(i=0;i<IP_MAX_MEMBERSHIPS;i++) 16. { 17. if(sk->ip_mc_list->multiaddr[i]==addr && 18. sk->ip_mc_list->multidev[i]==dev) 19. return -EADDRINUSE; 20. if(sk->ip_mc_list->multidev[i]==NULL) 21. // \u8bb0\u5f55\u53ef\u7528\u4f4d\u7f6e\u7684\u7d22\u5f15 22. unused=i; 23. } 24. // \u5230\u8fd9\u8bf4\u660e\u6ca1\u6709\u52a0\u5165\u8fc7\u5f53\u524d\u8bbe\u7f6e\u7684\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u4e14\u52a0\u5165 25. if(unused==-1) 26. return -ENOBUFS; 27. sk->ip_mc_list->multiaddr[unused]=addr; 28. sk->ip_mc_list->multidev[unused]=dev; 29. // addr\u4e3a\u591a\u64ad\u7ec4ip 30. ip_mc_inc_group(dev,addr); 31. return 0; 32. } ip_mc_join_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u628asocket\u60f3\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\u8bb0\u5f55\u5230socket\u7684ip_mc_list\u5b57\u6bb5\u4e2d\uff08\u5982\u679c\u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\u7684\u8bdd\uff09\u3002\u63a5\u7740\u8c03ip_mc_inc_group\u5f80\u4e0b\u8d70\u3002device\u7684ip_mc_list\u5b57\u6bb5\u7ef4\u62a4\u4e86\u4e3b\u673a\u4e2d\u4f7f\u7528\u4e86\u8be5device\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-4\u6240\u793a\u3002 \u56fe16-4 1. static void ip_mc_inc_group(struct device *dev, 2. unsigned long addr) 3. { 4. struct ip_mc_list *i; 5. /* 6. \u904d\u5386\u8be5\u8bbe\u5907\u7ef4\u62a4\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c 7. \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\uff0c\u662f\u5219\u5f15\u7528\u6570\u52a0\u4e00 8. */ 9. for(i=dev->ip_mc_list;i!=NULL;i=i->next) 10. { 11. if(i->multiaddr==addr) 12. { 13. i->users++; 14. return; 15. } 16. } 17. // \u5230\u8fd9\u8bf4\u660e\uff0c\u8fd8\u6ca1\u6709socket\u52a0\u5165\u8fc7\u5f53\u524d\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u52a0\u5165 18. i=(struct ip_mc_list *)kmalloc(sizeof(*i), GFP_KERNEL); 19. if(!i) 20. return; 21. i->users=1; 22. i->interface=dev; 23. i->multiaddr=addr; 24. i->next=dev->ip_mc_list; 25. // \u901a\u8fc7igmp\u901a\u77e5\u5176\u5b83\u65b9 26. igmp_group_added(i); 27. dev->ip_mc_list=i; 28. } ip_mc_inc_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u5224\u65adsocket\u60f3\u8981\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u662f\u4e0d\u662f\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524ddevice\u4e2d\uff0c\u5982\u679c\u4e0d\u662f\u5219\u65b0\u589e\u4e00\u4e2a\u8282\u70b9\u3002\u7ee7\u7eed\u8c03\u7528igmp_group_added 1. static void igmp_group_added(struct ip_mc_list *im) 2. { 3. // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 4. igmp_init_timer(im); 5. /* 6. \u53d1\u9001\u4e00\u4e2aigmp\u6570\u636e\u5305\uff0c\u540c\u6b65\u591a\u64ad\u7ec4\u4fe1\u606f\uff08socket\u52a0\u5165 7. \u4e86\u4e00\u4e2a\u65b0\u7684\u591a\u64ad\u7ec4\uff09 8. */ 9. igmp_send_report(im->interface, 10. im->multiaddr, 11. IGMP_HOST_MEMBERSHIP_REPORT); 12. // \u8f6c\u6362\u591a\u64ad\u7ec4ip\u5230\u591a\u64admac\u5730\u5740\uff0c\u5e76\u8bb0\u5f55\u5230device\u4e2d 13. ip_mc_filter_add(im->interface, im->multiaddr); 14. } \u6211\u4eec\u770b\u770bigmp_send_report\u548cip_mc_filter_add\u7684\u5177\u4f53\u903b\u8f91\u3002 1. static void igmp_send_report(struct device *dev, 2. unsigned long address, 3. int type) 4. { 5. // \u7533\u8bf7\u4e00\u4e2askb\u8868\u793a\u4e00\u4e2a\u6570\u636e\u5305 6. struct sk_buff *skb=alloc_skb(MAX_IGMP_SIZE, GFP_ATOMIC); 7. int tmp; 8. struct igmphdr *igh; 9. /* 10. \u6784\u5efaip\u5934\uff0cip\u534f\u8bae\u5934\u7684\u6e90ip\u662fINADDR_ANY\uff0c 11. \u5373\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u672c\u673a\u7684\uff0c\u76ee\u7684ip\u4e3a\u591a\u64ad\u7ec4ip\uff08address\uff09 12. */ 13. tmp=ip_build_header(skb, 14. INADDR_ANY, 15. address, 16. &dev, 17. IPPROTO_IGMP, 18. NULL, 19. skb->mem_len, 0, 1); 20. /* 21. data\u8868\u793a\u6240\u6709\u7684\u6570\u636e\u90e8\u5206\uff0ctmp\u8868\u793aip\u5934\u5927\u5c0f\uff0c\u6240\u4ee5igh 22. \u5c31\u662fip\u534f\u8bae\u7684\u6570\u636e\u90e8\u5206\uff0c\u5373igmp\u62a5\u6587\u7684\u5185\u5bb9 23. */ 24. igh=(struct igmphdr *)(skb->data+tmp); 25. skb->len=tmp+sizeof(*igh); 26. igh->csum=0; 27. igh->unused=0; 28. igh->type=type; 29. igh->group=address; 30. igh->csum=ip_compute_csum((void *)igh,sizeof(*igh)); 31. // \u8c03\u7528ip\u5c42\u53d1\u9001\u51fa\u53bb 32. ip_queue_xmit(NULL,dev,skb,1); 33. } igmp_send_report\u5176\u5b9e\u5c31\u662f\u6784\u9020\u4e00\u4e2aIGMP\u534f\u8bae\u6570\u636e\u5305\uff0c\u7136\u540e\u53d1\u9001\u51fa\u53bb\uff0c\u544a\u8bc9\u8def\u7531\u5668\u67d0\u4e2a\u4e3b\u673a\u52a0\u5165\u4e86\u591a\u64ad\u7ec4\uff0cIGMP\u7684\u534f\u8bae\u683c\u5f0f\u5982\u4e0b 1. struct igmphdr 2. { 3. // \u7c7b\u578b 4. unsigned char type; 5. unsigned char unused; 6. // \u6821\u9a8c\u548c 7. unsigned short csum; 8. // igmp\u7684\u6570\u636e\u90e8\u5206\uff0c\u6bd4\u5982\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0cgroup\u8868\u793a\u591a\u64ad\u7ec4ip 9. unsigned long group; 10. }; \u63a5\u7740\u6211\u4eec\u770bip_mc_filter_add 1. void ip_mc_filter_add(struct device *dev, unsigned long addr) 2. { 3. char buf[6]; 4. // \u628a\u591a\u64ad\u7ec4ip\u8f6c\u6210mac\u591a\u64ad\u5730\u5740 5. addr=ntohl(addr); 6. buf[0]=0x01; 7. buf[1]=0x00; 8. buf[2]=0x5e; 9. buf[5]=addr&0xFF; 10. addr>>=8; 11. buf[4]=addr&0xFF; 12. addr>>=8; 13. buf[3]=addr&0x7F; 14. dev_mc_add(dev,buf,ETH_ALEN,0); 15. } \u6211\u4eec\u77e5\u9053IP\u5730\u5740\u662f32\u4f4d\uff0cmac\u5730\u5740\u662f48\u4f4d\uff0c\u4f46\u662fIANA\u89c4\u5b9a\uff0cIP V4\u7ec4\u64adMAC\u5730\u5740\u7684\u9ad824\u4f4d\u662f0x01005E\uff0c\u7b2c25\u4f4d\u662f0\uff0c\u4f4e23\u4f4d\u662fipv4\u7ec4\u64ad\u5730\u5740\u7684\u4f4e23\u4f4d\u3002\u800c\u591a\u64ad\u7684IP\u5730\u5740\u9ad8\u56db\u4f4d\u56fa\u5b9a\u662f1110\u3002\u53e6\u5916\u4f4e23\u4f4d\u88ab\u6620\u5c04\u5230MAC\u591a\u64ad\u5730\u5740\u768423\u4f4d\uff0c\u6240\u4ee5\u591a\u64adIP\u5730\u5740\u4e2d\uff0c\u67095\u4f4d\u662f\u53ef\u4ee5\u968f\u673a\u7ec4\u5408\u7684\u3002\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u6bcf32\u4e2a\u591a\u64adIP\u5730\u5740\uff0c\u6620\u5c04\u5230\u4e00\u4e2aMAC\u5730\u5740\u3002\u8fd9\u4f1a\u5e26\u6765\u4e00\u4e9b\u95ee\u9898\uff0c\u5047\u8bbe\u4e3b\u673ax\u52a0\u5165\u4e86\u591a\u64ad\u7ec4a\uff0c\u4e3b\u673ay\u52a0\u5165\u4e86\u591a\u64ad\u7ec4b\uff0c\u800ca\u548cb\u5bf9\u5e94\u7684mac\u591a\u64ad\u5730\u5740\u662f\u4e00\u6837\u7684\u3002\u5f53\u4e3b\u673az\u7ed9\u591a\u64ad\u7ec4a\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8fd9\u65f6\u5019\u4e3b\u673ax\u548cy\u7684\u7f51\u5361\u90fd\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\uff0c\u5e76\u4e0a\u62a5\u5230\u4e0a\u5c42\uff0c\u4f46\u662f\u591a\u64ad\u7ec4a\u5bf9\u5e94\u7684MAC\u591a\u64ad\u5730\u5740\u548c\u591a\u64ad\u7ec4b\u662f\u4e00\u6837\u7684\u3002\u6211\u4eec\u62ff\u5230\u4e00\u4e2a\u591a\u64ad\u7ec4ip\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u8ba1\u7b97\u51fa\u5b83\u7684\u591a\u64adMAC\u5730\u5740\uff0c\u4f46\u662f\u53cd\u8fc7\u6765\u5c31\u4e0d\u884c\uff0c\u56e0\u4e3a\u4e00\u4e2a\u591a\u64admac\u5730\u5740\u5bf9\u5e94\u4e8632\u4e2a\u591a\u64adip\u5730\u5740\u3002\u90a3\u4e3b\u673ax\u548cy\u600e\u4e48\u5224\u65ad\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff1f\u56e0\u4e3adevice\u7ef4\u62a4\u4e86\u4e00\u4e2a\u672cdevice\u4e0a\u7684\u591a\u64adIP\u5217\u8868\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u6536\u5230\u7684\u6570\u636e\u5305\u4e2d\u7684IP\u76ee\u7684\u5730\u5740\u548cdevice\u7684\u591a\u64adIP\u5217\u8868\u5bf9\u6bd4\u3002\u5982\u679c\u5728\u5217\u8868\u4e2d\uff0c\u5219\u8bf4\u660e\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u770bdev_mc_add\u3002device\u4e2d\u7ef4\u62a4\u4e86\u5f53\u524d\u7684mac\u591a\u64ad\u5730\u5740\u5217\u8868\uff0c\u5b83\u4f1a\u628a\u8fd9\u4e2a\u5217\u8868\u4fe1\u606f\u540c\u6b65\u5230\u7f51\u5361\u4e2d\uff0c\u4f7f\u5f97\u7f51\u5361\u53ef\u4ee5\u5904\u7406\u8be5\u5217\u8868\u4e2d\u591a\u64admac\u5730\u5740\u7684\u6570\u636e\u5305\uff0c\u5982\u56fe16-5\u6240\u793a\u3002 \u56fe16-5 1. void dev_mc_add(struct device *dev, void *addr, int alen, int newonly) 2. { 3. struct dev_mc_list *dmi; 4. // device\u7ef4\u62a4\u7684\u591a\u64admac\u5730\u5740\u5217\u8868 5. for(dmi=dev->mc_list;dmi!=NULL;dmi=dmi->next) 6. { 7. // \u5df2\u5b58\u5728\uff0c\u5219\u5f15\u7528\u8ba1\u6570\u52a0\u4e00 8. if(memcmp(dmi->dmi_addr,addr,dmi->dmi_addrlen)==0 && 9. dmi->dmi_addrlen==alen) 10. { 11. if(!newonly) 12. dmi->dmi_users++; 13. return; 14. } 15. } 16. // \u4e0d\u5b58\u5728\u5219\u65b0\u589e\u4e00\u4e2a\u9879\u5230device\u5217\u8868\u4e2d 17. dmi=(struct dev_mc_list *)kmalloc(sizeof(*dmi),GFP_KERNEL); 18. memcpy(dmi->dmi_addr, addr, alen); 19. dmi->dmi_addrlen=alen; 20. dmi->next=dev->mc_list; 21. dmi->dmi_users=1; 22. dev->mc_list=dmi; 23. dev->mc_count++; 24. // \u901a\u77e5\u7f51\u5361\u9700\u8981\u5904\u7406\u8be5\u591a\u64admac\u5730\u5740 25. dev_mc_upload(dev); 26. } \u7f51\u5361\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u51e0\u79cd\uff0c\u5206\u522b\u662f\u6b63\u5e38\u6a21\u5f0f\uff08\u53ea\u63a5\u6536\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff09\u3001\u6df7\u6742\u6a21\u5f0f\uff08\u63a5\u6536\u6240\u6709\u6570\u636e\u5305\uff09\u3001\u591a\u64ad\u6a21\u5f0f\uff08\u63a5\u6536\u4e00\u822c\u6570\u636e\u5305\u548c\u591a\u64ad\u6570\u636e\u5305\uff09\u3002\u7f51\u5361\u9ed8\u8ba4\u662f\u53ea\u5904\u7406\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u7f51\u5361\uff0c\u5f53\u6536\u5230\u8be5\u591a\u64ad\u7ec4\u7684\u6570\u636e\u5305\u65f6\uff0c\u9700\u8981\u5904\u7406\uff0c\u800c\u4e0d\u662f\u5ffd\u7565\u3002dev_mc_upload\u51fd\u6570\u5c31\u662f\u901a\u77e5\u7f51\u5361\u3002 1. void dev_mc_upload(struct device *dev) 2. { 3. struct dev_mc_list *dmi; 4. char *data, *tmp; 5. // \u4e0d\u5de5\u4f5c\u4e86 6. if(!(dev->flags&IFF_UP)) 7. return; 8. /* 9. \u5f53\u524d\u662f\u6df7\u6742\u6a21\u5f0f\uff0c\u5219\u4e0d\u9700\u8981\u8bbe\u7f6e\u591a\u64ad\u4e86\uff0c\u56e0\u4e3a\u7f51\u5361\u4f1a\u5904\u7406\u6240\u6709 10. \u6536\u5230\u7684\u6570\u636e\uff0c\u4e0d\u7ba1\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684 11. */ 12. if(dev->flags&IFF_PROMISC) 13. { 14. dev->set_multicast_list(dev, -1, NULL); 15. return; 16. } 17. /* 18. \u591a\u64ad\u5730\u5740\u4e2a\u6570\uff0c\u4e3a0\uff0c\u5219\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u4e3a\u6b63\u5e38\u6a21\u5f0f\uff0c 19. \u56e0\u4e3a\u4e0d\u9700\u8981\u5904\u7406\u591a\u64ad\u4e86 20. */ 21. if(dev->mc_count==0) 22. { 23. dev->set_multicast_list(dev,0,NULL); 24. return; 25. } 26. 27. data=kmalloc(dev->mc_count*dev->addr_len, GFP_KERNEL); 28. // \u590d\u5236\u6240\u6709\u7684\u591a\u64admac\u5730\u5740\u4fe1\u606f 29. for(tmp = data, dmi=dev->mc_list;dmi!=NULL;dmi=dmi->next) 30. { 31. memcpy(tmp,dmi->dmi_addr, dmi->dmi_addrlen); 32. tmp+=dev->addr_len; 33. } 34. // \u544a\u8bc9\u7f51\u5361 35. dev->set_multicast_list(dev,dev->mc_count,data); 36. kfree(data); 37. } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bset_multicast_list 1. static void set_multicast_list(struct device *dev, int num_addrs, void *addrs) 2. { 3. int ioaddr = dev->base_addr; 4. // \u591a\u64ad\u6a21\u5f0f 5. if (num_addrs > 0) { 6. outb(RX_MULT, RX_CMD); 7. inb(RX_STATUS); /* Clear status. */ 8. } else if (num_addrs < 0) { // \u6df7\u6742\u6a21\u5f0f 9. outb(RX_PROM, RX_CMD); 10. inb(RX_STATUS); 11. } else { // \u6b63\u5e38\u6a21\u5f0f 12. outb(RX_NORM, RX_CMD); 13. inb(RX_STATUS); 14. } 15. } set_multicast_list\u5c31\u662f\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u7684\u51fd\u6570\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u6210\u529f\u52a0\u5165\u4e86\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002\u79bb\u5f00\u4e00\u4e2a\u591a\u64ad\u7ec4\u4e5f\u662f\u7c7b\u4f3c\u7684\u8fc7\u7a0b\u3002","title":"16.2.5.1 \u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4"},{"location":"chapter16-UDP/#16252","text":"\u52a0\u5165\u591a\u64ad\u7ec4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u9000\u51fa\u591a\u64ad\u7ec4\uff0c\u4f46\u662f\u5982\u679c\u4e3b\u673a\u6302\u4e86\uff0c\u5c31\u65e0\u6cd5\u4e3b\u52a8\u9000\u51fa\u4e86\uff0c\u6240\u4ee5\u591a\u64ad\u8def\u7531\u4e5f\u4f1a\u5b9a\u671f\u5411\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\uff0c\u6240\u4ee5\u4e3b\u673a\u9700\u8981\u76d1\u542c\u6765\u81ea\u591a\u64ad\u8def\u7531\u7684\u63a2\u6d4b\u62a5\u6587\u3002 1. void ip_mc_allhost(struct device *dev) 2. { 3. struct ip_mc_list *i; 4. for(i=dev->ip_mc_list;i!=NULL;i=i->next) 5. if(i->multiaddr==IGMP_ALL_HOSTS) 6. return; 7. i=(struct ip_mc_list *)kmalloc(sizeof(*i), GFP_KERNEL); 8. if(!i) 9. return; 10. I ->users=1; 11. i->interface=dev; 12. i->multiaddr=IGMP_ALL_HOSTS; 13. i->next=dev->ip_mc_list; 14. dev->ip_mc_list=i; 15. ip_mc_filter_add(i->interface, i->multiaddr); 16. } \u8bbe\u5907\u542f\u52a8\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8bbe\u7f6e\u7f51\u5361\u76d1\u542c\u76ee\u7684IP\u662f224.0.0.1\u7684\u62a5\u6587\uff0c\u4f7f\u5f97\u53ef\u4ee5\u5904\u7406\u76ee\u7684IP\u662f224.0.0.1\u7684\u591a\u64ad\u6d88\u606f\u3002\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u662f\u591a\u64ad\u8def\u7531\u7528\u4e8e\u67e5\u8be2\u5c40\u57df\u7f51\u5f53\u524d\u591a\u64ad\u7ec4\u60c5\u51b5\u7684\uff0c\u6bd4\u5982\u67e5\u8be2\u54ea\u4e9b\u591a\u64ad\u7ec4\u5df2\u7ecf\u6ca1\u6709\u6210\u5458\u4e86\uff0c\u5982\u679c\u6ca1\u6709\u6210\u5458\u5219\u5220\u9664\u8def\u7531\u4fe1\u606f\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u5904\u7406\u67d0\u8bbe\u5907\u7684IGMP\u62a5\u6587\u3002 1. int igmp_rcv(struct sk_buff *skb, struct device *dev, struct options *opt, 2. unsigned long daddr, unsigned short len, unsigned long saddr, int redo, 3. struct inet_protocol *protocol) 4. { 5. // IGMP\u62a5\u5934 6. struct igmphdr *igh=(struct igmphdr *)skb->h.raw; 7. // \u8be5\u6570\u636e\u5305\u662f\u53d1\u7ed9\u6240\u6709\u591a\u64ad\u4e3b\u673a\u7684\uff0c\u7528\u4e8e\u67e5\u8be2\u672c\u591a\u64ad\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458 8. if(igh->type==IGMP_HOST_MEMBERSHIP_QUERY && daddr==IGMP_ALL_HOSTS) 9. igmp_heard_query(dev); 10. // \u8be5\u6570\u636e\u5305\u662f\u5176\u5b83\u6210\u5458\u5bf9\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u4e5f\u4f1a\u6536\u5230 11. if(igh->type==IGMP_HOST_MEMBERSHIP_REPORT && daddr==igh->group) 12. igmp_heard_report(dev,igh->group); 13. kfree_skb(skb, FREE_READ); 14. return 0; 15. } IGMP V1\u53ea\u5904\u7406\u4e24\u79cd\u62a5\u6587\uff0c\u5206\u522b\u662f\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\uff08\u67e5\u8be2\u7ec4\u662f\u5426\u6709\u6210\u5458\uff09\uff0c\u5176\u5b83\u6210\u5458\u56de\u590d\u591a\u64ad\u8def\u7531\u7684\u62a5\u544a\u62a5\u6587\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7531\u591a\u64ad\u8def\u7531\u53d1\u51fa\uff0c\u6240\u6709\u7684\u591a\u64ad\u7ec4\u4e2d\u7684\u6240\u6709\u4e3b\u673a\u90fd\u53ef\u4ee5\u6536\u5230\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7684IP\u534f\u8bae\u5934\u7684\u76ee\u7684\u5730\u5740\u662f224.0.0.1\uff08IGMP_ALL_HOSTS\uff09\uff0c\u4ee3\u8868\u6240\u6709\u7684\u7ec4\u64ad\u4e3b\u673a\u90fd\u53ef\u4ee5\u5904\u7406\u8be5\u62a5\u6587\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u79cd\u62a5\u6587\u7684\u5177\u4f53\u5b9e\u73b0\u3002 1. static void igmp_heard_query(struct device *dev) 2. { 3. struct ip_mc_list *im; 4. for(im=dev->ip_mc_list;im!=NULL;im=im->next) 5. // IGMP_ALL_HOSTS\u8868\u793a\u6240\u6709\u7ec4\u64ad\u4e3b\u673a 6. if(!im->tm_running && im->multiaddr!=IGMP_ALL_HOSTS) 7. igmp_start_timer(im); 8. } \u8be5\u51fd\u6570\u7528\u4e8e\u5904\u7406\u7ec4\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\uff0cdev->ip_mc_list\u662f\u8be5\u8bbe\u5907\u5bf9\u5e94\u7684\u6240\u6709\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u8fd9\u91cc\u9488\u5bf9\u8be5\u8bbe\u5907\u4e2d\u7684\u6bcf\u4e00\u4e2a\u591a\u64ad\u7ec4\uff0c\u5f00\u542f\u5bf9\u5e94\u7684\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u4f1a\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f00\u542f\u5b9a\u65f6\u5668\u7684\u903b\u8f91\u3002 1. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668 2. static void igmp_start_timer(struct ip_mc_list *im) 3. { 4. int tv; 5. if(im->tm_running) 6. return; 7. tv=random()%(10*HZ); /* Pick a number any number 8) */ 8. im->timer.expires=tv; 9. im->tm_running=1; 10. add_timer(&im->timer); 11. } \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u7136\u540e\u63d2\u5165\u7cfb\u7edf\u7ef4\u62a4\u7684\u5b9a\u65f6\u5668\u961f\u5217\u3002\u4e3a\u4ec0\u4e48\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u800c\u4e0d\u662f\u7acb\u5373\u56de\u590d\u5462\uff1f\u56e0\u4e3a\u591a\u64ad\u8def\u7531\u53ea\u9700\u8981\u77e5\u9053\u67d0\u4e2a\u591a\u64ad\u7ec4\u662f\u5426\u81f3\u5c11\u8fd8\u6709\u4e00\u4e2a\u6210\u5458\uff0c\u5982\u679c\u6709\u7684\u8bdd\u5c31\u4fdd\u5b58\u8be5\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5426\u5219\u5c31\u5220\u9664\u8def\u7531\u9879\u3002\u5982\u679c\u67d0\u591a\u64ad\u7ec4\u5728\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u6210\u5458\uff0c\u90a3\u4e48\u591a\u4e2a\u6210\u5458\u90fd\u4f1a\u5904\u7406\u8be5\u62a5\u6587\uff0c\u5982\u679c\u90fd\u7acb\u5373\u54cd\u5e94\uff0c\u5219\u4f1a\u5f15\u8d77\u8fc7\u591a\u6ca1\u6709\u5fc5\u8981\u7684\u6d41\u91cf\uff0c\u56e0\u4e3a\u7ec4\u64ad\u8def\u7531\u53ea\u9700\u8981\u6536\u5230\u4e00\u4e2a\u54cd\u5e94\u5c31\u884c\u3002\u6211\u4eec\u770b\u770b\u8d85\u65f6\u65f6\u7684\u903b\u8f91\u3002 1. static void igmp_init_timer(struct ip_mc_list *im) 2. { 3. im->tm_running=0; 4. init_timer(&im->timer); 5. im->timer.data=(unsigned long)im; 6. im->timer.function=&igmp_timer_expire; 7. } 8. 9. static void igmp_timer_expire(unsigned long data) 10. { 11. struct ip_mc_list *im=(struct ip_mc_list *)data; 12. igmp_stop_timer(im); 13. igmp_send_report(im->interface, im->multiaddr, IGMP_HOST_MEMBERSHIP_REPORT); 14. } \u6211\u4eec\u770b\u5230\uff0c\u8d85\u65f6\u540e\u4f1a\u6267\u884cigmp_send_report\u53d1\u9001\u4e00\u4e2a\u7c7b\u578b\u662fIGMP_HOST_MEMBERSHIP_REPORT\u7684IGMP\u3001\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\u7684\u62a5\u6587\uff0c\u8bf4\u660e\u8be5\u591a\u64ad\u7ec4\u8fd8\u6709\u6210\u5458\u3002\u8be5\u62a5\u6587\u4e0d\u4ec5\u4f1a\u53d1\u9001\u7ed9\u591a\u64ad\u8def\u7531\uff0c\u8fd8\u4f1a\u53d1\u7ed9\u540c\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u3002\u5176\u5b83\u4e3b\u673a\u4e5f\u662f\u7c7b\u4f3c\u7684\u903b\u8f91\uff0c\u5373\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u6240\u4ee5\u6700\u5feb\u5230\u671f\u7684\u4e3b\u673a\u4f1a\u5148\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u548c\u540c\u591a\u64ad\u7ec4\u7684\u6210\u5458\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5176\u5b83\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u62a5\u6587\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1. // \u6210\u5458\u62a5\u544a\u62a5\u6587\u5e76\u4e14\u591a\u64ad\u7ec4\u662f\u5f53\u524d\u8bbe\u7f6e\u5173\u8054\u7684\u591a\u64ad\u7ec4 2. if(igh->type==IGMP_HOST_MEMBERSHIP_REPORT && daddr==igh->group) 3. igmp_heard_report(dev,igh->group); \u5f53\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u9488\u5bf9\u591a\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\u4f5c\u4e86\u54cd\u5e94\uff0c\u56e0\u4e3a\u8be5\u54cd\u5e94\u62a5\u6587\u7684\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\uff0c\u6240\u4ee5\u8be5\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u4e5f\u80fd\u6536\u5230\u8be5\u62a5\u6587\u3002\u5f53\u67d0\u4e2a\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u7684\u65f6\u5019\uff0c\u5c31\u77e5\u9053\u540c\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u5df2\u7ecf\u56de\u590d\u4e86\u591a\u64ad\u8def\u7531\u4e86\uff0c\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u56de\u590d\u4e86\u3002 1. /* 2. \u6536\u5230\u5176\u5b83\u7ec4\u6210\u5458\uff0c\u5bf9\u4e8e\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u5219\u81ea\u5df1\u5c31\u4e0d\u7528\u56de\u590d\u4e86\uff0c 3. \u56e0\u4e3a\u591a\u64ad\u8def\u7531\u77e5\u9053\u8be5\u7ec4\u8fd8\u6709\u6210\u5458\uff0c\u4e0d\u4f1a\u5220\u9664\u8def\u7531\u4fe1\u606f\uff0c\u51cf\u5c11\u7f51\u7edc\u6d41\u91cf 4. */ 5. static void igmp_heard_report(struct device *dev, unsigned long address) 6. { 7. struct ip_mc_list *im; 8. for(im=dev->ip_mc_list;im!=NULL;im=im->next) 9. if(im->multiaddr==address) 10. igmp_stop_timer(im); 11. } \u6211\u4eec\u770b\u5230\uff0c\u8fd9\u91cc\u4f1a\u5220\u9664\u5b9a\u65f6\u5668\u3002\u5373\u4e0d\u4f1a\u4f5c\u4e3a\u54cd\u5e94\u4e86\u3002 2.3 \u5176\u5b83 socket\u5173\u95ed\uff0c \u9000\u51fa\u5b83\u4e4b\u524d\u52a0\u5165\u8fc7\u7684\u591a\u64ad 1. void ip_mc_drop_socket(struct sock *sk) 2. { 3. int i; 4. 5. if(sk->ip_mc_list==NULL) 6. return; 7. 8. for(i=0;i<IP_MAX_MEMBERSHIPS;i++) 9. { 10. if(sk->ip_mc_list->multidev[i]) 11. { 12. ip_mc_dec_group(sk->ip_mc_list->multidev[i], sk->ip_mc_list->multiaddr[i]); 13. sk->ip_mc_list->multidev[i]=NULL; 14. } 15. } 16. kfree_s(sk->ip_mc_list,sizeof(*sk->ip_mc_list)); 17. sk->ip_mc_list=NULL; 18. } \u8bbe\u5907\u505c\u6b62\u5de5\u4f5c\u4e86\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u591a\u64ad\u4fe1\u606f 1. void ip_mc_drop_device(struct device *dev) 2. { 3. struct ip_mc_list *i; 4. struct ip_mc_list *j; 5. for(i=dev->ip_mc_list;i!=NULL;i=j) 6. { 7. j=i->next; 8. kfree_s(i,sizeof(*i)); 9. } 10. dev->ip_mc_list=NULL; 11. } \u4ee5\u4e0a\u662fIGMP V1\u7248\u672c\u7684\u5b9e\u73b0\uff0c\u5728\u540e\u7eedV2 V3\u7248\u672c\u4e86\u53c8\u589e\u52a0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u6bd4\u5982\u79bb\u5f00\u7ec4\u62a5\u6587\uff0c\u9488\u5bf9\u79bb\u5f00\u62a5\u6587\u4e2d\u7684\u591a\u64ad\u7ec4\uff0c\u589e\u52a0\u7279\u5b9a\u7ec4\u67e5\u8be2\u62a5\u6587\uff0c\u7528\u4e8e\u67e5\u8be2\u67d0\u4e2a\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458\uff0c\u53e6\u5916\u8fd8\u6709\u8def\u7531\u9009\u4e3e\uff0c\u5f53\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u591a\u64ad\u8def\u7531\uff0c\u591a\u64ad\u8def\u7531\u4e4b\u95f4\u901a\u8fc7\u534f\u8bae\u9009\u4e3e\u51faIP\u6700\u5c0f\u7684\u8def\u7531\u4e3a\u67e5\u8be2\u8def\u7531\uff0c\u5b9a\u65f6\u7ed9\u591a\u64ad\u7ec4\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\u3002\u7136\u540e\u6210\u4e3a\u67e5\u8be2\u5668\u7684\u591a\u64ad\u8def\u7531\uff0c\u4f1a\u5b9a\u671f\u7ed9\u5176\u5b83\u591a\u64ad\u8def\u7531\u540c\u6b65\u5fc3\u8df3\u3002\u5426\u5219\u5176\u5b83\u591a\u64ad\u8def\u7531\u4f1a\u5728\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\u8ba4\u4e3a\u5f53\u524d\u67e5\u8be2\u8def\u7531\u5df2\u7ecf\u6302\u4e86\uff0c\u91cd\u65b0\u9009\u4e3e\u3002","title":"16.2.5.2 \u7ef4\u62a4\u591a\u64ad\u7ec4\u4fe1\u606f"},{"location":"chapter16-UDP/#16253","text":"UDP\u7684\u591a\u64ad\u80fd\u529b\u662f\u9700\u8981\u7528\u6237\u4e3b\u52a8\u5f00\u542f\u7684\uff0c\u539f\u56e0\u662f\u9632\u6b62\u7528\u6237\u53d1\u9001UDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8bef\u4f20\u4e86\u4e00\u4e2a\u591a\u64ad\u5730\u5740\uff0c\u4f46\u5176\u5b9e\u7528\u6237\u662f\u60f3\u53d1\u9001\u4e00\u4e2a\u5355\u64ad\u7684\u6570\u636e\u5305\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setBroadcast\u5f00\u542f\u591a\u64ad\u80fd\u529b\u3002\u6211\u4eec\u770bLibuv\u7684\u4ee3\u7801\u3002 1. int uv_udp_set_broadcast(uv_udp_t* handle, int on) { 2. if (setsockopt(handle->io_watcher.fd, 3. SOL_SOCKET, 4. SO_BROADCAST, 5. &on, 6. sizeof(on))) { 7. return UV__ERR(errno); 8. } 9. 10. return 0; 11. } \u518d\u770b\u770b\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 1. int sock_setsockopt(struct sock *sk, int level, int optname, 2. char *optval, int optlen){ 3. ... 4. case SO_BROADCAST: 5. sk->broadcast=val?1:0; 6. } \u6211\u4eec\u770b\u5230\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u6807\u8bb0\u4f4d\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6d88\u606f\u7684\u65f6\u5019\uff0c\u5982\u679c\u76ee\u7684\u5730\u5740\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u53c8\u6ca1\u6709\u8bbe\u7f6e\u8fd9\u4e2a\u6807\u8bb0\uff0c\u5219\u4f1a\u62a5\u9519\u3002 1. if(!sk->broadcast && ip_chk_addr(sin.sin_addr.s_addr)==IS_BROADCAST) 2. return -EACCES; \u4e0a\u9762\u4ee3\u7801\u6765\u81ea\u8c03\u7528udp\u7684\u53d1\u9001\u51fd\u6570\uff08\u4f8b\u5982sendto\uff09\u65f6\uff0c\u8fdb\u884c\u7684\u6821\u9a8c\uff0c\u5982\u679c\u53d1\u9001\u7684\u76ee\u7684ip\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u6ca1\u6709\u8bbe\u7f6e\u591a\u64ad\u6807\u8bb0\uff0c\u5219\u62a5\u9519\u3002","title":"16.2.5.3 \u5f00\u542f\u591a\u64ad"},{"location":"chapter16-UDP/#16254","text":"\u670d\u52a1\u5668 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket('udp4'); 3. 4. udp.bind(1234, () => { 5. // \u5c40\u57df\u7f51\u591a\u64ad\u5730\u5740\uff08224.0.0.0~224.0.0.255\uff0c\u8be5\u8303\u56f4\u7684\u591a\u64ad\u6570\u636e\u5305\uff0c\u8def\u7531\u5668\u4e0d\u4f1a\u8f6c\u53d1\uff09 6. udp.addMembership('224.0.0.114'); 7. }); 8. 9. udp.on('message', (msg, rinfo) => { 10. console.log(`receive msg: ${msg} from ${rinfo.address}:${rinfo.port}`); 11. }); \u670d\u52a1\u5668\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u52a0\u5165\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u7b49\u5f85\u591a\u64ad\u6570\u636e\u7684\u5230\u6765\u3002 \u5ba2\u6237\u7aef 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket('udp4'); 3. udp.bind(1234, () => { 4. udp.addMembership('224.0.0.114'); 5. }); 6. udp.send('test', 1234, '224.0.0.114', (err) => {}); \u5ba2\u6237\u7aef\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u4e5f\u52a0\u5165\u4e86\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\uff0c\u4f46\u662f\u53d1\u73b0\u670d\u52a1\u7aef\u6ca1\u6709\u6536\u5230\u6570\u636e\uff0c\u5ba2\u6237\u7aef\u6253\u5370\u4e86receive msg test from 169.254.167.41:1234\u3002\u8fd9\u600e\u4e48\u591a\u4e86\u4e00\u4e2aIP\u51fa\u6765\uff1f\u539f\u6765\u6211\u4e3b\u673a\u6709\u4e24\u4e2a\u5c40\u57df\u7f51\u5730\u5740\u3002\u5f53\u6211\u4eec\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u4e0d\u4ec5\u53ef\u4ee5\u8bbe\u7f6e\u52a0\u5165\u54ea\u4e2a\u591a\u64ad\u7ec4\uff0c\u8fd8\u80fd\u8bbe\u7f6e\u51fa\u53e3\u7684\u8bbe\u5907\u548cIP\u3002\u5f53\u6211\u4eec\u8c03\u7528udp.addMembership('224.0.0.114')\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u662f\u8bbe\u7f6e\u4e86\u6211\u4eec\u52a0\u5165\u7684\u591a\u64ad\u7ec4\uff0c\u6ca1\u6709\u8bbe\u7f6e\u51fa\u53e3\u3002\u8fd9\u65f6\u5019\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u6211\u4eec\u9009\u62e9\u4e00\u4e2a\u3002\u6839\u636e\u8f93\u51fa\uff0c\u6211\u4eec\u53d1\u73b0\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u662f169.254.167.41\uff08\u5b50\u7f51\u63a9\u7801\u662f255.255.0.0\uff09\u3002\u56e0\u4e3a\u8fd9\u4e2aIP\u548c192\u5f00\u5934\u7684\u90a3\u4e2a\u4e0d\u662f\u540c\u4e00\u5b50\u7f51\uff0c\u4f46\u662f\u6211\u4eec\u52a0\u5165\u7684\u662f\u5c40\u57df\u7f51\u7684\u591a\u64adIP\uff0c\u6240\u6709\u670d\u52a1\u7aef\u65e0\u6cd5\u6536\u5230\u5ba2\u6237\u7aef\u53d1\u51fa\u7684\u6570\u636e\u5305\u3002\u4e0b\u9762\u662fNode.js\u6587\u6863\u7684\u89e3\u91ca\u3002 Tells the kernel to join a multicast group at the given multicastAddress and multicastInterface using the IP_ADD_MEMBERSHIP socket option. If the multicastInterface argument is not specified, the operating system will choose one interface and will add membership to it. To add membership to every available interface, call addMembership multiple times, once per interface. \u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u76f8\u5173\u903b\u8f91\u3002 1. if(MULTICAST(daddr) && *dev==NULL && skb->sk && *skb->sk->ip_mc_name) 2. *dev=dev_get(skb->sk->ip_mc_name); \u4e0a\u9762\u7684\u4ee3\u7801\u6765\u81ea\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001IP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\uff0c\u5982\u679c\u76ee\u7684IP\u4f3c\u4e4e\u591a\u64ad\u5730\u5740\u5e76\u4e14ip_mc_name\u975e\u7a7a\uff08\u5373\u6211\u4eec\u901a\u8fc7addMembership\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8bbe\u7f6e\u7684\u503c\uff09\uff0c\u5219\u51fa\u53e3\u8bbe\u5907\u5c31\u662f\u6211\u4eec\u8bbe\u7f6e\u7684\u503c\u3002\u5426\u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u663e\u793a\u6307\u5b9a\u8fd9\u4e2a\u51fa\u53e3\uff0c\u628a\u4ee3\u7801\u6539\u6210udp.addMembership('224.0.0.114', '192.168.8.164');\u91cd\u65b0\u6267\u884c\u53d1\u73b0\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u90fd\u663e\u793a\u4e86receive msg test from 192.168.8.164:1234\u3002\u4e3a\u4ec0\u4e48\u5ba2\u6237\u7aef\u81ea\u5df1\u4e5f\u4f1a\u6536\u5230\u5462\uff1f\u539f\u6765\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001\u591a\u64ad\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e5f\u4f1a\u7ed9\u81ea\u5df1\u53d1\u9001\u4e00\u4efd\u3002\u6211\u4eec\u770b\u770b\u76f8\u5173\u903b\u8f91 1. // \u76ee\u7684\u5730\u662f\u591a\u64ad\u5730\u5740\uff0c\u5e76\u4e14\u4e0d\u662f\u56de\u73af\u8bbe\u5907 2. if (MULTICAST(iph->daddr) && !(dev->flags&IFF_LOOPBACK)) 3. { 4. // \u662f\u5426\u9700\u8981\u7ed9\u81ea\u5df1\u4e00\u4efd\uff0c\u9ed8\u8ba4\u4e3atrue 5. if(sk==NULL || sk->ip_mc_loop) 6. { 7. // \u7ed9\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u7684\u6570\u636e\u5305\uff0c\u5219\u76f4\u63a5\u7ed9\u81ea\u5df1\u4e00\u4efd 8. if(iph->daddr==IGMP_ALL_HOSTS) 9. ip_loopback(dev,skb); 10. else 11. { 12. // \u5224\u65ad\u76ee\u7684ip\u662f\u5426\u5728\u5f53\u524d\u8bbe\u5907\u7684\u591a\u64adip\u5217\u8868\u4e2d\uff0c\u662f\u7684\u56de\u4f20\u4e00\u4efd 13. struct ip_mc_list *imc=dev->ip_mc_list; 14. while(imc!=NULL) 15. { 16. if(imc->multiaddr==iph->daddr) 17. { 18. ip_loopback(dev,skb); 19. break; 20. } 21. imc=imc->next; 22. } 23. } 24. } 25. } \u4ee5\u4e0a\u4ee3\u7801\u6765\u81eaIP\u5c42\u53d1\u9001\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86sk->ip_mc_loop\u5b57\u6bb5\u4e3a1\uff0c\u5e76\u4e14\u6570\u636e\u5305\u7684\u76ee\u7684IP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u9700\u8981\u7ed9\u81ea\u5df1\u56de\u4f20\u4e00\u4efd\u3002\u90a3\u4e48\u6211\u4eec\u5982\u4f55\u5173\u95ed\u8fd9\u4e2a\u7279\u6027\u5462\uff1f\u8c03\u7528udp.setMulticastLoopback(false)\u5c31\u53ef\u4ee5\u4e86\u3002","title":"16.2.5.4 \u591a\u64ad\u7684\u95ee\u9898"},{"location":"chapter16-UDP/#16255","text":"UDP\u6a21\u5757\u8fd8\u63d0\u4f9b\u4e86\u5176\u5b83\u4e00\u4e9b\u529f\u80fd 1 \u83b7\u53d6\u672c\u7aef\u5730\u5740address \u5982\u679c\u7528\u6237\u6ca1\u6709\u663e\u793a\u8c03\u7528bind\u7ed1\u5b9a\u81ea\u5df1\u8bbe\u7f6e\u7684IP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u968f\u673a\u9009\u62e9\u3002\u901a\u8fc7address\u51fd\u6570\u5c31\u53ef\u4ee5\u83b7\u53d6\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u6e90IP\u548c\u7aef\u53e3\u3002 2 \u83b7\u53d6\u5bf9\u7aef\u7684\u5730\u5740 \u901a\u8fc7remoteAddress\u51fd\u6570\u53ef\u4ee5\u83b7\u53d6\u5bf9\u7aef\u5730\u5740\u3002\u8be5\u5730\u5740\u7531\u7528\u6237\u8c03\u7528connect\u6216sendto\u51fd\u6570\u65f6\u8bbe\u7f6e\u3002 3 \u83b7\u53d6/\u8bbe\u7f6e\u7f13\u51b2\u533a\u5927\u5c0fget/setRecvBufferSize\uff0cget/setSendBufferSize 4 setMulticastLoopback \u53d1\u9001\u591a\u64ad\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5982\u679c\u591a\u64adIP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u7ed9\u56de\u73af\u8bbe\u5907\u4e5f\u53d1\u4e00\u4efd\u3002 5 setMulticastInterface \u8bbe\u7f6e\u591a\u64ad\u6570\u636e\u7684\u51fa\u53e3\u8bbe\u5907 6 \u52a0\u5165\u6216\u9000\u51fa\u591a\u64ad\u7ec4addMembership/dropMembership 7 addSourceSpecificMembership/dropSourceSpecificMembership \u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u8bbe\u7f6e\u672c\u7aef\u53ea\u63a5\u6536\u7279\u6027\u6e90\uff08\u4e3b\u673a\uff09\u7684\u591a\u64ad\u6570\u636e\u5305\u3002 8 setTTL \u5355\u64adttl\uff08\u5355\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u5934\u4e2d\u7684ttl\u5b57\u6bb5\uff09\u3002 9 setMulticastTTL \u591a\u64adttl\uff08\u591a\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u7684ttl\u5b57\u6bb5\uff09\u3002 10 ref/unref \u8fd9\u4e24\u4e2a\u51fd\u6570\u8bbe\u7f6e\u5982\u679cNode.js\u4e3b\u8fdb\u7a0b\u4e2d\u53ea\u6709UDP\u5bf9\u5e94\u7684handle\u65f6\uff0c\u662f\u5426\u5141\u8bb8Node.js\u9000\u51fa\u3002Node.js\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u7684\u6761\u4ef6\u4e4b\u4e00\u662f\u662f\u5426\u8fd8\u6709ref\u72b6\u6001\u7684handle\u3002 \u8fd9\u4e9b\u90fd\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002","title":"16.2.5.5 \u5176\u5b83\u529f\u80fd"},{"location":"chapter16-UDP/#1626","text":"\u6211\u4eec\u5728\u7f51\u7edc\u7f16\u7a0b\u4e2d\u7ecf\u5e38\u4f1a\u9047\u5230\u7aef\u53e3\u91cd\u590d\u7ed1\u5b9a\u7684\u9519\u8bef\uff0c\u6839\u636e\u5230\u5e95\u662f\u6211\u4eec\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u548cIP\u4e24\u6b21\u3002\u4f46\u662f\u5728UDP\u4e2d\uff0c\u8fd9\u662f\u5141\u8bb8\u7684\uff0c\u8fd9\u5c31\u662f\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u5728TCP\u4e2d\uff0c\u6211\u4eec\u901a\u8fc7\u7aef\u53e3\u590d\u7528\u6765\u89e3\u51b3\u670d\u52a1\u5668\u91cd\u542f\u65f6\u91cd\u65b0\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\u7aef\u53e3\u6709\u4e00\u4e2a2msl\u7684\u7b49\u5f85\u65f6\u95f4\uff0c\u91cd\u542f\u670d\u52a1\u5668\u91cd\u65b0\u7ed1\u5b9a\u5230\u8fd9\u4e2a\u7aef\u53e3\u65f6\uff0c\u9ed8\u8ba4\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff08Node.js\u81ea\u52a8\u5e2e\u6211\u4eec\u8bbe\u7f6e\u4e86\uff09\uff0c\u5219\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002UDP\u4e2d\u4e5f\u652f\u6301\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u4f46\u662f\u529f\u80fd\u3001\u7528\u9014\u548cTCP\u7684\u4e0d\u592a\u4e00\u6837\u3002\u56e0\u4e3a\u591a\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\u3002\u4f46\u662f\u4e00\u822c\u53ea\u7528\u4e8e\u591a\u64ad\u7684\u60c5\u51b5\u4e0b\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0budp\u7aef\u53e3\u590d\u7528\u7684\u903b\u8f91\u3002\u5728Node.js\u4e2d\uff0c\u4f7f\u7528UDP\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u901a\u8fc7reuseAddr\u9009\u9879\u4f7f\u5f97\u8fdb\u7a0b\u53ef\u4ee5\u590d\u7528\u7aef\u53e3\uff0c\u5e76\u4e14\u6bcf\u4e00\u4e2a\u60f3\u590d\u7528\u7aef\u53e3\u7684socket\u90fd\u9700\u8981\u8bbe\u7f6ereuseAddr\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u5173\u4e8ereuseAddr\u7684\u903b\u8f91\u3002 1. Socket.prototype.bind = function(port_, address_ /* , callback */) { 2. let flags = 0; 3. if (state.reuseAddr) 4. flags |= UV_UDP_REUSEADDR; 5. state.handle.bind(ip, port || 0, flags); 6. }; \u6211\u4eec\u770b\u5230Node.js\u5728bind\u7684\u65f6\u5019\u4f1a\u5904\u7406reuseAddr\u5b57\u6bb5\u3002\u6211\u4eec\u76f4\u63a5\u770bLibuv\u7684\u903b\u8f91\u3002 1. int uv__udp_bind(uv_udp_t* handle, 2. const struct sockaddr* addr, 3. unsigned int addrlen, 4. unsigned int flags) { 5. if (flags & UV_UDP_REUSEADDR) { 6. err = uv__set_reuse(fd); 7. } 8. bind(fd, addr, addrlen)) 9. return 0; 10. } 11. 12. static int uv__set_reuse(int fd) { 13. int yes; 14. yes = 1; 15. 16. if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes))) 17. return UV__ERR(errno); 18. return 0; 19. } \u6211\u4eec\u770b\u5230Libuv\u901a\u8fc7\u6700\u7ec8\u901a\u8fc7setsockopt\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff0c\u5e76\u4e14\u662f\u5728bind\u4e4b\u524d\u3002\u6211\u4eec\u4e0d\u59a8\u518d\u6df1\u5165\u4e00\u70b9\uff0c\u770b\u4e00\u4e0bLinux\u5185\u6838\u7684\u5b9e\u73b0\u3002 1. asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen) 2. { 3. int err; 4. struct socket *sock; 5. 6. if (optlen < 0) 7. return -EINVAL; 8. 9. if ((sock = sockfd_lookup(fd, &err))!=NULL) 10. { 11. if (level == SOL_SOCKET) 12. err=sock_setsockopt(sock,level,optname,optval,optlen); 13. else 14. err=sock->ops->setsockopt(sock, level, optname, optval, optlen); 15. sockfd_put(sock); 16. } 17. return err; 18. } sys_setsockopt\u662fsetsockopt\u5bf9\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u6211\u4eec\u770b\u5230sys_setsockopt\u4e5f\u53ea\u662f\u4e2a\u5165\u53e3\u51fd\u6570\uff0c\u5177\u4f53\u51fd\u6570\u662fsock_setsockopt\u3002 1. int sock_setsockopt(struct socket *sock, int level, int optname, 2. char __user *optval, int optlen) 3. { 4. struct sock *sk=sock->sk; 5. int val; 6. int valbool; 7. int ret = 0; 8. 9. if (get_user(val, (int __user *)optval)) 10. return -EFAULT; 11. 12. valbool = val?1:0; 13. 14. lock_sock(sk); 15. 16. switch(optname) 17. { 18. case SO_REUSEADDR: 19. sk->sk_reuse = valbool; 20. break; 21. // ... 22. release_sock(sk); 23. return ret; 24. } \u64cd\u4f5c\u7cfb\u7edf\u7684\u5904\u7406\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u505a\u4e86\u4e00\u4e2a\u6807\u8bb0\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bbind\u7684\u65f6\u5019\u662f\u600e\u4e48\u5904\u7406\u7684\uff0c\u56e0\u4e3a\u7aef\u53e3\u662f\u5426\u91cd\u590d\u548c\u80fd\u5426\u590d\u7528\u662f\u5728bind\u7684\u65f6\u5019\u5224\u65ad\u7684\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u5728TCP\u4e2d\uff0c\u5373\u4f7f\u4e24\u4e2a\u8fdb\u7a0b\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u4e3b\u8fdb\u7a0b\u91cc\u6267\u884c\u4e86bind\u4e4b\u540e\uff0c\u518dfork\u51fd\u6570\u65f6\uff0c\u662f\u53ef\u4ee5\u5b9e\u73b0\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u7aef\u53e3\u7684\u3002\u8a00\u5f52\u6b63\u4f20\u6211\u4eec\u770b\u4e00\u4e0bUDP\u4e2d\u6267\u884cbind\u65f6\u7684\u903b\u8f91\u3002 1. int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len) 2. { 3. if (sk->sk_prot->get_port(sk, snum)) { 4. inet->saddr = inet->rcv_saddr = 0; 5. err = -EADDRINUSE; 6. goto out_release_sock; 7. } 8. 9. } \u6bcf\u4e2a\u534f\u8bae\u90fd\u53ef\u4ee5\u5b9e\u73b0\u81ea\u5df1\u7684get_port\u94a9\u5b50\u51fd\u6570\u3002\u7528\u6765\u5224\u65ad\u5f53\u524d\u7684\u7aef\u53e3\u662f\u5426\u5141\u8bb8\u88ab\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u5141\u8bb8\u5219\u8fd4\u56deEADDRINUSE\uff0c\u6211\u4eec\u770b\u770bUDP\u534f\u8bae\u7684\u5b9e\u73b0\u3002 1. static int udp_v4_get_port(struct sock *sk, unsigned short snum) 2. { 3. struct hlist_node *node; 4. struct sock *sk2; 5. struct inet_sock *inet = inet_sk(sk); 6. // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u94fe\u8868 7. sk_for_each(sk2, node, &udp_hash[snum & (UDP_HTABLE_SIZE - 1)]) { 8. struct inet_sock *inet2 = inet_sk(sk2); 9. // \u7aef\u53e3\u5df2\u4f7f\u7528\uff0c\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528 10. if (inet2->num == snum && 11. sk2 != sk && 12. (!inet2->rcv_saddr || 13. !inet->rcv_saddr || 14. inet2->rcv_saddr == inet->rcv_saddr) && 15. // \u6bcf\u4e2asocket\u90fd\u9700\u8981\u8bbe\u7f6e\u7aef\u53e3\u590d\u7528\u6807\u8bb0 16. (!sk2->sk_reuse || !sk->sk_reuse)) 17. // \u4e0d\u53ef\u4ee5\u590d\u7528\uff0c\u62a5\u9519 18. goto fail; 19. } 20. // \u53ef\u4ee5\u590d\u7528 21. inet->num = snum; 22. if (sk_unhashed(sk)) { 23. // \u627e\u5230\u7aef\u53e3\u5bf9\u5e94\u7684\u4f4d\u7f6e 24. struct hlist_head *h = &udp_hash[snum & (UDP_HTABLE_SIZE - 1)]; 25. // \u63d2\u5165\u94fe\u8868 26. sk_add_node(sk, h); 27. sock_prot_inc_use(sk->sk_prot); 28. } 29. return 0; 30. 31. fail: 32. write_unlock_bh(&udp_hash_lock); 33. return 1; 34. } \u5206\u6790\u4e4b\u524d\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0cUDP\u534f\u8bae\u7684\u5b9e\u73b0\u4e2d\uff0c\u4f1a\u4f7f\u7528\u5982\u4e0b\u7684\u6570\u636e\u7ed3\u6784\u8bb0\u5f55\u6bcf\u4e00\u4e2aUDP socket\uff0c\u5982\u56fe16-6\u6240\u793a\u3002 \u56fe16-6 \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u4f5c\u4e3a\u54c8\u5e0c\u8868\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e00\u4e2asocket\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u6839\u636esocket\u7684\u6e90\u7aef\u53e3\u548c\u54c8\u5e0c\u7b97\u6cd5\u8ba1\u7b97\u5f97\u5230\u4e00\u4e2a\u6570\u7ec4\u7d22\u5f15\uff0c\u7136\u540e\u628asocket\u63d2\u5165\u7d22\u5f15\u9501\u5bf9\u5e94\u7684\u94fe\u8868\u4e2d\uff0c\u5373\u54c8\u5e0c\u51b2\u7a81\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u94fe\u5730\u5740\u6cd5\u3002\u56de\u5230\u4ee3\u7801\u7684\u903b\u8f91\uff0c\u5f53\u7528\u6237\u60f3\u7ed1\u5b9a\u4e00\u4e2a\u7aef\u53e3\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u7aef\u53e3\u62ff\u5230\u5bf9\u5e94\u7684socket\u94fe\u8868\uff0c\u7136\u540e\u9010\u4e2a\u5224\u65ad\u662f\u5426\u6709\u76f8\u7b49\u7684\u7aef\u53e3\uff0c\u5982\u679c\u6709\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528\u3002\u4f8b\u5982\u4e24\u4e2asocket\u90fd\u8bbe\u7f6e\u4e86\u590d\u7528\u6807\u8bb0\u5219\u53ef\u4ee5\u590d\u7528\u3002\u6700\u540e\u628asocket\u63d2\u5165\u5230\u94fe\u8868\u4e2d\u3002 1. static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h) 2. { 3. // \u5934\u7ed3\u70b9 4. struct hlist_node *first = h->first; 5. n->next = first; 6. if (first) 7. first->pprev = &n->next; 8. h->first = n; 9. n->pprev = &h->first; 10. } \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u662f\u4ee5\u5934\u63d2\u6cd5\u7684\u65b9\u5f0f\u63d2\u5165\u65b0\u8282\u70b9\u7684\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\u7684\u3002","title":"16.2.6 \u7aef\u53e3\u590d\u7528"},{"location":"chapter16-UDP/#16261","text":"\u6211\u4eec\u5148\u770b\u4e00\u4e2a\u4f8b\u5b50\uff0c\u6211\u4eec\u5728\u540c\u4e3b\u673a\u4e0a\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\uff08\u5ba2\u6237\u7aef\uff09\uff0c\u4ee3\u7801\u5982\u4e0b 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4', reuseAddr: true}); 3. udp.bind(1234, \u2018192.168.8.164\u2018, () => { 4. udp.addMembership('224.0.0.114', '192.168.8.164'); 5. }); 6. udp.on('message', (msg) => { 7. console.log(msg) 8. }); \u4e0a\u9762\u4ee3\u7801\u4f7f\u5f97\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u6837\u7684IP\u548c\u7aef\u53e3\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5199\u4e00\u4e2aUDP\u670d\u52a1\u5668\u3002 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4'}); 3. const socket = udp.bind(5678); 4. socket.send('hi', 1234, '224.0.0.114', (err) => { 5. console.log(err) 6. }); \u4e0a\u9762\u7684\u4ee3\u7801\u7ed9\u4e00\u4e2a\u591a\u64ad\u7ec4\u53d1\u9001\u4e86\u4e00\u4e2a\u6570\u636e\uff0c\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u6536\u5230\u4e86\u6570\u636e\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6536\u5230\u6570\u636e\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u628a\u6570\u636e\u5206\u53d1\u7ed9\u6bcf\u4e2a\u76d1\u542c\u4e86\u540c\u6837IP\u548c\u7aef\u53e3\u7684\u8fdb\u7a0b\u7684\u3002\u4e0b\u9762\u662f\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002 1. int udp_rcv(struct sk_buff *skb) 2. { 3. struct sock *sk; 4. struct udphdr *uh; 5. unsigned short ulen; 6. struct rtable *rt = (struct rtable*)skb->dst; 7. // ip\u5934\u4e2d\u8bb0\u5f55\u7684\u6e90ip\u548c\u76ee\u7684ip 8. u32 saddr = skb->nh.iph->saddr; 9. u32 daddr = skb->nh.iph->daddr; 10. int len = skb->len; 11. // udp\u534f\u8bae\u5934\u7ed3\u6784\u4f53 12. uh = skb->h.uh; 13. ulen = ntohs(uh->len); 14. // \u5e7f\u64ad\u6216\u591a\u64ad\u5305 15. if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST)) 16. return udp_v4_mcast_deliver(skb, uh, saddr, daddr); 17. // \u5355\u64ad 18. sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex); 19. // \u627e\u5230\u5bf9\u5e94\u7684socket 20. if (sk != NULL) { 21. // \u628a\u6570\u636e\u63d2\u5230socket\u7684\u6d88\u606f\u961f\u5217 22. int ret = udp_queue_rcv_skb(sk, skb); 23. sock_put(sk); 24. if (ret > 0) 25. return -ret; 26. return 0; 27. } 28. return(0); 29. } \u6211\u4eec\u770b\u5230\u5355\u64ad\u548c\u975e\u5355\u64ad\u65f6\u5904\u7406\u903b\u8f91\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u975e\u5355\u64ad\u7684\u60c5\u51b5 1. static int udp_v4_mcast_deliver(struct sk_buff *skb, struct udphdr *uh, 2. u32 saddr, u32 daddr) 3. { 4. struct sock *sk; 5. int dif; 6. 7. read_lock(&udp_hash_lock); 8. // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868 9. sk = sk_head(&udp_hash[ntohs(uh->dest) & (UDP_HTABLE_SIZE - 1)]); 10. dif = skb->dev->ifindex; 11. sk = udp_v4_mcast_next(sk, uh->dest, daddr, uh->source, saddr, dif); 12. if (sk) { 13. struct sock *sknext = NULL; 14. // \u904d\u5386\u6bcf\u4e00\u4e2a\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u7684socket 15. do { 16. struct sk_buff *skb1 = skb; 17. sknext = udp_v4_mcast_next(sk_next(sk), 18. uh->dest, daddr, 19. uh->source, 20. saddr, 21. dif); 22. if(sknext) 23. // \u590d\u5236\u4e00\u4efd 24. skb1 = skb_clone(skb, GFP_ATOMIC); 25. // \u63d2\u5165\u6bcf\u4e00\u4e2asocket\u7684\u6570\u636e\u5305\u961f\u5217 26. if(skb1) { 27. int ret = udp_queue_rcv_skb(sk, skb1); 28. if (ret > 0) 29. kfree_skb(skb1); 30. } 31. sk = sknext; 32. } while(sknext); 33. } else 34. kfree_skb(skb); 35. read_unlock(&udp_hash_lock); 36. return 0; 37. } \u5728\u975e\u5355\u64ad\u7684\u60c5\u51b5\u4e0b\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u904d\u5386\u94fe\u8868\u627e\u5230\u6bcf\u4e00\u4e2a\u53ef\u4ee5\u63a5\u6536\u8be5\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u590d\u5236\u4e00\u4efd\uff0c\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u3002\u8fd9\u5c31\u89e3\u91ca\u4e86\u672c\u8282\u5f00\u5934\u7684\u4f8b\u5b50\uff0c\u5373\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u4f1a\u6536\u5230UDP\u6570\u636e\u5305\u3002","title":"16.2.6.1 \u591a\u64ad"},{"location":"chapter16-UDP/#16262","text":"\u63a5\u7740\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b\u5355\u64ad\u7684\u60c5\u51b5\u3002\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002\u6211\u4eec\u540c\u6837\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u5ba2\u6237\u7aef\u3002 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4', reuseAddr: true}); 3. const socket = udp.bind(5678); 4. socket.on('message', (msg) => { 5. console.log(msg) 6. }) \u7136\u540e\u518d\u65b0\u5efa\u4e00\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u670d\u52a1\u5668\u3002 1. const dgram = require('dgram'); 2. const udp = dgram.createSocket({type: 'udp4'}); 3. const socket = udp.bind(1234); 4. udp.send('hi', 5678) \u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u9996\u5148\u6267\u884c\u5ba2\u6237\u7aef\uff0c\u518d\u6267\u884c\u670d\u52a1\u5668\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u5177\u4f53\u7684\u539f\u56e0\uff0c\u5355\u64ad\u65f6\u6536\u5230\u4f1a\u8c03\u7528udp_v4_lookup\u51fd\u6570\u627e\u5230\u63a5\u6536\u8be5UDP\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u4e2d\u3002\u6211\u4eec\u770b\u770budp_v4_lookup\u3002 1. static __inline__ struct sock *udp_v4_lookup(u32 saddr, u16 sport, 2. u32 daddr, u16 dport, int dif) 3. { 4. struct sock *sk; 5. sk = udp_v4_lookup_longway(saddr, sport, daddr, dport, dif); 6. return sk; 7. } 8. 9. static struct sock *udp_v4_lookup_longway(u32 saddr, u16 sport, 10. u32 daddr, u16 dport, int dif) 11. { 12. struct sock *sk, *result = NULL; 13. struct hlist_node *node; 14. unsigned short hnum = ntohs(dport); 15. int badness = -1; 16. // \u904d\u5386\u7aef\u53e3\u5bf9\u5e94\u7684\u94fe\u8868 17. sk_for_each(sk, node, &udp_hash[hnum & (UDP_HTABLE_SIZE - 1)]) { 18. struct inet_sock *inet = inet_sk(sk); 19. 20. if (inet->num == hnum && !ipv6_only_sock(sk)) { 21. int score = (sk->sk_family == PF_INET ? 1 : 0); 22. if (inet->rcv_saddr) { 23. if (inet->rcv_saddr != daddr) 24. continue; 25. score+=2; 26. } 27. if (inet->daddr) { 28. if (inet->daddr != saddr) 29. continue; 30. score+=2; 31. } 32. if (inet->dport) { 33. if (inet->dport != sport) 34. continue; 35. score+=2; 36. } 37. if (sk->sk_bound_dev_if) { 38. if (sk->sk_bound_dev_if != dif) 39. continue; 40. score+=2; 41. } 42. // \u5168\u5339\u914d\uff0c\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u8bb0\u5f55\u5f53\u524d\u6700\u597d\u7684\u5339\u914d\u7ed3\u679c 43. if(score == 9) { 44. result = sk; 45. break; 46. } else if(score > badness) { 47. result = sk; 48. badness = score; 49. } 50. } 51. } 52. return result; 53. } \u6211\u4eec\u770b\u5230\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u6839\u636e\u7aef\u53e3\u4ece\u54c8\u5e0c\u8868\u4e2d\u62ff\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u8be5\u94fe\u8868\u627e\u51fa\u6700\u5339\u914d\u7684socket\u3002\u7136\u540e\u628a\u6570\u636e\u6302\u8f7d\u5230socket\u4e0a\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u7ec6\u8282\u9700\u8981\u6ce8\u610f\uff0c\u5982\u679c\u6709\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u54ea\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u5462\uff1f\u8fd9\u4e2a\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\uff0c\u4eceLinux\u6e90\u7801\u6211\u4eec\u770b\u5230\uff0c\u63d2\u5165socket\u7684\u65f6\u5019\u662f\u4f7f\u7528\u5934\u63d2\u6cd5\uff0c\u67e5\u627e\u7684\u65f6\u5019\u662f\u4ece\u5934\u5f00\u59cb\u627e\u6700\u5339\u914d\u7684socket\u3002\u5373\u540e\u9762\u63d2\u5165\u7684socket\u4f1a\u5148\u88ab\u641c\u7d22\u5230\u3002\u4f46\u662fWindows\u4e0b\u7ed3\u6784\u5374\u76f8\u53cd\uff0c\u5148\u76d1\u542c\u4e86\u8be5IP\u7aef\u53e3\u7684\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002 \u7b2c","title":"16.2.6.2 \u5355\u64ad"},{"location":"chapter17-TCP/","text":"\u672c\u7ae0\u6211\u4eec\u4e3b\u8981\u770b\u4e00\u4e0bNode.js\u4e2d\u5bf9TCP\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u7f51\u7edc\u7f16\u7a0b\u4e2d\uff0c\u662f\u5982\u4f55\u7f16\u5199\u4e00\u4e2a\u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u7684\uff08\u4f2a\u4ee3\u7801\uff09\u3002 \u670d\u52a1\u5668 1. const fd = socket(); 2. bind(fd, ip, port); 3. listen(fd); 4. const acceptedFd = accept(fd); 5. handle(acceptedFd); \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u51e0\u4e2a\u51fd\u6570\u7684\u4f5c\u7528 1 socket\uff1asocket\u51fd\u6570\u7528\u4e8e\u4ece\u64cd\u4f5c\u7cfb\u7edf\u7533\u8bf7\u4e00\u4e2asocket\u7ed3\u6784\u4f53\uff0cLinux\u4e2d\u4e07\u7269\u7686\u6587\u4ef6\uff0c\u6240\u4ee5\u6700\u540e\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8fd4\u56de\u4e00\u4e2afd\uff0cfd\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7c7b\u4f3c\u6570\u636e\u5e93\u7684id\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5e95\u5c42\u7ef4\u62a4\u4e86fd\u5bf9\u5e94\u7684\u8d44\u6e90\uff0c\u6bd4\u5982\u7f51\u7edc\u3001\u6587\u4ef6\u3001\u7ba1\u9053\u7b49\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u901a\u8fc7\u8be5fd\u53bb\u64cd\u4f5c\u5bf9\u5e94\u7684\u8d44\u6e90\u3002 2 bind\uff1abind\u51fd\u6570\u7528\u4e8e\u7ed9fd\u5bf9\u5e94\u7684socket\u8bbe\u7f6e\u5730\u5740\uff08IP\u548c\u7aef\u53e3\uff09\uff0c\u540e\u7eed\u9700\u8981\u7528\u5230\u3002 3 listen\uff1alisten\u51fd\u6570\u7528\u4e8e\u4fee\u6539fd\u5bf9\u5e94\u7684socket\u7684\u72b6\u6001\u548c\u76d1\u542c\u72b6\u6001\u3002\u53ea\u6709\u76d1\u542c\u72b6\u6001\u7684socket\u53ef\u4ee5\u63a5\u53d7\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u3002socket\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u6709\u4e24\u79cd\uff0c\u4e00\u79cd\u662f\u76d1\u542c\u578b\u7684\uff0c\u4e00\u79cd\u662f\u901a\u4fe1\u578b\u7684\uff0c\u76d1\u542c\u578b\u7684socket\u53ea\u8d1f\u8d23\u5904\u7406\u4e09\u6b21\u63e1\u624b\uff0c\u5efa\u7acb\u8fde\u63a5\uff0c\u901a\u4fe1\u578b\u7684\u8d1f\u8d23\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u3002 4 accept\uff1aaccept\u51fd\u6570\u9ed8\u8ba4\u4f1a\u963b\u585e\u8fdb\u7a0b\uff0c\u76f4\u5230\u6709\u6709\u8fde\u63a5\u5230\u6765\u5e76\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u3002 \u6267\u884c\u5b8c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u5c31\u5b8c\u6210\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u7684\u542f\u52a8\u3002\u8fd9\u65f6\u5019\u5173\u7cfb\u56fe\u5982\u56fe17-1\u6240\u793a\u3002 \u56fe17-1 \u5ba2\u6237\u7aef 1. const fd = socket(); 2. const connectRet = connect(fd, ip, port); 3. write(fd, 'hello'); \u5ba2\u6237\u7aef\u6bd4\u670d\u52a1\u5668\u7a0d\u5fae\u7b80\u5355\u4e00\u70b9\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u51e0\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u3002 1 socket\uff1a\u548c\u670d\u52a1\u5668\u4e00\u6837\uff0c\u5ba2\u6237\u7aef\u4e5f\u9700\u8981\u7533\u8bf7\u4e00\u4e2asocket\u7528\u4e8e\u548c\u670d\u52a1\u5668\u901a\u4fe1\u3002 2 connect\uff1aconnect\u4f1a\u5f00\u59cb\u4e09\u6b21\u63e1\u624b\u8fc7\u7a0b\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4f1a\u963b\u585e\u8fdb\u7a0b\uff0c\u76f4\u5230\u8fde\u63a5\u6709\u7ed3\u679c\uff0c\u8fde\u63a5\u7ed3\u679c\u901a\u8fc7\u8fd4\u56de\u503c\u544a\u8bc9\u8c03\u7528\u65b9\uff0c\u5982\u679c\u4e09\u6b21\u63e1\u624b\u5b8c\u6210\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u53d1\u9001\u6570\u636e\u4e86\u3002 3 write\uff1awrite\u7528\u4e8e\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\uff0c\u4e0d\u8fc7\u5e76\u4e0d\u662f\u76f4\u63a5\u53d1\u9001\uff0c\u8fd9\u4e9b\u6570\u636e\u53ea\u662f\u4fdd\u5b58\u5230socket\u7684\u53d1\u9001\u7f13\u51b2\u533a\uff0c\u5e95\u5c42\u4f1a\u6839\u636eTCP\u534f\u8bae\u51b3\u5b9a\u4ec0\u4e48\u65f6\u5019\u53d1\u9001\u6570\u636e\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u5ba2\u6237\u7aef\u53d1\u9001\u7b2c\u4e00\u4e2a\u63e1\u624b\u7684syn\u5305\u65f6\uff0csocket\u5904\u4e8esyn\u53d1\u9001\u72b6\u6001\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u7684\u670d\u52a1\u5668\u662f\u600e\u6837\u7684\uff0c\u5982\u56fe17-2\u6240\u793a\u3002 \u56fe17-2 \u6211\u4eec\u770b\u5230\u8fd9\u65f6\u5019\uff0c\u670d\u52a1\u5668\u5bf9\u5e94\u7684socket\u4e2d\uff0c\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\u7528\u4e8e\u540e\u7eed\u901a\u4fe1\uff08socket\u7ed3\u6784\u4f53\u6709\u4e00\u4e2a\u5b57\u6bb5\u6307\u5411\u8be5\u961f\u5217\uff09\u3002\u5e76\u4e14\u6807\u8bb0\u8be5socket\u7684\u72b6\u6001\u4e3a\u6536\u5230syn\uff0c\u7136\u540e\u53d1\u9001ack\uff0c\u5373\u7b2c\u4e8c\u6b21\u63e1\u624b\uff0c\u7b49\u5230\u5ba2\u6237\u7aef\u56de\u590d\u7b2c\u4e09\u6b21\u63e1\u624b\u7684\u6570\u636e\u5305\u65f6\uff0c\u5c31\u5b8c\u6210\u4e86\u8fde\u63a5\u7684\u5efa\u7acb\u3002\u4e0d\u540c\u7684\u64cd\u4f5c\u7cfb\u7edf\u7248\u672c\u5b9e\u73b0\u4e0d\u4e00\u6837\uff0c\u6709\u7684\u7248\u672c\u5b9e\u73b0\u4e2d\uff0c\u5df2\u5b8c\u6210\u8fde\u63a5\u548c\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\u7684socket\u662f\u5728\u4e00\u4e2a\u961f\u5217\u4e2d\u7684\uff0c\u6709\u7684\u7248\u672c\u5b9e\u73b0\u4e2d\uff0c\u5df2\u5b8c\u6210\u8fde\u63a5\u548c\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\u7684socket\u662f\u5206\u4e3a\u4e24\u4e2a\u961f\u5217\u7ef4\u62a4\u7684\u3002 \u5f53\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5b8c\u6210\u4e86TCP\u8fde\u63a5\u540e\uff0c\u5c31\u53ef\u4ee5\u8fdb\u884c\u6570\u636e\u901a\u4fe1\u4e86\uff0c\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u7684accept\u5c31\u4f1a\u4ece\u963b\u585e\u4e2d\u88ab\u5524\u9192\uff0c\u5e76\u4ece\u8fde\u63a5\u961f\u5217\u4e2d\u6458\u4e0b\u4e00\u4e2a\u5df2\u5b8c\u6210\u8fde\u63a5\u7684socket\u7ed3\u70b9\uff0c\u7136\u540e\u751f\u6210\u4e00\u4e2a\u65b0\u7684fd\u3002\u540e\u7eed\u5c31\u53ef\u4ee5\u5728\u8be5fd\u4e0a\u548c\u5bf9\u7aef\u901a\u4fe1\u3002\u90a3\u4e48\u5f53\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2aTCP\u6570\u636e\u5305\u8fc7\u6765\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u5904\u7406\u7684\u5462\uff1f 1 \u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u6839\u636eTCP\u62a5\u6587\u7684\u6e90IP\u3001\u6e90\u7aef\u53e3\u3001\u76ee\u7684IP\u3001\u76ee\u7684\u7aef\u53e3\u7b49\u4fe1\u606f\u4ecesocket\u6c60\u4e2d\u627e\u5230\u5bf9\u5e94\u7684socket\u3002 2 \u64cd\u4f5c\u7cfb\u7edf\u5224\u65ad\u8bfb\u7f13\u51b2\u533a\u662f\u5426\u8fd8\u6709\u8db3\u591f\u7684\u7a7a\u95f4\uff0c\u5982\u679c\u7a7a\u95f4\u4e0d\u591f\uff0c\u5219\u4e22\u5f03TCP\u62a5\u6587\uff0c\u5426\u5219\u628a\u62a5\u6587\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u6302\u8f7d\u5230socket\u7684\u6570\u636e\u961f\u5217\uff0c\u7b49\u5f85\u8bfb\u53d6\u3002 \u4e86\u89e3\u4e86TCP\u901a\u4fe1\u7684\u5927\u81f4\u8fc7\u7a0b\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u662f\u5982\u4f55\u5c01\u88c5\u5e95\u5c42\u7684\u80fd\u529b\u7684\u3002 17.1 TCP\u5ba2\u6237\u7aef \u00b6 17.1.1 \u5efa\u7acb\u8fde\u63a5 \u00b6 net.connect\u662fNode.js\u4e2d\u53d1\u8d77TCP\u8fde\u63a5\u7684API\u3002\u672c\u8d28\u4e0a\u662f\u5bf9\u5e95\u5c42TCP connect\u51fd\u6570\u7684\u5c01\u88c5\u3002connect\u8fd4\u56de\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684Socket\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bconnect\u51fd\u6570\u7684\u5165\u53e3\u5b9a\u4e49\u3002 1. function connect(...args) { 2. // \u5904\u7406\u53c2\u6570 3. var normalized = normalizeArgs(args); 4. var options = normalized[0]; 5. // \u7533\u8bf7\u4e00\u4e2asocket\u8868\u793a\u4e00\u4e2a\u5ba2\u6237\u7aef 6. var socket = new Socket(options); 7. // \u8bbe\u7f6e\u8d85\u65f6\uff0c\u8d85\u65f6\u540e\u4f1a\u89e6\u53d1timeout\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u5904\u7406\u8d85\u65f6\u903b\u8f91 8. if (options.timeout) { 9. socket.setTimeout(options.timeout); 10. } 11. // \u8c03\u7528socket\u7684connect 12. return Socket.prototype.connect.call(socket, normalized); 13. } \u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cconnect\u51fd\u6570\u662f\u5bf9Socket\u5bf9\u8c61\u7684\u5c01\u88c5\u3002Socket\u8868\u793a\u4e00\u4e2aTCP\u5ba2\u6237\u7aef\u3002\u6211\u4eec\u5206\u6210\u4e09\u90e8\u5206\u5206\u6790\u3002 1 new Socket 2 setTimeout 3 Socket\u7684connect 1 new Socket \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aSocket\u5bf9\u8c61\uff0c\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1. function Socket(options) { 2. // \u662f\u5426\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b\u4e2d 3. this.connecting = false; 4. // \u89e6\u53d1close\u4e8b\u4ef6\u65f6\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u662f\u5426\u7531\u4e8e\u9519\u8bef\u5bfc\u81f4\u4e86close 5. this._hadError = false; 6. // \u5bf9\u5e94\u7684\u5e95\u5c42handle\uff0c\u6bd4\u5982tcp_wrap 7. this._handle = null; 8. // \u5b9a\u65f6\u5668id 9. this[kTimeout] = null; 10. options = options || {}; 11. // socket\u662f\u53cc\u5411\u6d41 12. stream.Duplex.call(this, options); 13. // \u8fd8\u4e0d\u80fd\u8bfb\u5199\uff0c\u5148\u8bbe\u7f6e\u6210false\uff0c\u8fde\u63a5\u6210\u529f\u540e\u518d\u91cd\u65b0\u8bbe\u7f6e 14. this.readable = this.writable = false; 15. // \u6ce8\u518c\u5199\u7aef\u5173\u95ed\u7684\u56de\u8c03 16. this.on('finish', onSocketFinish); 17. // \u6ce8\u518c\u8bfb\u7aef\u5173\u95ed\u7684\u56de\u8c03 18. this.on('_socketEnd', onSocketEnd); 19. // \u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e0d\u5141\u8bb8 20. this.allowHalfOpen = options && options.allowHalfOpen||false; 21. } Socket\u662f\u5bf9C++\u6a21\u5757tcp_wrap\u7684\u5c01\u88c5\u3002\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u5c5e\u6027\u548c\u76d1\u542c\u4e00\u4e9b\u4e8b\u4ef6\u3002 2 setTimeout 1. Socket.prototype.setTimeout = function(msecs, callback) { 2. // \u6e05\u9664\u4e4b\u524d\u7684\uff0c\u5982\u679c\u6709\u7684\u8bdd 3. clearTimeout(this[kTimeout]); 4. // 0\u4ee3\u8868\u6e05\u9664 5. if (msecs === 0) { 6. if (callback) { 7. this.removeListener('timeout', callback); 8. } 9. } else { 10. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u65f6\u95f4\u662fmsecs\uff0c\u8d85\u65f6\u56de\u8c03\u662f_onTimeout 11. this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs); 12. /* 13. \u76d1\u542ctimeout\u4e8b\u4ef6\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u5e95\u5c42\u4f1a\u8c03\u7528Node.js\u7684\u56de\u8c03\uff0c 14. Node.js\u4f1a\u8c03\u7528\u7528\u6237\u7684\u56de\u8c03callback 15. */ 16. if (callback) { 17. this.once('timeout', callback); 18. } 19. } 20. return this; 21. }; setTimeout\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u8fd9\u4e2a\u65f6\u95f4\u7528\u4e8e\u68c0\u6d4bsocket\u7684\u6d3b\u8dc3\u60c5\u51b5\uff08\u6bd4\u5982\u6709\u6570\u636e\u901a\u4fe1\uff09\uff0c\u5f53socket\u6d3b\u8dc3\u65f6\uff0cNode.js\u4f1a\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\uff0c\u5982\u679csocket\u4e00\u76f4\u4e0d\u6d3b\u8dc3\u5219\u8d85\u65f6\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884cNode.js\u7684_onTimeout\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u518d\u89e6\u53d1\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8d85\u65f6\u5904\u7406\u51fd\u6570_onTimeout\u3002 1. Socket.prototype._onTimeout = function() { 2. this.emit('timeout'); 3. }; \u76f4\u63a5\u89e6\u53d1timeout\u51fd\u6570\uff0c\u56de\u8c03\u7528\u6237\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u5230setTimeout\u53ea\u662f\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u7136\u540e\u89e6\u53d1timeout\u4e8b\u4ef6\uff0cNode.js\u5e76\u6ca1\u6709\u5e2e\u6211\u4eec\u505a\u989d\u5916\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5904\u7406\uff0c\u6bd4\u5982\u5173\u95edsocket\u3002 1. socket.setTimeout(10000); 2. socket.on('timeout', () => { 3. socket.close(); 4. }); \u53e6\u5916\u6211\u4eec\u770b\u5230\u8fd9\u91cc\u662f\u4f7f\u7528setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u8fd9\u4e00\u7c7b\u5b9a\u65f6\u5668\u4e0d\u5e94\u8be5\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 3 connect\u51fd\u6570 \u5728\u7b2c\u4e00\u6b65\u6211\u4eec\u5df2\u7ecf\u521b\u5efa\u4e86\u4e00\u4e2asocket\uff0c\u63a5\u7740\u6211\u4eec\u8c03\u7528\u8be5socket\u7684connect\u51fd\u6570\u5f00\u59cb\u53d1\u8d77\u8fde\u63a5\u3002 1. // \u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b 2. Socket.prototype.connect = function(...args) { 3. let normalized; 4. /* \u5ffd\u7565\u53c2\u6570\u5904\u7406 */ 5. var options = normalized[0]; 6. var cb = normalized[1]; 7. // TCP\u5728tcp_wrap.cc\u4e2d\u5b9a\u4e49 8. this._handle = new TCP(TCPConstants.SOCKET); 9. // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u7684\u56de\u8c03 10. this._handle.onread = onread; 11. // \u8fde\u63a5\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 12. if (cb !== null) { 13. this.once('connect', cb); 14. } 15. // \u6b63\u5728\u8fde\u63a5 16. this.connecting = true; 17. this.writable = true; 18. // \u91cd\u7f6e\u5b9a\u65f6\u5668 19. this._unrefTimer(); 20. // \u53ef\u80fd\u9700\u8981DNS\u89e3\u6790\uff0c\u89e3\u6790\u6210\u529f\u518d\u53d1\u8d77\u8fde\u63a5 21. lookupAndConnect(this, options); 22. return this; 23. }; connect \u51fd\u6570\u4e3b\u8981\u662f\u4e09\u4e2a\u903b\u8f91 1 \u9996\u5148\u901a\u8fc7new TCP()\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle\uff0c\u6bd4\u5982\u6211\u4eec\u8fd9\u91cc\u662fTCP\uff08\u5bf9\u5e94tcp_wrap.cc\u7684\u5b9e\u73b0\uff09\u3002 2 \u8bbe\u7f6e\u4e00\u4e9b\u56de\u8c03 3 \u505aDNS\u89e3\u6790\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u7136\u540e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u3002 \u6211\u4eec\u770b\u4e00\u4e0bnew TCP\u610f\u5473\u7740\u4ec0\u4e48\uff0c\u6211\u4eec\u770btcp_wrap.cc\u7684\u5b9e\u73b0 1. void TCPWrap::New(const FunctionCallbackInfo<Value>& args) { 2. // \u8981\u4ee5new TCP\u7684\u5f62\u5f0f\u8c03\u7528 3. CHECK(args.IsConstructCall()); 4. // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662f\u6570\u5b57 5. CHECK(args[0]->IsInt32()); 6. Environment* env = Environment::GetCurrent(args); 7. // \u4f5c\u4e3a\u5ba2\u6237\u7aef\u8fd8\u662f\u670d\u52a1\u5668 8. int type_value = args[0].As<Int32>()->Value(); 9. TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value); 10. 11. ProviderType provider; 12. switch (type) { 13. // \u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u5373\u53d1\u8d77\u8fde\u63a5\u65b9 14. case SOCKET: 15. provider = PROVIDER_TCPWRAP; 16. break; 17. // \u4f5c\u4e3a\u670d\u52a1\u5668 18. case SERVER: 19. provider = PROVIDER_TCPSERVERWRAP; 20. break; 21. default: 22. UNREACHABLE(); 23. } 24. new TCPWrap(env, args.This(), provider); 25. } new TCP\u5bf9\u5e94\u5230C++\u5c42\uff0c\u5c31\u662f\u521b\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u5e76\u521d\u59cb\u5316\u5bf9\u8c61\u4e2d\u7684handle_\u5b57\u6bb5 1. TCPWrap::TCPWrap(Environment* env, 2. Local<Object> object, 3. ProviderType provider) 4. : ConnectionWrap(env, object, provider) { 5. int r = uv_tcp_init(env->event_loop(), &handle_); 6. } \u521d\u59cb\u5316\u5b8c\u5e95\u5c42\u7684\u6570\u636e\u7ed3\u6784\u540e\uff0c\u6211\u4eec\u7ee7\u7eed\u770blookupAndConnect\uff0clookupAndConnect\u4e3b\u8981\u662f\u5bf9\u53c2\u6570\u8fdb\u884c\u6821\u9a8c\uff0c\u7136\u540e\u8fdb\u884cDNS\u89e3\u6790\uff08\u5982\u679c\u4f20\u7684\u662f\u57df\u540d\u7684\u8bdd\uff09\uff0cDNS\u89e3\u6790\u6210\u529f\u540e\u6267\u884cinternalConnect 1. function internalConnect( 2. self, 3. // \u9700\u8981\u8fde\u63a5\u7684\u8fdc\u7aefIP\u3001\u7aef\u53e3 4. address, 5. port, 6. addressType, 7. /* 8. \u7528\u4e8e\u548c\u5bf9\u7aef\u8fde\u63a5\u7684\u672c\u5730IP\u3001\u7aef\u53e3\uff08\u5982\u679c\u4e0d\u8bbe\u7f6e\uff0c 9. \u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u51b3\u5b9a\uff09 10. */ 11. localAddress, 12. localPort) { 13. var err; 14. /* 15. \u5982\u679c\u4f20\u4e86\u672c\u5730\u7684\u5730\u5740\u6216\u7aef\u53e3\uff0c\u5219TCP\u8fde\u63a5\u4e2d\u7684\u6e90IP 16. \u548c\u7aef\u53e3\u5c31\u662f\u4f20\u7684\uff0c\u5426\u5219\u7531\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009 17. */ 18. if (localAddress || localPort) { 19. // IP v4 20. if (addressType === 4) { 21. localAddress = localAddress || '0.0.0.0'; 22. // \u7ed1\u5b9a\u5730\u5740\u548c\u7aef\u53e3\u5230handle 23. err = self._handle.bind(localAddress, localPort); 24. } else if (addressType === 6) { 25. localAddress = localAddress || '::'; 26. err = self._handle.bind6(localAddress, localPort); 27. } 28. 29. // \u7ed1\u5b9a\u662f\u5426\u6210\u529f 30. err = checkBindError(err, localPort, self._handle); 31. if (err) { 32. const ex = exceptionWithHostPort(err, 33. 'bind', 34. localAddress, 35. localPort); 36. self.destroy(ex); 37. return; 38. } 39. } 40. // \u5bf9\u7aef\u7684\u5730\u5740\u4fe1\u606f 41. if (addressType === 6 || addressType === 4) { 42. // \u65b0\u5efa\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61\uff0cC++\u5c42\u5b9a\u4e49 43. const req = new TCPConnectWrap(); 44. // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 45. req.oncomplete = afterConnect; 46. req.address = address; 47. req.port = port; 48. req.localAddress = localAddress; 49. req.localPort = localPort; 50. // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 51. if (addressType === 4) 52. err = self._handle.connect(req, address, port); 53. else 54. err = self._handle.connect6(req, address, port); 55. } 56. /* 57. \u975e\u963b\u585e\u8c03\u7528\uff0c\u53ef\u80fd\u5728\u8fd8\u6ca1\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u4e4b\u524d\u5c31\u62a5\u9519\u4e86\uff0c 58. \u800c\u4e0d\u662f\u4e09\u6b21\u63e1\u624b\u51fa\u9519\uff0c\u8fd9\u91cc\u8fdb\u884c\u51fa\u9519\u5904\u7406 59. */ 60. if (err) { 61. // \u83b7\u53d6socket\u5bf9\u5e94\u7684\u5e95\u5c42IP\u7aef\u53e3\u4fe1\u606f 62. var sockname = self._getsockname(); 63. var details; 64. 65. if (sockname) { 66. details = sockname.address + ':' + sockname.port; 67. } 68. // \u6784\u9020\u9519\u8bef\u4fe1\u606f\uff0c\u9500\u9b42socket\u5e76\u89e6\u53d1error\u4e8b\u4ef6 69. const ex = exceptionWithHostPort(err, 70. 'connect', 71. address, 72. port, 73. details); 74. self.destroy(ex); 75. } 76. } \u8fd9\u91cc\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u9664\u4e86\u9519\u8bef\u5904\u7406\u5916\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662fbind\u548cconnect\u3002bind\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff08\u5373\u4f7f\u662f\u5e95\u5c42\u7684bind\uff09\uff0c\u5b83\u5c31\u662f\u5728\u5e95\u5c42\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0a\u8bbe\u7f6e\u4e86\u4e24\u4e2a\u5b57\u6bb5\u7684\u503c\u3002\u6240\u4ee5\u6211\u4eec\u4e3b\u8981\u6765\u5206\u6790connect\u3002\u6211\u4eec\u628a\u5173\u4e8econnect\u7684\u8fd9\u6bb5\u903b\u8f91\u62ce\u51fa\u6765\u3002 1. const req = new TCPConnectWrap(); 2. // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 3. req.oncomplete = afterConnect; 4. req.address = address; 5. req.port = port; 6. req.localAddress = localAddress; 7. req.localPort = localPort; 8. // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 9. self._handle.connect(req, address, port); TCPConnectWrap\u662fC++\u5c42\u63d0\u4f9b\u7684\u7c7b\uff0cconnect\u5bf9\u5e94C++\u5c42\u7684Conenct\uff0c \u524d\u9762\u7684\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u8fde\u63a5\u5b8c\u6210\u540e\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__stream_io\u3002\u5728uv__stream_io\u91cc\u4f1a\u8c03\u7528connect_req\u4e2d\u7684\u56de\u8c03\u3002\u5047\u8bbe\u8fde\u63a5\u5efa\u7acb\uff0c\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884cC++\u5c42\u7684AfterConnect\u3002AfterConnect\u4f1a\u6267\u884cJS\u5c42\u7684afterConnect\u3002 1. // \u8fde\u63a5\u540e\u6267\u884c\u7684\u56de\u8c03\uff0c\u6210\u529f\u6216\u5931\u8d25 2. function afterConnect(status, handle, req, readable, writable) { // handle\u5173\u8054\u7684socket 3. var self = handle.owner; 4. // \u8fde\u63a5\u8fc7\u7a0b\u4e2d\u6267\u884c\u4e86socket\u88ab\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u7ee7\u7eed\u5904\u7406 5. if (self.destroyed) { 6. return; 7. } 8. 9. handle = self._handle; 10. self.connecting = false; 11. self._sockname = null; 12. // \u8fde\u63a5\u6210\u529f 13. if (status === 0) { 14. // \u8bbe\u7f6e\u8bfb\u5199\u5c5e\u6027 15. self.readable = readable; 16. self.writable = writable; 17. // socket\u5f53\u524d\u6d3b\u8dc3\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 18. self._unrefTimer(); 19. // \u89e6\u53d1\u8fde\u63a5\u6210\u529f\u4e8b\u4ef6 20. self.emit('connect'); 21. // socket\u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u5f00\u542f\u8bfb 22. if (readable && !self.isPaused()) 23. self.read(0); 24. } else { 25. // \u8fde\u63a5\u5931\u8d25\uff0c\u62a5\u9519\u5e76\u9500\u6bc1socket 26. self.connecting = false; 27. var details; 28. // \u63d0\u793a\u51fa\u9519\u4fe1\u606f 29. if (req.localAddress && req.localPort) { 30. details = req.localAddress + ':' + req.localPort; 31. } 32. var ex = exceptionWithHostPort(status, 33. 'connect', 34. req.address, 35. req.port, 36. details); 37. if (details) { 38. ex.localAddress = req.localAddress; 39. ex.localPort = req.localPort; 40. } 41. // \u9500\u6bc1socket 42. self.destroy(ex); 43. } 44. } \u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u8fde\u63a5\u6210\u529f\u540e\uff0cJS\u5c42\u8c03\u7528self.read(0)\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u3002 17.1.2 \u8bfb\u64cd\u4f5c \u00b6 \u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684\u8bfb\u64cd\u4f5c\u903b\u8f91\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\uff0csocket\u4f1a\u901a\u8fc7read\u51fd\u6570\u5728\u5e95\u5c42\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85\u5e95\u5c42\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u901a\u77e5\u6709\u6570\u636e\u53ef\u8bfb\u3002 1. Socket.prototype.read = function(n) { 2. if (n === 0) 3. return stream.Readable.prototype.read.call(this, n); 4. 5. this.read = stream.Readable.prototype.read; 6. this._consuming = true; 7. return this.read(n); 8. }; \u8fd9\u91cc\u4f1a\u6267\u884cReadable\u6a21\u5757\u7684read\u51fd\u6570\uff0c\u4ece\u800c\u6267\u884c_read\u51fd\u6570\uff0c_read\u51fd\u6570\u662f\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6240\u4ee5\u6211\u4eec\u770bSocket\u7684_read 1. Socket.prototype._read = function(n) { 2. // \u8fd8\u6ca1\u5efa\u7acb\u8fde\u63a5\uff0c\u5219\u5efa\u7acb\u540e\u518d\u6267\u884c 3. if (this.connecting || !this._handle) { 4. this.once('connect', () => this._read(n)); 5. } else if (!this._handle.reading) { 6. this._handle.reading = true; 7. // \u6267\u884c\u5e95\u5c42\u7684readStart\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 8. var err = this._handle.readStart(); 9. if (err) 10. this.destroy(errnoException(err, 'read')); 11. } 12. }; \u4f46\u662f\u6211\u4eec\u53d1\u73b0tcp_wrap.cc\u6ca1\u6709readStart\u51fd\u6570\u3002\u4e00\u8def\u5f80\u7236\u7c7b\u627e\uff0c\u6700\u7ec8\u5728stream_wrap.cc\u627e\u5230\u4e86\u8be5\u51fd\u6570\u3002 1. // \u6ce8\u518c\u8bfb\u4e8b\u4ef6 2. int LibuvStreamWrap::ReadStart() { 3. return uv_read_start(stream(), 4. [](uv_handle_t* handle, 5. size_t suggested_size, 6. uv_buf_t* buf) { 7. // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 8. static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); 9. }, 10. [](uv_stream_t* stream,ssize_t nread,const uv_buf_t* buf) { 11. // \u8bfb\u53d6\u6570\u636e\u6210\u529f\u7684\u56de\u8c03 12. static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); 13. }); 14. } uv_read_start\u51fd\u6570\u5728\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4f5c\u7528\u5c31\u662f\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u518d\u6df1\u5165\u3002OnUvAlloc\u662f\u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u4e0d\u5173\u6ce8\uff0c\u6211\u4eec\u770b\u4e00\u4e0bOnUvRead\uff0c\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u4f1a\u6267\u884cOnUvRead 1. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 2. HandleScope scope(env()->isolate()); 3. Context::Scope context_scope(env()->context()); 4. // \u89e6\u53d1onread\u4e8b\u4ef6 5. EmitRead(nread, *buf); 6. } OnUvRead\u51fd\u6570\u89e6\u53d1onread\u56de\u8c03\u3002 1. function onread(nread, buffer) { 2. var handle = this; 3. // handle\u5173\u8054\u7684socket 4. var self = handle.owner; 5. // socket\u6709\u6570\u636e\u5230\u6765\uff0c\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 6. self._unrefTimer(); 7. // \u6210\u529f\u8bfb\u53d6\u6570\u636e 8. if (nread > 0) { 9. // push\u5230\u6d41\u4e2d 10. var ret = self.push(buffer); 11. /* 12. push\u8fd4\u56defalse\uff0c\u8bf4\u660e\u7f13\u5b58\u7684\u6570\u636e\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c 13. \u4e0d\u80fd\u518d\u89e6\u53d1\u8bfb\uff0c\u9700\u8981\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 14. */ 15. if (handle.reading && !ret) { 16. handle.reading = false; 17. var err = handle.readStop(); 18. if (err) 19. self.destroy(errnoException(err, 'read')); 20. } 21. return; 22. } 23. 24. // \u6ca1\u6709\u6570\u636e\uff0c\u5ffd\u7565 25. if (nread === 0) { 26. debug('not any data, keep waiting'); 27. return; 28. } 29. // \u4e0d\u7b49\u4e8e\u7ed3\u675f\uff0c\u5219\u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 30. if (nread !== UV_EOF) { 31. return self.destroy(errnoException(nread, 'read')); 32. } 33. // \u6d41\u7ed3\u675f\u4e86\uff0c\u6ca1\u6709\u6570\u636e\u8bfb\u4e86 34. self.push(null); 35. /* 36. \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u4e86\uff0c\u53ef\u80fd\u9700\u8981\u9500\u6bc1\u6d41\uff0c\u6bd4\u5982\u662f\u53ea\u8bfb\u6d41\uff0c 37. \u6216\u8005\u53ef\u8bfb\u5199\u6d41\uff0c\u5199\u7aef\u4e5f\u6ca1\u6709\u6570\u636e\u4e86\uff0c\u53c2\u8003maybeDestroy 38. */ 39. if (self.readableLength === 0) { 40. self.readable = false; 41. maybeDestroy(self); 42. } 43. // \u89e6\u53d1\u4e8b\u4ef6 44. self.emit('_socketEnd'); 45. } socket\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u5927\u6982\u6709\u4e0b\u9762\u51e0\u79cd\u60c5\u51b5 1 \u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0cpush\u5230\u6d41\u4e2d\uff0c\u89e6\u53d1ondata\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u3002 2 \u6ca1\u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0c\u5ffd\u7565\u3002 3 \u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 4 \u8bfb\u7ed3\u675f\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0b4\u3002\u5728\u65b0\u5efa\u4e00\u4e2asocket\u7684\u65f6\u5019\u6ce8\u518c\u4e86\u6d41\u7ed3\u675f\u7684\u5904\u7406\u51fd\u6570onSocketEnd\u3002 1. // \u8bfb\u7ed3\u675f\u540e\u6267\u884c\u7684\u51fd\u6570 2. function onSocketEnd() { 3. // \u8bfb\u7ed3\u675f\u6807\u8bb0 4. this._readableState.ended = true; 5. /* 6. \u5df2\u7ecf\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\uff0c\u5219\u5224\u65ad\u662f\u5426\u9700\u8981\u9500\u6bc1\uff0c\u53ef\u80fd\u8fd8\u6709\u5199\u7aef 7. */ 8. if (this._readableState.endEmitted) { 9. this.readable = false; 10. maybeDestroy(this); 11. } else { 12. // \u8fd8\u6ca1\u6709\u89e6\u53d1end\u5219\u7b49\u5f85\u89e6\u53d1end\u4e8b\u4ef6\u518d\u6267\u884c\u4e0b\u4e00\u6b65\u64cd\u4f5c 13. this.once('end', function end() { 14. this.readable = false; 15. maybeDestroy(this); 16. }); 17. /* 18. \u6267\u884cread\uff0c\u5982\u679c\u6d41\u4e2d\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u4f1a\u89e6\u53d1end\u4e8b\u4ef6\uff0c 19. \u5426\u5219\u7b49\u5f85\u6d88\u8d39\u5b8c\u540e\u518d\u89e6\u53d1 20. */ 21. this.read(0); 22. } 23. /* 24. 1 \u8bfb\u7ed3\u675f\u540e\uff0c\u5982\u679c\u4e0d\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5219\u5173\u95ed\u5199\u7aef\uff0c\u5982\u679c\u8fd8\u6709\u6570\u636e\u8fd8\u6ca1\u6709\u53d1\u9001 25. \u5b8c\u6bd5\uff0c\u5219\u5148\u53d1\u9001\u5b8c\u518d\u5173\u95ed 26. 2 \u91cd\u7f6e\u5199\u51fd\u6570\uff0c\u540e\u7eed\u6267\u884c\u5199\u7684\u65f6\u5019\u62a5\u9519 27. */ 28. if (!this.allowHalfOpen) { 29. this.write = writeAfterFIN; 30. this.destroySoon(); 31. } 32. } \u5f53socket\u7684\u8bfb\u7aef\u7ed3\u675f\u65f6\uff0csocket\u7684\u72b6\u6001\u53d8\u66f4\u5206\u4e3a\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u53ef\u8bfb\u6d41\u4e2d\u8fd8\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u7b49\u5f85\u8bfb\u53d6\u3002 2 \u5982\u679c\u5199\u7aef\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1\u6d41\u3002 3 \u5982\u679c\u5199\u7aef\u6ca1\u6709\u7ed3\u675f\uff0c\u5219\u5224\u65adallowHalfOpen\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u4e0d\u5141\u8bb8\u5e76\u4e14\u5199\u7aef\u6570\u636e\u5df2\u7ecf\u53d1\u9001\u5b8c\u6bd5\u5219\u5173\u95ed\u5199\u7aef\u3002 17.1.3 \u5199\u64cd\u4f5c \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5728\u4e00\u4e2a\u6d41\u4e0a\u5199\u7684\u65f6\u5019\uff0c\u903b\u8f91\u662f\u600e\u6837\u7684\u3002Socket\u5b9e\u73b0\u4e86\u5355\u4e2a\u5199\u548c\u6279\u91cf\u5199\u63a5\u53e3\u3002 1. // \u6279\u91cf\u5199 2. Socket.prototype._writev = function(chunks, cb) { 3. this._writeGeneric(true, chunks, '', cb); 4. }; 5. 6. // \u5355\u4e2a\u5199 7. Socket.prototype._write = function(data, encoding, cb) { 8. this._writeGeneric(false, data, encoding, cb); 9. }; _writeGeneric 1. Socket.prototype._writeGeneric = function(writev, data, encoding, cb) { 2. /* 3. \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u5148\u4fdd\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u56e0\u4e3astream\u6a21\u5757\u662f\u4e32\u884c\u5199\u7684\uff0c 4. \u6240\u4ee5\u7b2c\u4e00\u6b21\u5199\u6ca1\u5b8c\u6210\uff0c\u4e0d\u4f1a\u6267\u884c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\uff08_write\uff09\uff0c 5. \u6240\u4ee5\u8fd9\u91cc\u7528\u4e00\u4e2a\u5b57\u6bb5\u800c\u4e0d\u662f\u4e00\u4e2a\u6570\u7ec4\u6216\u961f\u5217\u4fdd\u5b58\u6570\u636e\u548c\u7f16\u7801\uff0c 6. \u56e0\u4e3a\u6709pendingData\u65f6_writeGeneric \u4e0d\u4f1a\u88ab\u6267\u884c\u7b2c\u4e8c\u6b21\uff0c\u8fd9\u91cc\u7f13\u5b58 7. pendingData\u4e0d\u662f\u4e3a\u4e86\u540e\u7eed\u5199\u5165\uff0c\u800c\u662f\u4e3a\u4e86\u7edf\u8ba1\u5199\u5165\u7684\u6570\u636e\u603b\u6570 8. */ 9. if (this.connecting) { 10. this._pendingData = data; 11. this._pendingEncoding = encoding; 12. this.once('connect', function connect() { 13. this._writeGeneric(writev, data, encoding, cb); 14. }); 15. return; 16. } 17. // \u5f00\u59cb\u5199\uff0c\u5219\u6e05\u7a7a\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e 18. this._pendingData = null; 19. this._pendingEncoding = ''; 20. // \u5199\u64cd\u4f5c\uff0c\u6709\u6570\u636e\u901a\u4fe1\uff0c\u5237\u65b0\u5b9a\u65f6\u5668 21. this._unrefTimer(); 22. // \u5df2\u7ecf\u5173\u95ed\uff0c\u5219\u9500\u6bc1socket 23. if (!this._handle) { 24. this.destroy(new errors.Error('ERR_SOCKET_CLOSED'), cb); 25. return false; 26. } 27. // \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 28. var req = new WriteWrap(); 29. req.handle = this._handle; 30. req.oncomplete = afterWrite; 31. // \u662f\u5426\u540c\u6b65\u6267\u884c\u5199\u5b8c\u6210\u56de\u8c03\uff0c\u53d6\u51b3\u4e8e\u5e95\u5c42\u662f\u540c\u6b65\u5199\u5165\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u8fd8\u662f\u5f02\u6b65\u5199\u5165 32. req.async = false; 33. var err; 34. // \u662f\u5426\u6279\u91cf\u5199 35. if (writev) { 36. // \u6240\u6709\u6570\u636e\u90fd\u662fbuffer\u7c7b\u578b\uff0c\u5219\u76f4\u63a5\u5806\u8d77\u6765\uff0c\u5426\u5219\u9700\u8981\u4fdd\u5b58\u7f16\u7801\u7c7b\u578b 37. var allBuffers = data.allBuffers; 38. var chunks; 39. var i; 40. if (allBuffers) { 41. chunks = data; 42. for (i = 0; i < data.length; i++) 43. data[i] = data[i].chunk; 44. } else { 45. // \u7533\u8bf7double\u4e2a\u5927\u5c0f\u7684\u6570\u7ec4 46. chunks = new Array(data.length << 1); 47. for (i = 0; i < data.length; i++) { 48. var entry = data[i]; 49. chunks[i * 2] = entry.chunk; 50. chunks[i * 2 + 1] = entry.encoding; 51. } 52. } 53. err = this._handle.writev(req, chunks, allBuffers); 54. 55. // Retain chunks 56. if (err === 0) req._chunks = chunks; 57. } else { 58. var enc; 59. if (data instanceof Buffer) { 60. enc = 'buffer'; 61. } else { 62. enc = encoding; 63. } 64. err = createWriteReq(req, this._handle, data, enc); 65. } 66. 67. if (err) 68. return this.destroy(errnoException(err, 'write', req.error), cb); 69. // \u8bf7\u6c42\u5199\u5165\u5e95\u5c42\u7684\u6570\u636e\u5b57\u8282\u957f\u5ea6 70. this._bytesDispatched += req.bytes; 71. // \u5728stream_base.cc\u4e2dreq_wrap_obj->Set(env->async(), True(env->isolate()));\u8bbe\u7f6e 72. if (!req.async) { 73. cb(); 74. return; 75. } 76. 77. req.cb = cb; 78. // \u6700\u540e\u4e00\u6b21\u8bf7\u6c42\u5199\u6570\u636e\u7684\u5b57\u8282\u957f\u5ea6 79. this[kLastWriteQueueSize] = req.bytes; 80. }; \u4e0a\u9762\u7684\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5177\u4f53\u5b9e\u73b0\u5728stream_base.cc\u548cstream_wrap.cc\uff0c\u8fd9\u91cc\u4e0d\u518d\u5c55\u5f00\u5206\u6790\uff0c\u4e3b\u8981\u662f\u6267\u884cwritev\u548ccreateWriteReq\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u5b83\u4eec\u5e95\u5c42\u8c03\u7528\u7684\u90fd\u662fuv_write2\uff08\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216uv_write\uff08\u4e0d\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216\u8005uv_try_write\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u4e00\u4e0basync\u7684\u610f\u4e49\uff0casync\u9ed8\u8ba4\u662ffalse\uff0c\u5b83\u8868\u793a\u7684\u610f\u4e49\u662f\u6267\u884c\u5e95\u5c42\u5199\u5165\u65f6\uff0c\u5e95\u5c42\u662f\u5426\u540c\u6b65\u6267\u884c\u56de\u8c03\uff0casync\u4e3afalse\u8bf4\u660e\u5199\u5165\u5b8c\u6210\u56de\u8c03\u662f\u540c\u6b65\u6267\u884c\u7684\u3002\u5728stream_base.cc\u7684\u5199\u51fd\u6570\u4e2d\u6709\u76f8\u5173\u7684\u903b\u8f91\u3002 1. err = DoWrite(req_wrap, buf_list, count, nullptr); 2. req_wrap_obj->Set(env->async(), True(env->isolate())); \u5f53\u6267\u884cDoWrite\u7684\u65f6\u5019\uff0creq_wrap\u4e2d\u4fdd\u5b58\u7684\u56de\u8c03\u53ef\u80fd\u4f1a\u88abLibuv\u540c\u6b65\u6267\u884c\uff0c\u4ece\u800c\u6267\u884cJS\u4ee3\u7801\uff0c\u8fd9\u65f6\u5019async\u662ffalse\uff08\u9ed8\u8ba4\u503c\uff09\uff0c\u8bf4\u660e\u56de\u8c03\u662f\u88ab\u540c\u6b65\u6267\u884c\u7684\uff0c\u5982\u679cDoWrite\u6ca1\u6709\u540c\u6b65\u6267\u884c\u56de\u8c03\u3002\u5219\u8bf4\u660e\u662f\u5f02\u6b65\u6267\u884c\u56de\u8c03\u3002\u8bbe\u7f6easync\u4e3atrue\uff0c\u518d\u6267\u884cJS\u4ee3\u7801\u3002 17.1.4 \u5173\u95ed\u5199\u64cd\u4f5c \u00b6 \u5f53\u6211\u4eec\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528socket\u5bf9\u8c61\u7684end\u51fd\u6570\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u4e00\u4e0bend\u7684\u903b\u8f91\u3002 1. Socket.prototype.end = function(data, encoding, callback) { 2. stream.Duplex.prototype.end.call(this, 3. data, 4. encoding, 5. callback); 6. return this; 7. }; Socket\u7684end\u662f\u8c03\u7528\u7684Duplex\u7684end\uff0c\u800cDuplex\u7684end\u662f\u7ee7\u627f\u4e8eWritable\u7684end\u3002Writable\u7684end\u6700\u7ec8\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6\uff0csocket\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u76d1\u542c\u4e86\u8be5\u4e8b\u4ef6\u3002 1. this.on('finish', onSocketFinish); \u6211\u4eec\u770b\u770bonSocketFinish\u3002 1. // \u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff0c\u5219\u5173\u95ed\u5199\u7aef 2. function onSocketFinish() { 3. // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\u5c31\u6267\u884c\u4e86end 4. if (this.connecting) { 5. return this.once('connect', onSocketFinish); 6. } 7. // \u5199\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u4e5f\u4e0d\u80fd\u8bfb\u6216\u8005\u8bfb\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket 8. if (!this.readable || this._readableState.ended) { 9. return this.destroy(); 10. } 11. // \u4e0d\u652f\u6301shutdown\u5219\u76f4\u63a5\u9500\u6bc1 12. if (!this._handle || !this._handle.shutdown) 13. return this.destroy(); 14. // \u652f\u6301shutdown\u5219\u6267\u884c\u5173\u95ed\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03 15. var err = defaultTriggerAsyncIdScope( 16. this[async_id_symbol], shutdownSocket, this, afterShutdown 17. ); 18. // \u6267\u884cshutdown\u5931\u8d25\u5219\u76f4\u63a5\u9500\u6bc1 19. if (err) 20. return this.destroy(errnoException(err, 'shutdown')); 21. } 22. 23. // \u53d1\u9001\u5173\u95ed\u5199\u7aef\u7684\u8bf7\u6c42 24. function shutdownSocket(self, callback) { 25. var req = new ShutdownWrap(); 26. req.oncomplete = callback; 27. req.handle = self._handle; 28. return self._handle.shutdown(req); 29. } Shutdown\u51fd\u6570\u5728stream_base.cc\u4e2d\u5b9a\u4e49\uff0c\u6700\u7ec8\u8c03\u7528uv_shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u5728Libuv\u6d41\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u5199\u7aef\u540e\uff0c\u56de\u8c03\u51fd\u6570\u7684\u903b\u8f91\u3002 1. // \u5173\u95ed\u5199\u7aef\u6210\u529f\u540e\u7684\u56de\u8c03 2. function afterShutdown(status, handle, req) { 3. // handle\u5173\u8054\u7684socket 4. var self = handle.owner; 5. // \u5df2\u7ecf\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\u4e86\uff0c\u5426\u5219\u6267\u884c\u9500\u6bc1\u64cd\u4f5c 6. if (self.destroyed) 7. return; 8. // \u5199\u5173\u95ed\u6210\u529f\uff0c\u5e76\u4e14\u8bfb\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket\uff0c\u5426\u5219\u7b49\u5f85\u8bfb\u7ed3\u675f\u518d\u6267\u884c\u9500\u6bc1 9. if (self._readableState.ended) { 10. self.destroy(); 11. } else { 12. self.once('_socketEnd', self.destroy); 13. } 14. } 17.1.5 \u9500\u6bc1 \u00b6 \u5f53\u4e00\u4e2asocket\u4e0d\u53ef\u8bfb\u4e5f\u4e0d\u53ef\u5199\u7684\u65f6\u5019\u3001\u88ab\u5173\u95ed\u3001\u53d1\u751f\u9519\u8bef\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002\u9500\u6bc1\u4e00\u4e2a\u6d41\u5c31\u662f\u9500\u6bc1\u6d41\u7684\u8bfb\u7aef\u3001\u5199\u7aef\u3002\u7136\u540e\u6267\u884c\u6d41\u5b50\u7c7b\u7684_destory\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684_destroy\u51fd\u6570 1. // \u9500\u6bc1\u65f6\u6267\u884c\u7684\u94a9\u5b50\u51fd\u6570\uff0cexception\u4ee3\u8868\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u9500\u6bc1 2. Socket.prototype._destroy = function(exception, cb) { 3. this.connecting = false; 4. this.readable = this.writable = false; 5. // \u6e05\u9664\u5b9a\u65f6\u5668 6. for (var s = this; s !== null; s = s._parent) { 7. clearTimeout(s[kTimeout]); 8. } 9. 10. if (this._handle) { 11. // \u662f\u5426\u56e0\u4e3a\u51fa\u9519\u5bfc\u81f4\u9500\u6bc1\u6d41 12. var isException = exception ? true : false; 13. // \u5173\u95ed\u5e95\u5c42handle 14. this._handle.close(() => { 15. // close\u4e8b\u4ef6\u7684\u5165\u53c2\uff0c\u8868\u793a\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u5173\u95ed 16. this.emit('close', isException); 17. }); 18. this._handle.onread = noop; 19. this._handle = null; 20. this._sockname = null; 21. } 22. // \u6267\u884c\u56de\u8c03 23. cb(exception); 24. // socket\u6240\u5c5e\u7684server\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u65f6\u662fnull 25. if (this._server) { 26. // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 27. this._server._connections--; 28. /* 29. \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c 30. \u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 31. */ 32. if (this._server._emitCloseIfDrained) { 33. this._server._emitCloseIfDrained(); 34. } 35. } 36. }; _stream_writable.js\u4e2d\u7684destroy\u51fd\u6570\u53ea\u662f\u4fee\u6539\u8bfb\u5199\u6d41\u7684\u72b6\u6001\u548c\u6807\u8bb0\uff0c\u5b50\u7c7b\u9700\u8981\u5b9a\u4e49_destroy\u51fd\u6570\u9500\u6bc1\u76f8\u5173\u7684\u8d44\u6e90\uff0csocket\u901a\u8fc7\u8c03\u7528close\u5173\u95ed\u5e95\u5c42\u5173\u8054\u7684\u8d44\u6e90\uff0c\u5173\u95ed\u540e\u89e6\u53d1socket\u7684close\u4e8b\u4ef6\uff08\u56de\u8c03\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fboolean\u7c7b\u578b\uff0c\u8bf4\u660e\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4socket\u5173\u95ed\uff09\u3002\u6700\u540e\u5224\u65ad\u8be5socket\u662f\u5426\u6765\u81ea\u670d\u52a1\u5668\u521b\u5efa\u7684\uff0c\u662f\u7684\u8bdd\u8be5\u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u5982\u679c\u670d\u52a1\u5668\u6267\u884c\u4e86close\u5e76\u4e14\u5f53\u524d\u8fde\u63a5\u6570\u4e3a0\uff0c\u5219\u5173\u95ed\u670d\u52a1\u5668\u3002 17.2 TCP \u670d\u52a1\u5668 \u00b6 net\u6a21\u5757\u63d0\u4f9b\u4e86createServer\u51fd\u6570\u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668\u3002 1. function createServer(options, connectionListener) { 2. return new Server(options, connectionListener); 3. } 4. 5. function Server(options, connectionListener) { 6. EventEmitter.call(this); 7. // \u6ce8\u518c\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03 8. if (typeof options === 'function') { 9. connectionListener = options; 10. options = {}; 11. this.on('connection', connectionListener); 12. } else if (options == null || typeof options === 'object') { 13. options = options || {}; 14. if (typeof connectionListener === 'function') { 15. this.on('connection', connectionListener); 16. } 17. } else { 18. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 19. 'options', 20. 'Object', 21. options); 22. } 23. // \u670d\u52a1\u5668\u5efa\u7acb\u7684\u8fde\u63a5\u6570 24. this._connections = 0; 25. this._handle = null; 26. this._unref = false; 27. // \u670d\u52a1\u5668\u4e0b\u7684\u6240\u6709\u8fde\u63a5\u662f\u5426\u5141\u8bb8\u534a\u8fde\u63a5 28. this.allowHalfOpen = options.allowHalfOpen || false; 29. // \u6709\u8fde\u63a5\u65f6\u662f\u5426\u6ce8\u518c\u8bfb\u4e8b\u4ef6 30. this.pauseOnConnect = !!options.pauseOnConnect; 31. } createServer\u8fd4\u56de\u7684\u5c31\u662f\u4e00\u4e2a\u4e00\u822c\u7684JS\u5bf9\u8c61\uff0c\u63a5\u7740\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u7aef\u53e3\u3002\u770b\u4e00\u4e0blisten\u51fd\u6570\u7684\u903b\u8f91 1. Server.prototype.listen = function(...args) { 2. /* 3. \u5904\u7406\u5165\u53c2\uff0c\u6839\u636e\u6587\u6863\u6211\u4eec\u77e5\u9053listen\u53ef\u4ee5\u63a5\u6536\u597d\u51e0\u4e2a\u53c2\u6570\uff0c 4. \u5047\u8bbe\u6211\u4eec\u8fd9\u91cc\u662f\u53ea\u4f20\u4e86\u7aef\u53e3\u53f79297 5. */ 6. var normalized = normalizeArgs(args); 7. // normalized = [{port: 9297}, null]; 8. var options = normalized[0]; 9. var cb = normalized[1]; 10. // \u7b2c\u4e00\u6b21listen\u7684\u65f6\u5019\u4f1a\u521b\u5efa\uff0c\u5982\u679c\u975e\u7a7a\u8bf4\u660e\u5df2\u7ecflisten\u8fc7 11. if (this._handle) { 12. throw new errors.Error('ERR_SERVER_ALREADY_LISTEN'); 13. } 14. // listen\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 15. var hasCallback = (cb !== null); 16. if (hasCallback) { 17. // listen\u6210\u529f\u7684\u56de\u8c03 18. this.once('listening', cb); 19. } 20. 21. options = options._handle || options.handle || options; 22. // \u7b2c\u4e00\u79cd\u60c5\u51b5\uff0c\u4f20\u8fdb\u6765\u7684\u662f\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u800c\u4e0d\u662f\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668 23. if (options instanceof TCP) { 24. this._handle = options; 25. this[async_id_symbol] = this._handle.getAsyncId(); 26. listenIncluster(this, null, -1, -1, backlogFromArgs); 27. return this; 28. } 29. // \u7b2c\u4e8c\u79cd\uff0c\u4f20\u8fdb\u6765\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u5e26\u4e86fd 30. if (typeof options.fd === 'number' && options.fd >= 0) { 31. listenIncluster(this, 32. null, 33. null, 34. null, 35. backlogFromArgs, 36. options.fd); 37. return this; 38. } 39. // \u521b\u5efa\u4e00\u4e2atcp\u670d\u52a1\u5668 40. var backlog; 41. if (typeof options.port === 'number' || 42. typeof options.port === 'string') { 43. backlog = options.backlog || backlogFromArgs; 44. // \u7b2c\u4e09\u79cd \u542f\u52a8\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u4f20\u4e86host\u5219\u5148\u8fdb\u884cDNS\u89e3\u6790 45. if (options.host) { 46. lookupAndListen(this, 47. options.port | 0, 48. options.host, 49. backlog, 50. options.exclusive); 51. } else { 52. listenIncluster(this, 53. null, 54. options.port | 0, 55. 4, 56. backlog, 57. undefined, 58. options.exclusive); 59. } 60. return this; 61. } 62. }; \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u5206\u522b\u662f\u4f20\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u3001\u4f20\u4e86\u4e00\u4e2afd\u3001\u4f20\u4e86\u7aef\u53e3\uff08\u6216\u8005host\uff09\uff0c\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0c\u8fd9\u51e0\u79cd\u60c5\u51b5\u6700\u540e\u90fd\u662f\u8c03\u7528\u4e86listenIncluster\uff08lookupAndListen\u662f\u5148DNS\u89e3\u6790\u540e\u518d\u6267\u884clistenIncluster\uff09\uff0c\u53ea\u662f\u5165\u53c2\u4e0d\u4e00\u6837\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u770blistenIncluster\u3002 1. function listenIncluster(server, 2. address, 3. port, 4. addressType, 5. backlog, 6. fd, 7. exclusive) { 8. exclusive = !!exclusive; 9. if (cluster === null) cluster = require('cluster'); 10. if (cluster.isMaster || exclusive) { 11. server._listen2(address, port, addressType, backlog, fd); 12. return; 13. } 14. } \u56e0\u4e3a\u6211\u4eec\u662f\u5728\u4e3b\u8fdb\u7a0b\uff0c\u6240\u4ee5\u76f4\u63a5\u6267\u884c_listen2\uff0c\u5b50\u8fdb\u7a0b\u7684\u5728cluster\u6a21\u5757\u5206\u6790\u3002_listen\u5bf9\u5e94\u7684\u51fd\u6570\u662fsetupListenHandle 1. function setupListenHandle(address, port, addressType, backlog, fd) { 2. // \u6709handle\u5219\u4e0d\u9700\u8981\u521b\u5efa\u4e86\uff0c\u5426\u5219\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle 3. if (this._handle) { 4. 5. } else { 6. var rval = null; 7. // \u6ca1\u6709\u4f20fd\uff0c\u5219\u8bf4\u660e\u662f\u76d1\u542c\u7aef\u53e3\u548cIP 8. if (!address && typeof fd !== 'number') { 9. rval = createServerHandle('::', port, 6, fd); 10. /* 11. \u8fd4\u56denumber\u8bf4\u660ebind IPv6\u7248\u672c\u7684handle\u5931\u8d25\uff0c 12. \u56de\u9000\u5230v4\uff0c\u5426\u5219\u8bf4\u660e\u652f\u6301IPv6 13. */ 14. if (typeof rval === 'number') { 15. // \u8d4b\u503c\u4e3anull\uff0c\u624d\u80fd\u8d70\u4e0b\u9762\u7684createServerHandle 16. rval = null; 17. address = '0.0.0.0'; 18. addressType = 4; 19. } else { 20. address = '::'; 21. addressType = 6; 22. } 23. } 24. // \u521b\u5efa\u5931\u8d25\u5219\u7ee7\u7eed\u521b\u5efa 25. if (rval === null) 26. rval = createServerHandle(address, 27. port, 28. addressType, 29. fd); 30. // \u8fd8\u62a5\u9519\u5219\u8bf4\u660e\u521b\u5efa\u670d\u52a1\u5668\u5931\u8d25\uff0c\u62a5\u9519 31. if (typeof rval === 'number') { 32. var error = exceptionWithHostPort(rval, 33. 'listen', 34. address, 35. port); 36. process.nextTick(emitErrorNT, this, error); 37. return; 38. } 39. this._handle = rval; 40. } 41. 42. // \u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 43. this._handle.onconnection = onconnection; 44. this._handle.owner = this; 45. // \u6267\u884cC++\u5c42listen 46. var err = this._handle.listen(backlog || 511); 47. // \u51fa\u9519\u5219\u62a5\u9519 48. if (err) { 49. var ex = exceptionWithHostPort(err, 50. 'listen', 51. address, 52. port); 53. this._handle.close(); 54. this._handle = null; 55. nextTick(this[async_id_symbol], emitErrorNT, this, ex); 56. return; 57. } 58. // \u89e6\u53d1listen\u56de\u8c03 59. nextTick(this[async_id_symbol], emitListeningNT, this); 60. } \u4e3b\u8981\u662f\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u3002\u6211\u4eec\u5148\u770bcreateServerHandle 1. function createServerHandle(address, port, addressType, fd) { 2. var err = 0; 3. var handle; 4. 5. var isTCP = false; 6. // \u4f20\u4e86fd\u5219\u6839\u636efd\u521b\u5efa\u4e00\u4e2ahandle 7. if (typeof fd === 'number' && fd >= 0) { 8. try { 9. handle = createHandle(fd, true); 10. } catch (e) { 11. return UV_EINVAL; 12. } 13. // \u628afd\u5b58\u5230handle\u4e2d 14. handle.open(fd); 15. handle.readable = true; 16. handle.writable = true; 17. assert(!address && !port); 18. // \u7ba1\u9053 19. } else if (port === -1 && addressType === -1) { 20. // \u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 21. handle = new Pipe(PipeConstants.SERVER); 22. } else { 23. // \u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668 24. handle = new TCP(TCPConstants.SERVER); 25. isTCP = true; 26. } 27. /* 28. \u6709\u5730\u5740\u6216\u8005IP\u8bf4\u660e\u662f\u901a\u8fc7IP\u7aef\u53e3\u521b\u5efa\u7684TCP\u670d\u52a1\u5668\uff0c 29. \u9700\u8981\u8c03bind\u7ed1\u5b9a\u5730\u5740 30. */ 31. if (address || port || isTCP) { 32. // \u6ca1\u6709\u5730\u5740\uff0c\u5219\u4f18\u5148\u7ed1\u5b9aIPv6\u7248\u672c\u7684\u672c\u5730\u5730\u5740 33. if (!address) { 34. // Try binding to IPv6 first 35. err = handle.bind6('::', port); 36. // \u5931\u8d25\u5219\u7ed1\u5b9av4\u7684 37. if (err) { 38. handle.close(); 39. // Fallback to IPv4 40. return createServerHandle('0.0.0.0', port); 41. } 42. } else if (addressType === 6) { // IPv6\u6216v4 43. err = handle.bind6(address, port); 44. } else { 45. err = handle.bind(address, port); 46. } 47. } 48. 49. if (err) { 50. handle.close(); 51. return err; 52. } 53. 54. return handle; 55. } createServerHandle\u4e3b\u8981\u662f\u8c03\u7528createHandle\u521b\u5efa\u4e00\u4e2ahandle\u7136\u540e\u6267\u884cbind\u51fd\u6570\u3002\u521b\u5efahandle\u7684\u65b9\u5f0f\u6709\u51e0\u79cd\uff0c\u76f4\u63a5\u8c03\u7528C++\u5c42\u7684\u51fd\u6570\u6216\u8005\u901a\u8fc7fd\u521b\u5efa\u3002\u8c03\u7528createHandle\u53ef\u4ee5\u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle 1. // \u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u6216\u8005\u670d\u52a1\u5668 2. function createHandle(fd, is_server) { 3. // \u5224\u65adfd\u5bf9\u5e94\u7684\u7c7b\u578b 4. const type = TTYWrap.guessHandleType(fd); 5. // Unix\u57df 6. if (type === 'PIPE') { 7. return new Pipe( 8. is_server ? PipeConstants.SERVER : PipeConstants.SOCKET ); 9. } 10. // tcp 11. if (type === 'TCP') { 12. return new TCP( 13. is_server ? TCPConstants.SERVER : TCPConstants.SOCKET 14. ); 15. } 16. 17. throw new errors.TypeError('ERR_INVALID_FD_TYPE', type); 18. } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bbind\u51fd\u6570\u7684\u903b\u8f91\uff0c 1. int uv__tcp_bind(uv_tcp_t* tcp, 2. const struct sockaddr* addr, 3. unsigned int addrlen, 4. unsigned int flags) { 5. int err; 6. int on; 7. // \u5982\u679c\u6ca1\u6709socket\u5219\u521b\u5efa\u4e00\u4e2a\uff0c\u6709\u5224\u65ad\u662f\u5426\u8bbe\u7f6e\u4e86UV_HANDLE_BOUND\uff0c\u662f\u5219\u6267\u884cbind\uff0c\u5426\u5219\u4e0d\u6267\u884cbind 8. err = maybe_new_socket(tcp, addr->sa_family, 0); 9. if (err) 10. return err; 11. 12. on = 1; 13. // \u8bbe\u7f6e\u5728\u65ad\u5f00\u8fde\u63a5\u76842 msl\u5185\u53ef\u4ee5\u91cd\u7528\u7aef\u53e3\uff0c\u6240\u4ee5Node.js\u670d\u52a1\u5668\u53ef\u4ee5\u5feb\u901f\u91cd\u542f 14. if (setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))) 15. return UV__ERR(errno); 16. errno = 0; 17. // \u6267\u884cbind 18. if (bind(tcp->io_watcher.fd, addr, addrlen) && errno != EADDRINUSE) { 19. if (errno == EAFNOSUPPORT) 20. return UV_EINVAL; 21. return UV__ERR(errno); 22. } 23. // bind\u662f\u5426\u51fa\u9519 24. tcp->delayed_error = UV__ERR(errno); 25. // \u6253\u4e0a\u5df2\u7ecf\u6267\u884c\u4e86bind\u7684\u6807\u8bb0 26. tcp->flags |= UV_HANDLE_BOUND; 27. if (addr->sa_family == AF_INET6) 28. tcp->flags |= UV_HANDLE_IPV6; 29. 30. return 0; 31. } \u6267\u884c\u5b8cbind\u540e\uff0c\u4f1a\u7ee7\u7eed\u6267\u884clisten\uff0c\u6211\u4eec\u63a5\u7740\u770blisten\u51fd\u6570\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770btcp_wrap.cc\u7684Listen\u3002 1. void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) { 2. TCPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. int backlog = args[0]->Int32Value(); 7. int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_), 8. backlog, 9. OnConnection); 10. args.GetReturnValue().Set(err); 11. } C++\u5c42\u51e0\u4e4e\u662f\u900f\u4f20\u5230Libuv\uff0cLibuv\u7684\u5185\u5bb9\u6211\u4eec\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\uff0c\u5f53\u6709\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u5b8c\u6210\u65f6\uff0c\u4f1a\u6267\u884cOnConnection 1. template <typename WrapType, typename UVType> 2. void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle, int status) { 3. // TCPWrap 4. WrapType* wrap_data = static_cast<WrapType*>(handle->data); 5. Environment* env = wrap_data->env(); 6. HandleScope handle_scope(env->isolate()); 7. Context::Scope context_scope(env->context()); 8. Local<Value> argv[] = { 9. Integer::New(env->isolate(), status), 10. Undefined(env->isolate()) 11. }; 12. 13. if (status == 0) { 14. // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61,\u5fc5\u586bTCPWrap\u5bf9\u8c61 15. Local<Object> client_obj = WrapType::Instantiate(env,wrap_data,WrapType::SOCKET); 16. WrapType* wrap; 17. // \u89e3\u5305\u51fa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u5b58\u5230wrap 18. ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj); 19. uv_stream_t* client_handle = reinterpret_cast<uv_stream_t*>(&wrap->handle_); 20. // \u628a\u901a\u4fe1fd\u5b58\u50a8\u5230client_handle\u4e2d 21. if (uv_accept(handle, client_handle)) 22. return; 23. argv[1] = client_obj; 24. } 25. // \u56de\u8c03\u4e0a\u5c42\u7684onconnection\u51fd\u6570 26. wrap_data->MakeCallback(env->onconnection_string(), arraysize(argv), argv); 27. } \u5f53\u5efa\u7acb\u4e86\u65b0\u8fde\u63a5\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\u8868\u793a\uff0c\u540c\u6837\uff0c\u5728Node.js\u5c42\uff0c\u4e5f\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u6211\u4eec\u770bJS\u5c42\u56de\u8c03\u3002 1. // clientHandle\u4ee3\u8868\u4e00\u4e2a\u548c\u5ba2\u6237\u7aef\u5efa\u7acbTCP\u8fde\u63a5\u7684\u5b9e\u4f53 2. function onconnection(err, clientHandle) { 3. var handle = this; 4. var self = handle.owner; 5. // \u9519\u8bef\u5219\u89e6\u53d1\u9519\u8bef\u4e8b\u4ef6 6. if (err) { 7. self.emit('error', errnoException(err, 'accept')); 8. return; 9. } 10. // \u5efa\u7acb\u8fc7\u591a\uff0c\u5173\u6389 11. if (self.maxConnections && self._connections >= self.maxConnections) { 12. clientHandle.close(); 13. return; 14. } 15. //\u65b0\u5efa\u4e00\u4e2asocket\u7528\u4e8e\u901a\u4fe1 16. var socket = new Socket({ 17. handle: clientHandle, 18. allowHalfOpen: self.allowHalfOpen, 19. pauseOnCreate: self.pauseOnConnect 20. }); 21. socket.readable = socket.writable = true; 22. // \u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u52a0\u4e00 23. self._connections++; 24. socket.server = self; 25. socket._server = self; 26. // \u89e6\u53d1\u7528\u6237\u5c42\u8fde\u63a5\u4e8b\u4ef6 27. self.emit('connection', socket); 28. } \u5728JS\u5c42\u4e5f\u4f1a\u5c01\u88c5\u4e00\u4e2aSocket\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u5269\u4e0b\u7684\u4e8b\u60c5\u5c31\u662f\u5e94\u7528\u5c42\u5904\u7406\u4e86\u3002 17.3 keepalive \u00b6 \u672c\u8282\u5206\u6790\u57fa\u4e8eTCP\u5c42\u7684\u957f\u8fde\u63a5\u95ee\u9898\uff0c\u76f8\u6bd4\u5e94\u7528\u5c42HTTP\u534f\u8bae\u7684\u957f\u8fde\u63a5\uff0cTCP\u5c42\u63d0\u4f9b\u7684\u529f\u80fd\u66f4\u591a\u3002TCP\u5c42\u5b9a\u4e49\u4e86\u4e09\u4e2a\u914d\u7f6e\u3002 1 \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u65ad\u5f00\u8fde\u63a5\u3002 \u6211\u4eec\u770bLinux\u5185\u6838\u4ee3\u7801\u91cc\u63d0\u4f9b\u7684\u914d\u7f6e\u3002 1. // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5c31\u53d1\u8d77\u63a2\u6d4b\u5305 2. #define TCP_KEEPALIVE_TIME (120*60*HZ) /* two hours */ 3. // \u63a2\u6d4b\u6b21\u6570 4. #define TCP_KEEPALIVE_PROBES 9 /* Max of 9 keepalive probes*/ 5. // \u6bcf\u9694\u591a\u4e45\u63a2\u6d4b\u4e00\u6b21 6. #define TCP_KEEPALIVE_INTVL (75*HZ) \u8fd9\u662fLinux\u63d0\u4f9b\u7684\u9ed8\u8ba4\u503c\u3002\u4e0b\u9762\u518d\u770b\u770b\u9608\u503c 1. #define MAX_TCP_KEEPIDLE 32767 2. #define MAX_TCP_KEEPINTVL 32767 3. #define MAX_TCP_KEEPCNT 127 \u8fd9\u4e09\u4e2a\u914d\u7f6e\u548c\u4e0a\u9762\u4e09\u4e2a\u4e00\u4e00\u5bf9\u5e94\u3002\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u9608\u503c\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dkeep-alive\u7684\u4f7f\u7528\u3002 socket.setKeepAlive([enable][, initialDelay]) enable\uff1a\u662f\u5426\u5f00\u542fkeep-alive\uff0cLinux\u4e0b\u9ed8\u8ba4\u662f\u4e0d\u5f00\u542f\u7684\u3002 initialDelay\uff1a\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5c31\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 \u63a5\u7740\u6211\u4eec\u770b\u770b\u8fd9\u4e2aAPI\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002 1. int uv__tcp_keepalive(int fd, int on, unsigned int delay) { 2. if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on))) 3. return UV__ERR(errno); 4. // Linux\u5b9a\u4e49\u4e86\u8fd9\u4e2a\u5b8f 5. #ifdef TCP_KEEPIDLE 6. /* 7. on\u662f1\u624d\u4f1a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5148\u5f00\u542fkeep-alive\uff0c\u5e76\u4e14\u8bbe\u7f6edelay\uff0c 8. \u7136\u540e\u5173\u95edkeep-alive\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u4f1a\u4fee\u6539\u4e4b\u524d\u4fee\u6539\u8fc7\u7684\u914d\u7f6e\u7684\u3002 9. \u56e0\u4e3a\u8fd9\u4e2a\u914d\u7f6e\u5728keep-alive\u5173\u95ed\u7684\u65f6\u5019\u662f\u6ca1\u7528\u7684 10. */ 11. if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay))) 12. return UV__ERR(errno); 13. #endif 14. 15. return 0; 16. } \u6211\u4eec\u770b\u5230Libuv\u8c03\u7528\u4e86\u540c\u4e00\u4e2a\u7cfb\u7edf\u51fd\u6570\u4e24\u6b21\u3002\u6211\u4eec\u5206\u522b\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u610f\u4e49\u3002\u53c2\u8003Linux2.6.13.1\u7684\u4ee3\u7801\u3002 1. // net\\socket.c 2. asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen) 3. { 4. int err; 5. struct socket *sock; 6. 7. if ((sock = sockfd_lookup(fd, &err))!=NULL) 8. { 9. ... 10. if (level == SOL_SOCKET) 11. err=sock_setsockopt(sock,level,optname,optval,optlen); 12. else 13. err=sock->ops->setsockopt(sock, level, optname, optval, optlen); 14. sockfd_put(sock); 15. } 16. return err; 17. } \u5f53level\u662fSOL_SOCKET\u4ee3\u8868\u4fee\u6539\u7684socket\u5c42\u9762\u7684\u914d\u7f6e\u3002IPPROTO_TCP\u662f\u4fee\u6539TCP\u5c42\u7684\u914d\u7f6e\uff08\u8be5\u7248\u672c\u4ee3\u7801\u91cc\u662fSOL_TCP\uff09\u3002\u6211\u4eec\u5148\u770bSOL_SOCKET\u5c42\u9762\u7684\u3002 1. // net\\socket.c -> net\\core\\sock.c -> net\\ipv4\\tcp_timer.c 2. int sock_setsockopt(struct socket *sock, int level, int optname, 3. char __user *optval, int optlen) { 4. ... 5. case SO_KEEPALIVE: 6. 7. if (sk->sk_protocol == IPPROTO_TCP) 8. tcp_set_keepalive(sk, valbool); 9. // \u8bbe\u7f6eSOCK_KEEPOPEN\u6807\u8bb0\u4f4d1 10. sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool); 11. break; 12. ... 13. } sock_setcsockopt\u9996\u5148\u8c03\u7528\u4e86tcp_set_keepalive\u51fd\u6570\uff0c\u7136\u540e\u7ed9\u5bf9\u5e94socket\u7684SOCK_KEEPOPEN\u5b57\u6bb5\u6253\u4e0a\u6807\u8bb0\uff080\u6216\u80051\u8868\u793a\u5f00\u542f\u8fd8\u662f\u5173\u95ed\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770btcp_set_keepalive 1. void tcp_set_keepalive(struct sock *sk, int val) 2. { 3. if ((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)) 4. return; 5. /* 6. \u5982\u679cval\u662f1\u5e76\u4e14\u4e4b\u524d\u662f0\uff08\u6ca1\u5f00\u542f\uff09\u90a3\u4e48\u5c31\u5f00\u542f\u8ba1\u65f6\uff0c\u8d85\u65f6\u540e\u53d1\u9001\u63a2\u6d4b\u5305\uff0c 7. \u5982\u679c\u4e4b\u524d\u662f1\uff0cval\u53c8\u662f1\uff0c\u5219\u5ffd\u7565\uff0c\u6240\u4ee5\u91cd\u590d\u8bbe\u7f6e\u662f\u65e0\u5bb3\u7684 8. */ 9. if (val && !sock_flag(sk, SOCK_KEEPOPEN)) 10. tcp_reset_keepalive_timer(sk, keepalive_time_when(tcp_sk(sk))); 11. else if (!val) 12. // val\u662f0\u8868\u793a\u5173\u95ed\uff0c\u5219\u6e05\u9664\u5b9a\u65f6\u5668\uff0c\u5c31\u4e0d\u53d1\u9001\u63a2\u6d4b\u5305\u4e86 13. tcp_delete_keepalive_timer(sk); 14. } \u6211\u4eec\u770b\u770b\u8d85\u65f6\u540e\u7684\u903b\u8f91\u3002 1. // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u7b2c\u4e00\u4e2a\u63a2\u6d4b\u5305 2. static inline int keepalive_time_when(const struct tcp_sock *tp) 3. { 4. // \u7528\u6237\u8bbe\u7f6e\u7684\uff08TCP_KEEPIDLE\uff09\u548c\u7cfb\u7edf\u9ed8\u8ba4\u7684 5. return tp->keepalive_time ? : sysctl_tcp_keepalive_time; 6. } 7. // \u9694\u591a\u4e45\u53d1\u9001\u4e00\u4e2a\u63a2\u6d4b\u5305 8. static inline int keepalive_intvl_when(const struct tcp_sock *tp) 9. { 10. return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl; 11. } 12. 13. static void tcp_keepalive_timer (unsigned long data) 14. { 15. ... 16. // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 17. elapsed = tcp_time_stamp - tp->rcv_tstamp; 18. // \u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c 19. if (elapsed >= keepalive_time_when(tp)) { 20. // \u53d1\u9001\u7684\u63a2\u6d4b\u5305\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u53d1\u9001\u91cd\u7f6e\u5305 21. if ((!tp->keepalive_probes && tp->probes_out >= sysctl_tcp_keepalive_probes) || 22. (tp->keepalive_probes && tp->probes_out >= tp->keepalive_probes)) { 23. tcp_send_active_reset(sk, GFP_ATOMIC); 24. tcp_write_err(sk); 25. goto out; 26. } 27. // \u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u5e76\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u63a2\u6d4b\u5305\u7684\u53d1\u9001\u65f6\u95f4\uff08\u8d85\u65f6\u65f6\u95f4\uff09 28. tcp_write_wakeup(sk) 29. tp->probes_out++; 30. elapsed = keepalive_intvl_when(tp); 31. } else { 32. /* 33. \u8fd8\u6ca1\u5230\u671f\u5219\u91cd\u65b0\u8ba1\u7b97\u5230\u671f\u65f6\u95f4\uff0c\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\u5e94\u8be5\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\uff0c 34. \u6240\u4ee5\u6267\u884c\u8be5\u51fd\u6570\u8bf4\u660e\u7684\u786e\u662f\u8d85\u65f6\u4e86\uff0c\u6309\u7406\u8bf4\u4e0d\u4f1a\u8fdb\u5165\u8fd9\u91cc\u3002 35. */ 36. elapsed = keepalive_time_when(tp) - elapsed; 37. } 38. 39. TCP_CHECK_TIMER(sk); 40. sk_stream_mem_reclaim(sk); 41. 42. resched: 43. // \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668 44. tcp_reset_keepalive_timer (sk, elapsed); 45. ... \u6240\u4ee5\u5728SOL_SOCKET\u5c42\u9762\u662f\u8bbe\u7f6e\u662f\u5426\u5f00\u542fkeep-alive\u673a\u5236\u3002\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5c31\u4f1a\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0cSOL_SOCKET\u53ea\u662f\u8bbe\u7f6e\u4e86\u662f\u5426\u5f00\u542f\u63a2\u6d4b\u673a\u5236\uff0c\u5e76\u6ca1\u6709\u5b9a\u4e49\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u503c\uff0c\u6240\u4ee5\u7cfb\u7edf\u4f1a\u4f7f\u7528\u9ed8\u8ba4\u503c\u8fdb\u884c\u5fc3\u8df3\u673a\u5236\uff08\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u5f00\u542fkeep-alive\u7684\u8bdd\uff09\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48Libuv\u8c03\u4e86\u4e24\u6b21setsockopt\u51fd\u6570\u3002\u7b2c\u4e8c\u6b21\u7684\u8c03\u7528\u8bbe\u7f6e\u4e86\u5c31\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u4e2d\u7684\u7b2c\u4e00\u4e2a\uff08\u540e\u9762\u4e24\u4e2a\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\uff0c\u4e0d\u8fc7Libuv\u6ca1\u6709\u63d0\u4f9b\u63a5\u53e3\uff0c\u53ef\u4ee5\u81ea\u5df1\u8c03\u7528setsockopt\u8bbe\u7f6e\uff09\u3002\u90a3\u4e48\u6211\u4eec\u6765\u770b\u4e00\u4e0bLibuv\u7684\u7b2c\u4e8c\u6b21\u8c03\u7528setsockopt\u662f\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770bTCP\u5c42\u7684\u5b9e\u73b0\u3002 1. // net\\ipv4\\tcp.c 2. int tcp_setsockopt(struct sock *sk, int level, int optname, char __user *optval,int optlen) 3. { 4. ... 5. case TCP_KEEPIDLE: 6. // \u4fee\u6539\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\u7684\u914d\u7f6e 7. tp->keepalive_time = val * HZ; 8. // \u662f\u5426\u5f00\u542f\u4e86keep-alive\u673a\u5236 9. if (sock_flag(sk, SOCK_KEEPOPEN) && 10. !((1 << sk->sk_state) & 11. (TCPF_CLOSE | TCPF_LISTEN))) { 12. // \u5f53\u524d\u65f6\u95f4\u51cf\u53bb\u4e0a\u6b21\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5373\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 13. __u32 elapsed = tcp_time_stamp - tp->rcv_tstamp; 14. // \u7b97\u51fa\u8fd8\u8981\u591a\u4e45\u53ef\u4ee5\u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u8fd8\u662f\u53ef\u4ee5\u76f4\u63a5\u53d1\uff08\u5df2\u7ecf\u89e6\u53d1\u4e86\uff09 15. if (tp->keepalive_time > elapsed) 16. elapsed = tp->keepalive_time - elapsed; 17. else 18. elapsed = 0; 19. // \u8bbe\u7f6e\u5b9a\u65f6\u5668 20. tcp_reset_keepalive_timer(sk, elapsed); 21. } 22. ... 23. } \u8be5\u51fd\u6570\u9996\u5148\u4fee\u6539\u914d\u7f6e\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u5f00\u542f\u4e86keep-alive\u7684\u673a\u5236\uff0c\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5fc3\u8df3\u673a\u5236\u5e76\u4e0d\u662f\u4ec0\u4e48\u65f6\u5019\u90fd\u597d\u4f7f\uff0c\u5982\u679c\u4e24\u7aef\u90fd\u6ca1\u6709\u6570\u636e\u6765\u5f80\u65f6\uff0c\u5fc3\u8df3\u673a\u5236\u80fd\u5f88\u597d\u5730\u5de5\u4f5c\uff0c\u4f46\u662f\u4e00\u65e6\u672c\u7aef\u6709\u6570\u636e\u53d1\u9001\u7684\u65f6\u5019\uff0c\u5b83\u5c31\u4f1a\u6291\u5236\u5fc3\u8df3\u673a\u5236\u3002\u6211\u4eec\u770b\u4e00\u4e0bLinux\u5185\u68385.7.7\u7684\u4e00\u6bb5\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-3\u6240\u793a\u3002 \u56fe17-3 \u4e0a\u9762\u8fd9\u4e00\u6bb5\u662f\u5fc3\u8df3\u673a\u5236\u4e2d\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u6267\u884c\u7684\u4e00\u6bb5\u903b\u8f91\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8\u7ea2\u8272\u6846\u91cc\u7684\u4ee3\u7801\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5fc3\u8df3\u5b9a\u65f6\u5668\u8d85\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u53d1\u9001\u4e00\u4e2a\u65b0\u7684\u5fc3\u8df3\u5305\uff0c\u4f46\u662f\u5982\u679c\u53d1\u9001\u961f\u5217\u91cc\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u53d1\u9001\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4f18\u5148\u53d1\u9001\u3002\u6216\u8005\u53d1\u9001\u51fa\u53bb\u7684\u6ca1\u6709ack\uff0c\u4e5f\u4f1a\u4f18\u5148\u89e6\u53d1\u91cd\u4f20\u3002\u8fd9\u65f6\u5019\u5fc3\u8df3\u673a\u5236\u5c31\u5931\u6548\u4e86\u3002\u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0cLinux\u63d0\u4f9b\u4e86\u53e6\u4e00\u4e2a\u5c5e\u6027TCP_USER_TIMEOUT\u3002\u8fd9\u4e2a\u5c5e\u6027\u7684\u529f\u80fd\u662f\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u8ba4\u4e3a\u8fd9\u4e2a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-4\u6240\u793a\u3002 \u56fe17-4 \u4e0b\u9762\u662f\u8bbe\u7f6e\u9608\u503c\u7684\u4ee3\u7801\uff0c\u5982\u56fe17-5\u6240\u793a\u3002 \u56fe17-5 \u8fd9\u662f\u8d85\u65f6\u65f6\u5224\u65ad\u662f\u5426\u65ad\u5f00\u8fde\u63a5\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u5230\u6709\u4e24\u4e2a\u60c5\u51b5\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002 1 \u8bbe\u7f6e\u4e86TCP_USER_TIMEOUT\u65f6\uff0c\u5982\u679c\u53d1\u9001\u5305\u6570\u91cf\u5927\u4e8e1\u5e76\u4e14\u5f53\u524d\u65f6\u95f4\u8ddd\u79bb\u4e0a\u6b21\u6536\u5230\u5305\u7684\u65f6\u95f4\u95f4\u9694\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\u3002 2 \u6ca1\u6709\u8bbe\u7f6eTCP_USER_TIMEOUT\uff0c\u4f46\u662f\u5fc3\u8df3\u5305\u53d1\u9001\u6570\u91cf\u8fbe\u5230\u9608\u503c\u3002 \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u540c\u65f6\u8bbe\u7f6e\u8fd9\u4e24\u4e2a\u5c5e\u6027\u3002\u4fdd\u8bc1\u5fc3\u8df3\u673a\u5236\u53ef\u4ee5\u6b63\u5e38\u8fd0\u884c\uff0c Node.js\u7684keep-alive\u6709\u4e24\u4e2a\u5c42\u9762\u7684\u5185\u5bb9\uff0c\u7b2c\u4e00\u4e2a\u662f\u662f\u5426\u5f00\u542f\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5f00\u542f\u540e\uff0c\u4f7f\u7528\u7684\u914d\u7f6e\u3002Node.js\u7684setKeepAlive\u5c31\u662f\u505a\u4e86\u8fd9\u4e24\u4ef6\u4e8b\u60c5\u3002\u53ea\u4e0d\u8fc7\u5b83\u53ea\u652f\u6301\u4fee\u6539\u4e00\u4e2a\u914d\u7f6e\u3002Node.js\u53ea\u652f\u6301TCP_KEEPALIVE_TIME\u3002\u53e6\u5916\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u4ee3\u7801\u5224\u65ad\u914d\u7f6e\u7684\u503c\u3002 1. include <stdio.h> 2. #include <netinet/tcp.h> 3. 4. int main(int argc, const char *argv[]) 5. { 6. int sockfd; 7. int optval; 8. socklen_t optlen = sizeof(optval); 9. 10. sockfd = socket(AF_INET, SOCK_STREAM, 0); 11. getsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &optval, &optlen); 12. printf(\"\u9ed8\u8ba4\u662f\u5426\u5f00\u542fkeep-alive\uff1a%d \\n\", optval); 13. 14. getsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &optval, &optlen); 15. printf(\"\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\uff1a%d seconds \\n\", optval); 16. 17. getsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &optval, &optlen); 18. printf(\"\u591a\u4e45\u53d1\u9001\u4e00\u6b21\u63a2\u6d4b\u5305\uff1a%d seconds \\n\", optval); 19. 20. getsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &optval, &optlen); 21. printf(\"\u6700\u591a\u53d1\u9001\u51e0\u4e2a\u63a2\u6d4b\u5305\u5c31\u65ad\u5f00\u8fde\u63a5\uff1a%d \\n\", optval); 22. 23. return 0; 24. } \u8f93\u51fa\u5982\u56fe17-6\u6240\u793a\u3002 \u56fe17-6 \u518d\u770b\u4e00\u4e0bwireshark\u4e0b\u7684keepalive\u5305\uff0c\u5982\u56fe17-7\u6240\u793a\u3002 \u56fe17-7 17.4 allowHalfOpen \u00b6 \u6211\u4eec\u77e5\u9053TCP\u8fde\u63a5\u5728\u6b63\u5e38\u65ad\u5f00\u7684\u65f6\u5019\uff0c\u4f1a\u8d70\u56db\u6b21\u6325\u624b\u7684\u6d41\u7a0b\uff0c\u5728Node.js\u4e2d\uff0c\u5f53\u6536\u5230\u5bf9\u7aef\u53d1\u9001\u8fc7\u6765\u7684fin\u5305\u65f6\uff0c\u56de\u590dack\u540e\uff0c\u9ed8\u8ba4\u4f1a\u53d1\u9001fin\u5305\u7ed9\u5bf9\u7aef\uff0c\u4ee5\u5b8c\u6210\u56db\u6b21\u6325\u624b\u3002\u4f46\u662f\u6211\u4eec\u53ef\u80fd\u4f1a\u6709\u8fd9\u6837\u7684\u573a\u666f\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u53d1\u9001fin\u5305\u8868\u793a\u81ea\u5df1\u6ca1\u6709\u6570\u636e\u53ef\u5199\u4e86\uff0c\u53ea\u9700\u8981\u7b49\u5f85\u670d\u52a1\u5668\u8fd4\u56de\u3002\u8fd9\u65f6\u5019\u5982\u679c\u670d\u52a1\u5668\u5728\u6536\u5230fin\u5305\u540e\uff0c\u4e5f\u56de\u590dfin\uff0c\u90a3\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u5728Node.js\u4e2d\u63d0\u4f9b\u4e86allowHalfOpen\u9009\u9879\u652f\u6301\u534a\u5173\u95ed\uff0c\u6211\u4eec\u77e5\u9053TCP\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4e24\u7aef\u53ef\u4ee5\u540c\u65f6\u4e92\u76f8\u53d1\u9001\u6570\u636e\uff0callowHalfOpen\u76f8\u5f53\u4e8e\u628a\u4e00\u7aef\u5173\u95ed\u4e86\uff0c\u5141\u8bb8\u6570\u636e\u5355\u5411\u4f20\u8f93\u3002\u6211\u4eec\u770b\u4e00\u4e0ballowHalfOpen\u7684\u5b9e\u73b0\u3002allowHalfOpen\u662f\u5c5e\u4e8eSocket\u7684\u9009\u9879\u3002\u6211\u4eec\u4eceNode.js\u6536\u5230\u4e00\u4e2afin\u5305\u5f00\u59cb\u5206\u6790\u6574\u4e2a\u6d41\u7a0b\u3002\u9996\u5148\u5728\u65b0\u5efaSocket\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u6ce8\u518c\u5bf9\u5e94\u4e8b\u4ef6\u3002 socket.on('_socketEnd', onSocketEnd); \u5f53\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230fin\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1socket\u7684\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6267\u884cNode.js\u7684\u8bfb\u56de\u8c03\u3002Node.js\u6267\u884c\u8bfb\u53d6\u7684\u65f6\u5019\u53d1\u73b0\uff0c\u8bfb\u53d6\u5df2\u7ed3\u675f\uff0c\u56e0\u4e3a\u5bf9\u7aef\u53d1\u9001\u4e86fin\u5305\u3002\u8fd9\u65f6\u5019\u4f1a\u89e6\u53d1_socketEnd\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\u3002 1. function onSocketEnd() { 2. // ... 3. if (!this.allowHalfOpen) { 4. this.write = writeAfterFIN; 5. this.destroySoon(); 6. } 7. } allowHalfOpen\u9ed8\u8ba4\u662ffalse\u3002onSocketEnd\u9996\u5148\u8bbe\u7f6ewrite\u51fd\u6570\u4e3awriteAfterFIN\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u5982\u679c\u6211\u4eec\u5199\u4f1a\u600e\u6837\u3002\u6211\u4eec\u4f1a\u6536\u5230\u4e00\u4e2a\u9519\u8bef\u3002 1. function writeAfterFIN(chunk, encoding, cb) { 2. var er = new Error('This socket has been ended by the other party'); 3. er.code = 'EPIPE'; 4. this.emit('error', er); 5. if (typeof cb === 'function') { 6. nextTick(this[async_id_symbol], cb, er); 7. } 8. } \u8bbe\u7f6e\u5b8cwrite\u540e\uff0c\u63a5\u7740Node.js\u4f1a\u53d1\u9001fin\u5305\u3002 1. Socket.prototype.destroySoon = function() { 2. // \u5173\u95ed\u5199\u6d41 3. if (this.writable) 4. this.end(); 5. // \u5173\u95ed\u6210\u529f\u540e\u9500\u6bc1\u6d41 6. if (this._writableState.finished) 7. this.destroy(); 8. else 9. this.once('finish', this.destroy); 10. }; \u9996\u5148\u5173\u95ed\u5199\u6d41\uff0c\u7136\u540e\u6267\u884cdestroy\u51fd\u6570\u9500\u6bc1\u6d41\u3002\u5728destroy\u4e2d\u4f1a\u6267\u884c_destroy\u3002_destroy\u4f1a\u6267\u884c\u5177\u4f53\u7684\u5173\u95ed\u64cd\u4f5c\uff0c\u5373\u53d1\u9001fin\u5305\u3002 1. this._handle.close(() => { 2. this.emit('close', isException); 3. }); \u6211\u4eec\u770b\u5230C++\u5c42\u7684close\u3002 1. void HandleWrap::Close(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. HandleWrap* wrap; 5. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 6. // \u5173\u95edhandle 7. uv_close(wrap->handle_, OnClose); 8. wrap->state_ = kClosing; 9. // \u6267\u884c\u56de\u8c03\uff0c\u89e6\u53d1close\u4e8b\u4ef6 10. if (args[0]->IsFunction()) { 11. wrap->object()->Set(env->onclose_string(), args[0]); 12. wrap->state_ = kClosingWithCallback; 13. } 14. } \u6211\u4eec\u7ee7\u7eed\u5f80Libuv\u770b\u3002 1. void uv_close(uv_handle_t* handle, uv_close_cb cb) { 2. uv_loop_t* loop = handle->loop; 3. 4. handle->close_cb = cb; 5. switch (handle->type) { 6. case UV_TCP: 7. uv_tcp_close(loop, (uv_tcp_t*)handle); 8. return; 9. 10. // ... 11. } 12. } uv_tcp_close\u4f1a\u5bf9close\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770btcp close\u7684\u5927\u81f4\u5b9e\u73b0\u3002 1. static void tcp_close(struct sock *sk, int timeout) 2. { 3. 4. // \u76d1\u542c\u578b\u7684socket\u8981\u5173\u95ed\u5efa\u7acb\u7684\u8fde\u63a5 5. if(sk->state == TCP_LISTEN) 6. { 7. /* Special case */ 8. tcp_set_state(sk, TCP_CLOSE); 9. // \u5173\u95ed\u5df2\u7ecf\u5efa\u7acb\u7684\u8fde\u63a5 10. tcp_close_pending(sk); 11. release_sock(sk); 12. return; 13. } 14. 15. struct sk_buff *skb; 16. // \u9500\u6bc1\u63a5\u6536\u961f\u5217\u4e2d\u672a\u5904\u7406\u7684\u6570\u636e 17. while((skb=skb_dequeue(&sk->receive_queue))!=NULL) 18. kfree_skb(skb, FREE_READ); 19. // \u53d1\u9001fin\u5305 20. tcp_send_fin(sk); 21. release_sock(sk); 22. } \u4ee5\u4e0a\u662fNode.js\u4e2dsocket\u6536\u5230fin\u5305\u65f6\u7684\u9ed8\u8ba4\u5904\u7406\u6d41\u7a0b\uff0c\u5f53\u6211\u4eec\u8bbe\u7f6eallowHalfOpen\u4e3atrue\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u9ed8\u8ba4\u7684\u884c\u4e3a\uff0c\u5141\u8bb8\u534a\u5173\u95ed\u72b6\u6001\u7684\u8fde\u63a5\u3002 17.5 server close \u00b6 \u8c03\u7528close\u53ef\u4ee5\u5173\u95ed\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6587\u6863\u5173\u4e8eclose\u51fd\u6570\u7684\u89e3\u91ca Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. The optional callback will be called once the 'close' event occurs. Unlike that event, it will be called with an Error as its only argument if the server was not open when it was closed. \u5728Node.js\u4e2d \uff0c\u5f53\u6211\u4eec\u4f7f\u7528close\u5173\u95ed\u4e00\u4e2aserver\u65f6\uff0cserver\u4f1a\u7b49\u6240\u6709\u7684\u8fde\u63a5\u5173\u95ed\u540e\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u6211\u4eec\u770bclose\u7684\u5b9e\u73b0\uff0c\u4e00\u63a2\u7a76\u7adf\u3002 1. Server.prototype.close = function(cb) { 2. // \u89e6\u53d1\u56de\u8c03 3. if (typeof cb === 'function') { 4. if (!this._handle) { 5. this.once('close', function close() { 6. cb(new errors.Error('ERR_SERVER_NOT_RUNNING')); 7. }); 8. } else { 9. this.once('close', cb); 10. } 11. } 12. // \u5173\u95ed\u5e95\u5c42\u8d44\u6e90 13. if (this._handle) { 14. this._handle.close(); 15. this._handle = null; 16. } 17. // \u5224\u65ad\u662f\u5426\u9700\u8981\u7acb\u523b\u89e6\u53d1close\u4e8b\u4ef6 18. this._emitCloseIfDrained(); 19. return this; 20. }; close\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u76d1\u542cclose\u4e8b\u4ef6\uff0c\u7136\u540e\u5173\u95edserver\u5bf9\u5e94\u7684handle\uff0c\u6240\u4ee5server\u4e0d\u4f1a\u518d\u63a5\u6536\u65b0\u7684\u8bf7\u6c42\u4e86\u3002\u6700\u540e\u8c03\u7528_emitCloseIfDrained\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u662f\u5e72\u561b\u7684\u3002 1. Server.prototype._emitCloseIfDrained = function() { 2. // \u8fd8\u6709\u8fde\u63a5\u6216\u8005handle\u975e\u7a7a\u8bf4\u660ehandle\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u5148\u4e0d\u89e6\u53d1close\u4e8b\u4ef6 3. if (this._handle || this._connections) { 4. return; 5. } 6. // \u89e6\u53d1close\u4e8b\u4ef6 7. const asyncId = this._handle ? this[async_id_symbol] : null; 8. nextTick(asyncId, emitCloseNT, this); 9. }; 10. 11. 12. function emitCloseNT(self) { 13. self.emit('close'); 14. } _emitCloseIfDrained\u4e2d\u6709\u4e00\u4e2a\u62e6\u622a\u7684\u5224\u65ad\uff0chandle\u975e\u7a7a\u6216\u8005\u8fde\u63a5\u6570\u975e0\u3002\u7531\u4e4b\u524d\u7684\u4ee3\u7801\u6211\u4eec\u5df2\u7ecf\u77e5\u9053handle\u662fnull\uff0c\u4f46\u662f\u5982\u679c\u8fd9\u65f6\u5019\u8fde\u63a5\u6570\u975e0\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u90a3\u4ec0\u4e48\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u5462\uff1f\u5728socket\u7684_destroy\u51fd\u6570\u4e2d\u6211\u4eec\u627e\u5230\u4fee\u6539\u8fde\u63a5\u6570\u7684\u903b\u8f91\u3002 1. Socket.prototype._destroy = function(exception, cb) { 2. ... 3. // socket\u6240\u5c5e\u7684server 4. if (this._server) { 5. // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 6. this._server._connections--; 7. // \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c\u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 8. if (this._server._emitCloseIfDrained) { 9. this._server._emitCloseIfDrained(); 10. } 11. } 12. }; \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u4e2a\u8fde\u63a5\u5173\u95ed\u7684\u65f6\u5019\uff0c\u90fd\u4f1a\u5bfc\u81f4\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u76f4\u5230\u4e3a0\u7684\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u5047\u8bbe\u6211\u4eec\u542f\u52a8\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u63a5\u6536\u5230\u4e86\u4e00\u4e9b\u5ba2\u6237\u7aef\u7684\u8bf7\u6c42\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u60f3\u4fee\u6539\u4e00\u4e2a\u4ee3\u7801\u53d1\u5e03\uff0c\u9700\u8981\u91cd\u542f\u670d\u52a1\u5668\uff0c\u600e\u4e48\u529e\uff1f\u5047\u8bbe\u6211\u4eec\u6709\u4ee5\u4e0b\u4ee3\u7801\u3002 server.js 1. const net = require('net'); 2. const server = net.createServer().listen(80); client.js 1. const net = require('net'); 2. net.connect({port:80}) \u5982\u679c\u6211\u4eec\u76f4\u63a5\u6740\u6b7b\u8fdb\u7a0b\uff0c\u90a3\u4e48\u5b58\u91cf\u7684\u8bf7\u6c42\u5c31\u4f1a\u65e0\u6cd5\u6b63\u5e38\u88ab\u5904\u7406\u3002\u8fd9\u4f1a\u5f71\u54cd\u6211\u4eec\u7684\u670d\u52a1\u8d28\u91cf\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u5982\u4f55\u5728\u91cd\u542f\u65f6\u4f18\u96c5\u5730\u9000\u51fa\uff0c\u6240\u8c13\u4f18\u96c5\uff0c\u5373\u8ba9Node.js\u8fdb\u7a0b\u5904\u7406\u5b8c\u5b58\u91cf\u8bf7\u6c42\u540e\u518d\u9000\u51fa\u3002Server\u7684close\u7684\u5b9e\u73b0\u7ed9\u4e86\u6211\u4eec\u4e00\u4e9b\u601d\u8def\u3002\u6211\u4eec\u53ef\u4ee5\u76d1\u542cserver\u7684close\u4e8b\u4ef6\uff0c\u7b49\u5230\u89e6\u53d1close\u4e8b\u4ef6\u540e\u624d\u9000\u51fa\u8fdb\u7a0b\u3002 1. const net = require('net'); 2. const server = net.createServer().listen(80); 3. server.on('close', () => { 4. process.exit(); 5. }); 6. // \u9632\u6b62\u8fdb\u7a0b\u63d0\u524d\u6302\u6389 7. process.on('uncaughtException', () => { 8. 9. }); 10. process.on('SIGINT', function() { 11. server.close(); 12. }) \u6211\u4eec\u9996\u5148\u76d1\u542cSIGINT\u4fe1\u53f7\uff0c\u5f53\u6211\u4eec\u4f7f\u7528SIGINT\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b\u65f6\uff0c\u9996\u5148\u8c03\u7528server.close\uff0c\u7b49\u5230\u6240\u6709\u7684\u8fde\u63a5\u65ad\u5f00\uff0c\u89e6\u53d1close\u65f6\u5019\u65f6\uff0c\u518d\u9000\u51fa\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u5f00\u542f\u670d\u52a1\u5668\uff0c\u7136\u540e\u5f00\u542f\u4e24\u4e2a\u5ba2\u6237\u7aef\u3002\u63a5\u7740\u6309\u4e0bctrl+c\uff0c\u6211\u4eec\u53d1\u73b0\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u4e0d\u4f1a\u9000\u51fa\uff0c\u7136\u540e\u6211\u4eec\u5173\u95ed\u4e24\u4e2a\u5ba2\u6237\u7aef\uff0c\u8fd9\u65f6\u5019server\u5c31\u4f1a\u4f18\u96c5\u5730\u9000\u51fa\u3002","title":"17-TCP"},{"location":"chapter17-TCP/#171-tcp","text":"","title":"17.1 TCP\u5ba2\u6237\u7aef"},{"location":"chapter17-TCP/#1711","text":"net.connect\u662fNode.js\u4e2d\u53d1\u8d77TCP\u8fde\u63a5\u7684API\u3002\u672c\u8d28\u4e0a\u662f\u5bf9\u5e95\u5c42TCP connect\u51fd\u6570\u7684\u5c01\u88c5\u3002connect\u8fd4\u56de\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684Socket\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bconnect\u51fd\u6570\u7684\u5165\u53e3\u5b9a\u4e49\u3002 1. function connect(...args) { 2. // \u5904\u7406\u53c2\u6570 3. var normalized = normalizeArgs(args); 4. var options = normalized[0]; 5. // \u7533\u8bf7\u4e00\u4e2asocket\u8868\u793a\u4e00\u4e2a\u5ba2\u6237\u7aef 6. var socket = new Socket(options); 7. // \u8bbe\u7f6e\u8d85\u65f6\uff0c\u8d85\u65f6\u540e\u4f1a\u89e6\u53d1timeout\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u5904\u7406\u8d85\u65f6\u903b\u8f91 8. if (options.timeout) { 9. socket.setTimeout(options.timeout); 10. } 11. // \u8c03\u7528socket\u7684connect 12. return Socket.prototype.connect.call(socket, normalized); 13. } \u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cconnect\u51fd\u6570\u662f\u5bf9Socket\u5bf9\u8c61\u7684\u5c01\u88c5\u3002Socket\u8868\u793a\u4e00\u4e2aTCP\u5ba2\u6237\u7aef\u3002\u6211\u4eec\u5206\u6210\u4e09\u90e8\u5206\u5206\u6790\u3002 1 new Socket 2 setTimeout 3 Socket\u7684connect 1 new Socket \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aSocket\u5bf9\u8c61\uff0c\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1. function Socket(options) { 2. // \u662f\u5426\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b\u4e2d 3. this.connecting = false; 4. // \u89e6\u53d1close\u4e8b\u4ef6\u65f6\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u662f\u5426\u7531\u4e8e\u9519\u8bef\u5bfc\u81f4\u4e86close 5. this._hadError = false; 6. // \u5bf9\u5e94\u7684\u5e95\u5c42handle\uff0c\u6bd4\u5982tcp_wrap 7. this._handle = null; 8. // \u5b9a\u65f6\u5668id 9. this[kTimeout] = null; 10. options = options || {}; 11. // socket\u662f\u53cc\u5411\u6d41 12. stream.Duplex.call(this, options); 13. // \u8fd8\u4e0d\u80fd\u8bfb\u5199\uff0c\u5148\u8bbe\u7f6e\u6210false\uff0c\u8fde\u63a5\u6210\u529f\u540e\u518d\u91cd\u65b0\u8bbe\u7f6e 14. this.readable = this.writable = false; 15. // \u6ce8\u518c\u5199\u7aef\u5173\u95ed\u7684\u56de\u8c03 16. this.on('finish', onSocketFinish); 17. // \u6ce8\u518c\u8bfb\u7aef\u5173\u95ed\u7684\u56de\u8c03 18. this.on('_socketEnd', onSocketEnd); 19. // \u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e0d\u5141\u8bb8 20. this.allowHalfOpen = options && options.allowHalfOpen||false; 21. } Socket\u662f\u5bf9C++\u6a21\u5757tcp_wrap\u7684\u5c01\u88c5\u3002\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u5c5e\u6027\u548c\u76d1\u542c\u4e00\u4e9b\u4e8b\u4ef6\u3002 2 setTimeout 1. Socket.prototype.setTimeout = function(msecs, callback) { 2. // \u6e05\u9664\u4e4b\u524d\u7684\uff0c\u5982\u679c\u6709\u7684\u8bdd 3. clearTimeout(this[kTimeout]); 4. // 0\u4ee3\u8868\u6e05\u9664 5. if (msecs === 0) { 6. if (callback) { 7. this.removeListener('timeout', callback); 8. } 9. } else { 10. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u65f6\u95f4\u662fmsecs\uff0c\u8d85\u65f6\u56de\u8c03\u662f_onTimeout 11. this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs); 12. /* 13. \u76d1\u542ctimeout\u4e8b\u4ef6\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u5e95\u5c42\u4f1a\u8c03\u7528Node.js\u7684\u56de\u8c03\uff0c 14. Node.js\u4f1a\u8c03\u7528\u7528\u6237\u7684\u56de\u8c03callback 15. */ 16. if (callback) { 17. this.once('timeout', callback); 18. } 19. } 20. return this; 21. }; setTimeout\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u8fd9\u4e2a\u65f6\u95f4\u7528\u4e8e\u68c0\u6d4bsocket\u7684\u6d3b\u8dc3\u60c5\u51b5\uff08\u6bd4\u5982\u6709\u6570\u636e\u901a\u4fe1\uff09\uff0c\u5f53socket\u6d3b\u8dc3\u65f6\uff0cNode.js\u4f1a\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\uff0c\u5982\u679csocket\u4e00\u76f4\u4e0d\u6d3b\u8dc3\u5219\u8d85\u65f6\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884cNode.js\u7684_onTimeout\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u518d\u89e6\u53d1\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8d85\u65f6\u5904\u7406\u51fd\u6570_onTimeout\u3002 1. Socket.prototype._onTimeout = function() { 2. this.emit('timeout'); 3. }; \u76f4\u63a5\u89e6\u53d1timeout\u51fd\u6570\uff0c\u56de\u8c03\u7528\u6237\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u5230setTimeout\u53ea\u662f\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u7136\u540e\u89e6\u53d1timeout\u4e8b\u4ef6\uff0cNode.js\u5e76\u6ca1\u6709\u5e2e\u6211\u4eec\u505a\u989d\u5916\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5904\u7406\uff0c\u6bd4\u5982\u5173\u95edsocket\u3002 1. socket.setTimeout(10000); 2. socket.on('timeout', () => { 3. socket.close(); 4. }); \u53e6\u5916\u6211\u4eec\u770b\u5230\u8fd9\u91cc\u662f\u4f7f\u7528setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u8fd9\u4e00\u7c7b\u5b9a\u65f6\u5668\u4e0d\u5e94\u8be5\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 3 connect\u51fd\u6570 \u5728\u7b2c\u4e00\u6b65\u6211\u4eec\u5df2\u7ecf\u521b\u5efa\u4e86\u4e00\u4e2asocket\uff0c\u63a5\u7740\u6211\u4eec\u8c03\u7528\u8be5socket\u7684connect\u51fd\u6570\u5f00\u59cb\u53d1\u8d77\u8fde\u63a5\u3002 1. // \u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b 2. Socket.prototype.connect = function(...args) { 3. let normalized; 4. /* \u5ffd\u7565\u53c2\u6570\u5904\u7406 */ 5. var options = normalized[0]; 6. var cb = normalized[1]; 7. // TCP\u5728tcp_wrap.cc\u4e2d\u5b9a\u4e49 8. this._handle = new TCP(TCPConstants.SOCKET); 9. // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u7684\u56de\u8c03 10. this._handle.onread = onread; 11. // \u8fde\u63a5\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 12. if (cb !== null) { 13. this.once('connect', cb); 14. } 15. // \u6b63\u5728\u8fde\u63a5 16. this.connecting = true; 17. this.writable = true; 18. // \u91cd\u7f6e\u5b9a\u65f6\u5668 19. this._unrefTimer(); 20. // \u53ef\u80fd\u9700\u8981DNS\u89e3\u6790\uff0c\u89e3\u6790\u6210\u529f\u518d\u53d1\u8d77\u8fde\u63a5 21. lookupAndConnect(this, options); 22. return this; 23. }; connect \u51fd\u6570\u4e3b\u8981\u662f\u4e09\u4e2a\u903b\u8f91 1 \u9996\u5148\u901a\u8fc7new TCP()\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle\uff0c\u6bd4\u5982\u6211\u4eec\u8fd9\u91cc\u662fTCP\uff08\u5bf9\u5e94tcp_wrap.cc\u7684\u5b9e\u73b0\uff09\u3002 2 \u8bbe\u7f6e\u4e00\u4e9b\u56de\u8c03 3 \u505aDNS\u89e3\u6790\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u7136\u540e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u3002 \u6211\u4eec\u770b\u4e00\u4e0bnew TCP\u610f\u5473\u7740\u4ec0\u4e48\uff0c\u6211\u4eec\u770btcp_wrap.cc\u7684\u5b9e\u73b0 1. void TCPWrap::New(const FunctionCallbackInfo<Value>& args) { 2. // \u8981\u4ee5new TCP\u7684\u5f62\u5f0f\u8c03\u7528 3. CHECK(args.IsConstructCall()); 4. // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662f\u6570\u5b57 5. CHECK(args[0]->IsInt32()); 6. Environment* env = Environment::GetCurrent(args); 7. // \u4f5c\u4e3a\u5ba2\u6237\u7aef\u8fd8\u662f\u670d\u52a1\u5668 8. int type_value = args[0].As<Int32>()->Value(); 9. TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value); 10. 11. ProviderType provider; 12. switch (type) { 13. // \u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u5373\u53d1\u8d77\u8fde\u63a5\u65b9 14. case SOCKET: 15. provider = PROVIDER_TCPWRAP; 16. break; 17. // \u4f5c\u4e3a\u670d\u52a1\u5668 18. case SERVER: 19. provider = PROVIDER_TCPSERVERWRAP; 20. break; 21. default: 22. UNREACHABLE(); 23. } 24. new TCPWrap(env, args.This(), provider); 25. } new TCP\u5bf9\u5e94\u5230C++\u5c42\uff0c\u5c31\u662f\u521b\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u5e76\u521d\u59cb\u5316\u5bf9\u8c61\u4e2d\u7684handle_\u5b57\u6bb5 1. TCPWrap::TCPWrap(Environment* env, 2. Local<Object> object, 3. ProviderType provider) 4. : ConnectionWrap(env, object, provider) { 5. int r = uv_tcp_init(env->event_loop(), &handle_); 6. } \u521d\u59cb\u5316\u5b8c\u5e95\u5c42\u7684\u6570\u636e\u7ed3\u6784\u540e\uff0c\u6211\u4eec\u7ee7\u7eed\u770blookupAndConnect\uff0clookupAndConnect\u4e3b\u8981\u662f\u5bf9\u53c2\u6570\u8fdb\u884c\u6821\u9a8c\uff0c\u7136\u540e\u8fdb\u884cDNS\u89e3\u6790\uff08\u5982\u679c\u4f20\u7684\u662f\u57df\u540d\u7684\u8bdd\uff09\uff0cDNS\u89e3\u6790\u6210\u529f\u540e\u6267\u884cinternalConnect 1. function internalConnect( 2. self, 3. // \u9700\u8981\u8fde\u63a5\u7684\u8fdc\u7aefIP\u3001\u7aef\u53e3 4. address, 5. port, 6. addressType, 7. /* 8. \u7528\u4e8e\u548c\u5bf9\u7aef\u8fde\u63a5\u7684\u672c\u5730IP\u3001\u7aef\u53e3\uff08\u5982\u679c\u4e0d\u8bbe\u7f6e\uff0c 9. \u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u51b3\u5b9a\uff09 10. */ 11. localAddress, 12. localPort) { 13. var err; 14. /* 15. \u5982\u679c\u4f20\u4e86\u672c\u5730\u7684\u5730\u5740\u6216\u7aef\u53e3\uff0c\u5219TCP\u8fde\u63a5\u4e2d\u7684\u6e90IP 16. \u548c\u7aef\u53e3\u5c31\u662f\u4f20\u7684\uff0c\u5426\u5219\u7531\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009 17. */ 18. if (localAddress || localPort) { 19. // IP v4 20. if (addressType === 4) { 21. localAddress = localAddress || '0.0.0.0'; 22. // \u7ed1\u5b9a\u5730\u5740\u548c\u7aef\u53e3\u5230handle 23. err = self._handle.bind(localAddress, localPort); 24. } else if (addressType === 6) { 25. localAddress = localAddress || '::'; 26. err = self._handle.bind6(localAddress, localPort); 27. } 28. 29. // \u7ed1\u5b9a\u662f\u5426\u6210\u529f 30. err = checkBindError(err, localPort, self._handle); 31. if (err) { 32. const ex = exceptionWithHostPort(err, 33. 'bind', 34. localAddress, 35. localPort); 36. self.destroy(ex); 37. return; 38. } 39. } 40. // \u5bf9\u7aef\u7684\u5730\u5740\u4fe1\u606f 41. if (addressType === 6 || addressType === 4) { 42. // \u65b0\u5efa\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61\uff0cC++\u5c42\u5b9a\u4e49 43. const req = new TCPConnectWrap(); 44. // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 45. req.oncomplete = afterConnect; 46. req.address = address; 47. req.port = port; 48. req.localAddress = localAddress; 49. req.localPort = localPort; 50. // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 51. if (addressType === 4) 52. err = self._handle.connect(req, address, port); 53. else 54. err = self._handle.connect6(req, address, port); 55. } 56. /* 57. \u975e\u963b\u585e\u8c03\u7528\uff0c\u53ef\u80fd\u5728\u8fd8\u6ca1\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u4e4b\u524d\u5c31\u62a5\u9519\u4e86\uff0c 58. \u800c\u4e0d\u662f\u4e09\u6b21\u63e1\u624b\u51fa\u9519\uff0c\u8fd9\u91cc\u8fdb\u884c\u51fa\u9519\u5904\u7406 59. */ 60. if (err) { 61. // \u83b7\u53d6socket\u5bf9\u5e94\u7684\u5e95\u5c42IP\u7aef\u53e3\u4fe1\u606f 62. var sockname = self._getsockname(); 63. var details; 64. 65. if (sockname) { 66. details = sockname.address + ':' + sockname.port; 67. } 68. // \u6784\u9020\u9519\u8bef\u4fe1\u606f\uff0c\u9500\u9b42socket\u5e76\u89e6\u53d1error\u4e8b\u4ef6 69. const ex = exceptionWithHostPort(err, 70. 'connect', 71. address, 72. port, 73. details); 74. self.destroy(ex); 75. } 76. } \u8fd9\u91cc\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u9664\u4e86\u9519\u8bef\u5904\u7406\u5916\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662fbind\u548cconnect\u3002bind\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff08\u5373\u4f7f\u662f\u5e95\u5c42\u7684bind\uff09\uff0c\u5b83\u5c31\u662f\u5728\u5e95\u5c42\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0a\u8bbe\u7f6e\u4e86\u4e24\u4e2a\u5b57\u6bb5\u7684\u503c\u3002\u6240\u4ee5\u6211\u4eec\u4e3b\u8981\u6765\u5206\u6790connect\u3002\u6211\u4eec\u628a\u5173\u4e8econnect\u7684\u8fd9\u6bb5\u903b\u8f91\u62ce\u51fa\u6765\u3002 1. const req = new TCPConnectWrap(); 2. // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 3. req.oncomplete = afterConnect; 4. req.address = address; 5. req.port = port; 6. req.localAddress = localAddress; 7. req.localPort = localPort; 8. // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 9. self._handle.connect(req, address, port); TCPConnectWrap\u662fC++\u5c42\u63d0\u4f9b\u7684\u7c7b\uff0cconnect\u5bf9\u5e94C++\u5c42\u7684Conenct\uff0c \u524d\u9762\u7684\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u8fde\u63a5\u5b8c\u6210\u540e\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__stream_io\u3002\u5728uv__stream_io\u91cc\u4f1a\u8c03\u7528connect_req\u4e2d\u7684\u56de\u8c03\u3002\u5047\u8bbe\u8fde\u63a5\u5efa\u7acb\uff0c\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884cC++\u5c42\u7684AfterConnect\u3002AfterConnect\u4f1a\u6267\u884cJS\u5c42\u7684afterConnect\u3002 1. // \u8fde\u63a5\u540e\u6267\u884c\u7684\u56de\u8c03\uff0c\u6210\u529f\u6216\u5931\u8d25 2. function afterConnect(status, handle, req, readable, writable) { // handle\u5173\u8054\u7684socket 3. var self = handle.owner; 4. // \u8fde\u63a5\u8fc7\u7a0b\u4e2d\u6267\u884c\u4e86socket\u88ab\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u7ee7\u7eed\u5904\u7406 5. if (self.destroyed) { 6. return; 7. } 8. 9. handle = self._handle; 10. self.connecting = false; 11. self._sockname = null; 12. // \u8fde\u63a5\u6210\u529f 13. if (status === 0) { 14. // \u8bbe\u7f6e\u8bfb\u5199\u5c5e\u6027 15. self.readable = readable; 16. self.writable = writable; 17. // socket\u5f53\u524d\u6d3b\u8dc3\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 18. self._unrefTimer(); 19. // \u89e6\u53d1\u8fde\u63a5\u6210\u529f\u4e8b\u4ef6 20. self.emit('connect'); 21. // socket\u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u5f00\u542f\u8bfb 22. if (readable && !self.isPaused()) 23. self.read(0); 24. } else { 25. // \u8fde\u63a5\u5931\u8d25\uff0c\u62a5\u9519\u5e76\u9500\u6bc1socket 26. self.connecting = false; 27. var details; 28. // \u63d0\u793a\u51fa\u9519\u4fe1\u606f 29. if (req.localAddress && req.localPort) { 30. details = req.localAddress + ':' + req.localPort; 31. } 32. var ex = exceptionWithHostPort(status, 33. 'connect', 34. req.address, 35. req.port, 36. details); 37. if (details) { 38. ex.localAddress = req.localAddress; 39. ex.localPort = req.localPort; 40. } 41. // \u9500\u6bc1socket 42. self.destroy(ex); 43. } 44. } \u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u8fde\u63a5\u6210\u529f\u540e\uff0cJS\u5c42\u8c03\u7528self.read(0)\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u3002","title":"17.1.1 \u5efa\u7acb\u8fde\u63a5"},{"location":"chapter17-TCP/#1712","text":"\u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684\u8bfb\u64cd\u4f5c\u903b\u8f91\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\uff0csocket\u4f1a\u901a\u8fc7read\u51fd\u6570\u5728\u5e95\u5c42\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85\u5e95\u5c42\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u901a\u77e5\u6709\u6570\u636e\u53ef\u8bfb\u3002 1. Socket.prototype.read = function(n) { 2. if (n === 0) 3. return stream.Readable.prototype.read.call(this, n); 4. 5. this.read = stream.Readable.prototype.read; 6. this._consuming = true; 7. return this.read(n); 8. }; \u8fd9\u91cc\u4f1a\u6267\u884cReadable\u6a21\u5757\u7684read\u51fd\u6570\uff0c\u4ece\u800c\u6267\u884c_read\u51fd\u6570\uff0c_read\u51fd\u6570\u662f\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6240\u4ee5\u6211\u4eec\u770bSocket\u7684_read 1. Socket.prototype._read = function(n) { 2. // \u8fd8\u6ca1\u5efa\u7acb\u8fde\u63a5\uff0c\u5219\u5efa\u7acb\u540e\u518d\u6267\u884c 3. if (this.connecting || !this._handle) { 4. this.once('connect', () => this._read(n)); 5. } else if (!this._handle.reading) { 6. this._handle.reading = true; 7. // \u6267\u884c\u5e95\u5c42\u7684readStart\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 8. var err = this._handle.readStart(); 9. if (err) 10. this.destroy(errnoException(err, 'read')); 11. } 12. }; \u4f46\u662f\u6211\u4eec\u53d1\u73b0tcp_wrap.cc\u6ca1\u6709readStart\u51fd\u6570\u3002\u4e00\u8def\u5f80\u7236\u7c7b\u627e\uff0c\u6700\u7ec8\u5728stream_wrap.cc\u627e\u5230\u4e86\u8be5\u51fd\u6570\u3002 1. // \u6ce8\u518c\u8bfb\u4e8b\u4ef6 2. int LibuvStreamWrap::ReadStart() { 3. return uv_read_start(stream(), 4. [](uv_handle_t* handle, 5. size_t suggested_size, 6. uv_buf_t* buf) { 7. // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 8. static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); 9. }, 10. [](uv_stream_t* stream,ssize_t nread,const uv_buf_t* buf) { 11. // \u8bfb\u53d6\u6570\u636e\u6210\u529f\u7684\u56de\u8c03 12. static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); 13. }); 14. } uv_read_start\u51fd\u6570\u5728\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4f5c\u7528\u5c31\u662f\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u518d\u6df1\u5165\u3002OnUvAlloc\u662f\u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u4e0d\u5173\u6ce8\uff0c\u6211\u4eec\u770b\u4e00\u4e0bOnUvRead\uff0c\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u4f1a\u6267\u884cOnUvRead 1. void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { 2. HandleScope scope(env()->isolate()); 3. Context::Scope context_scope(env()->context()); 4. // \u89e6\u53d1onread\u4e8b\u4ef6 5. EmitRead(nread, *buf); 6. } OnUvRead\u51fd\u6570\u89e6\u53d1onread\u56de\u8c03\u3002 1. function onread(nread, buffer) { 2. var handle = this; 3. // handle\u5173\u8054\u7684socket 4. var self = handle.owner; 5. // socket\u6709\u6570\u636e\u5230\u6765\uff0c\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 6. self._unrefTimer(); 7. // \u6210\u529f\u8bfb\u53d6\u6570\u636e 8. if (nread > 0) { 9. // push\u5230\u6d41\u4e2d 10. var ret = self.push(buffer); 11. /* 12. push\u8fd4\u56defalse\uff0c\u8bf4\u660e\u7f13\u5b58\u7684\u6570\u636e\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c 13. \u4e0d\u80fd\u518d\u89e6\u53d1\u8bfb\uff0c\u9700\u8981\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 14. */ 15. if (handle.reading && !ret) { 16. handle.reading = false; 17. var err = handle.readStop(); 18. if (err) 19. self.destroy(errnoException(err, 'read')); 20. } 21. return; 22. } 23. 24. // \u6ca1\u6709\u6570\u636e\uff0c\u5ffd\u7565 25. if (nread === 0) { 26. debug('not any data, keep waiting'); 27. return; 28. } 29. // \u4e0d\u7b49\u4e8e\u7ed3\u675f\uff0c\u5219\u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 30. if (nread !== UV_EOF) { 31. return self.destroy(errnoException(nread, 'read')); 32. } 33. // \u6d41\u7ed3\u675f\u4e86\uff0c\u6ca1\u6709\u6570\u636e\u8bfb\u4e86 34. self.push(null); 35. /* 36. \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u4e86\uff0c\u53ef\u80fd\u9700\u8981\u9500\u6bc1\u6d41\uff0c\u6bd4\u5982\u662f\u53ea\u8bfb\u6d41\uff0c 37. \u6216\u8005\u53ef\u8bfb\u5199\u6d41\uff0c\u5199\u7aef\u4e5f\u6ca1\u6709\u6570\u636e\u4e86\uff0c\u53c2\u8003maybeDestroy 38. */ 39. if (self.readableLength === 0) { 40. self.readable = false; 41. maybeDestroy(self); 42. } 43. // \u89e6\u53d1\u4e8b\u4ef6 44. self.emit('_socketEnd'); 45. } socket\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u5927\u6982\u6709\u4e0b\u9762\u51e0\u79cd\u60c5\u51b5 1 \u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0cpush\u5230\u6d41\u4e2d\uff0c\u89e6\u53d1ondata\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u3002 2 \u6ca1\u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0c\u5ffd\u7565\u3002 3 \u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 4 \u8bfb\u7ed3\u675f\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0b4\u3002\u5728\u65b0\u5efa\u4e00\u4e2asocket\u7684\u65f6\u5019\u6ce8\u518c\u4e86\u6d41\u7ed3\u675f\u7684\u5904\u7406\u51fd\u6570onSocketEnd\u3002 1. // \u8bfb\u7ed3\u675f\u540e\u6267\u884c\u7684\u51fd\u6570 2. function onSocketEnd() { 3. // \u8bfb\u7ed3\u675f\u6807\u8bb0 4. this._readableState.ended = true; 5. /* 6. \u5df2\u7ecf\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\uff0c\u5219\u5224\u65ad\u662f\u5426\u9700\u8981\u9500\u6bc1\uff0c\u53ef\u80fd\u8fd8\u6709\u5199\u7aef 7. */ 8. if (this._readableState.endEmitted) { 9. this.readable = false; 10. maybeDestroy(this); 11. } else { 12. // \u8fd8\u6ca1\u6709\u89e6\u53d1end\u5219\u7b49\u5f85\u89e6\u53d1end\u4e8b\u4ef6\u518d\u6267\u884c\u4e0b\u4e00\u6b65\u64cd\u4f5c 13. this.once('end', function end() { 14. this.readable = false; 15. maybeDestroy(this); 16. }); 17. /* 18. \u6267\u884cread\uff0c\u5982\u679c\u6d41\u4e2d\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u4f1a\u89e6\u53d1end\u4e8b\u4ef6\uff0c 19. \u5426\u5219\u7b49\u5f85\u6d88\u8d39\u5b8c\u540e\u518d\u89e6\u53d1 20. */ 21. this.read(0); 22. } 23. /* 24. 1 \u8bfb\u7ed3\u675f\u540e\uff0c\u5982\u679c\u4e0d\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5219\u5173\u95ed\u5199\u7aef\uff0c\u5982\u679c\u8fd8\u6709\u6570\u636e\u8fd8\u6ca1\u6709\u53d1\u9001 25. \u5b8c\u6bd5\uff0c\u5219\u5148\u53d1\u9001\u5b8c\u518d\u5173\u95ed 26. 2 \u91cd\u7f6e\u5199\u51fd\u6570\uff0c\u540e\u7eed\u6267\u884c\u5199\u7684\u65f6\u5019\u62a5\u9519 27. */ 28. if (!this.allowHalfOpen) { 29. this.write = writeAfterFIN; 30. this.destroySoon(); 31. } 32. } \u5f53socket\u7684\u8bfb\u7aef\u7ed3\u675f\u65f6\uff0csocket\u7684\u72b6\u6001\u53d8\u66f4\u5206\u4e3a\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u53ef\u8bfb\u6d41\u4e2d\u8fd8\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u7b49\u5f85\u8bfb\u53d6\u3002 2 \u5982\u679c\u5199\u7aef\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1\u6d41\u3002 3 \u5982\u679c\u5199\u7aef\u6ca1\u6709\u7ed3\u675f\uff0c\u5219\u5224\u65adallowHalfOpen\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u4e0d\u5141\u8bb8\u5e76\u4e14\u5199\u7aef\u6570\u636e\u5df2\u7ecf\u53d1\u9001\u5b8c\u6bd5\u5219\u5173\u95ed\u5199\u7aef\u3002","title":"17.1.2 \u8bfb\u64cd\u4f5c"},{"location":"chapter17-TCP/#1713","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5728\u4e00\u4e2a\u6d41\u4e0a\u5199\u7684\u65f6\u5019\uff0c\u903b\u8f91\u662f\u600e\u6837\u7684\u3002Socket\u5b9e\u73b0\u4e86\u5355\u4e2a\u5199\u548c\u6279\u91cf\u5199\u63a5\u53e3\u3002 1. // \u6279\u91cf\u5199 2. Socket.prototype._writev = function(chunks, cb) { 3. this._writeGeneric(true, chunks, '', cb); 4. }; 5. 6. // \u5355\u4e2a\u5199 7. Socket.prototype._write = function(data, encoding, cb) { 8. this._writeGeneric(false, data, encoding, cb); 9. }; _writeGeneric 1. Socket.prototype._writeGeneric = function(writev, data, encoding, cb) { 2. /* 3. \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u5148\u4fdd\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u56e0\u4e3astream\u6a21\u5757\u662f\u4e32\u884c\u5199\u7684\uff0c 4. \u6240\u4ee5\u7b2c\u4e00\u6b21\u5199\u6ca1\u5b8c\u6210\uff0c\u4e0d\u4f1a\u6267\u884c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\uff08_write\uff09\uff0c 5. \u6240\u4ee5\u8fd9\u91cc\u7528\u4e00\u4e2a\u5b57\u6bb5\u800c\u4e0d\u662f\u4e00\u4e2a\u6570\u7ec4\u6216\u961f\u5217\u4fdd\u5b58\u6570\u636e\u548c\u7f16\u7801\uff0c 6. \u56e0\u4e3a\u6709pendingData\u65f6_writeGeneric \u4e0d\u4f1a\u88ab\u6267\u884c\u7b2c\u4e8c\u6b21\uff0c\u8fd9\u91cc\u7f13\u5b58 7. pendingData\u4e0d\u662f\u4e3a\u4e86\u540e\u7eed\u5199\u5165\uff0c\u800c\u662f\u4e3a\u4e86\u7edf\u8ba1\u5199\u5165\u7684\u6570\u636e\u603b\u6570 8. */ 9. if (this.connecting) { 10. this._pendingData = data; 11. this._pendingEncoding = encoding; 12. this.once('connect', function connect() { 13. this._writeGeneric(writev, data, encoding, cb); 14. }); 15. return; 16. } 17. // \u5f00\u59cb\u5199\uff0c\u5219\u6e05\u7a7a\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e 18. this._pendingData = null; 19. this._pendingEncoding = ''; 20. // \u5199\u64cd\u4f5c\uff0c\u6709\u6570\u636e\u901a\u4fe1\uff0c\u5237\u65b0\u5b9a\u65f6\u5668 21. this._unrefTimer(); 22. // \u5df2\u7ecf\u5173\u95ed\uff0c\u5219\u9500\u6bc1socket 23. if (!this._handle) { 24. this.destroy(new errors.Error('ERR_SOCKET_CLOSED'), cb); 25. return false; 26. } 27. // \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 28. var req = new WriteWrap(); 29. req.handle = this._handle; 30. req.oncomplete = afterWrite; 31. // \u662f\u5426\u540c\u6b65\u6267\u884c\u5199\u5b8c\u6210\u56de\u8c03\uff0c\u53d6\u51b3\u4e8e\u5e95\u5c42\u662f\u540c\u6b65\u5199\u5165\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u8fd8\u662f\u5f02\u6b65\u5199\u5165 32. req.async = false; 33. var err; 34. // \u662f\u5426\u6279\u91cf\u5199 35. if (writev) { 36. // \u6240\u6709\u6570\u636e\u90fd\u662fbuffer\u7c7b\u578b\uff0c\u5219\u76f4\u63a5\u5806\u8d77\u6765\uff0c\u5426\u5219\u9700\u8981\u4fdd\u5b58\u7f16\u7801\u7c7b\u578b 37. var allBuffers = data.allBuffers; 38. var chunks; 39. var i; 40. if (allBuffers) { 41. chunks = data; 42. for (i = 0; i < data.length; i++) 43. data[i] = data[i].chunk; 44. } else { 45. // \u7533\u8bf7double\u4e2a\u5927\u5c0f\u7684\u6570\u7ec4 46. chunks = new Array(data.length << 1); 47. for (i = 0; i < data.length; i++) { 48. var entry = data[i]; 49. chunks[i * 2] = entry.chunk; 50. chunks[i * 2 + 1] = entry.encoding; 51. } 52. } 53. err = this._handle.writev(req, chunks, allBuffers); 54. 55. // Retain chunks 56. if (err === 0) req._chunks = chunks; 57. } else { 58. var enc; 59. if (data instanceof Buffer) { 60. enc = 'buffer'; 61. } else { 62. enc = encoding; 63. } 64. err = createWriteReq(req, this._handle, data, enc); 65. } 66. 67. if (err) 68. return this.destroy(errnoException(err, 'write', req.error), cb); 69. // \u8bf7\u6c42\u5199\u5165\u5e95\u5c42\u7684\u6570\u636e\u5b57\u8282\u957f\u5ea6 70. this._bytesDispatched += req.bytes; 71. // \u5728stream_base.cc\u4e2dreq_wrap_obj->Set(env->async(), True(env->isolate()));\u8bbe\u7f6e 72. if (!req.async) { 73. cb(); 74. return; 75. } 76. 77. req.cb = cb; 78. // \u6700\u540e\u4e00\u6b21\u8bf7\u6c42\u5199\u6570\u636e\u7684\u5b57\u8282\u957f\u5ea6 79. this[kLastWriteQueueSize] = req.bytes; 80. }; \u4e0a\u9762\u7684\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5177\u4f53\u5b9e\u73b0\u5728stream_base.cc\u548cstream_wrap.cc\uff0c\u8fd9\u91cc\u4e0d\u518d\u5c55\u5f00\u5206\u6790\uff0c\u4e3b\u8981\u662f\u6267\u884cwritev\u548ccreateWriteReq\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u5b83\u4eec\u5e95\u5c42\u8c03\u7528\u7684\u90fd\u662fuv_write2\uff08\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216uv_write\uff08\u4e0d\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216\u8005uv_try_write\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u4e00\u4e0basync\u7684\u610f\u4e49\uff0casync\u9ed8\u8ba4\u662ffalse\uff0c\u5b83\u8868\u793a\u7684\u610f\u4e49\u662f\u6267\u884c\u5e95\u5c42\u5199\u5165\u65f6\uff0c\u5e95\u5c42\u662f\u5426\u540c\u6b65\u6267\u884c\u56de\u8c03\uff0casync\u4e3afalse\u8bf4\u660e\u5199\u5165\u5b8c\u6210\u56de\u8c03\u662f\u540c\u6b65\u6267\u884c\u7684\u3002\u5728stream_base.cc\u7684\u5199\u51fd\u6570\u4e2d\u6709\u76f8\u5173\u7684\u903b\u8f91\u3002 1. err = DoWrite(req_wrap, buf_list, count, nullptr); 2. req_wrap_obj->Set(env->async(), True(env->isolate())); \u5f53\u6267\u884cDoWrite\u7684\u65f6\u5019\uff0creq_wrap\u4e2d\u4fdd\u5b58\u7684\u56de\u8c03\u53ef\u80fd\u4f1a\u88abLibuv\u540c\u6b65\u6267\u884c\uff0c\u4ece\u800c\u6267\u884cJS\u4ee3\u7801\uff0c\u8fd9\u65f6\u5019async\u662ffalse\uff08\u9ed8\u8ba4\u503c\uff09\uff0c\u8bf4\u660e\u56de\u8c03\u662f\u88ab\u540c\u6b65\u6267\u884c\u7684\uff0c\u5982\u679cDoWrite\u6ca1\u6709\u540c\u6b65\u6267\u884c\u56de\u8c03\u3002\u5219\u8bf4\u660e\u662f\u5f02\u6b65\u6267\u884c\u56de\u8c03\u3002\u8bbe\u7f6easync\u4e3atrue\uff0c\u518d\u6267\u884cJS\u4ee3\u7801\u3002","title":"17.1.3 \u5199\u64cd\u4f5c"},{"location":"chapter17-TCP/#1714","text":"\u5f53\u6211\u4eec\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528socket\u5bf9\u8c61\u7684end\u51fd\u6570\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u4e00\u4e0bend\u7684\u903b\u8f91\u3002 1. Socket.prototype.end = function(data, encoding, callback) { 2. stream.Duplex.prototype.end.call(this, 3. data, 4. encoding, 5. callback); 6. return this; 7. }; Socket\u7684end\u662f\u8c03\u7528\u7684Duplex\u7684end\uff0c\u800cDuplex\u7684end\u662f\u7ee7\u627f\u4e8eWritable\u7684end\u3002Writable\u7684end\u6700\u7ec8\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6\uff0csocket\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u76d1\u542c\u4e86\u8be5\u4e8b\u4ef6\u3002 1. this.on('finish', onSocketFinish); \u6211\u4eec\u770b\u770bonSocketFinish\u3002 1. // \u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff0c\u5219\u5173\u95ed\u5199\u7aef 2. function onSocketFinish() { 3. // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\u5c31\u6267\u884c\u4e86end 4. if (this.connecting) { 5. return this.once('connect', onSocketFinish); 6. } 7. // \u5199\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u4e5f\u4e0d\u80fd\u8bfb\u6216\u8005\u8bfb\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket 8. if (!this.readable || this._readableState.ended) { 9. return this.destroy(); 10. } 11. // \u4e0d\u652f\u6301shutdown\u5219\u76f4\u63a5\u9500\u6bc1 12. if (!this._handle || !this._handle.shutdown) 13. return this.destroy(); 14. // \u652f\u6301shutdown\u5219\u6267\u884c\u5173\u95ed\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03 15. var err = defaultTriggerAsyncIdScope( 16. this[async_id_symbol], shutdownSocket, this, afterShutdown 17. ); 18. // \u6267\u884cshutdown\u5931\u8d25\u5219\u76f4\u63a5\u9500\u6bc1 19. if (err) 20. return this.destroy(errnoException(err, 'shutdown')); 21. } 22. 23. // \u53d1\u9001\u5173\u95ed\u5199\u7aef\u7684\u8bf7\u6c42 24. function shutdownSocket(self, callback) { 25. var req = new ShutdownWrap(); 26. req.oncomplete = callback; 27. req.handle = self._handle; 28. return self._handle.shutdown(req); 29. } Shutdown\u51fd\u6570\u5728stream_base.cc\u4e2d\u5b9a\u4e49\uff0c\u6700\u7ec8\u8c03\u7528uv_shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u5728Libuv\u6d41\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u5199\u7aef\u540e\uff0c\u56de\u8c03\u51fd\u6570\u7684\u903b\u8f91\u3002 1. // \u5173\u95ed\u5199\u7aef\u6210\u529f\u540e\u7684\u56de\u8c03 2. function afterShutdown(status, handle, req) { 3. // handle\u5173\u8054\u7684socket 4. var self = handle.owner; 5. // \u5df2\u7ecf\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\u4e86\uff0c\u5426\u5219\u6267\u884c\u9500\u6bc1\u64cd\u4f5c 6. if (self.destroyed) 7. return; 8. // \u5199\u5173\u95ed\u6210\u529f\uff0c\u5e76\u4e14\u8bfb\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket\uff0c\u5426\u5219\u7b49\u5f85\u8bfb\u7ed3\u675f\u518d\u6267\u884c\u9500\u6bc1 9. if (self._readableState.ended) { 10. self.destroy(); 11. } else { 12. self.once('_socketEnd', self.destroy); 13. } 14. }","title":"17.1.4 \u5173\u95ed\u5199\u64cd\u4f5c"},{"location":"chapter17-TCP/#1715","text":"\u5f53\u4e00\u4e2asocket\u4e0d\u53ef\u8bfb\u4e5f\u4e0d\u53ef\u5199\u7684\u65f6\u5019\u3001\u88ab\u5173\u95ed\u3001\u53d1\u751f\u9519\u8bef\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002\u9500\u6bc1\u4e00\u4e2a\u6d41\u5c31\u662f\u9500\u6bc1\u6d41\u7684\u8bfb\u7aef\u3001\u5199\u7aef\u3002\u7136\u540e\u6267\u884c\u6d41\u5b50\u7c7b\u7684_destory\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684_destroy\u51fd\u6570 1. // \u9500\u6bc1\u65f6\u6267\u884c\u7684\u94a9\u5b50\u51fd\u6570\uff0cexception\u4ee3\u8868\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u9500\u6bc1 2. Socket.prototype._destroy = function(exception, cb) { 3. this.connecting = false; 4. this.readable = this.writable = false; 5. // \u6e05\u9664\u5b9a\u65f6\u5668 6. for (var s = this; s !== null; s = s._parent) { 7. clearTimeout(s[kTimeout]); 8. } 9. 10. if (this._handle) { 11. // \u662f\u5426\u56e0\u4e3a\u51fa\u9519\u5bfc\u81f4\u9500\u6bc1\u6d41 12. var isException = exception ? true : false; 13. // \u5173\u95ed\u5e95\u5c42handle 14. this._handle.close(() => { 15. // close\u4e8b\u4ef6\u7684\u5165\u53c2\uff0c\u8868\u793a\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u5173\u95ed 16. this.emit('close', isException); 17. }); 18. this._handle.onread = noop; 19. this._handle = null; 20. this._sockname = null; 21. } 22. // \u6267\u884c\u56de\u8c03 23. cb(exception); 24. // socket\u6240\u5c5e\u7684server\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u65f6\u662fnull 25. if (this._server) { 26. // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 27. this._server._connections--; 28. /* 29. \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c 30. \u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 31. */ 32. if (this._server._emitCloseIfDrained) { 33. this._server._emitCloseIfDrained(); 34. } 35. } 36. }; _stream_writable.js\u4e2d\u7684destroy\u51fd\u6570\u53ea\u662f\u4fee\u6539\u8bfb\u5199\u6d41\u7684\u72b6\u6001\u548c\u6807\u8bb0\uff0c\u5b50\u7c7b\u9700\u8981\u5b9a\u4e49_destroy\u51fd\u6570\u9500\u6bc1\u76f8\u5173\u7684\u8d44\u6e90\uff0csocket\u901a\u8fc7\u8c03\u7528close\u5173\u95ed\u5e95\u5c42\u5173\u8054\u7684\u8d44\u6e90\uff0c\u5173\u95ed\u540e\u89e6\u53d1socket\u7684close\u4e8b\u4ef6\uff08\u56de\u8c03\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fboolean\u7c7b\u578b\uff0c\u8bf4\u660e\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4socket\u5173\u95ed\uff09\u3002\u6700\u540e\u5224\u65ad\u8be5socket\u662f\u5426\u6765\u81ea\u670d\u52a1\u5668\u521b\u5efa\u7684\uff0c\u662f\u7684\u8bdd\u8be5\u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u5982\u679c\u670d\u52a1\u5668\u6267\u884c\u4e86close\u5e76\u4e14\u5f53\u524d\u8fde\u63a5\u6570\u4e3a0\uff0c\u5219\u5173\u95ed\u670d\u52a1\u5668\u3002","title":"17.1.5 \u9500\u6bc1"},{"location":"chapter17-TCP/#172-tcp","text":"net\u6a21\u5757\u63d0\u4f9b\u4e86createServer\u51fd\u6570\u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668\u3002 1. function createServer(options, connectionListener) { 2. return new Server(options, connectionListener); 3. } 4. 5. function Server(options, connectionListener) { 6. EventEmitter.call(this); 7. // \u6ce8\u518c\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03 8. if (typeof options === 'function') { 9. connectionListener = options; 10. options = {}; 11. this.on('connection', connectionListener); 12. } else if (options == null || typeof options === 'object') { 13. options = options || {}; 14. if (typeof connectionListener === 'function') { 15. this.on('connection', connectionListener); 16. } 17. } else { 18. throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 19. 'options', 20. 'Object', 21. options); 22. } 23. // \u670d\u52a1\u5668\u5efa\u7acb\u7684\u8fde\u63a5\u6570 24. this._connections = 0; 25. this._handle = null; 26. this._unref = false; 27. // \u670d\u52a1\u5668\u4e0b\u7684\u6240\u6709\u8fde\u63a5\u662f\u5426\u5141\u8bb8\u534a\u8fde\u63a5 28. this.allowHalfOpen = options.allowHalfOpen || false; 29. // \u6709\u8fde\u63a5\u65f6\u662f\u5426\u6ce8\u518c\u8bfb\u4e8b\u4ef6 30. this.pauseOnConnect = !!options.pauseOnConnect; 31. } createServer\u8fd4\u56de\u7684\u5c31\u662f\u4e00\u4e2a\u4e00\u822c\u7684JS\u5bf9\u8c61\uff0c\u63a5\u7740\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u7aef\u53e3\u3002\u770b\u4e00\u4e0blisten\u51fd\u6570\u7684\u903b\u8f91 1. Server.prototype.listen = function(...args) { 2. /* 3. \u5904\u7406\u5165\u53c2\uff0c\u6839\u636e\u6587\u6863\u6211\u4eec\u77e5\u9053listen\u53ef\u4ee5\u63a5\u6536\u597d\u51e0\u4e2a\u53c2\u6570\uff0c 4. \u5047\u8bbe\u6211\u4eec\u8fd9\u91cc\u662f\u53ea\u4f20\u4e86\u7aef\u53e3\u53f79297 5. */ 6. var normalized = normalizeArgs(args); 7. // normalized = [{port: 9297}, null]; 8. var options = normalized[0]; 9. var cb = normalized[1]; 10. // \u7b2c\u4e00\u6b21listen\u7684\u65f6\u5019\u4f1a\u521b\u5efa\uff0c\u5982\u679c\u975e\u7a7a\u8bf4\u660e\u5df2\u7ecflisten\u8fc7 11. if (this._handle) { 12. throw new errors.Error('ERR_SERVER_ALREADY_LISTEN'); 13. } 14. // listen\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 15. var hasCallback = (cb !== null); 16. if (hasCallback) { 17. // listen\u6210\u529f\u7684\u56de\u8c03 18. this.once('listening', cb); 19. } 20. 21. options = options._handle || options.handle || options; 22. // \u7b2c\u4e00\u79cd\u60c5\u51b5\uff0c\u4f20\u8fdb\u6765\u7684\u662f\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u800c\u4e0d\u662f\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668 23. if (options instanceof TCP) { 24. this._handle = options; 25. this[async_id_symbol] = this._handle.getAsyncId(); 26. listenIncluster(this, null, -1, -1, backlogFromArgs); 27. return this; 28. } 29. // \u7b2c\u4e8c\u79cd\uff0c\u4f20\u8fdb\u6765\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u5e26\u4e86fd 30. if (typeof options.fd === 'number' && options.fd >= 0) { 31. listenIncluster(this, 32. null, 33. null, 34. null, 35. backlogFromArgs, 36. options.fd); 37. return this; 38. } 39. // \u521b\u5efa\u4e00\u4e2atcp\u670d\u52a1\u5668 40. var backlog; 41. if (typeof options.port === 'number' || 42. typeof options.port === 'string') { 43. backlog = options.backlog || backlogFromArgs; 44. // \u7b2c\u4e09\u79cd \u542f\u52a8\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u4f20\u4e86host\u5219\u5148\u8fdb\u884cDNS\u89e3\u6790 45. if (options.host) { 46. lookupAndListen(this, 47. options.port | 0, 48. options.host, 49. backlog, 50. options.exclusive); 51. } else { 52. listenIncluster(this, 53. null, 54. options.port | 0, 55. 4, 56. backlog, 57. undefined, 58. options.exclusive); 59. } 60. return this; 61. } 62. }; \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u5206\u522b\u662f\u4f20\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u3001\u4f20\u4e86\u4e00\u4e2afd\u3001\u4f20\u4e86\u7aef\u53e3\uff08\u6216\u8005host\uff09\uff0c\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0c\u8fd9\u51e0\u79cd\u60c5\u51b5\u6700\u540e\u90fd\u662f\u8c03\u7528\u4e86listenIncluster\uff08lookupAndListen\u662f\u5148DNS\u89e3\u6790\u540e\u518d\u6267\u884clistenIncluster\uff09\uff0c\u53ea\u662f\u5165\u53c2\u4e0d\u4e00\u6837\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u770blistenIncluster\u3002 1. function listenIncluster(server, 2. address, 3. port, 4. addressType, 5. backlog, 6. fd, 7. exclusive) { 8. exclusive = !!exclusive; 9. if (cluster === null) cluster = require('cluster'); 10. if (cluster.isMaster || exclusive) { 11. server._listen2(address, port, addressType, backlog, fd); 12. return; 13. } 14. } \u56e0\u4e3a\u6211\u4eec\u662f\u5728\u4e3b\u8fdb\u7a0b\uff0c\u6240\u4ee5\u76f4\u63a5\u6267\u884c_listen2\uff0c\u5b50\u8fdb\u7a0b\u7684\u5728cluster\u6a21\u5757\u5206\u6790\u3002_listen\u5bf9\u5e94\u7684\u51fd\u6570\u662fsetupListenHandle 1. function setupListenHandle(address, port, addressType, backlog, fd) { 2. // \u6709handle\u5219\u4e0d\u9700\u8981\u521b\u5efa\u4e86\uff0c\u5426\u5219\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle 3. if (this._handle) { 4. 5. } else { 6. var rval = null; 7. // \u6ca1\u6709\u4f20fd\uff0c\u5219\u8bf4\u660e\u662f\u76d1\u542c\u7aef\u53e3\u548cIP 8. if (!address && typeof fd !== 'number') { 9. rval = createServerHandle('::', port, 6, fd); 10. /* 11. \u8fd4\u56denumber\u8bf4\u660ebind IPv6\u7248\u672c\u7684handle\u5931\u8d25\uff0c 12. \u56de\u9000\u5230v4\uff0c\u5426\u5219\u8bf4\u660e\u652f\u6301IPv6 13. */ 14. if (typeof rval === 'number') { 15. // \u8d4b\u503c\u4e3anull\uff0c\u624d\u80fd\u8d70\u4e0b\u9762\u7684createServerHandle 16. rval = null; 17. address = '0.0.0.0'; 18. addressType = 4; 19. } else { 20. address = '::'; 21. addressType = 6; 22. } 23. } 24. // \u521b\u5efa\u5931\u8d25\u5219\u7ee7\u7eed\u521b\u5efa 25. if (rval === null) 26. rval = createServerHandle(address, 27. port, 28. addressType, 29. fd); 30. // \u8fd8\u62a5\u9519\u5219\u8bf4\u660e\u521b\u5efa\u670d\u52a1\u5668\u5931\u8d25\uff0c\u62a5\u9519 31. if (typeof rval === 'number') { 32. var error = exceptionWithHostPort(rval, 33. 'listen', 34. address, 35. port); 36. process.nextTick(emitErrorNT, this, error); 37. return; 38. } 39. this._handle = rval; 40. } 41. 42. // \u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 43. this._handle.onconnection = onconnection; 44. this._handle.owner = this; 45. // \u6267\u884cC++\u5c42listen 46. var err = this._handle.listen(backlog || 511); 47. // \u51fa\u9519\u5219\u62a5\u9519 48. if (err) { 49. var ex = exceptionWithHostPort(err, 50. 'listen', 51. address, 52. port); 53. this._handle.close(); 54. this._handle = null; 55. nextTick(this[async_id_symbol], emitErrorNT, this, ex); 56. return; 57. } 58. // \u89e6\u53d1listen\u56de\u8c03 59. nextTick(this[async_id_symbol], emitListeningNT, this); 60. } \u4e3b\u8981\u662f\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u3002\u6211\u4eec\u5148\u770bcreateServerHandle 1. function createServerHandle(address, port, addressType, fd) { 2. var err = 0; 3. var handle; 4. 5. var isTCP = false; 6. // \u4f20\u4e86fd\u5219\u6839\u636efd\u521b\u5efa\u4e00\u4e2ahandle 7. if (typeof fd === 'number' && fd >= 0) { 8. try { 9. handle = createHandle(fd, true); 10. } catch (e) { 11. return UV_EINVAL; 12. } 13. // \u628afd\u5b58\u5230handle\u4e2d 14. handle.open(fd); 15. handle.readable = true; 16. handle.writable = true; 17. assert(!address && !port); 18. // \u7ba1\u9053 19. } else if (port === -1 && addressType === -1) { 20. // \u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 21. handle = new Pipe(PipeConstants.SERVER); 22. } else { 23. // \u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668 24. handle = new TCP(TCPConstants.SERVER); 25. isTCP = true; 26. } 27. /* 28. \u6709\u5730\u5740\u6216\u8005IP\u8bf4\u660e\u662f\u901a\u8fc7IP\u7aef\u53e3\u521b\u5efa\u7684TCP\u670d\u52a1\u5668\uff0c 29. \u9700\u8981\u8c03bind\u7ed1\u5b9a\u5730\u5740 30. */ 31. if (address || port || isTCP) { 32. // \u6ca1\u6709\u5730\u5740\uff0c\u5219\u4f18\u5148\u7ed1\u5b9aIPv6\u7248\u672c\u7684\u672c\u5730\u5730\u5740 33. if (!address) { 34. // Try binding to IPv6 first 35. err = handle.bind6('::', port); 36. // \u5931\u8d25\u5219\u7ed1\u5b9av4\u7684 37. if (err) { 38. handle.close(); 39. // Fallback to IPv4 40. return createServerHandle('0.0.0.0', port); 41. } 42. } else if (addressType === 6) { // IPv6\u6216v4 43. err = handle.bind6(address, port); 44. } else { 45. err = handle.bind(address, port); 46. } 47. } 48. 49. if (err) { 50. handle.close(); 51. return err; 52. } 53. 54. return handle; 55. } createServerHandle\u4e3b\u8981\u662f\u8c03\u7528createHandle\u521b\u5efa\u4e00\u4e2ahandle\u7136\u540e\u6267\u884cbind\u51fd\u6570\u3002\u521b\u5efahandle\u7684\u65b9\u5f0f\u6709\u51e0\u79cd\uff0c\u76f4\u63a5\u8c03\u7528C++\u5c42\u7684\u51fd\u6570\u6216\u8005\u901a\u8fc7fd\u521b\u5efa\u3002\u8c03\u7528createHandle\u53ef\u4ee5\u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle 1. // \u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u6216\u8005\u670d\u52a1\u5668 2. function createHandle(fd, is_server) { 3. // \u5224\u65adfd\u5bf9\u5e94\u7684\u7c7b\u578b 4. const type = TTYWrap.guessHandleType(fd); 5. // Unix\u57df 6. if (type === 'PIPE') { 7. return new Pipe( 8. is_server ? PipeConstants.SERVER : PipeConstants.SOCKET ); 9. } 10. // tcp 11. if (type === 'TCP') { 12. return new TCP( 13. is_server ? TCPConstants.SERVER : TCPConstants.SOCKET 14. ); 15. } 16. 17. throw new errors.TypeError('ERR_INVALID_FD_TYPE', type); 18. } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bbind\u51fd\u6570\u7684\u903b\u8f91\uff0c 1. int uv__tcp_bind(uv_tcp_t* tcp, 2. const struct sockaddr* addr, 3. unsigned int addrlen, 4. unsigned int flags) { 5. int err; 6. int on; 7. // \u5982\u679c\u6ca1\u6709socket\u5219\u521b\u5efa\u4e00\u4e2a\uff0c\u6709\u5224\u65ad\u662f\u5426\u8bbe\u7f6e\u4e86UV_HANDLE_BOUND\uff0c\u662f\u5219\u6267\u884cbind\uff0c\u5426\u5219\u4e0d\u6267\u884cbind 8. err = maybe_new_socket(tcp, addr->sa_family, 0); 9. if (err) 10. return err; 11. 12. on = 1; 13. // \u8bbe\u7f6e\u5728\u65ad\u5f00\u8fde\u63a5\u76842 msl\u5185\u53ef\u4ee5\u91cd\u7528\u7aef\u53e3\uff0c\u6240\u4ee5Node.js\u670d\u52a1\u5668\u53ef\u4ee5\u5feb\u901f\u91cd\u542f 14. if (setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))) 15. return UV__ERR(errno); 16. errno = 0; 17. // \u6267\u884cbind 18. if (bind(tcp->io_watcher.fd, addr, addrlen) && errno != EADDRINUSE) { 19. if (errno == EAFNOSUPPORT) 20. return UV_EINVAL; 21. return UV__ERR(errno); 22. } 23. // bind\u662f\u5426\u51fa\u9519 24. tcp->delayed_error = UV__ERR(errno); 25. // \u6253\u4e0a\u5df2\u7ecf\u6267\u884c\u4e86bind\u7684\u6807\u8bb0 26. tcp->flags |= UV_HANDLE_BOUND; 27. if (addr->sa_family == AF_INET6) 28. tcp->flags |= UV_HANDLE_IPV6; 29. 30. return 0; 31. } \u6267\u884c\u5b8cbind\u540e\uff0c\u4f1a\u7ee7\u7eed\u6267\u884clisten\uff0c\u6211\u4eec\u63a5\u7740\u770blisten\u51fd\u6570\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770btcp_wrap.cc\u7684Listen\u3002 1. void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) { 2. TCPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. int backlog = args[0]->Int32Value(); 7. int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_), 8. backlog, 9. OnConnection); 10. args.GetReturnValue().Set(err); 11. } C++\u5c42\u51e0\u4e4e\u662f\u900f\u4f20\u5230Libuv\uff0cLibuv\u7684\u5185\u5bb9\u6211\u4eec\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\uff0c\u5f53\u6709\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u5b8c\u6210\u65f6\uff0c\u4f1a\u6267\u884cOnConnection 1. template <typename WrapType, typename UVType> 2. void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle, int status) { 3. // TCPWrap 4. WrapType* wrap_data = static_cast<WrapType*>(handle->data); 5. Environment* env = wrap_data->env(); 6. HandleScope handle_scope(env->isolate()); 7. Context::Scope context_scope(env->context()); 8. Local<Value> argv[] = { 9. Integer::New(env->isolate(), status), 10. Undefined(env->isolate()) 11. }; 12. 13. if (status == 0) { 14. // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61,\u5fc5\u586bTCPWrap\u5bf9\u8c61 15. Local<Object> client_obj = WrapType::Instantiate(env,wrap_data,WrapType::SOCKET); 16. WrapType* wrap; 17. // \u89e3\u5305\u51fa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u5b58\u5230wrap 18. ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj); 19. uv_stream_t* client_handle = reinterpret_cast<uv_stream_t*>(&wrap->handle_); 20. // \u628a\u901a\u4fe1fd\u5b58\u50a8\u5230client_handle\u4e2d 21. if (uv_accept(handle, client_handle)) 22. return; 23. argv[1] = client_obj; 24. } 25. // \u56de\u8c03\u4e0a\u5c42\u7684onconnection\u51fd\u6570 26. wrap_data->MakeCallback(env->onconnection_string(), arraysize(argv), argv); 27. } \u5f53\u5efa\u7acb\u4e86\u65b0\u8fde\u63a5\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\u8868\u793a\uff0c\u540c\u6837\uff0c\u5728Node.js\u5c42\uff0c\u4e5f\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u6211\u4eec\u770bJS\u5c42\u56de\u8c03\u3002 1. // clientHandle\u4ee3\u8868\u4e00\u4e2a\u548c\u5ba2\u6237\u7aef\u5efa\u7acbTCP\u8fde\u63a5\u7684\u5b9e\u4f53 2. function onconnection(err, clientHandle) { 3. var handle = this; 4. var self = handle.owner; 5. // \u9519\u8bef\u5219\u89e6\u53d1\u9519\u8bef\u4e8b\u4ef6 6. if (err) { 7. self.emit('error', errnoException(err, 'accept')); 8. return; 9. } 10. // \u5efa\u7acb\u8fc7\u591a\uff0c\u5173\u6389 11. if (self.maxConnections && self._connections >= self.maxConnections) { 12. clientHandle.close(); 13. return; 14. } 15. //\u65b0\u5efa\u4e00\u4e2asocket\u7528\u4e8e\u901a\u4fe1 16. var socket = new Socket({ 17. handle: clientHandle, 18. allowHalfOpen: self.allowHalfOpen, 19. pauseOnCreate: self.pauseOnConnect 20. }); 21. socket.readable = socket.writable = true; 22. // \u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u52a0\u4e00 23. self._connections++; 24. socket.server = self; 25. socket._server = self; 26. // \u89e6\u53d1\u7528\u6237\u5c42\u8fde\u63a5\u4e8b\u4ef6 27. self.emit('connection', socket); 28. } \u5728JS\u5c42\u4e5f\u4f1a\u5c01\u88c5\u4e00\u4e2aSocket\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u5269\u4e0b\u7684\u4e8b\u60c5\u5c31\u662f\u5e94\u7528\u5c42\u5904\u7406\u4e86\u3002","title":"17.2 TCP \u670d\u52a1\u5668"},{"location":"chapter17-TCP/#173-keepalive","text":"\u672c\u8282\u5206\u6790\u57fa\u4e8eTCP\u5c42\u7684\u957f\u8fde\u63a5\u95ee\u9898\uff0c\u76f8\u6bd4\u5e94\u7528\u5c42HTTP\u534f\u8bae\u7684\u957f\u8fde\u63a5\uff0cTCP\u5c42\u63d0\u4f9b\u7684\u529f\u80fd\u66f4\u591a\u3002TCP\u5c42\u5b9a\u4e49\u4e86\u4e09\u4e2a\u914d\u7f6e\u3002 1 \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u65ad\u5f00\u8fde\u63a5\u3002 \u6211\u4eec\u770bLinux\u5185\u6838\u4ee3\u7801\u91cc\u63d0\u4f9b\u7684\u914d\u7f6e\u3002 1. // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5c31\u53d1\u8d77\u63a2\u6d4b\u5305 2. #define TCP_KEEPALIVE_TIME (120*60*HZ) /* two hours */ 3. // \u63a2\u6d4b\u6b21\u6570 4. #define TCP_KEEPALIVE_PROBES 9 /* Max of 9 keepalive probes*/ 5. // \u6bcf\u9694\u591a\u4e45\u63a2\u6d4b\u4e00\u6b21 6. #define TCP_KEEPALIVE_INTVL (75*HZ) \u8fd9\u662fLinux\u63d0\u4f9b\u7684\u9ed8\u8ba4\u503c\u3002\u4e0b\u9762\u518d\u770b\u770b\u9608\u503c 1. #define MAX_TCP_KEEPIDLE 32767 2. #define MAX_TCP_KEEPINTVL 32767 3. #define MAX_TCP_KEEPCNT 127 \u8fd9\u4e09\u4e2a\u914d\u7f6e\u548c\u4e0a\u9762\u4e09\u4e2a\u4e00\u4e00\u5bf9\u5e94\u3002\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u9608\u503c\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dkeep-alive\u7684\u4f7f\u7528\u3002 socket.setKeepAlive([enable][, initialDelay]) enable\uff1a\u662f\u5426\u5f00\u542fkeep-alive\uff0cLinux\u4e0b\u9ed8\u8ba4\u662f\u4e0d\u5f00\u542f\u7684\u3002 initialDelay\uff1a\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5c31\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 \u63a5\u7740\u6211\u4eec\u770b\u770b\u8fd9\u4e2aAPI\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002 1. int uv__tcp_keepalive(int fd, int on, unsigned int delay) { 2. if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on))) 3. return UV__ERR(errno); 4. // Linux\u5b9a\u4e49\u4e86\u8fd9\u4e2a\u5b8f 5. #ifdef TCP_KEEPIDLE 6. /* 7. on\u662f1\u624d\u4f1a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5148\u5f00\u542fkeep-alive\uff0c\u5e76\u4e14\u8bbe\u7f6edelay\uff0c 8. \u7136\u540e\u5173\u95edkeep-alive\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u4f1a\u4fee\u6539\u4e4b\u524d\u4fee\u6539\u8fc7\u7684\u914d\u7f6e\u7684\u3002 9. \u56e0\u4e3a\u8fd9\u4e2a\u914d\u7f6e\u5728keep-alive\u5173\u95ed\u7684\u65f6\u5019\u662f\u6ca1\u7528\u7684 10. */ 11. if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay))) 12. return UV__ERR(errno); 13. #endif 14. 15. return 0; 16. } \u6211\u4eec\u770b\u5230Libuv\u8c03\u7528\u4e86\u540c\u4e00\u4e2a\u7cfb\u7edf\u51fd\u6570\u4e24\u6b21\u3002\u6211\u4eec\u5206\u522b\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u610f\u4e49\u3002\u53c2\u8003Linux2.6.13.1\u7684\u4ee3\u7801\u3002 1. // net\\socket.c 2. asmlinkage long sys_setsockopt(int fd, int level, int optname, char __user *optval, int optlen) 3. { 4. int err; 5. struct socket *sock; 6. 7. if ((sock = sockfd_lookup(fd, &err))!=NULL) 8. { 9. ... 10. if (level == SOL_SOCKET) 11. err=sock_setsockopt(sock,level,optname,optval,optlen); 12. else 13. err=sock->ops->setsockopt(sock, level, optname, optval, optlen); 14. sockfd_put(sock); 15. } 16. return err; 17. } \u5f53level\u662fSOL_SOCKET\u4ee3\u8868\u4fee\u6539\u7684socket\u5c42\u9762\u7684\u914d\u7f6e\u3002IPPROTO_TCP\u662f\u4fee\u6539TCP\u5c42\u7684\u914d\u7f6e\uff08\u8be5\u7248\u672c\u4ee3\u7801\u91cc\u662fSOL_TCP\uff09\u3002\u6211\u4eec\u5148\u770bSOL_SOCKET\u5c42\u9762\u7684\u3002 1. // net\\socket.c -> net\\core\\sock.c -> net\\ipv4\\tcp_timer.c 2. int sock_setsockopt(struct socket *sock, int level, int optname, 3. char __user *optval, int optlen) { 4. ... 5. case SO_KEEPALIVE: 6. 7. if (sk->sk_protocol == IPPROTO_TCP) 8. tcp_set_keepalive(sk, valbool); 9. // \u8bbe\u7f6eSOCK_KEEPOPEN\u6807\u8bb0\u4f4d1 10. sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool); 11. break; 12. ... 13. } sock_setcsockopt\u9996\u5148\u8c03\u7528\u4e86tcp_set_keepalive\u51fd\u6570\uff0c\u7136\u540e\u7ed9\u5bf9\u5e94socket\u7684SOCK_KEEPOPEN\u5b57\u6bb5\u6253\u4e0a\u6807\u8bb0\uff080\u6216\u80051\u8868\u793a\u5f00\u542f\u8fd8\u662f\u5173\u95ed\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770btcp_set_keepalive 1. void tcp_set_keepalive(struct sock *sk, int val) 2. { 3. if ((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)) 4. return; 5. /* 6. \u5982\u679cval\u662f1\u5e76\u4e14\u4e4b\u524d\u662f0\uff08\u6ca1\u5f00\u542f\uff09\u90a3\u4e48\u5c31\u5f00\u542f\u8ba1\u65f6\uff0c\u8d85\u65f6\u540e\u53d1\u9001\u63a2\u6d4b\u5305\uff0c 7. \u5982\u679c\u4e4b\u524d\u662f1\uff0cval\u53c8\u662f1\uff0c\u5219\u5ffd\u7565\uff0c\u6240\u4ee5\u91cd\u590d\u8bbe\u7f6e\u662f\u65e0\u5bb3\u7684 8. */ 9. if (val && !sock_flag(sk, SOCK_KEEPOPEN)) 10. tcp_reset_keepalive_timer(sk, keepalive_time_when(tcp_sk(sk))); 11. else if (!val) 12. // val\u662f0\u8868\u793a\u5173\u95ed\uff0c\u5219\u6e05\u9664\u5b9a\u65f6\u5668\uff0c\u5c31\u4e0d\u53d1\u9001\u63a2\u6d4b\u5305\u4e86 13. tcp_delete_keepalive_timer(sk); 14. } \u6211\u4eec\u770b\u770b\u8d85\u65f6\u540e\u7684\u903b\u8f91\u3002 1. // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u7b2c\u4e00\u4e2a\u63a2\u6d4b\u5305 2. static inline int keepalive_time_when(const struct tcp_sock *tp) 3. { 4. // \u7528\u6237\u8bbe\u7f6e\u7684\uff08TCP_KEEPIDLE\uff09\u548c\u7cfb\u7edf\u9ed8\u8ba4\u7684 5. return tp->keepalive_time ? : sysctl_tcp_keepalive_time; 6. } 7. // \u9694\u591a\u4e45\u53d1\u9001\u4e00\u4e2a\u63a2\u6d4b\u5305 8. static inline int keepalive_intvl_when(const struct tcp_sock *tp) 9. { 10. return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl; 11. } 12. 13. static void tcp_keepalive_timer (unsigned long data) 14. { 15. ... 16. // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 17. elapsed = tcp_time_stamp - tp->rcv_tstamp; 18. // \u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c 19. if (elapsed >= keepalive_time_when(tp)) { 20. // \u53d1\u9001\u7684\u63a2\u6d4b\u5305\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u53d1\u9001\u91cd\u7f6e\u5305 21. if ((!tp->keepalive_probes && tp->probes_out >= sysctl_tcp_keepalive_probes) || 22. (tp->keepalive_probes && tp->probes_out >= tp->keepalive_probes)) { 23. tcp_send_active_reset(sk, GFP_ATOMIC); 24. tcp_write_err(sk); 25. goto out; 26. } 27. // \u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u5e76\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u63a2\u6d4b\u5305\u7684\u53d1\u9001\u65f6\u95f4\uff08\u8d85\u65f6\u65f6\u95f4\uff09 28. tcp_write_wakeup(sk) 29. tp->probes_out++; 30. elapsed = keepalive_intvl_when(tp); 31. } else { 32. /* 33. \u8fd8\u6ca1\u5230\u671f\u5219\u91cd\u65b0\u8ba1\u7b97\u5230\u671f\u65f6\u95f4\uff0c\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\u5e94\u8be5\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\uff0c 34. \u6240\u4ee5\u6267\u884c\u8be5\u51fd\u6570\u8bf4\u660e\u7684\u786e\u662f\u8d85\u65f6\u4e86\uff0c\u6309\u7406\u8bf4\u4e0d\u4f1a\u8fdb\u5165\u8fd9\u91cc\u3002 35. */ 36. elapsed = keepalive_time_when(tp) - elapsed; 37. } 38. 39. TCP_CHECK_TIMER(sk); 40. sk_stream_mem_reclaim(sk); 41. 42. resched: 43. // \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668 44. tcp_reset_keepalive_timer (sk, elapsed); 45. ... \u6240\u4ee5\u5728SOL_SOCKET\u5c42\u9762\u662f\u8bbe\u7f6e\u662f\u5426\u5f00\u542fkeep-alive\u673a\u5236\u3002\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5c31\u4f1a\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0cSOL_SOCKET\u53ea\u662f\u8bbe\u7f6e\u4e86\u662f\u5426\u5f00\u542f\u63a2\u6d4b\u673a\u5236\uff0c\u5e76\u6ca1\u6709\u5b9a\u4e49\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u503c\uff0c\u6240\u4ee5\u7cfb\u7edf\u4f1a\u4f7f\u7528\u9ed8\u8ba4\u503c\u8fdb\u884c\u5fc3\u8df3\u673a\u5236\uff08\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u5f00\u542fkeep-alive\u7684\u8bdd\uff09\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48Libuv\u8c03\u4e86\u4e24\u6b21setsockopt\u51fd\u6570\u3002\u7b2c\u4e8c\u6b21\u7684\u8c03\u7528\u8bbe\u7f6e\u4e86\u5c31\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u4e2d\u7684\u7b2c\u4e00\u4e2a\uff08\u540e\u9762\u4e24\u4e2a\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\uff0c\u4e0d\u8fc7Libuv\u6ca1\u6709\u63d0\u4f9b\u63a5\u53e3\uff0c\u53ef\u4ee5\u81ea\u5df1\u8c03\u7528setsockopt\u8bbe\u7f6e\uff09\u3002\u90a3\u4e48\u6211\u4eec\u6765\u770b\u4e00\u4e0bLibuv\u7684\u7b2c\u4e8c\u6b21\u8c03\u7528setsockopt\u662f\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770bTCP\u5c42\u7684\u5b9e\u73b0\u3002 1. // net\\ipv4\\tcp.c 2. int tcp_setsockopt(struct sock *sk, int level, int optname, char __user *optval,int optlen) 3. { 4. ... 5. case TCP_KEEPIDLE: 6. // \u4fee\u6539\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\u7684\u914d\u7f6e 7. tp->keepalive_time = val * HZ; 8. // \u662f\u5426\u5f00\u542f\u4e86keep-alive\u673a\u5236 9. if (sock_flag(sk, SOCK_KEEPOPEN) && 10. !((1 << sk->sk_state) & 11. (TCPF_CLOSE | TCPF_LISTEN))) { 12. // \u5f53\u524d\u65f6\u95f4\u51cf\u53bb\u4e0a\u6b21\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5373\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 13. __u32 elapsed = tcp_time_stamp - tp->rcv_tstamp; 14. // \u7b97\u51fa\u8fd8\u8981\u591a\u4e45\u53ef\u4ee5\u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u8fd8\u662f\u53ef\u4ee5\u76f4\u63a5\u53d1\uff08\u5df2\u7ecf\u89e6\u53d1\u4e86\uff09 15. if (tp->keepalive_time > elapsed) 16. elapsed = tp->keepalive_time - elapsed; 17. else 18. elapsed = 0; 19. // \u8bbe\u7f6e\u5b9a\u65f6\u5668 20. tcp_reset_keepalive_timer(sk, elapsed); 21. } 22. ... 23. } \u8be5\u51fd\u6570\u9996\u5148\u4fee\u6539\u914d\u7f6e\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u5f00\u542f\u4e86keep-alive\u7684\u673a\u5236\uff0c\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5fc3\u8df3\u673a\u5236\u5e76\u4e0d\u662f\u4ec0\u4e48\u65f6\u5019\u90fd\u597d\u4f7f\uff0c\u5982\u679c\u4e24\u7aef\u90fd\u6ca1\u6709\u6570\u636e\u6765\u5f80\u65f6\uff0c\u5fc3\u8df3\u673a\u5236\u80fd\u5f88\u597d\u5730\u5de5\u4f5c\uff0c\u4f46\u662f\u4e00\u65e6\u672c\u7aef\u6709\u6570\u636e\u53d1\u9001\u7684\u65f6\u5019\uff0c\u5b83\u5c31\u4f1a\u6291\u5236\u5fc3\u8df3\u673a\u5236\u3002\u6211\u4eec\u770b\u4e00\u4e0bLinux\u5185\u68385.7.7\u7684\u4e00\u6bb5\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-3\u6240\u793a\u3002 \u56fe17-3 \u4e0a\u9762\u8fd9\u4e00\u6bb5\u662f\u5fc3\u8df3\u673a\u5236\u4e2d\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u6267\u884c\u7684\u4e00\u6bb5\u903b\u8f91\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8\u7ea2\u8272\u6846\u91cc\u7684\u4ee3\u7801\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5fc3\u8df3\u5b9a\u65f6\u5668\u8d85\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u53d1\u9001\u4e00\u4e2a\u65b0\u7684\u5fc3\u8df3\u5305\uff0c\u4f46\u662f\u5982\u679c\u53d1\u9001\u961f\u5217\u91cc\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u53d1\u9001\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4f18\u5148\u53d1\u9001\u3002\u6216\u8005\u53d1\u9001\u51fa\u53bb\u7684\u6ca1\u6709ack\uff0c\u4e5f\u4f1a\u4f18\u5148\u89e6\u53d1\u91cd\u4f20\u3002\u8fd9\u65f6\u5019\u5fc3\u8df3\u673a\u5236\u5c31\u5931\u6548\u4e86\u3002\u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0cLinux\u63d0\u4f9b\u4e86\u53e6\u4e00\u4e2a\u5c5e\u6027TCP_USER_TIMEOUT\u3002\u8fd9\u4e2a\u5c5e\u6027\u7684\u529f\u80fd\u662f\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u8ba4\u4e3a\u8fd9\u4e2a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-4\u6240\u793a\u3002 \u56fe17-4 \u4e0b\u9762\u662f\u8bbe\u7f6e\u9608\u503c\u7684\u4ee3\u7801\uff0c\u5982\u56fe17-5\u6240\u793a\u3002 \u56fe17-5 \u8fd9\u662f\u8d85\u65f6\u65f6\u5224\u65ad\u662f\u5426\u65ad\u5f00\u8fde\u63a5\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u5230\u6709\u4e24\u4e2a\u60c5\u51b5\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002 1 \u8bbe\u7f6e\u4e86TCP_USER_TIMEOUT\u65f6\uff0c\u5982\u679c\u53d1\u9001\u5305\u6570\u91cf\u5927\u4e8e1\u5e76\u4e14\u5f53\u524d\u65f6\u95f4\u8ddd\u79bb\u4e0a\u6b21\u6536\u5230\u5305\u7684\u65f6\u95f4\u95f4\u9694\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\u3002 2 \u6ca1\u6709\u8bbe\u7f6eTCP_USER_TIMEOUT\uff0c\u4f46\u662f\u5fc3\u8df3\u5305\u53d1\u9001\u6570\u91cf\u8fbe\u5230\u9608\u503c\u3002 \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u540c\u65f6\u8bbe\u7f6e\u8fd9\u4e24\u4e2a\u5c5e\u6027\u3002\u4fdd\u8bc1\u5fc3\u8df3\u673a\u5236\u53ef\u4ee5\u6b63\u5e38\u8fd0\u884c\uff0c Node.js\u7684keep-alive\u6709\u4e24\u4e2a\u5c42\u9762\u7684\u5185\u5bb9\uff0c\u7b2c\u4e00\u4e2a\u662f\u662f\u5426\u5f00\u542f\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5f00\u542f\u540e\uff0c\u4f7f\u7528\u7684\u914d\u7f6e\u3002Node.js\u7684setKeepAlive\u5c31\u662f\u505a\u4e86\u8fd9\u4e24\u4ef6\u4e8b\u60c5\u3002\u53ea\u4e0d\u8fc7\u5b83\u53ea\u652f\u6301\u4fee\u6539\u4e00\u4e2a\u914d\u7f6e\u3002Node.js\u53ea\u652f\u6301TCP_KEEPALIVE_TIME\u3002\u53e6\u5916\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u4ee3\u7801\u5224\u65ad\u914d\u7f6e\u7684\u503c\u3002 1. include <stdio.h> 2. #include <netinet/tcp.h> 3. 4. int main(int argc, const char *argv[]) 5. { 6. int sockfd; 7. int optval; 8. socklen_t optlen = sizeof(optval); 9. 10. sockfd = socket(AF_INET, SOCK_STREAM, 0); 11. getsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &optval, &optlen); 12. printf(\"\u9ed8\u8ba4\u662f\u5426\u5f00\u542fkeep-alive\uff1a%d \\n\", optval); 13. 14. getsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &optval, &optlen); 15. printf(\"\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\uff1a%d seconds \\n\", optval); 16. 17. getsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &optval, &optlen); 18. printf(\"\u591a\u4e45\u53d1\u9001\u4e00\u6b21\u63a2\u6d4b\u5305\uff1a%d seconds \\n\", optval); 19. 20. getsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &optval, &optlen); 21. printf(\"\u6700\u591a\u53d1\u9001\u51e0\u4e2a\u63a2\u6d4b\u5305\u5c31\u65ad\u5f00\u8fde\u63a5\uff1a%d \\n\", optval); 22. 23. return 0; 24. } \u8f93\u51fa\u5982\u56fe17-6\u6240\u793a\u3002 \u56fe17-6 \u518d\u770b\u4e00\u4e0bwireshark\u4e0b\u7684keepalive\u5305\uff0c\u5982\u56fe17-7\u6240\u793a\u3002 \u56fe17-7","title":"17.3 keepalive"},{"location":"chapter17-TCP/#174-allowhalfopen","text":"\u6211\u4eec\u77e5\u9053TCP\u8fde\u63a5\u5728\u6b63\u5e38\u65ad\u5f00\u7684\u65f6\u5019\uff0c\u4f1a\u8d70\u56db\u6b21\u6325\u624b\u7684\u6d41\u7a0b\uff0c\u5728Node.js\u4e2d\uff0c\u5f53\u6536\u5230\u5bf9\u7aef\u53d1\u9001\u8fc7\u6765\u7684fin\u5305\u65f6\uff0c\u56de\u590dack\u540e\uff0c\u9ed8\u8ba4\u4f1a\u53d1\u9001fin\u5305\u7ed9\u5bf9\u7aef\uff0c\u4ee5\u5b8c\u6210\u56db\u6b21\u6325\u624b\u3002\u4f46\u662f\u6211\u4eec\u53ef\u80fd\u4f1a\u6709\u8fd9\u6837\u7684\u573a\u666f\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u53d1\u9001fin\u5305\u8868\u793a\u81ea\u5df1\u6ca1\u6709\u6570\u636e\u53ef\u5199\u4e86\uff0c\u53ea\u9700\u8981\u7b49\u5f85\u670d\u52a1\u5668\u8fd4\u56de\u3002\u8fd9\u65f6\u5019\u5982\u679c\u670d\u52a1\u5668\u5728\u6536\u5230fin\u5305\u540e\uff0c\u4e5f\u56de\u590dfin\uff0c\u90a3\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u5728Node.js\u4e2d\u63d0\u4f9b\u4e86allowHalfOpen\u9009\u9879\u652f\u6301\u534a\u5173\u95ed\uff0c\u6211\u4eec\u77e5\u9053TCP\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4e24\u7aef\u53ef\u4ee5\u540c\u65f6\u4e92\u76f8\u53d1\u9001\u6570\u636e\uff0callowHalfOpen\u76f8\u5f53\u4e8e\u628a\u4e00\u7aef\u5173\u95ed\u4e86\uff0c\u5141\u8bb8\u6570\u636e\u5355\u5411\u4f20\u8f93\u3002\u6211\u4eec\u770b\u4e00\u4e0ballowHalfOpen\u7684\u5b9e\u73b0\u3002allowHalfOpen\u662f\u5c5e\u4e8eSocket\u7684\u9009\u9879\u3002\u6211\u4eec\u4eceNode.js\u6536\u5230\u4e00\u4e2afin\u5305\u5f00\u59cb\u5206\u6790\u6574\u4e2a\u6d41\u7a0b\u3002\u9996\u5148\u5728\u65b0\u5efaSocket\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u6ce8\u518c\u5bf9\u5e94\u4e8b\u4ef6\u3002 socket.on('_socketEnd', onSocketEnd); \u5f53\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230fin\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1socket\u7684\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6267\u884cNode.js\u7684\u8bfb\u56de\u8c03\u3002Node.js\u6267\u884c\u8bfb\u53d6\u7684\u65f6\u5019\u53d1\u73b0\uff0c\u8bfb\u53d6\u5df2\u7ed3\u675f\uff0c\u56e0\u4e3a\u5bf9\u7aef\u53d1\u9001\u4e86fin\u5305\u3002\u8fd9\u65f6\u5019\u4f1a\u89e6\u53d1_socketEnd\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\u3002 1. function onSocketEnd() { 2. // ... 3. if (!this.allowHalfOpen) { 4. this.write = writeAfterFIN; 5. this.destroySoon(); 6. } 7. } allowHalfOpen\u9ed8\u8ba4\u662ffalse\u3002onSocketEnd\u9996\u5148\u8bbe\u7f6ewrite\u51fd\u6570\u4e3awriteAfterFIN\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u5982\u679c\u6211\u4eec\u5199\u4f1a\u600e\u6837\u3002\u6211\u4eec\u4f1a\u6536\u5230\u4e00\u4e2a\u9519\u8bef\u3002 1. function writeAfterFIN(chunk, encoding, cb) { 2. var er = new Error('This socket has been ended by the other party'); 3. er.code = 'EPIPE'; 4. this.emit('error', er); 5. if (typeof cb === 'function') { 6. nextTick(this[async_id_symbol], cb, er); 7. } 8. } \u8bbe\u7f6e\u5b8cwrite\u540e\uff0c\u63a5\u7740Node.js\u4f1a\u53d1\u9001fin\u5305\u3002 1. Socket.prototype.destroySoon = function() { 2. // \u5173\u95ed\u5199\u6d41 3. if (this.writable) 4. this.end(); 5. // \u5173\u95ed\u6210\u529f\u540e\u9500\u6bc1\u6d41 6. if (this._writableState.finished) 7. this.destroy(); 8. else 9. this.once('finish', this.destroy); 10. }; \u9996\u5148\u5173\u95ed\u5199\u6d41\uff0c\u7136\u540e\u6267\u884cdestroy\u51fd\u6570\u9500\u6bc1\u6d41\u3002\u5728destroy\u4e2d\u4f1a\u6267\u884c_destroy\u3002_destroy\u4f1a\u6267\u884c\u5177\u4f53\u7684\u5173\u95ed\u64cd\u4f5c\uff0c\u5373\u53d1\u9001fin\u5305\u3002 1. this._handle.close(() => { 2. this.emit('close', isException); 3. }); \u6211\u4eec\u770b\u5230C++\u5c42\u7684close\u3002 1. void HandleWrap::Close(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. 4. HandleWrap* wrap; 5. ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); 6. // \u5173\u95edhandle 7. uv_close(wrap->handle_, OnClose); 8. wrap->state_ = kClosing; 9. // \u6267\u884c\u56de\u8c03\uff0c\u89e6\u53d1close\u4e8b\u4ef6 10. if (args[0]->IsFunction()) { 11. wrap->object()->Set(env->onclose_string(), args[0]); 12. wrap->state_ = kClosingWithCallback; 13. } 14. } \u6211\u4eec\u7ee7\u7eed\u5f80Libuv\u770b\u3002 1. void uv_close(uv_handle_t* handle, uv_close_cb cb) { 2. uv_loop_t* loop = handle->loop; 3. 4. handle->close_cb = cb; 5. switch (handle->type) { 6. case UV_TCP: 7. uv_tcp_close(loop, (uv_tcp_t*)handle); 8. return; 9. 10. // ... 11. } 12. } uv_tcp_close\u4f1a\u5bf9close\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770btcp close\u7684\u5927\u81f4\u5b9e\u73b0\u3002 1. static void tcp_close(struct sock *sk, int timeout) 2. { 3. 4. // \u76d1\u542c\u578b\u7684socket\u8981\u5173\u95ed\u5efa\u7acb\u7684\u8fde\u63a5 5. if(sk->state == TCP_LISTEN) 6. { 7. /* Special case */ 8. tcp_set_state(sk, TCP_CLOSE); 9. // \u5173\u95ed\u5df2\u7ecf\u5efa\u7acb\u7684\u8fde\u63a5 10. tcp_close_pending(sk); 11. release_sock(sk); 12. return; 13. } 14. 15. struct sk_buff *skb; 16. // \u9500\u6bc1\u63a5\u6536\u961f\u5217\u4e2d\u672a\u5904\u7406\u7684\u6570\u636e 17. while((skb=skb_dequeue(&sk->receive_queue))!=NULL) 18. kfree_skb(skb, FREE_READ); 19. // \u53d1\u9001fin\u5305 20. tcp_send_fin(sk); 21. release_sock(sk); 22. } \u4ee5\u4e0a\u662fNode.js\u4e2dsocket\u6536\u5230fin\u5305\u65f6\u7684\u9ed8\u8ba4\u5904\u7406\u6d41\u7a0b\uff0c\u5f53\u6211\u4eec\u8bbe\u7f6eallowHalfOpen\u4e3atrue\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u9ed8\u8ba4\u7684\u884c\u4e3a\uff0c\u5141\u8bb8\u534a\u5173\u95ed\u72b6\u6001\u7684\u8fde\u63a5\u3002","title":"17.4 allowHalfOpen"},{"location":"chapter17-TCP/#175-server-close","text":"\u8c03\u7528close\u53ef\u4ee5\u5173\u95ed\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6587\u6863\u5173\u4e8eclose\u51fd\u6570\u7684\u89e3\u91ca Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. The optional callback will be called once the 'close' event occurs. Unlike that event, it will be called with an Error as its only argument if the server was not open when it was closed. \u5728Node.js\u4e2d \uff0c\u5f53\u6211\u4eec\u4f7f\u7528close\u5173\u95ed\u4e00\u4e2aserver\u65f6\uff0cserver\u4f1a\u7b49\u6240\u6709\u7684\u8fde\u63a5\u5173\u95ed\u540e\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u6211\u4eec\u770bclose\u7684\u5b9e\u73b0\uff0c\u4e00\u63a2\u7a76\u7adf\u3002 1. Server.prototype.close = function(cb) { 2. // \u89e6\u53d1\u56de\u8c03 3. if (typeof cb === 'function') { 4. if (!this._handle) { 5. this.once('close', function close() { 6. cb(new errors.Error('ERR_SERVER_NOT_RUNNING')); 7. }); 8. } else { 9. this.once('close', cb); 10. } 11. } 12. // \u5173\u95ed\u5e95\u5c42\u8d44\u6e90 13. if (this._handle) { 14. this._handle.close(); 15. this._handle = null; 16. } 17. // \u5224\u65ad\u662f\u5426\u9700\u8981\u7acb\u523b\u89e6\u53d1close\u4e8b\u4ef6 18. this._emitCloseIfDrained(); 19. return this; 20. }; close\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u76d1\u542cclose\u4e8b\u4ef6\uff0c\u7136\u540e\u5173\u95edserver\u5bf9\u5e94\u7684handle\uff0c\u6240\u4ee5server\u4e0d\u4f1a\u518d\u63a5\u6536\u65b0\u7684\u8bf7\u6c42\u4e86\u3002\u6700\u540e\u8c03\u7528_emitCloseIfDrained\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u662f\u5e72\u561b\u7684\u3002 1. Server.prototype._emitCloseIfDrained = function() { 2. // \u8fd8\u6709\u8fde\u63a5\u6216\u8005handle\u975e\u7a7a\u8bf4\u660ehandle\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u5148\u4e0d\u89e6\u53d1close\u4e8b\u4ef6 3. if (this._handle || this._connections) { 4. return; 5. } 6. // \u89e6\u53d1close\u4e8b\u4ef6 7. const asyncId = this._handle ? this[async_id_symbol] : null; 8. nextTick(asyncId, emitCloseNT, this); 9. }; 10. 11. 12. function emitCloseNT(self) { 13. self.emit('close'); 14. } _emitCloseIfDrained\u4e2d\u6709\u4e00\u4e2a\u62e6\u622a\u7684\u5224\u65ad\uff0chandle\u975e\u7a7a\u6216\u8005\u8fde\u63a5\u6570\u975e0\u3002\u7531\u4e4b\u524d\u7684\u4ee3\u7801\u6211\u4eec\u5df2\u7ecf\u77e5\u9053handle\u662fnull\uff0c\u4f46\u662f\u5982\u679c\u8fd9\u65f6\u5019\u8fde\u63a5\u6570\u975e0\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u90a3\u4ec0\u4e48\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u5462\uff1f\u5728socket\u7684_destroy\u51fd\u6570\u4e2d\u6211\u4eec\u627e\u5230\u4fee\u6539\u8fde\u63a5\u6570\u7684\u903b\u8f91\u3002 1. Socket.prototype._destroy = function(exception, cb) { 2. ... 3. // socket\u6240\u5c5e\u7684server 4. if (this._server) { 5. // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 6. this._server._connections--; 7. // \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c\u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 8. if (this._server._emitCloseIfDrained) { 9. this._server._emitCloseIfDrained(); 10. } 11. } 12. }; \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u4e2a\u8fde\u63a5\u5173\u95ed\u7684\u65f6\u5019\uff0c\u90fd\u4f1a\u5bfc\u81f4\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u76f4\u5230\u4e3a0\u7684\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u5047\u8bbe\u6211\u4eec\u542f\u52a8\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u63a5\u6536\u5230\u4e86\u4e00\u4e9b\u5ba2\u6237\u7aef\u7684\u8bf7\u6c42\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u60f3\u4fee\u6539\u4e00\u4e2a\u4ee3\u7801\u53d1\u5e03\uff0c\u9700\u8981\u91cd\u542f\u670d\u52a1\u5668\uff0c\u600e\u4e48\u529e\uff1f\u5047\u8bbe\u6211\u4eec\u6709\u4ee5\u4e0b\u4ee3\u7801\u3002 server.js 1. const net = require('net'); 2. const server = net.createServer().listen(80); client.js 1. const net = require('net'); 2. net.connect({port:80}) \u5982\u679c\u6211\u4eec\u76f4\u63a5\u6740\u6b7b\u8fdb\u7a0b\uff0c\u90a3\u4e48\u5b58\u91cf\u7684\u8bf7\u6c42\u5c31\u4f1a\u65e0\u6cd5\u6b63\u5e38\u88ab\u5904\u7406\u3002\u8fd9\u4f1a\u5f71\u54cd\u6211\u4eec\u7684\u670d\u52a1\u8d28\u91cf\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u5982\u4f55\u5728\u91cd\u542f\u65f6\u4f18\u96c5\u5730\u9000\u51fa\uff0c\u6240\u8c13\u4f18\u96c5\uff0c\u5373\u8ba9Node.js\u8fdb\u7a0b\u5904\u7406\u5b8c\u5b58\u91cf\u8bf7\u6c42\u540e\u518d\u9000\u51fa\u3002Server\u7684close\u7684\u5b9e\u73b0\u7ed9\u4e86\u6211\u4eec\u4e00\u4e9b\u601d\u8def\u3002\u6211\u4eec\u53ef\u4ee5\u76d1\u542cserver\u7684close\u4e8b\u4ef6\uff0c\u7b49\u5230\u89e6\u53d1close\u4e8b\u4ef6\u540e\u624d\u9000\u51fa\u8fdb\u7a0b\u3002 1. const net = require('net'); 2. const server = net.createServer().listen(80); 3. server.on('close', () => { 4. process.exit(); 5. }); 6. // \u9632\u6b62\u8fdb\u7a0b\u63d0\u524d\u6302\u6389 7. process.on('uncaughtException', () => { 8. 9. }); 10. process.on('SIGINT', function() { 11. server.close(); 12. }) \u6211\u4eec\u9996\u5148\u76d1\u542cSIGINT\u4fe1\u53f7\uff0c\u5f53\u6211\u4eec\u4f7f\u7528SIGINT\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b\u65f6\uff0c\u9996\u5148\u8c03\u7528server.close\uff0c\u7b49\u5230\u6240\u6709\u7684\u8fde\u63a5\u65ad\u5f00\uff0c\u89e6\u53d1close\u65f6\u5019\u65f6\uff0c\u518d\u9000\u51fa\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u5f00\u542f\u670d\u52a1\u5668\uff0c\u7136\u540e\u5f00\u542f\u4e24\u4e2a\u5ba2\u6237\u7aef\u3002\u63a5\u7740\u6309\u4e0bctrl+c\uff0c\u6211\u4eec\u53d1\u73b0\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u4e0d\u4f1a\u9000\u51fa\uff0c\u7136\u540e\u6211\u4eec\u5173\u95ed\u4e24\u4e2a\u5ba2\u6237\u7aef\uff0c\u8fd9\u65f6\u5019server\u5c31\u4f1a\u4f18\u96c5\u5730\u9000\u51fa\u3002","title":"17.5 server close"},{"location":"chapter18-HTTP/","text":"HTTP\u6a21\u5757\u5b9e\u73b0\u4e86HTTP\u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u7684\u529f\u80fd\uff0c\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\uff0c\u4e5f\u662f\u6211\u4eec\u4f7f\u7528\u5f97\u6700\u591a\u7684\u6a21\u5757\u3002\u672c\u7ae0\u6211\u4eec\u6765\u5206\u6790HTTP\u6a21\u5757\uff0c\u4ece\u4e2d\u6211\u4eec\u53ef\u4ee5\u5b66\u4e60\u5230\u4e00\u4e2aHTTP\u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u662f\u600e\u4e48\u5b9e\u73b0\u7684\uff0c\u4ee5\u53caHTTP\u534f\u8bae\u672c\u8eab\u7684\u4e00\u4e9b\u539f\u7406\u548c\u4f18\u5316\u3002 18.1 HTTP\u89e3\u6790\u5668 \u00b6 HTTP\u89e3\u6790\u5668\u662fHTTP\u6a21\u5757\u7684\u6838\u5fc3\uff0c\u4e0d\u7ba1\u662f\u4f5c\u4e3a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u8fd8\u662f\u5ba2\u6237\u7aef\u5904\u7406\u54cd\u5e94\u90fd\u9700\u8981\u4f7f\u7528HTTP\u89e3\u6790\u5668\u89e3\u6790HTTP\u534f\u8bae\u3002\u65b0\u7248Node.js\u4f7f\u7528\u4e86\u65b0\u7684HTTP\u89e3\u6790\u5668llhttp\u3002\u6839\u636e\u5b98\u65b9\u8bf4\u660ellhttp\u6bd4\u65e7\u7248\u7684http_parser\u5728\u6027\u80fd\u4e0a\u6709\u4e86\u975e\u5e38\u5927\u7684\u63d0\u9ad8\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u5206\u6790llhttp\u7684\u57fa\u7840\u539f\u7406\u548c\u4f7f\u7528\u3002HTTP\u89e3\u6790\u5668\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u72b6\u6001\u673a\uff0c\u5728\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u4e0b\u9762\u662fllhttp\u652f\u6301\u7684\u94a9\u5b50\u51fd\u6570\u3002\u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u5c31\u4f1a\u88ab\u56de\u8c03\u3002 1. // \u5f00\u59cb\u89e3\u6790HTTP\u534f\u8bae 2. int llhttp__on_message_begin(llhttp_t* s, const char* p, const char* endp) { 3. int err; 4. CALLBACK_MAYBE(s, on_message_begin, s); 5. return err; 6. } 7. 8. // \u89e3\u6790\u51fa\u8bf7\u6c42url\u65f6\u7684\u56de\u8c03\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2aurl 9. int llhttp__on_url(llhttp_t* s, const char* p, const char* endp) { 10. int err; 11. CALLBACK_MAYBE(s, on_url, s, p, endp - p); 12. return err; 13. } 14. 15. // \u89e3\u6790\u51faHTTP\u54cd\u5e94\u72b6\u6001\u7684\u56de\u8c03 16. int llhttp__on_status(llhttp_t* s, const char* p, const char* endp) { 17. int err; 18. CALLBACK_MAYBE(s, on_status, s, p, endp - p); 19. return err; 20. } 21. 22. // \u89e3\u6790\u51fa\u5934\u90e8\u952e\u65f6\u7684\u56de\u8c03 23. int llhttp__on_header_field(llhttp_t* s, const char* p, const char* endp) { 24. int err; 25. CALLBACK_MAYBE(s, on_header_field, s, p, endp - p); 26. return err; 27. } 28. 29. // \u89e3\u6790\u51fa\u5934\u90e8\u503c\u65f6\u7684\u56de\u8c03 30. int llhttp__on_header_value(llhttp_t* s, const char* p, const char* endp) { 31. int err; 32. CALLBACK_MAYBE(s, on_header_value, s, p, endp - p); 33. return err; 34. } 35. 36. // \u89e3\u6790HTTP\u5934\u5b8c\u6210\u65f6\u7684\u56de\u8c03 37. int llhttp__on_headers_complete(llhttp_t* s, const char* p, const char* endp) { 38. int err; 39. CALLBACK_MAYBE(s, on_headers_complete, s); 40. return err; 41. } 42. 43. // \u89e3\u6790\u5b8cbody\u7684\u56de\u8c03 44. int llhttp__on_message_complete(llhttp_t* s, const char* p, const char* endp) { 45. int err; 46. CALLBACK_MAYBE(s, on_message_complete, s); 47. return err; 48. } 49. 50. // \u89e3\u6790body\u65f6\u7684\u56de\u8c03 51. int llhttp__on_body(llhttp_t* s, const char* p, const char* endp) { 52. int err; 53. CALLBACK_MAYBE(s, on_body, s, p, endp - p); 54. return err; 55. } 56. 57. // \u89e3\u6790\u5230\u4e00\u4e2achunk\u7ed3\u6784\u5934\u65f6\u7684\u56de\u8c03 58. int llhttp__on_chunk_header(llhttp_t* s, const char* p, const char* endp) { 59. int err; 60. CALLBACK_MAYBE(s, on_chunk_header, s); 61. return err; 62. } 63. 64. // \u89e3\u6790\u5b8c\u4e00\u4e2achunk\u65f6\u7684\u56de\u8c03 65. int llhttp__on_chunk_complete(llhttp_t* s, const char* p, const char* endp) { 66. int err; 67. CALLBACK_MAYBE(s, on_chunk_complete, s); 68. return err; 69. } Node.js\u5728node_http_parser.cc\u4e2d\u5bf9llhttp\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8be5\u6a21\u5757\u5bfc\u51fa\u4e86\u4e00\u4e2aHTTPParser\u3002 1. Local<FunctionTemplate> t=env->NewFunctionTemplate(Parser::New); 2. t->InstanceTemplate()->SetInternalFieldCount(1); 3. t->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), 4. \"HTTPParser\")); 5. target->Set(env->context(), 6. FIXED_ONE_BYTE_STRING(env->isolate(), \"HTTPParser\"), 7. t->GetFunction(env->context()).ToLocalChecked()).Check(); \u5728Node.js\u4e2d\u6211\u4eec\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528HTTPParser\u3002 1. const parser = new HTTPParser(); 2. 3. cleanParser(parser); 4. parser.onIncoming = null; 5. parser[kOnHeaders] = parserOnHeaders; 6. parser[kOnHeadersComplete] = parserOnHeadersComplete; 7. parser[kOnBody] = parserOnBody; 8. parser[kOnMessageComplete] = parserOnMessageComplete; 9. // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u5904\u7406\u7684\u62a5\u6587\u7c7b\u578b\uff0c\u8fd9\u91cc\u662f\u54cd\u5e94\u62a5\u6587 10. parser.initialize(HTTPParser.RESPONSE, 11. new HTTPClientAsyncResource('HTTPINCOMINGMESSAGE', req), 12. req.maxHeaderSize || 0, 13. req.insecureHTTPParser === undefined ? 14. isLenient() : req.insecureHTTPParser); 15. // \u6536\u5230\u6570\u636e\u540e\u4f20\u7ed9\u89e3\u6790\u5668\u5904\u7406 16. const ret = parser.execute(data); 17. } \u6211\u4eec\u770b\u4e00\u4e0binitialize\u548cexecute\u7684\u4ee3\u7801\u3002Initialize\u51fd\u6570\u7528\u4e8e\u521d\u59cb\u5316llhttp\u3002 1. static void Initialize(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. bool lenient = args[3]->IsTrue(); 4. 5. uint64_t max_http_header_size = 0; 6. // \u5934\u90e8\u7684\u6700\u5927\u5927\u5c0f 7. if (args.Length() > 2) { 8. max_http_header_size = args[2].As<Number>()->Value(); 9. } 10. // \u6ca1\u6709\u8bbe\u7f6e\u5219\u53d6Node.js\u7684\u9ed8\u8ba4\u503c 11. if (max_http_header_size == 0) { 12. max_http_header_size=env->options()->max_http_header_size; 13. } 14. // \u89e3\u6790\u7684\u62a5\u6587\u7c7b\u578b 15. llhttp_type_t type = 16. static_cast<llhttp_type_t>(args[0].As<Int32>()->Value()); 17. 18. CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE); 19. Parser* parser; 20. ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder()); 21. parser->Init(type, max_http_header_size, lenient); 22. } Initialize\u505a\u4e86\u4e00\u4e9b\u9884\u5904\u7406\u540e\u8c03\u7528Init\u3002 1. void Init(llhttp_type_t type, uint64_t max_http_header_size, bool lenient) { 2. // \u521d\u59cb\u5316llhttp 3. llhttp_init(&parser_, type, &settings); 4. llhttp_set_lenient(&parser_, lenient); 5. header_nread_ = 0; 6. url_.Reset(); 7. status_message_.Reset(); 8. num_fields_ = 0; 9. num_values_ = 0; 10. have_flushed_ = false; 11. got_exception_ = false; 12. max_http_header_size_ = max_http_header_size; 13. } Init\u505a\u4e86\u4e00\u4e9b\u5b57\u6bb5\u7684\u521d\u59cb\u5316\uff0c\u6700\u91cd\u8981\u7684\u662f\u8c03\u7528\u4e86llhttp_init\u5bf9llhttp\u8fdb\u884c\u4e86\u521d\u59cb\u5316\uff0c\u53e6\u5916kOn\u5f00\u5934\u7684\u5c5e\u6027\u662f\u94a9\u5b50\u51fd\u6570\uff0c\u7531node_http_parser.cc\u4e2d\u7684\u56de\u8c03\uff0c\u800cnode_http_parser.cc\u4e5f\u4f1a\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\uff0c\u7531llhttp\u56de\u8c03\uff0c\u6211\u4eec\u770b\u4e00\u4e0bnode_http_parser.cc\u94a9\u5b50\u51fd\u6570\u7684\u5b9a\u4e49\u548c\u5b9e\u73b0\u3002 1. const llhttp_settings_t Parser::settings = { 2. Proxy<Call, &Parser::on_message_begin>::Raw, 3. Proxy<DataCall, &Parser::on_url>::Raw, 4. Proxy<DataCall, &Parser::on_status>::Raw, 5. Proxy<DataCall, &Parser::on_header_field>::Raw, 6. Proxy<DataCall, &Parser::on_header_value>::Raw, 7. Proxy<Call, &Parser::on_headers_complete>::Raw, 8. Proxy<DataCall, &Parser::on_body>::Raw, 9. Proxy<Call, &Parser::on_message_complete>::Raw, 10. Proxy<Call, &Parser::on_chunk_header>::Raw, 11. Proxy<Call, &Parser::on_chunk_complete>::Raw, 12. }; 1 \u5f00\u59cb\u89e3\u6790\u62a5\u6587\u7684\u56de\u8c03 1. // \u5f00\u59cb\u89e3\u6790\u62a5\u6587\uff0c\u4e00\u4e2aTCP\u8fde\u63a5\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u62a5\u6587 2. int on_message_begin() { 3. num_fields_ = num_values_ = 0; 4. url_.Reset(); 5. status_message_.Reset(); 6. return 0; 7. } 2 \u89e3\u6790url\u65f6\u7684\u56de\u8c03 1. int on_url(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. 7. url_.Update(at, length); 8. return 0; 9. } 3\u89e3\u6790HTTP\u54cd\u5e94\u65f6\u7684\u56de\u8c03 1. int on_status(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. 7. status_message_.Update(at, length); 8. return 0; 9. } 4\u89e3\u6790\u5230HTTP\u5934\u7684\u952e\u65f6\u56de\u8c03 1. int on_header_field(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. // \u76f8\u7b49\u8bf4\u660e\u952e\u5bf9\u503c\u7684\u89e3\u6790\u662f\u4e00\u4e00\u5bf9\u5e94\u7684 7. if (num_fields_ == num_values_) { 8. // start of new field name 9. // \u952e\u7684\u6570\u52a0\u4e00 10. num_fields_++; 11. // \u8d85\u8fc7\u9608\u503c\u5219\u5148\u56de\u8c03js\u6d88\u8d39\u6389 12. if (num_fields_ == kMaxHeaderFieldsCount) { 13. // ran out of space - flush to javascript land 14. Flush(); 15. // \u91cd\u65b0\u5f00\u59cb 16. num_fields_ = 1; 17. num_values_ = 0; 18. } 19. // \u521d\u59cb\u5316 20. fields_[num_fields_ - 1].Reset(); 21. } 22. 23. // \u4fdd\u5b58\u952e 24. fields_[num_fields_ - 1].Update(at, length); 25. 26. return 0; 27. } \u5f53\u89e3\u6790\u7684\u5934\u90e8\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u65f6\uff0cNode.js\u4f1a\u5148\u901a\u8fc7Flush\u51fd\u6570\u56de\u8c03JS\u5c42\u4fdd\u5b58\u5f53\u524d\u7684\u4e00\u4e9b\u6570\u636e\u3002 1. void Flush() { 2. HandleScope scope(env()->isolate()); 3. 4. Local<Object> obj = object(); 5. // JS\u5c42\u7684\u94a9\u5b50 6. Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked(); 7. if (!cb->IsFunction()) 8. return; 9. 10. Local<Value> argv[2] = { 11. CreateHeaders(), 12. url_.ToString(env()) 13. }; 14. 15. MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 16. arraysize(argv), 17. argv); 18. url_.Reset(); 19. have_flushed_ = true; 20. } 21. 22. Local<Array> CreateHeaders() { 23. // HTTP\u5934\u7684\u4e2a\u6570\u4e58\u4ee52\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5934\u7531\u952e\u548c\u503c\u7ec4\u6210 24. Local<Value> headers_v[kMaxHeaderFieldsCount * 2]; 25. // \u4fdd\u5b58\u952e\u548c\u503c\u5230HTTP\u5934 26. for (size_t i = 0; i < num_values_; ++i) { 27. headers_v[i * 2] = fields_[i].ToString(env()); 28. headers_v[i * 2 + 1] = values_[i].ToString(env()); 29. } 30. 31. return Array::New(env()->isolate(), headers_v, num_values_ * 2); 32. } 33. Flush\u4f1a\u8c03\u7528JS\u5c42\u7684kOnHeaders\u94a9\u5b50\u51fd\u6570\u3002 5\u89e3\u6790\u5230HTTP\u5934\u7684\u503c\u65f6\u56de\u8c03 1. int on_header_value(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. /* 7. \u503c\u7684\u4e2a\u6570\u4e0d\u7b49\u4e8e\u952e\u7684\u4e2a\u6570\u8bf4\u660e\u6b63\u89e3\u6790\u5230\u952e\u5bf9\u5e94\u7684\u503c\uff0c\u5373\u4e00\u4e00\u5bf9\u5e94\u3002 8. \u5426\u5219\u8bf4\u660e\u4e00\u4e2a\u952e\u5b58\u5728\u591a\u4e2a\u503c\uff0c\u5219\u4e0d\u66f4\u65b0\u503c\u7684\u4e2a\u6570\uff0c\u591a\u4e2a\u503c\u7d2f\u52a0\u5230\u4e00\u4e2aslot 9. */ 10. if (num_values_ != num_fields_) { 11. // start of new header value 12. num_values_++; 13. values_[num_values_ - 1].Reset(); 14. } 15. 16. CHECK_LT(num_values_, arraysize(values_)); 17. CHECK_EQ(num_values_, num_fields_); 18. 19. values_[num_values_ - 1].Update(at, length); 20. 21. return 0; 22. } 6\u89e3\u6790\u5b8cHTTP\u5934\u540e\u7684\u56de\u8c03 1. int on_headers_complete() { 2. header_nread_ = 0; 3. enum on_headers_complete_arg_index { 4. A_VERSION_MAJOR = 0, 5. A_VERSION_MINOR, 6. A_HEADERS, 7. A_METHOD, 8. A_URL, 9. A_STATUS_CODE, 10. A_STATUS_MESSAGE, 11. A_UPGRADE, 12. A_SHOULD_KEEP_ALIVE, 13. A_MAX 14. }; 15. 16. Local<Value> argv[A_MAX]; 17. Local<Object> obj = object(); 18. Local<Value> cb = obj->Get(env()->context(), 19. kOnHeadersComplete).ToLocalChecked(); 20. 21. Local<Value> undefined = Undefined(env()->isolate()); 22. for (size_t i = 0; i < arraysize(argv); i++) 23. argv[i] = undefined; 24. // \u4e4b\u524dflush\u8fc7\uff0c\u5219\u7ee7\u7eedflush\u5230JS\u5c42\uff0c\u5426\u5219\u8fd4\u56de\u5168\u90e8\u5934\u7ed9js 25. if (have_flushed_) { 26. // Slow case, flush remaining headers. 27. Flush(); 28. } else { 29. // Fast case, pass headers and URL to JS land. 30. argv[A_HEADERS] = CreateHeaders(); 31. if (parser_.type == HTTP_REQUEST) 32. argv[A_URL] = url_.ToString(env()); 33. } 34. 35. num_fields_ = 0; 36. num_values_ = 0; 37. 38. // METHOD 39. if (parser_.type == HTTP_REQUEST) { 40. argv[A_METHOD] = 41. Uint32::NewFromUnsigned(env()->isolate(), parser_.method); 42. } 43. 44. // STATUS 45. if (parser_.type == HTTP_RESPONSE) { 46. argv[A_STATUS_CODE] = 47. Integer::New(env()->isolate(), parser_.status_code); 48. argv[A_STATUS_MESSAGE] = status_message_.ToString(env()); 49. } 50. 51. // VERSION 52. argv[A_VERSION_MAJOR] = Integer::New(env()->isolate(), parser_.http_major); 53. argv[A_VERSION_MINOR] = Integer::New(env()->isolate(), parser_.http_minor); 54. 55. bool should_keep_alive; 56. // \u662f\u5426\u5b9a\u4e49\u4e86keepalive\u5934 57. should_keep_alive = llhttp_should_keep_alive(&parser_); 58. 59. argv[A_SHOULD_KEEP_ALIVE] = 60. Boolean::New(env()->isolate(), should_keep_alive); 61. // \u662f\u5426\u662f\u5347\u7ea7\u534f\u8bae 62. argv[A_UPGRADE] = Boolean::New(env()->isolate(), parser_.upgrade); 63. 64. MaybeLocal<Value> head_response; 65. { 66. InternalCallbackScope callback_scope( 67. this, InternalCallbackScope::kSkipTaskQueues); 68. head_response = cb.As<Function>()->Call( 69. env()->context(), object(), arraysize(argv), argv); 70. } 71. 72. int64_t val; 73. 74. if (head_response.IsEmpty() || !head_response.ToLocalChecked() 75. ->IntegerValue(env()->context()) 76. .To(&val)) { 77. got_exception_ = true; 78. return -1; 79. } 80. 81. return val; 82. } on_headers_complete\u4f1a\u6267\u884cJS\u5c42\u7684kOnHeadersComplete\u94a9\u5b50\u3002 7 \u89e3\u6790body\u65f6\u7684\u56de\u8c03 1. int on_body(const char* at, size_t length) { 2. EscapableHandleScope scope(env()->isolate()); 3. 4. Local<Object> obj = object(); 5. Local<Value> cb = obj->Get(env()->context(), kOnBody).ToLocalChecked(); 6. 7. // We came from consumed stream 8. if (current_buffer_.IsEmpty()) { 9. // Make sure Buffer will be in parent HandleScope 10. current_buffer_ = scope.Escape(Buffer::Copy( 11. env()->isolate(), 12. current_buffer_data_, 13. current_buffer_len_).ToLocalChecked()); 14. } 15. 16. Local<Value> argv[3] = { 17. // \u5f53\u524d\u89e3\u6790\u4e2d\u7684\u6570\u636e 18. current_buffer_, 19. // body\u5f00\u59cb\u7684\u4f4d\u7f6e 20. Integer::NewFromUnsigned(env()->isolate(), at - current_buffer_data_), 21. // body\u5f53\u524d\u957f\u5ea6 22. Integer::NewFromUnsigned(env()->isolate(), length) 23. }; 24. 25. MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 26. arraysize(argv), 27. argv); 28. 29. return 0; 30. } Node.js\u4e2d\u5e76\u4e0d\u662f\u6bcf\u6b21\u89e3\u6790HTTP\u62a5\u6587\u7684\u65f6\u5019\u5c31\u65b0\u5efa\u4e00\u4e2aHTTP\u89e3\u6790\u5668\uff0cNode.js\u4f7f\u7528FreeList\u6570\u636e\u7ed3\u6784\u5bf9HTTP\u89e3\u6790\u5668\u5b9e\u4f8b\u8fdb\u884c\u4e86\u7ba1\u7406\u3002 1. class FreeList { 2. constructor(name, max, ctor) { 3. this.name = name; 4. // \u6784\u9020\u51fd\u6570 5. this.ctor = ctor; 6. // \u8282\u70b9\u7684\u6700\u5927\u503c 7. this.max = max; 8. // \u5b9e\u4f8b\u5217\u8868 9. this.list = []; 10. } 11. // \u5206\u914d\u4e00\u4e2a\u5b9e\u4f8b 12. alloc() { 13. // \u6709\u7a7a\u95f2\u7684\u5219\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u65b0\u5efa\u4e00\u4e2a 14. return this.list.length > 0 ? 15. this.list.pop() : 16. ReflectApply(this.ctor, this, arguments); 17. } 18. // \u91ca\u653e\u5b9e\u4f8b 19. free(obj) { 20. // \u5c0f\u4e8e\u9608\u503c\u5219\u653e\u5230\u7a7a\u95f2\u5217\u8868\uff0c\u5426\u5219\u91ca\u653e\uff08\u8c03\u7528\u65b9\u8d1f\u8d23\u91ca\u653e\uff09 21. if (this.list.length < this.max) { 22. this.list.push(obj); 23. return true; 24. } 25. return false; 26. } 27. } \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5bf9FreeList\u7684\u4f7f\u7528\u3002\u3002 1. const parsers = new FreeList('parsers', 1000, function parsersCb() { 2. const parser = new HTTPParser(); 3. // \u521d\u59cb\u5316\u5b57\u6bb5 4. cleanParser(parser); 5. // \u8bbe\u7f6e\u94a9\u5b50 6. parser.onIncoming = null; 7. parser[kOnHeaders] = parserOnHeaders; 8. parser[kOnHeadersComplete] = parserOnHeadersComplete; 9. parser[kOnBody] = parserOnBody; 10. parser[kOnMessageComplete] = parserOnMessageComplete; 11. 12. return parser; 13. }); HTTP\u89e3\u6790\u5668\u7684\u4f7f\u7528 1. var HTTPParser = process.binding('http_parser').HTTPParser; 2. var parser = new HTTPParser(HTTPParser.REQUEST); 3. 4. const kOnHeaders = HTTPParser.kOnHeaders; 5. const kOnHeadersComplete = HTTPParser.kOnHeadersComplete; 6. const kOnBody = HTTPParser.kOnBody; 7. const kOnMessageComplete = HTTPParser.kOnMessageComplete; 8. const kOnExecute = HTTPParser.kOnExecute; 9. 10. parser[kOnHeaders] = function(headers, url) { 11. console.log('kOnHeaders', headers.length, url); 12. } 13. parser[kOnHeadersComplete] = function(versionMajor, versionMinor, headers, method, 14. url, statusCode, statusMessage, upgrade, shouldKeepAlive) { 15. console.log('kOnHeadersComplete', headers); 16. } 17. 18. parser[kOnBody] = function(b, start, len) { 19. console.log('kOnBody', b.slice(start).toString('utf-8')); 20. } 21. parser[kOnMessageComplete] = function() { 22. console.log('kOnMessageComplete'); 23. } 24. parser[kOnExecute] = function() { 25. console.log('kOnExecute'); 26. } 27. 28. parser.execute(Buffer.from( 29. 'GET / HTTP/1.1\\r\\n' + 30. 'Host: http://localhost\\r\\n\\r\\n' 31. )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1. kOnHeadersComplete [ 'Host', 'http://localhost' ] 2. kOnMessageComplete \u6211\u4eec\u770b\u5230\u53ea\u6267\u884c\u4e86kOnHeadersComplete\u548c kOnMessageComplete\u3002\u90a3\u5176\u5b83\u51e0\u4e2a\u56de\u8c03\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770b\u3002\u6211\u4eec\u628a\u8f93\u5165\u6539\u4e00\u4e0b\u3002 1. parser.execute(Buffer.from( 2. 'GET / HTTP/1.1\\r\\n' + 3. 'Host: http://localhost\\r\\n' + 4. 'content-length: 1\\r\\n\\r\\n'+ 5. '1' 6. )); \u4e0a\u9762\u4ee3\u7801\u7684\u8f93\u51fa 1. kOnHeadersComplete [ 'Host', 'http://localhost', 'content-length', '1' ] 2. kOnBody 1 3. kOnMessageComplete \u6211\u4eec\u770b\u5230\u591a\u4e86\u4e00\u4e2a\u56de\u8c03kOnBody\uff0c\u56e0\u4e3a\u6211\u4eec\u52a0\u4e86\u4e00\u4e2aHTTP\u5934content-length\u6307\u793a\u6709body\uff0c\u6240\u4ee5HTTP\u89e3\u6790\u5668\u89e3\u6790\u5230body\u7684\u65f6\u5019\u5c31\u4f1a\u56de\u8c03kOnBody\u3002\u90a3kOnHeaders\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801\u3002 1. parser.execute(Buffer.from( 2. 'GET / HTTP/1.1\\r\\n' + 3. 'Host: http://localhost\\r\\n' + 4. 'a: b\\r\\n'+ 5. // \u5f88\u591a'a: b\\r\\n'+ 6. 'content-length: 1\\r\\n\\r\\n'+ 7. '1' 8. )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1. kOnHeaders 62 / 2. kOnHeaders 22 3. kOnHeadersComplete undefined 4. kOnBody 1 5. kOnMessageComplete \u6211\u4eec\u770b\u5230kOnHeaders\u88ab\u6267\u884c\u4e86\uff0c\u5e76\u4e14\u6267\u884c\u4e86\u4e24\u6b21\u3002\u56e0\u4e3a\u5982\u679cHTTP\u5934\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5728\u89e3\u6790HTTP\u5934\u90e8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u5148flush\u5230JS\u5c42\uff08\u5982\u679c\u591a\u6b21\u8fbe\u5230\u9608\u503c\uff0c\u5219\u56de\u8c03\u591a\u6b21\uff09\uff0c\u5e76\u4e14\u5728\u89e3\u6790\u5b8c\u6240\u6709HTTP\u5934\u540e\uff0c\u4f1a\u5728kOnHeadersComplet\u56de\u8c03\u4e4b\u524d\u518d\u6b21\u56de\u8c03kOnHeaders\uff08\u5982\u679c\u8fd8\u6709\u7684\u8bdd\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u5982\u4f55\u89e6\u53d1\u3002 1. var HTTPParser = process.binding('http_parser').HTTPParser; 2. var parser = new HTTPParser(HTTPParser.REQUEST); 3. var net = require('net'); 4. 5. const kOnHeaders = HTTPParser.kOnHeaders; 6. const kOnHeadersComplete = HTTPParser.kOnHeadersComplete; 7. const kOnBody = HTTPParser.kOnBody; 8. const kOnMessageComplete = HTTPParser.kOnMessageComplete; 9. const kOnExecute = HTTPParser.kOnExecute; 10. 11. parser[kOnHeaders] = function(headers, url) { 12. console.log('kOnHeaders', headers.length, url); 13. } 14. parser[kOnHeadersComplete] = function(versionMajor, versionMinor, headers, method, 15. url, statusCode, statusMessage, upgrade, shouldKeepAlive) { 16. console.log('kOnHeadersComplete', headers); 17. } 18. 19. parser[kOnBody] = function(b, start, len) { 20. console.log('kOnBody', b.slice(start).toString('utf-8')); 21. } 22. parser[kOnMessageComplete] = function() { 23. console.log('kOnMessageComplete'); 24. } 25. parser[kOnExecute] = function(a,b) { 26. console.log('kOnExecute,\u89e3\u6790\u7684\u5b57\u8282\u6570\uff1a',a); 27. } 28. // \u542f\u52a8\u4e00\u4e2a\u670d\u52a1\u5668 29. net.createServer((socket) => { 30. parser.consume(socket._handle); 31. }).listen(80); 32. 33. // \u542f\u52a8\u4e00\u4e2a\u5ba2\u6237\u7aef 34. setTimeout(() => { 35. var socket = net.connect({port: 80}); 36. socket.end('GET / HTTP/1.1\\r\\n' + 37. 'Host: http://localhost\\r\\n' + 38. 'content-length: 1\\r\\n\\r\\n'+ 39. '1'); 40. }, 1000); \u6211\u4eec\u9700\u8981\u8c03\u7528parser.consume\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2aisStreamBase\u7684\u6d41\uff08stream_base.cc\u5b9a\u4e49\uff09\uff0c\u624d\u4f1a\u89e6\u53d1kOnExecute\u3002\u56e0\u4e3akOnExecute\u662f\u5728StreamBase\u6d41\u53ef\u8bfb\u65f6\u89e6\u53d1\u7684\u3002 18.2 HTTP\u5ba2\u6237\u7aef \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4f7f\u7528Node.js\u4f5c\u4e3a\u5ba2\u6237\u7aef\u7684\u4f8b\u5b50\u3002 1. const data = querystring.stringify({ 2. 'msg': 'hi' 3. }); 4. 5. const options = { 6. hostname: 'your domain', 7. path: '/', 8. method: 'POST', 9. headers: { 10. 'Content-Type': 'application/x-www-form-urlencoded', 11. 'Content-Length': Buffer.byteLength(data) 12. } 13. }; 14. 15. const req = http.request(options, (res) => { 16. res.setEncoding('utf8'); 17. res.on('data', (chunk) => { 18. console.log(`${chunk}`); 19. }); 20. res.on('end', () => { 21. console.log('end'); 22. }); 23. }); 24. 25. req.on('error', (e) => { 26. console.error(`${e.message}`); 27. }); 28. // \u53d1\u9001\u8bf7\u6c42\u7684\u6570\u636e 29. req.write(data); 30. // \u8bbe\u7f6e\u8bf7\u6c42\u7ed3\u675f 31. req.end(); \u6211\u4eec\u770b\u4e00\u4e0bhttp.request\u7684\u5b9e\u73b0\u3002 1. function request(url, options, cb) { 2. return new ClientRequest(url, options, cb); 3. } HTTP\u5ba2\u6237\u7aef\u901a\u8fc7_http_client.js\u7684ClientRequest\u5b9e\u73b0\uff0cClientRequest\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u6211\u4eec\u53ea\u5206\u6790\u6838\u5fc3\u7684\u6d41\u7a0b\u3002\u6211\u4eec\u770b\u521d\u59cb\u5316\u4e00\u4e2a\u8bf7\u6c42\u7684\u903b\u8f91\u3002 1. function ClientRequest(input, options, cb) { 2. // \u7ee7\u627fOutgoingMessage 3. OutgoingMessage.call(this); 4. // \u662f\u5426\u4f7f\u7528agent 5. let agent = options.agent; 6. // \u5ffd\u7565agent\u7684\u5904\u7406\uff0c\u5177\u4f53\u53c2\u8003_http_agent.js\uff0c\u4e3b\u8981\u7528\u4e8e\u590d\u7528TCP\u8fde\u63a5 7. this.agent = agent; 8. // \u5efa\u7acb\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4 9. if (options.timeout !== undefined) 10. this.timeout = getTimerDuration(options.timeout, 'timeout'); 11. // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c 12. const maxHeaderSize = options.maxHeaderSize; 13. this.maxHeaderSize = maxHeaderSize; 14. // \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6 15. if (cb) { 16. this.once('response', cb); 17. } 18. // \u5ffd\u7565\u8bbe\u7f6ehttp\u534f\u8bae\u7684\u8bf7\u6c42\u884c\u6216\u8bf7\u6c42\u5934\u7684\u903b\u8f91 19. // \u5efa\u7acbTCP\u8fde\u63a5\u540e\u7684\u56de\u8c03 20. const oncreate = (err, socket) => { 21. if (called) 22. return; 23. called = true; 24. if (err) { 25. process.nextTick(() => this.emit('error', err)); 26. return; 27. } 28. // \u5efa\u7acb\u8fde\u63a5\u6210\u529f\uff0c\u6267\u884c\u56de\u8c03 29. this.onSocket(socket); 30. // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u6570\u636e 31. this._deferToConnect(null, null, () => this._flush()); 32. }; 33. 34. // \u4f7f\u7528agent\u65f6\uff0csocket\u7531agent\u63d0\u4f9b\uff0c\u5426\u5219\u81ea\u5df1\u521b\u5efasocket 35. if (this.agent) { 36. this.agent.addRequest(this, options); 37. } else { 38. // \u4e0d\u4f7f\u7528agent\u5219\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2asocket\uff0c\u9ed8\u8ba4\u4f7f\u7528net\u6a21\u5757\u7684\u63a5\u53e3 39. if (typeof options.createConnection === 'function') { 40. const newSocket = options.createConnection(options, 41. oncreate); 42. if (newSocket && !called) { 43. called = true; 44. this.onSocket(newSocket); 45. } else { 46. return; 47. } 48. } else { 49. this.onSocket(net.createConnection(options)); 50. } 51. } 52. // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u5f85\u7f13\u5b58\u7684\u6570\u636e 53. this._deferToConnect(null, null, () => this._flush()); 54. } \u83b7\u53d6\u4e00\u4e2aClientRequest\u5b9e\u4f8b\u540e\uff0c\u4e0d\u7ba1\u662f\u901a\u8fc7agent\u8fd8\u662f\u81ea\u5df1\u521b\u5efa\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\u90fd\u4f1a\u6267\u884conSocket\u3002 1. // socket\u53ef\u7528\u65f6\u7684\u56de\u8c03 2. ClientRequest.prototype.onSocket = function onSocket(socket) { 3. process.nextTick(onSocketNT, this, socket); 4. }; 5. 6. function onSocketNT(req, socket) { 7. // \u7533\u8bf7socket\u8fc7\u7a0b\u4e2d\uff0c\u8bf7\u6c42\u5df2\u7ecf\u7ec8\u6b62 8. if (req.aborted) { 9. // \u4e0d\u4f7f\u7528agent\uff0c\u76f4\u63a5\u9500\u6bc1socekt 10. if (!req.agent) { 11. socket.destroy(); 12. } else { 13. // \u4f7f\u7528agent\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u7531agent\u5904\u7406socekt 14. req.emit('close'); 15. socket.emit('free'); 16. } 17. } else { 18. // \u5904\u7406socket 19. tickOnSocket(req, socket); 20. } 21. } \u6211\u4eec\u7ee7\u7eed\u770btickOnSocket 1. // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u548c\u6ce8\u518cdata\u4e8b\u4ef6\u7b49\uff0c\u7b49\u5f85\u54cd\u5e94 2. function tickOnSocket(req, socket) { 3. // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 4. const parser = parsers.alloc(); 5. req.socket = socket; 6. // \u521d\u59cb\u5316\uff0c\u5904\u7406\u54cd\u5e94\u62a5\u6587 7. parser.initialize(HTTPParser.RESPONSE, 8. new HTTPClientAsyncResource('HTTPINCOMINGMESSAGE', req), req.maxHeaderSize || 0, 9. req.insecureHTTPParser === undefined ? 10. isLenient() : req.insecureHTTPParser); 11. parser.socket = socket; 12. parser.outgoing = req; 13. req.parser = parser; 14. 15. socket.parser = parser; 16. // socket\u6b63\u5904\u7406\u7684\u8bf7\u6c42 17. socket._httpMessage = req; 18. 19. // Propagate headers limit from request object to parser 20. if (typeof req.maxHeadersCount === 'number') { 21. parser.maxHeaderPairs = req.maxHeadersCount << 1; 22. } 23. // \u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u56de\u8c03 24. parser.onIncoming = parserOnIncomingClient; 25. socket.removeListener('error', freeSocketErrorListener); 26. socket.on('error', socketErrorListener); 27. socket.on('data', socketOnData); 28. socket.on('end', socketOnEnd); 29. socket.on('close', socketCloseListener); 30. socket.on('drain', ondrain); 31. 32. if ( 33. req.timeout !== undefined || 34. (req.agent && req.agent.options && 35. req.agent.options.timeout) 36. ) { 37. // \u5904\u7406\u8d85\u65f6\u65f6\u95f4 38. listenSocketTimeout(req); 39. } 40. req.emit('socket', socket); 41. } \u62ff\u5230\u4e00\u4e2asocket\u540e\uff0c\u5c31\u5f00\u59cb\u76d1\u542csocket\u4e0ahttp\u62a5\u6587\u7684\u5230\u6765\u3002\u5e76\u4e14\u7533\u8bf7\u4e00\u4e2aHTTP\u89e3\u6790\u5668\u51c6\u5907\u89e3\u6790http\u62a5\u6587\uff0c\u6211\u4eec\u4e3b\u8981\u5206\u6790\u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406\u548cdata\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1 \u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406 1. function listenSocketTimeout(req) { 2. // \u8bbe\u7f6e\u8fc7\u4e86\u5219\u8fd4\u56de 3. if (req.timeoutCb) { 4. return; 5. } 6. // \u8d85\u65f6\u56de\u8c03 7. req.timeoutCb = emitRequestTimeout; 8. // Delegate socket timeout event. 9. // \u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373socket\u4e0a\u4e00\u5b9a\u65f6\u95f4\u540e\u6ca1\u6709\u54cd\u5e94\u5219\u89e6\u53d1\u8d85\u65f6 10. if (req.socket) { 11. req.socket.once('timeout', emitRequestTimeout); 12. } else { 13. req.on('socket', (socket) => { 14. socket.once('timeout', emitRequestTimeout); 15. }); 16. } 17. } 18. 19. function emitRequestTimeout() { 20. const req = this._httpMessage; 21. if (req) { 22. req.emit('timeout'); 23. } 24. } 2 \u5904\u7406\u54cd\u5e94\u6570\u636e 1. function socketOnData(d) { 2. const socket = this; 3. const req = this._httpMessage; 4. const parser = this.parser; 5. // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406 6. const ret = parser.execute(d); 7. // ... 8. } \u5f53Node.js\u6536\u5230\u54cd\u5e94\u62a5\u6587\u65f6\uff0c\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002http\u89e3\u6790\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bJS\u5c42\u5404\u4e2a\u94a9\u5b50\u51fd\u6570\u7684\u903b\u8f91\u3002 1 \u89e3\u6790\u5934\u90e8\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03 1. function parserOnHeaders(headers, url) { 2. // \u4fdd\u5b58\u5934\u548curl 3. if (this.maxHeaderPairs <= 0 || 4. this._headers.length < this.maxHeaderPairs) { 5. this._headers = this._headers.concat(headers); 6. } 7. this._url += url; 8. } 2 \u89e3\u6790\u5b8c\u5934\u90e8\u7684\u56de\u8c03 1. function parserOnHeadersComplete(versionMajor, 2. versionMinor, 3. headers, 4. method, 5. url, 6. statusCode, 7. statusMessage, 8. upgrade, 9. shouldKeepAlive) { 10. const parser = this; 11. const { socket } = parser; 12. // \u5269\u4e0b\u7684HTTP\u5934 13. if (headers === undefined) { 14. headers = parser._headers; 15. parser._headers = []; 16. } 17. 18. if (url === undefined) { 19. url = parser._url; 20. parser._url = ''; 21. } 22. 23. // Parser is also used by http client 24. // IncomingMessage 25. const ParserIncomingMessage=(socket && 26. socket.server && 27. socket.server[kIncomingMessage] 28. ) || 29. IncomingMessage; 30. // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 31. const incoming = parser.incoming = new ParserIncomingMessage(socket); 32. incoming.httpVersionMajor = versionMajor; 33. incoming.httpVersionMinor = versionMinor; 34. incoming.httpVersion = `${versionMajor}.${versionMinor}`; 35. incoming.url = url; 36. incoming.upgrade = upgrade; 37. 38. let n = headers.length; 39. // If parser.maxHeaderPairs <= 0 assume that there's no limit. 40. if (parser.maxHeaderPairs > 0) 41. n = MathMin(n, parser.maxHeaderPairs); 42. // \u66f4\u65b0\u5230\u4fdd\u5b58HTTP\u5934\u7684\u5bf9\u8c61 43. incoming._addHeaderLines(headers, n); 44. // \u8bf7\u6c42\u65b9\u6cd5\u6216\u54cd\u5e94\u884c\u4fe1\u606f 45. if (typeof method === 'number') { 46. // server only 47. incoming.method = methods[method]; 48. } else { 49. // client only 50. incoming.statusCode = statusCode; 51. incoming.statusMessage = statusMessage; 52. } 53. // \u6267\u884c\u56de\u8c03 54. return parser.onIncoming(incoming, shouldKeepAlive); 55. } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8c\u5934\u90e8\u540e\u4f1a\u6267\u884c\u53e6\u4e00\u4e2a\u56de\u8c03onIncoming\uff0c\u5e76\u4f20\u5165IncomingMessage\u5b9e\u4f8b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684res\u3002\u5728\u524d\u9762\u5206\u6790\u8fc7\uff0conIncoming\u8bbe\u7f6e\u7684\u503c\u662fparserOnIncomingClient\u3002 1. function parserOnIncomingClient(res, shouldKeepAlive) { 2. const socket = this.socket; 3. // \u8bf7\u6c42\u5bf9\u8c61 4. const req = socket._httpMessage; 5. // \u670d\u52a1\u5668\u53d1\u9001\u4e86\u591a\u4e2a\u54cd\u5e94 6. if (req.res) { 7. socket.destroy(); 8. return 0; 9. } 10. req.res = res; 11. 12. if (statusIsInformational(res.statusCode)) { 13. req.res = null; 14. // \u8bf7\u6c42\u65f6\u8bbe\u7f6e\u4e86expect\u5934\uff0c\u5219\u54cd\u5e94\u7801\u4e3a100\uff0c\u53ef\u4ee5\u7ee7\u7eed\u53d1\u9001\u6570\u636e 15. if (res.statusCode === 100) { 16. req.emit('continue'); 17. } 18. return 1; 19. } 20. 21. req.res = res; 22. res.req = req; 23. 24. // \u7b49\u5f85\u54cd\u5e94\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u4f1a\u6e05\u9664\u5b9a\u65f6\u5668 25. res.on('end', responseOnEnd); 26. // \u8bf7\u6c42\u7ec8\u6b62\u4e86\u6216\u89e6\u53d1response\u4e8b\u4ef6\uff0c\u8fd4\u56defalse\u8bf4\u660e\u6ca1\u6709\u76d1\u542cresponse\u4e8b\u4ef6\uff0c\u5219\u4e22\u5f03\u6570\u636e 27. if (req.aborted || !req.emit('response', res)) 28. res._dump(); 29. 30. } \u4ece\u6e90\u7801\u4e2d\u6211\u4eec\u770b\u51fa\u5728\u89e3\u6790\u5b8cHTTP\u54cd\u5e94\u5934\u65f6\uff0c\u5c31\u6267\u884c\u4e86http.request\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u3002\u4f8b\u5982\u4e0b\u9762\u4ee3\u7801\u4e2d\u7684\u56de\u8c03\u3002 1. http. request('domain', { agent }, (res) => { 2. // \u89e3\u6790body 3. res.on('data', (data) => { 4. // 5. }); 6. // \u89e3\u6790body\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f 7. res.on('end', (data) => { 8. // 9. }); 10. }); 11. // ... \u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u628ares\u4f5c\u4e3a\u4e00\u4e2a\u6d41\u4f7f\u7528\uff0c\u5728\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cHTTP\u89e3\u6790\u5668\u4f1a\u7ee7\u7eed\u89e3\u6790HTTP body\u3002\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u89e3\u6790\u5668\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03\u3002 1. function parserOnBody(b, start, len) { 2. const stream = this.incoming; 3. if (len > 0 && !stream._dumped) { 4. const slice = b.slice(start, start + len); 5. // \u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 6. const ret = stream.push(slice); 7. // \u6570\u636e\u8fc7\u8f7d\uff0c\u6682\u505c\u63a5\u6536 8. if (!ret) 9. readStop(this.socket); 10. } 11. } \u6700\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u89e3\u6790\u5b8cbody\u65f6HTTP\u89e3\u6790\u5668\u6267\u884c\u7684\u56de\u8c03\u3002 1. function parserOnMessageComplete() { 2. const parser = this; 3. const stream = parser.incoming; 4. 5. if (stream !== null) { 6. // body\u89e3\u6790\u5b8c\u4e86 7. stream.complete = true; 8. // \u5728body\u540e\u53ef\u80fd\u6709trailer\u5934\uff0c\u4fdd\u5b58\u4e0b\u6765 9. const headers = parser._headers; 10. if (headers.length) { 11. stream._addHeaderLines(headers, headers.length); 12. parser._headers = []; 13. parser._url = ''; 14. } 15. // \u6d41\u7ed3\u675f 16. stream.push(null); 17. } 18. 19. // \u8bfb\u53d6\u4e0b\u4e00\u4e2a\u54cd\u5e94\uff0c\u5982\u679c\u6709\u7684\u8bdd 20. readStart(parser.socket); 21. } \u6211\u4eec\u770b\u5230\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5f80\u6d41\u4e2dpush\u6570\u636e\uff0c\u4ece\u800c\u4e0d\u65ad\u89e6\u53d1res\u7684data\u4e8b\u4ef6\uff0c\u6700\u540e\u89e3\u6790body\u7ed3\u675f\u540e\uff0c\u901a\u8fc7push(null)\u901a\u77e5\u6d41\u7ed3\u675f\uff0c\u4ece\u800c\u89e6\u53d1res.end\u4e8b\u4ef6\u3002\u6211\u4eec\u6cbf\u7740onSocket\u51fd\u6570\u5206\u6790\u5b8c\u5904\u7406\u54cd\u5e94\u540e\u6211\u4eec\u518d\u6765\u5206\u6790\u8bf7\u6c42\u7684\u8fc7\u7a0b\u3002\u6267\u884c\u5b8chttp.request\u540e\u6211\u4eec\u4f1a\u5f97\u5230\u4e00\u4e2a\u6807\u8bb0\u8bf7\u6c42\u7684\u5b9e\u4f8b\u3002\u7136\u540e\u6267\u884c\u5b83\u7684write\u65b9\u6cd5\u53d1\u9001\u6570\u636e\u3002 1. OutgoingMessage.prototype.write = function write(chunk, encoding, callback) { 2. const ret = write_(this, chunk, encoding, callback, false); 3. // \u8fd4\u56defalse\u8bf4\u660e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6 4. if (!ret) 5. this[kNeedDrain] = true; 6. return ret; 7. }; 8. 9. function write_(msg, chunk, encoding, callback, fromEnd) { 10. 11. // \u8fd8\u6ca1\u6709\u8bbe\u7f6ethis._header\u5b57\u6bb5\uff0c\u5219\u628a\u8bf7\u6c42\u884c\u548cHTTP\u5934\u62fc\u63a5\u5230this._header\u5b57\u6bb5 12. if (!msg._header) { 13. msg._implicitHeader(); 14. } 15. 16. let ret; 17. // chunk\u6a21\u5f0f\u5219\u9700\u8981\u989d\u5916\u52a0\u4e00\u4e0b\u5b57\u6bb5\uff0c\u5426\u5219\u76f4\u63a5\u53d1\u9001 18. if (msg.chunkedEncoding && chunk.length !== 0) { 19. let len; 20. if (typeof chunk === 'string') 21. len = Buffer.byteLength(chunk, encoding); 22. else 23. len = chunk.length; 24. /* 25. chunk\u6a21\u5f0f\u65f6\uff0chttp\u62a5\u6587\u7684\u683c\u5f0f\u5982\u4e0b 26. chunk\u957f\u5ea6 \u56de\u8f66\u6362\u884c 27. \u6570\u636e \u56de\u8f66\u6362\u884c 28. */ 29. msg._send(len.toString(16), 'latin1', null); 30. msg._send(crlf_buf, null, null); 31. msg._send(chunk, encoding, null); 32. ret = msg._send(crlf_buf, null, callback); 33. } else { 34. ret = msg._send(chunk, encoding, callback); 35. } 36. 37. return ret; 38. } \u6211\u4eec\u63a5\u7740\u770b_send\u51fd\u6570 1. OutgoingMessage.prototype._send = function _send(data, encoding, callback) { 2. // \u5934\u90e8\u8fd8\u6ca1\u6709\u53d1\u9001 3. if (!this._headerSent) { 4. // \u662f\u5b57\u7b26\u4e32\u5219\u8ffd\u52a0\u5230\u5934\u90e8\uff0cthis._header\u4fdd\u5b58\u4e86HTTP\u8bf7\u6c42\u884c\u548cHTTP\u5934 5. if (typeof data === 'string' && 6. (encoding === 'utf8' || 7. encoding === 'latin1' || 8. !encoding)) { 9. data = this._header + data; 10. } else { 11. // \u5426\u5219\u7f13\u5b58\u8d77\u6765 12. const header = this._header; 13. // HTTP\u5934\u9700\u8981\u653e\u5230\u6700\u524d\u9762 14. if (this.outputData.length === 0) { 15. this.outputData = [{ 16. data: header, 17. encoding: 'latin1', 18. callback: null 19. }]; 20. } else { 21. this.outputData.unshift({ 22. data: header, 23. encoding: 'latin1', 24. callback: null 25. }); 26. } 27. // \u66f4\u65b0\u7f13\u5b58\u5927\u5c0f 28. this.outputSize += header.length; 29. this._onPendingData(header.length); 30. } 31. // \u5df2\u7ecf\u5728\u6392\u961f\u7b49\u5f85\u53d1\u9001\u4e86\uff0c\u4e0d\u80fd\u4fee\u6539 32. this._headerSent = true; 33. } 34. return this._writeRaw(data, encoding, callback); 35. }; \u6211\u4eec\u7ee7\u7eed\u770b_writeRaw 1. OutgoingMessage.prototype._writeRaw = function _writeRaw(data, encoding, callback) { 2. 3. // \u53ef\u5199\u7684\u65f6\u5019\u76f4\u63a5\u53d1\u9001 4. if (conn && conn._httpMessage === this && conn.writable) { 5. // There might be pending data in the this.output buffer. 6. // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e 7. if (this.outputData.length) { 8. this._flushOutput(conn); 9. } 10. // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 11. return conn.write(data, encoding, callback); 12. } 13. // \u5426\u5148\u7f13\u5b58 14. this.outputData.push({ data, encoding, callback }); 15. this.outputSize += data.length; 16. this._onPendingData(data.length); 17. return this.outputSize < HIGH_WATER_MARK; 18. } 19. 20. OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) { 21. // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e 22. while (this[kCorked]) { 23. this[kCorked]--; 24. socket.cork(); 25. } 26. 27. const outputLength = this.outputData.length; 28. if (outputLength <= 0) 29. return undefined; 30. 31. const outputData = this.outputData; 32. socket.cork(); 33. // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket 34. let ret; 35. for (let i = 0; i < outputLength; i++) { 36. const { data, encoding, callback } = outputData[i]; 37. ret = socket.write(data, encoding, callback); 38. } 39. socket.uncork(); 40. 41. this.outputData = []; 42. this._onPendingData(-this.outputSize); 43. this.outputSize = 0; 44. 45. return ret; 46. }; \u5199\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u6267\u884cend\u51fd\u6570\u6807\u8bb0HTTP\u8bf7\u6c42\u7684\u7ed3\u675f\u3002 1. OutgoingMessage.prototype.end = function end(chunk, encoding, callback) { 2. // \u8fd8\u6ca1\u7ed3\u675f 3. // \u52a0\u585e 4. if (this.socket) { 5. this.socket.cork(); 6. } 7. 8. // \u6d41\u7ed3\u675f\u540e\u56de\u8c03 9. if (typeof callback === 'function') 10. this.once('finish', callback); 11. // \u6570\u636e\u5199\u5165\u5e95\u5c42\u540e\u7684\u56de\u8c03 12. const finish = onFinish.bind(undefined, this); 13. // chunk\u6a21\u5f0f\u540e\u9762\u9700\u8981\u53d1\u9001\u4e00\u4e2a0\\r\\n\u7ed3\u675f\u6807\u8bb0\uff0c\u5426\u5219\u4e0d\u9700\u8981\u7ed3\u675f\u6807\u8bb0 14. if (this._hasBody && this.chunkedEncoding) { 15. this._send('0\\r\\n' + 16. this._trailer + '\\r\\n', 'latin1', finish); 17. } else { 18. this._send('', 'latin1', finish); 19. } 20. // uncork\u89e3\u9664\u585e\u5b50\uff0c\u53d1\u9001\u6570\u636e 21. if (this.socket) { 22. // Fully uncork connection on end(). 23. this.socket._writableState.corked = 1; 24. this.socket.uncork(); 25. } 26. this[kCorked] = 0; 27. // \u6807\u8bb0\u6267\u884c\u4e86end 28. this.finished = true; 29. // \u6570\u636e\u53d1\u5b8c\u4e86 30. if (this.outputData.length === 0 && 31. this.socket && 32. this.socket._httpMessage === this) { 33. this._finish(); 34. } 35. 36. return this; 37. }; 18.3 HTTP\u670d\u52a1\u5668 \u00b6 \u672c\u8282\u6211\u4eec\u6765\u5206\u6790\u4f7f\u7528Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u4f8b\u5b50\u3002 1. const http = require('http'); 2. http.createServer((req, res) => { 3. res.write('hello'); 4. res.end(); 5. }) 6. .listen(3000); \u63a5\u7740\u6211\u4eec\u6cbf\u7740createServer\u5206\u6790Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1. function createServer(opts, requestListener) { 2. return new Server(opts, requestListener); 3. } \u6211\u4eec\u770bServer\u7684\u5b9e\u73b0 1. function Server(options, requestListener) { 2. // \u53ef\u4ee5\u81ea\u5b9a\u4e49\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61\u548c\u54cd\u5e94\u7684\u5bf9\u8c61 3. this[kIncomingMessage] = options.IncomingMessage || IncomingMessage; 4. this[kServerResponse] = options.ServerResponse || ServerResponse; 5. // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c 6. const maxHeaderSize = options.maxHeaderSize; 7. this.maxHeaderSize = maxHeaderSize; 8. // \u5141\u8bb8\u534a\u5173\u95ed 9. net.Server.call(this, { allowHalfOpen: true }); 10. // \u6709\u8bf7\u6c42\u65f6\u7684\u56de\u8c03 11. if (requestListener) { 12. this.on('request', requestListener); 13. } 14. // \u670d\u52a1\u5668socket\u8bfb\u7aef\u5173\u95ed\u65f6\u662f\u5426\u5141\u8bb8\u7ee7\u7eed\u5904\u7406\u961f\u5217\u91cc\u7684\u54cd\u5e94\uff08tcp\u4e0a\u6709\u591a\u4e2a\u8bf7\u6c42\uff0c\u7ba1\u9053\u5316\uff09 15. this.httpAllowHalfOpen = false; 16. // \u6709\u8fde\u63a5\u65f6\u7684\u56de\u8c03\uff0c\u7531net\u6a21\u5757\u89e6\u53d1 17. this.on('connection', connectionListener); 18. // \u670d\u52a1\u5668\u4e0b\u6240\u6709\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u8d85\u65f6\u65f6\u95f4 19. this.timeout = 0; 20. // \u540c\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\uff0c\u4e24\u4e2a\u8bf7\u6c42\u4e4b\u524d\u6700\u591a\u95f4\u9694\u7684\u65f6\u95f4 21. this.keepAliveTimeout = 5000; 22. this.maxHeadersCount = null; 23. // \u89e3\u6790\u5934\u90e8\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9632\u6b62ddos 24. this.headersTimeout = 60 * 1000; // 60 seconds 25. } \u63a5\u7740\u8c03\u7528listen\u51fd\u6570\uff0c\u56e0\u4e3aHTTP Server\u7ee7\u627f\u4e8enet.Server\uff0cnet.Server\u7684listen\u51fd\u6570\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u4e0d\u518d\u5206\u6790\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0c\u4f1a\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u4ece\u800c\u6267\u884cconnectionListener\u3002 1. function connectionListener(socket) { 2. defaultTriggerAsyncIdScope( 3. getOrSetAsyncId(socket), connectionListenerInternal, this, socket 4. ); 5. } 6. 7. // socket\u8868\u793a\u65b0\u8fde\u63a5 8. function connectionListenerInternal(server, socket) { 9. // socket\u6240\u5c5eserver 10. socket.server = server; 11. // \u8bbe\u7f6e\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u8d85\u65f6\u5904\u7406\u51fd\u6570\u4e3asocketOnTimeout 12. if (server.timeout && typeof socket.setTimeout === 'function') socket.setTimeout(server.timeout); 13. socket.on('timeout', socketOnTimeout); 14. // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 15. const parser = parsers.alloc(); 16. // \u89e3\u6790\u8bf7\u6c42\u62a5\u6587 17. parser.initialize( 18. HTTPParser.REQUEST, 19. new HTTPServerAsyncResource('HTTPINCOMINGMESSAGE', socket), 20. server.maxHeaderSize || 0, 21. server.insecureHTTPParser === undefined ? 22. isLenient() : server.insecureHTTPParser, 23. ); 24. parser.socket = socket; 25. // \u8bb0\u5f55\u5f00\u59cb\u89e3\u6790\u5934\u90e8\u7684\u5f00\u59cb\u65f6\u95f4 26. parser.parsingHeadersStart = nowDate(); 27. socket.parser = parser; 28. if (typeof server.maxHeadersCount === 'number') { 29. parser.maxHeaderPairs = server.maxHeadersCount << 1; 30. } 31. 32. const state = { 33. onData: null, 34. onEnd: null, 35. onClose: null, 36. onDrain: null, 37. // \u540c\u4e00TCP\u8fde\u63a5\u4e0a\uff0c\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u7684\u961f\u5217\uff0c\u7ebf\u5934\u963b\u585e\u7684\u539f\u7406 38. outgoing: [], 39. incoming: [], 40. // \u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570\uff0c\u5982\u679c\u8d85\u8fc7\u9608\u503c\uff0c\u5219\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u7684\u6570\u636e 41. outgoingData: 0, 42. /* 43. \u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u4e86timeout\uff0c\u7528\u4e8e\u54cd\u5e94\u4e00\u4e2a\u8bf7\u6c42\u65f6\uff0c 44. \u6807\u8bb0\u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u7684\u6807\u8bb0 45. */ 46. keepAliveTimeoutSet: false 47. }; 48. // \u76d1\u542ctcp\u4e0a\u7684\u6570\u636e\uff0c\u5f00\u59cb\u89e3\u6790http\u62a5\u6587 49. state.onData = socketOnData.bind(undefined, 50. server, 51. socket, 52. parser, 53. state); 54. state.onEnd = socketOnEnd.bind(undefined, 55. server, 56. socket, 57. parser, 58. state); 59. state.onClose = socketOnClose.bind(undefined, socket, state); 60. state.onDrain = socketOnDrain.bind(undefined, socket, state); 61. socket.on('data', state.onData); 62. socket.on('error', socketOnError); 63. socket.on('end', state.onEnd); 64. socket.on('close', state.onClose); 65. socket.on('drain', state.onDrain); 66. // \u89e3\u6790HTTP\u5934\u90e8\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 67. parser.onIncoming = parserOnIncoming.bind(undefined, 68. server, 69. socket, 70. state); 71. socket.on('resume', onSocketResume); 72. socket.on('pause', onSocketPause); 73. 74. /* 75. \u5982\u679chandle\u662f\u7ee7\u627fStreamBase\u7684\u6d41\u5219\u6267\u884cconsume\u6d88\u8d39http 76. \u8bf7\u6c42\u62a5\u6587\uff0c\u800c\u4e0d\u662f\u4e0a\u9762\u7684onData\uff0ctcp\u6a21\u5757\u7684isStreamBase\u4e3atrue 77. */ 78. if (socket._handle && socket._handle.isStreamBase && 79. !socket._handle._consumed) { 80. parser._consumed = true; 81. socket._handle._consumed = true; 82. parser.consume(socket._handle); 83. } 84. parser[kOnExecute] = 85. onParserExecute.bind(undefined, 86. server, 87. socket, 88. parser, 89. state); 90. 91. socket._paused = false; 92. } \u6267\u884c\u5b8cconnectionListener\u540e\u5c31\u5f00\u59cb\u7b49\u5f85tcp\u4e0a\u6570\u636e\u7684\u5230\u6765\uff0c\u5373HTTP\u8bf7\u6c42\u62a5\u6587\u3002\u4e0a\u9762\u4ee3\u7801\u4e2dNode.js\u76d1\u542c\u4e86socket\u7684data\u4e8b\u4ef6\uff0c\u540c\u65f6\u6ce8\u518c\u4e86\u94a9\u5b50kOnExecute\u3002data\u4e8b\u4ef6\u6211\u4eec\u90fd\u77e5\u9053\u662f\u6d41\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u89e6\u53d1\u7684\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocketOnData\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1. function socketOnData(server, socket, parser, state, d) { 2. // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 3. const ret = parser.execute(d); 4. onParserExecuteCommon(server, socket, parser, state, ret, d); 5. } socketOnData\u7684\u5904\u7406\u903b\u8f91\u662f\u5f53socket\u4e0a\u6709\u6570\u636e\uff0c\u7136\u540e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002\u8fd9\u770b\u8d77\u6765\u6ca1\u4ec0\u4e48\u95ee\u9898\uff0c\u90a3\u4e48kOnExecute\u662f\u505a\u4ec0\u4e48\u7684\u5462\uff1fkOnExecute\u94a9\u5b50\u51fd\u6570\u7684\u503c\u662fonParserExecute\uff0c\u8fd9\u4e2a\u770b\u8d77\u6765\u4e5f\u662f\u89e3\u6790tcp\u4e0a\u7684\u6570\u636e\u7684\uff0c\u770b\u8d77\u6765\u548conSocketData\u662f\u4e00\u6837\u7684\u4f5c\u7528\uff0c\u96be\u9053tcp\u4e0a\u7684\u6570\u636e\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u3002 1. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override { 2. 3. Local<Value> ret = Execute(buf.base, nread); 4. Local<Value> cb = 5. object()->Get(env()->context(), kOnExecute).ToLocalChecked(); 6. MakeCallback(cb.As<Function>(), 1, &ret); 7. } OnStreamRead\u662fnode_http_parser.cc\u5b9e\u73b0\u7684\u51fd\u6570\uff0c\u6240\u4ee5kOnExecute\u5728node_http_parser.cc\u4e2d\u7684OnStreamRead\u4e2d\u88ab\u56de\u8c03\uff0c\u90a3\u4e48OnStreamRead\u53c8\u662f\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u5462\uff1f\u5728C++\u5c42\u7ae0\u8282\u6211\u4eec\u5206\u6790\u8fc7\uff0cOnStreamRead\u662fNode.js\u4e2dC++\u5c42\u6d41\u64cd\u4f5c\u7684\u901a\u7528\u51fd\u6570\uff0c\u5f53\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u800c\u4e14OnStreamRead\u4e2d\u4e5f\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u89e3\u6790\u3002\u8fd9\u770b\u8d77\u6765\u771f\u7684\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u8fd9\u5c31\u5f88\u5947\u602a\uff0c\u4e3a\u4ec0\u4e48\u4e00\u4efd\u6570\u636e\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u4e24\u6b21\uff1f 1. if (socket._handle && socket._handle.isStreamBase && !socket._handle._consumed) { 2. parser._consumed = true; 3. socket._handle._consumed = true; 4. parser.consume(socket._handle); 5. } \u56e0\u4e3aTCP\u6d41\u662f\u7ee7\u627fStreamBase\u7c7b\u7684\uff0c\u6240\u4ee5if\u6210\u7acb\u3002\u6211\u4eec\u770b\u4e00\u4e0bconsume\u7684\u5b9e\u73b0\u3002 1. static void Consume(const FunctionCallbackInfo<Value>& args) { 2. Parser* parser; 3. ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder()); 4. CHECK(args[0]->IsObject()); 5. StreamBase* stream = StreamBase::FromObjject(args[0].As<Object>()); 6. CHECK_NOT_NULL(stream); 7. stream->PushStreamListener(parser); 8. } HTTP\u89e3\u6790\u5668\u628a\u81ea\u5df1\u6ce8\u518c\u4e3aTCP stream\u7684\u4e00\u4e2alistener\u3002\u8fd9\u4f1a\u4f7f\u5f97TCP\u6d41\u4e0a\u7684\u6570\u636e\u7531node_http_parser.cc\u7684OnStreamRead\u76f4\u63a5\u6d88\u8d39\uff0c\u800c\u4e0d\u662f\u89e6\u53d1onData\u4e8b\u4ef6\u3002\u5728OnStreamRead\u4e2d\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u76f4\u5230\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u540e\u6267\u884cparserOnIncoming\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u9700\u8981\u91cd\u7f6e\u5b9a\u65f6\u5668 3. resetSocketTimeout(server, socket, state); 4. // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 5. if (server.keepAliveTimeout > 0) { 6. req.on('end', resetHeadersTimeoutOnReqEnd); 7. } 8. 9. // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 10. socket.parser.parsingHeadersStart = 0; 11. 12. // \u8bf7\u6c42\u5165\u961f\uff08\u5f85\u5904\u7406\u7684\u8bf7\u6c42\u961f\u5217\uff09 13. state.incoming.push(req); 14. 15. if (!socket._paused) { 16. const ws = socket._writableState; 17. // \u5f85\u53d1\u9001\u7684\u6570\u636e\u8fc7\u591a\uff0c\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u6570\u636e 18. if (ws.needDrain || 19. state.outgoingData >= socket.writableHighWaterMark) { 20. socket._paused = true; 21. socket.pause(); 22. } 23. } 24. // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61 25. const res = new server[kServerResponse](req); 26. // \u8bbe\u7f6e\u6570\u636e\u5199\u5165\u5f85\u53d1\u9001\u961f\u5217\u65f6\u89e6\u53d1\u7684\u56de\u8c03\uff0c\u89c1OutgoingMessage 27. res._onPendingData = updateOutgoingData.bind(undefined, 28. socket, 29. state); 30. // \u6839\u636e\u8bf7\u6c42\u7684HTTP\u5934\u8bbe\u7f6e\u662f\u5426\u652f\u6301keepalive\uff08\u7ba1\u9053\u5316\uff09 31. res.shouldKeepAlive = keepAlive; 32. /* 33. socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c 34. \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 35. */ 36. if (socket._httpMessage) { 37. state.outgoing.push(res); 38. } else { 39. res.assignSocket(socket); 40. } 41. 42. // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 43. res.on('finish', 44. resOnFinish.bind(undefined, 45. req, 46. res, 47. socket, 48. state, 49. server)); 50. // \u6709expect\u8bf7\u6c42\u5934\uff0c\u5e76\u4e14\u662fhttp1.1 51. if (req.headers.expect !== undefined && 52. (req.httpVersionMajor === 1 && 53. req.httpVersionMinor === 1) 54. ) { 55. // Expect\u5934\u7684\u503c\u662f\u5426\u662f100-continue 56. if (continueExpression.test(req.headers.expect)) { 57. res._expect_continue = true; 58. /* 59. \u76d1\u542c\u4e86checkContinue\u4e8b\u4ef6\u5219\u89e6\u53d1\uff0c 60. \u5426\u5219\u76f4\u63a5\u8fd4\u56de\u5141\u8bb8\u7ee7\u7eed\u8bf7\u6c42\u5e76\u89e6\u53d1request\u4e8b\u4ef6 61. */ 62. if (server.listenerCount('checkContinue') > 0) { 63. server.emit('checkContinue', req, res); 64. } else { 65. res.writeContinue(); 66. server.emit('request', req, res); 67. } 68. } else if (server.listenerCount('checkExpectation') > 0) { 69. /* 70. \u503c\u5f02\u5e38\uff0c\u76d1\u542c\u4e86checkExpectation\u4e8b\u4ef6\uff0c 71. \u5219\u89e6\u53d1\uff0c\u5426\u5219\u8fd4\u56de417\u62d2\u7edd\u8bf7\u6c42 72. */ 73. server.emit('checkExpectation', req, res); 74. } else { 75. res.writeHead(417); 76. res.end(); 77. } 78. } else { 79. // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 80. server.emit('request', req, res); 81. } 82. return 0; // No special treatment. 83. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u7528\u6237\u5c31\u53ef\u4ee5\u5904\u7406\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u89e3\u6790\u5934\u90e8\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u56de\u8c03\uff0c\u901a\u77e5\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5e76\u4f20\u5165request\u548cresponse\u4f5c\u4e3a\u53c2\u6570\uff0c\u5206\u522b\u5bf9\u5e94\u7684\u662f\u8868\u793a\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u8c61\u3002\u53e6\u5916Node.js\u672c\u8eab\u662f\u4e0d\u4f1a\u89e3\u6790body\u90e8\u5206\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u83b7\u53d6body\u7684\u6570\u636e\u3002 1. const server = http.createServer((request, response) => { 2. request.on('data', (chunk) => { 3. // \u5904\u7406body 4. }); 5. request.on('end', () => { 6. // body\u7ed3\u675f 7. }); 8. }) 18.3.1 HTTP\u7ba1\u9053\u5316\u7684\u539f\u7406\u548c\u5b9e\u73b0 \u00b6 HTTP1.0\u7684\u65f6\u5019\uff0c\u4e0d\u652f\u6301\u7ba1\u9053\u5316\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u9996\u5148\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u670d\u52a1\u5668\u8fd4\u56de\u4e00\u4e2a\u54cd\u5e94\uff0c\u6700\u540e\u65ad\u5f00TCP\u8fde\u63a5\uff0c\u8fd9\u79cd\u662f\u6700\u7b80\u5355\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4f46\u662f\u6bcf\u6b21\u53d1\u9001\u8bf7\u6c42\u90fd\u9700\u8981\u8d70\u4e09\u6b21\u63e1\u624b\u663e\u7136\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u65f6\u95f4\u635f\u8017\uff0c\u6240\u4ee5HTTP1.1\u7684\u65f6\u5019\uff0c\u652f\u6301\u4e86\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u7684\u610f\u601d\u5c31\u662f\u53ef\u4ee5\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u6837\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u540c\u65f6\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff0c\u4f46\u662f\u7531\u4e8eHTTP1.1\u7684\u9650\u5236\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\u9700\u8981\u6309\u5e8f\u8fd4\u56de\u3002\u56e0\u4e3a\u5728HTTP1.1\u4e2d\uff0c\u6ca1\u6709\u6807\u8bb0\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u5e94\u5173\u7cfb\u3002\u6240\u4ee5HTTP\u5ba2\u6237\u7aef\u4f1a\u5047\u8bbe\u7b2c\u4e00\u4e2a\u8fd4\u56de\u7684\u54cd\u5e94\u662f\u5bf9\u5e94\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u7684\u3002\u5982\u679c\u4e71\u5e8f\u8fd4\u56de\uff0c\u5c31\u4f1a\u5bfc\u81f4\u95ee\u9898\uff0c\u5982\u56fe18-2\u6240\u793a\u3002 \u56fe18-2 \u800c\u5728HTTP 2.0\u4e2d\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u4f1a\u5206\u914d\u4e00\u4e2aid\uff0c\u54cd\u5e94\u4e2d\u4e5f\u4f1a\u8fd4\u56de\u5bf9\u5e94\u7684id\uff0c\u8fd9\u6837\u5c31\u7b97\u4e71\u5e8f\u8fd4\u56de\uff0cHTTP\u5ba2\u6237\u7aef\u4e5f\u53ef\u4ee5\u77e5\u9053\u54cd\u5e94\u6240\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u5728HTTP 1.1\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cHTTP\u670d\u52a1\u5668\u7684\u5b9e\u73b0\u5c31\u4f1a\u53d8\u5f97\u590d\u6742\uff0c\u670d\u52a1\u5668\u53ef\u4ee5\u4ee5\u4e32\u884c\u7684\u65b9\u5f0f\u5904\u7406\u8bf7\u6c42\uff0c\u5f53\u524d\u9762\u8bf7\u6c42\u7684\u54cd\u5e94\u8fd4\u56de\u5230\u5ba2\u6237\u7aef\u540e\uff0c\u518d\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u76f8\u5bf9\u7b80\u5355\u7684\uff0c\u4f46\u662f\u5f88\u660e\u663e\uff0c\u8fd9\u79cd\u65b9\u5f0f\u76f8\u5bf9\u6765\u8bf4\u8fd8\u662f\u6bd4\u8f83\u4f4e\u6548\u7684\uff0c\u53e6\u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5e76\u884c\u5904\u7406\u8bf7\u6c42\uff0c\u4e32\u884c\u8fd4\u56de\uff0c\u8fd9\u6837\u53ef\u4ee5\u8ba9\u8bf7\u6c42\u5f97\u5230\u5c3d\u5feb\u7684\u5904\u7406\uff0c\u6bd4\u5982\u4e24\u4e2a\u8bf7\u6c42\u90fd\u8bbf\u95ee\u6570\u636e\u5e93\uff0c\u90a3\u5e76\u884c\u5904\u7406\u4e24\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u6bd4\u4e32\u884c\u5feb\u5f97\u591a\uff0c\u4f46\u662f\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0cNode.js\u5c31\u662f\u5c5e\u4e8e\u8fd9\u79cd\u65b9\u5f0f\uff0c\u4e0b\u9762\u6211\u4eec\u6765\u770b\u4e00\u4e0bNode.js\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002\u524d\u9762\u5206\u6790\u8fc7\uff0cNode.js\u5728\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u65f6\u5019\u4f1a\u6267\u884cparserOnIncoming\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 3. socket.parser.parsingHeadersStart = 0; 4. // \u8bf7\u6c42\u5165\u961f 5. state.incoming.push(req); 6. // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61\uff0c\u4e00\u822c\u662fServerResponse 7. const res = new server[kServerResponse](req); 8. /* 9. socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c 10. \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 11. */ 12. if (socket._httpMessage) { 13. state.outgoing.push(res); 14. } else { 15. res.assignSocket(socket); // socket._httpMessage = res; 16. } 17. // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 18. res.on('finish', resOnFinish.bind(undefined, 19. req, 20. res, 21. socket, 22. state, 23. server)); 24. // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 25. server.emit('request', req, res); 26. return 0; 27. } \u5f53Node.js\u89e3\u6790HTTP\u8bf7\u6c42\u5934\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aServerResponse\u5bf9\u8c61\u8868\u793a\u54cd\u5e94\u3002\u7136\u540e\u5224\u65ad\u5f53\u524d\u662f\u5426\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c\u5982\u679c\u6709\u5219\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5426\u5219\u628a\u65b0\u5efa\u7684ServerResponse\u5bf9\u8c61\u4f5c\u4e3a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u54cd\u5e94\u3002\u6700\u540e\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u5c42\u3002\u7528\u6237\u5c31\u53ef\u4ee5\u8fdb\u884c\u8bf7\u6c42\u7684\u5904\u7406\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u7ef4\u62a4\u4e86\u4e24\u4e2a\u961f\u5217\uff0c\u5206\u522b\u662f\u8bf7\u6c42\u548c\u54cd\u5e94\u961f\u5217\uff0c\u5982\u56fe18-3\u6240\u793a\u3002 \u56fe18-3 \u5f53\u524d\u5904\u7406\u7684\u8bf7\u6c42\u5728\u8bf7\u6c42\u961f\u5217\u7684\u961f\u9996\uff0c\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684\u54cd\u5e94\u4f1a\u6302\u8f7d\u5230socket\u7684_httpMessage\u5c5e\u6027\u4e0a\u3002\u4f46\u662f\u6211\u4eec\u770b\u5230Node.js\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u6240\u6709\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0cNode.js\u4f1a\u5e76\u884c\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff08\u5982\u679c\u662fcpu\u5bc6\u96c6\u578b\u7684\u8bf7\u6c42\u5219\u5b9e\u9645\u4e0a\u8fd8\u662f\u4f1a\u53d8\u6210\u4e32\u884c\uff0c\u8fd9\u548cNode.js\u7684\u5355\u7ebf\u7a0b\u76f8\u5173\uff09\u3002\u90a3Node.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u7684\u987a\u5e8f\u7684\u5462\uff1f\u6211\u4eec\u77e5\u9053\u6bcf\u6b21\u89e6\u53d1request\u4e8b\u4ef6\u7684\u65f6\u5019\uff0c\u6211\u4eec\u90fd\u4f1a\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u3002\u6bd4\u5982\u4e0b\u9762\u7684\u4ee3\u7801\u3002 1. http.createServer((req, res) => { 2. // \u4e00\u4e9b\u7f51\u7edcIO 3. res.writeHead(200, { 'Content-Type': 'text/plain' }); 4. res.end('okay'); 5. }); \u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u8bf7\u6c42\u7684\u5904\u7406\u662f\u72ec\u7acb\u7684\u3002\u5047\u8bbe\u6bcf\u4e2a\u8bf7\u6c42\u90fd\u53bb\u64cd\u4f5c\u6570\u636e\u5e93\uff0c\u5982\u679c\u8bf7\u6c422\u6bd4\u8bf7\u6c421\u5148\u5b8c\u6210\u6570\u636e\u5e93\u7684\u64cd\u4f5c\uff0c\u4ece\u800c\u8bf7\u6c422\u5148\u6267\u884cres.write\u548cres.end\u3002\u90a3\u5c82\u4e0d\u662f\u8bf7\u6c422\u5148\u8fd4\u56de\uff1f\u6211\u4eec\u770b\u4e00\u4e0bServerResponse\u548cOutgoingMessage\u7684\u5b9e\u73b0\uff0c\u63ed\u5f00\u8ff7\u96fe\u3002ServerResponse\u662fOutgoingMessage\u7684\u5b50\u7c7b\u3002write\u51fd\u6570\u662f\u5728OutgoingMessage\u4e2d\u5b9e\u73b0\u7684\uff0cwrite\u7684\u8c03\u7528\u94fe\u8def\u5f88\u957f\uff0c\u6211\u4eec\u4e0d\u5c42\u5c42\u5206\u6790\uff0c\u76f4\u63a5\u770b\u6700\u540e\u7684\u8282\u70b9\u3002 1. function _writeRaw(data, encoding, callback) { 2. const conn = this.socket; 3. // socket\u5bf9\u5e94\u7684\u54cd\u5e94\u662f\u81ea\u5df1\u5e76\u4e14\u53ef\u5199 4. if (conn && conn._httpMessage === this && conn.writable) { 5. // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e 6. if (this.outputData.length) { 7. this._flushOutput(conn); 8. } 9. // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 10. return conn.write(data, encoding, callback); 11. } 12. // socket\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u5bf9\u8c61\u4e0d\u662f\u81ea\u5df1\uff0c\u5219\u5148\u7f13\u5b58\u6570\u636e\u3002 13. this.outputData.push({ data, encoding, callback }); 14. this.outputSize += data.length; 15. this._onPendingData(data.length); 16. return this.outputSize < HIGH_WATER_MARK; 17. } \u6211\u4eec\u770b\u5230\u6211\u4eec\u8c03\u7528res.write\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u9996\u5148\u5224\u65ad\uff0cres\u662f\u4e0d\u662f\u5c5e\u4e8e\u5f53\u524d\u5904\u7406\u4e2d\u54cd\u5e94\uff0c\u5982\u679c\u662f\u624d\u4f1a\u771f\u6b63\u53d1\u9001\u6570\u636e\uff0c\u5426\u5219\u4f1a\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\u3002\u5206\u6790\u5230\u8fd9\u91cc\uff0c\u76f8\u4fe1\u5927\u5bb6\u5df2\u7ecf\u5dee\u4e0d\u591a\u660e\u767dNode.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u6309\u5e8f\u8fd4\u56de\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e9b\u7f13\u5b58\u7684\u6570\u636e\u4ec0\u4e48\u65f6\u5019\u4f1a\u88ab\u53d1\u9001\u51fa\u53bb\u3002\u524d\u9762\u4ee3\u7801\u5df2\u7ecf\u8d34\u8fc7\uff0c\u5f53\u4e00\u4e2a\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u505a\u4e00\u4e9b\u5904\u7406\u3002 1. res.on('finish', resOnFinish.bind(undefined, 2. req, 3. res, 4. socket, 5. state, 6. server)); \u6211\u4eec\u770b\u770bresOnFinish 1. function resOnFinish(req, res, socket, state, server) { 2. // \u5220\u9664\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42 3. state.incoming.shift(); 4. clearIncoming(req); 5. // \u89e3\u9664socket\u4e0a\u6302\u8f7d\u7684\u54cd\u5e94\u5bf9\u8c61 6. res.detachSocket(socket); 7. req.emit('close'); 8. process.nextTick(emitCloseNT, res); 9. // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 10. if (res._last) { 11. // \u662f\u5219\u9500\u6bc1socket 12. if (typeof socket.destroySoon === 'function') { 13. socket.destroySoon(); 14. } else { 15. socket.end(); 16. } 17. } else if (state.outgoing.length === 0) { 18. /* 19. \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c 20. \u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 21. */ 22. if (server.keepAliveTimeout && 23. typeof socket.setTimeout === 'function') { 24. socket.setTimeout(server.keepAliveTimeout); 25. state.keepAliveTimeoutSet = true; 26. } 27. } else { 28. // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8981\u5904\u7406\u7684\u54cd\u5e94 29. const m = state.outgoing.shift(); 30. // \u6302\u8f7d\u5230socket\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 31. if (m) { 32. m.assignSocket(socket); 33. } 34. } 35. } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5904\u7406\u5b8c\u4e00\u4e2a\u54cd\u5e94\u540e\uff0c\u4f1a\u505a\u4e00\u4e9b\u5224\u65ad\u3002\u5206\u522b\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002 1 \u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 \u4ec0\u4e48\u60c5\u51b5\u4e0b\uff0c\u4f1a\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\uff1f\u56e0\u4e3a\u54cd\u5e94\u548c\u8bf7\u6c42\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u5c31\u610f\u5473\u7740\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u4e86\uff0c\u90a3\u4e48\u4ec0\u4e48\u65f6\u5019\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u5462\uff1f\u5f53\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u4e00\u4e2a\u54cd\u5e94\uff0c\u7136\u540e\u5173\u95edTCP\u8fde\u63a5\uff0c\u6240\u4ee5\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0ctcp\u4e0a\u7684\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u4e00\u4e2a\u8bf7\u6c42\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u7406\u8bba\u4e0a\u5c31\u6ca1\u6709\u6240\u8c13\u7684\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u3002\u4f46\u662f\u5b9e\u73b0\u4e0a\u4f1a\u505a\u4e00\u4e9b\u9650\u5236\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e00\u4e2a\u54cd\u5e94\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6eHTTP\u54cd\u5e94\u5934connection\u6765\u5b9a\u4e49\u662f\u5426\u53d1\u9001\u8be5\u54cd\u5e94\u540e\u5c31\u65ad\u5f00\u8fde\u63a5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002 1. // \u662f\u5426\u663e\u793a\u5220\u9664\u8fc7connection\u5934\uff0c\u662f\u5219\u54cd\u5e94\u540e\u65ad\u5f00\u8fde\u63a5\uff0c\u5e76\u6807\u8bb0\u5f53\u524d\u54cd\u5e94\u662f\u6700\u540e\u4e00\u4e2a 2. if (this._removedConnection) { 3. this._last = true; 4. this.shouldKeepAlive = false; 5. } else if (!state.connection) { 6. /* 7. \u6ca1\u6709\u663e\u793a\u8bbe\u7f6e\u4e86connection\u5934\uff0c\u5219\u53d6\u9ed8\u8ba4\u884c\u4e3a 8. 1 Node.js\u7684shouldKeepAlive\u9ed8\u8ba4\u4e3atrue\uff0c\u4e5f\u53ef\u4ee5\u6839\u636e\u8bf7\u6c42\u62a5\u6587\u91cc 9. \u7684connection\u5934\u5b9a\u4e49 10. 2 \u8bbe\u7f6econtent-length\u6216\u4f7f\u7528chunk\u6a21\u5f0f\u624d\u80fd\u533a\u5206\u54cd\u5e94\u62a5\u6587\u7f16\u8fb9\u754c\uff0c 11. \u624d\u80fd\u652f\u6301keepalive 12. 3 \u4f7f\u7528\u4e86\u4ee3\u7406\uff0c\u4ee3\u7406\u662f\u590d\u7528TCP\u8fde\u63a5\u7684\uff0c\u652f\u6301keepalive 13. */ 14. const shouldSendKeepAlive = this.shouldKeepAlive && 15. (state.contLen || 16. this.useChunkedEncodingByDefault || 17. this.agent); 18. if (shouldSendKeepAlive) { 19. header += 'Connection: keep-alive\\r\\n'; 20. } else { 21. this._last = true; 22. header += 'Connection: close\\r\\n'; 23. } 24. } \u53e6\u5916\u5f53\u8bfb\u7aef\u5173\u95ed\u7684\u65f6\u5019\uff0c\u4e5f\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\uff0c\u6bd5\u7adf\u4e0d\u4f1a\u518d\u53d1\u9001\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7aef\u5173\u95ed\u7684\u903b\u8f91\u3002 1. function socketOnEnd(server, socket, parser, state) { 2. const ret = parser.finish(); 3. 4. if (ret instanceof Error) { 5. socketOnError.call(socket, ret); 6. return; 7. } 8. // \u4e0d\u5141\u8bb8\u534a\u5f00\u5173\u5219\u7ec8\u6b62\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u4e0d\u54cd\u5e94\uff0c\u5173\u95ed\u5199\u7aef 9. if (!server.httpAllowHalfOpen) { 10. abortIncoming(state.incoming); 11. if (socket.writable) socket.end(); 12. } else if (state.outgoing.length) { 13. /* 14. \u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5e76\u4e14\u8fd8\u6709\u54cd\u5e94\u9700\u8981\u5904\u7406\uff0c 15. \u6807\u8bb0\u54cd\u5e94\u961f\u5217\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u4e3a\u6700\u540e\u7684\u54cd\u5e94\uff0c 16. \u5904\u7406\u5b8c\u5c31\u5173\u95edsocket\u5199\u7aef 17. */ 18. state.outgoing[state.outgoing.length - 1]._last = true; 19. } else if (socket._httpMessage) { 20. /* 21. \u6ca1\u6709\u7b49\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u4f46\u662f\u8fd8\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c 22. \u5219\u6807\u8bb0\u4e3a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 23. */ 24. socket._httpMessage._last = true; 25. } else if (socket.writable) { 26. // \u5426\u5219\u5173\u95edsocket\u5199\u7aef 27. socket.end(); 28. } 29. } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5224\u65ad\u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u60c5\u51b5\uff0c\u5982\u679c\u4e00\u4e2a\u54cd\u5e94\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u90a3\u4e48\u53d1\u9001\u54cd\u5e94\u540e\u5c31\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 2 \u54cd\u5e94\u961f\u5217\u4e3a\u7a7a \u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679c\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u65f6\u5019\uff0cNode.js\u53c8\u662f\u600e\u4e48\u5904\u7406\u7684\u3002\u5982\u679c\u5f53\u524d\u7684\u5f85\u5904\u7406\u54cd\u5e94\u961f\u5217\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u662f\u76ee\u524d\u6700\u540e\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\uff0c\u4f46\u662f\u4e0d\u662fTCP\u8fde\u63a5\u4e0a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u8fd9\u65f6\u5019\uff0cNode.js\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u5982\u679c\u8d85\u65f6\u8fd8\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\uff0c\u5219Node.js\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 3 \u54cd\u5e94\u961f\u5217\u975e\u7a7a \u5982\u679c\u5f53\u524d\u5f85\u5904\u7406\u961f\u5217\u975e\u7a7a\uff0c\u5904\u7406\u5b8c\u5f53\u524d\u8bf7\u6c42\u540e\u4f1a\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u3002\u5e76\u4ece\u961f\u5217\u4e2d\u5220\u9664\u8be5\u54cd\u5e94\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u662f\u5982\u4f55\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u7684\u3002 1. // \u628a\u54cd\u5e94\u5bf9\u8c61\u6302\u8f7d\u5230socket\uff0c\u6807\u8bb0socket\u5f53\u524d\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94 2. ServerResponse.prototype.assignSocket = function assignSocket(socket) { 3. // \u6302\u8f7d\u5230socket\u4e0a\uff0c\u6807\u8bb0\u662f\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 4. socket._httpMessage = this; 5. socket.on('close', onServerResponseClose); 6. this.socket = socket; 7. this.emit('socket', socket); 8. this._flush(); 9. }; \u6211\u4eec\u770b\u5230Node.js\u662f\u901a\u8fc7_httpMessage\u6807\u8bb0\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u7684\uff0c\u914d\u5408\u54cd\u5e94\u961f\u5217\u6765\u5b9e\u73b0\u54cd\u5e94\u7684\u6309\u5e8f\u8fd4\u56de\u3002\u6807\u8bb0\u5b8c\u540e\u6267\u884c_flush\u53d1\u9001\u54cd\u5e94\u7684\u6570\u636e\uff08\u5982\u679c\u8fd9\u65f6\u5019\u8bf7\u6c42\u5df2\u7ecf\u88ab\u5904\u7406\u5b8c\u6210\uff09 1. OutgoingMessage.prototype._flush = function _flush() { 2. const socket = this.socket; 3. if (socket && socket.writable) { 4. const ret = this._flushOutput(socket); 5. }; 6. 7. OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) { 8. // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e 9. while (this[kCorked]) { 10. this[kCorked]--; 11. socket.cork(); 12. } 13. 14. const outputLength = this.outputData.length; 15. // \u6ca1\u6709\u6570\u636e\u9700\u8981\u53d1\u9001 16. if (outputLength <= 0) 17. return undefined; 18. 19. const outputData = this.outputData; 20. // \u52a0\u585e\uff0c\u8ba9\u6570\u636e\u4e00\u8d77\u53d1\u9001\u51fa\u53bb 21. socket.cork(); 22. // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket 23. let ret; 24. for (let i = 0; i < outputLength; i++) { 25. const { data, encoding, callback } = outputData[i]; 26. ret = socket.write(data, encoding, callback); 27. } 28. socket.uncork(); 29. 30. this.outputData = []; 31. this._onPendingData(-this.outputSize); 32. this.outputSize = 0; 33. 34. return ret; 35. } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5bf9\u4e8e\u7ba1\u9053\u5316\u7684\u5b9e\u73b0\u3002 18.3.2 HTTP Connect\u65b9\u6cd5\u7684\u539f\u7406\u548c\u5b9e\u73b0 \u00b6 \u5206\u6790HTTP Connect\u5b9e\u73b0\u4e4b\u524d\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u9700\u8981HTTP Connect\u65b9\u6cd5\u6216\u8005\u8bf4\u5b83\u51fa\u73b0\u7684\u80cc\u666f\u3002Connect\u65b9\u6cd5\u4e3b\u8981\u7528\u4e8e\u4ee3\u7406\u670d\u52a1\u5668\u7684\u8bf7\u6c42\u8f6c\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f20\u7edfHTTP\u670d\u52a1\u5668\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u5982\u56fe18-4\u6240\u793a\u3002 \u56fe18-4 1 \u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u5ba2\u6237\u7aef\u53d1\u9001HTTP\u8bf7\u6c42\u7ed9\u4ee3\u7406\u670d\u52a1\u5668 3 \u4ee3\u7406\u670d\u52a1\u5668\u89e3\u6790HTTP\u534f\u8bae\uff0c\u6839\u636e\u914d\u7f6e\u62ff\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u7684\u5730\u5740 4 \u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u901a\u8fc7HTTP\u534f\u8bae\u6216\u8005\u5176\u5b83\u534f\u8bae\u8f6c\u53d1\u8bf7\u6c42 5 \u4e1a\u52a1\u670d\u52a1\u5668\u8fd4\u56de\u6570\u636e\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u56de\u590dHTTP\u62a5\u6587\u7ed9\u5ba2\u6237\u7aef\u3002 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bHTTPS\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1 \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u670d\u52a1\u5668\u901a\u8fc7TLS\u62a5\u6587\u8fd4\u56de\u8bc1\u4e66\u4fe1\u606f\uff0c\u5e76\u548c\u5ba2\u6237\u7aef\u5b8c\u6210\u540e\u7eed\u7684TLS\u901a\u4fe1\u3002 3 \u5b8c\u6210TLS\u901a\u4fe1\u540e\uff0c\u540e\u7eed\u53d1\u9001\u7684HTTP\u62a5\u6587\u4f1a\u7ecf\u8fc7TLS\u5c42\u52a0\u5bc6\u89e3\u5bc6\u540e\u518d\u4f20\u8f93\u3002 \u90a3\u4e48\u5982\u679c\u6211\u4eec\u60f3\u5b9e\u73b0\u4e00\u4e2aHTTPS\u7684\u4ee3\u7406\u670d\u52a1\u5668\u600e\u4e48\u505a\u5462\uff1f\u56e0\u4e3a\u5ba2\u6237\u7aef\u53ea\u7ba1\u548c\u76f4\u63a5\u76f8\u8fde\u7684\u670d\u52a1\u5668\u8fdb\u884cHTTPS\u7684\u901a\u4fe1\uff0c\u5982\u679c\u6211\u4eec\u7684\u4e1a\u52a1\u670d\u52a1\u5668\u524d\u9762\u8fd8\u6709\u4ee3\u7406\u670d\u52a1\u5668\uff0c\u90a3\u4e48\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u5fc5\u987b\u8981\u6709\u8bc1\u4e66\u624d\u80fd\u548c\u5ba2\u6237\u7aef\u5b8c\u6210TLS\u63e1\u624b\uff0c\u4ece\u800c\u8fdb\u884cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u4f7f\u7528HTTP\u6216\u8005HTTPS\u8fd8\u662f\u5176\u5b83\u534f\u8bae\u90fd\u53ef\u4ee5\u3002\u8fd9\u6837\u5c31\u610f\u5473\u7740\u6211\u4eec\u6240\u6709\u7684\u670d\u52a1\u7684\u8bc1\u4e66\u90fd\u9700\u8981\u653e\u5230\u4ee3\u7406\u670d\u52a1\u5668\u4e0a\uff0c\u8fd9\u79cd\u573a\u666f\u7684\u9650\u5236\u662f\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u90fd\u7531\u6211\u4eec\u81ea\u5df1\u7ba1\u7406\u6216\u8005\u516c\u53f8\u7edf\u4e00\u7ba1\u7406\u3002\u5982\u679c\u6211\u4eec\u60f3\u52a0\u4e00\u4e2a\u4ee3\u7406\u5bf9\u4e1a\u52a1\u670d\u52a1\u5668\u4e0d\u611f\u77e5\u90a3\u600e\u4e48\u529e\u5462\uff08\u6bd4\u5982\u5199\u4e00\u4e2a\u4ee3\u7406\u670d\u52a1\u5668\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5\uff09\uff1f\u6709\u4e00\u79cd\u65b9\u5f0f\u5c31\u662f\u4e3a\u6211\u4eec\u7684\u4ee3\u7406\u670d\u52a1\u5668\u7533\u8bf7\u4e00\u4e2a\u8bc1\u4e66\uff0c\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u5b8c\u6210\u6b63\u5e38\u7684HTTPS\u901a\u4fe1\u4e86\u3002\u4ece\u800c\u4e5f\u5c31\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\u3002\u53e6\u5916\u4e00\u79cd\u65b9\u5f0f\u5c31\u662fHTTP Connect\u65b9\u6cd5\u3002HTTP Connect\u65b9\u6cd5\u7684\u4f5c\u7528\u662f\u6307\u793a\u670d\u52a1\u5668\u5e2e\u5fd9\u5efa\u7acb\u4e00\u6761TCP\u8fde\u63a5\u5230\u771f\u6b63\u7684\u4e1a\u52a1\u670d\u52a1\u5668\uff0c\u5e76\u4e14\u900f\u4f20\u540e\u7eed\u7684\u6570\u636e\uff0c\u8fd9\u6837\u4e0d\u7533\u8bf7\u8bc1\u4e66\u4e5f\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\uff0c\u5982\u56fe18-5\u6240\u793a\u3002 \u56fe18-5 \u8fd9\u65f6\u5019\u4ee3\u7406\u670d\u52a1\u5668\u53ea\u8d1f\u8d23\u900f\u4f20\u4e24\u7aef\u7684\u6570\u636e\uff0c\u4e0d\u50cf\u4f20\u7edf\u7684\u65b9\u5f0f\u4e00\u6837\u89e3\u6790\u8bf7\u6c42\u7136\u540e\u518d\u8f6c\u53d1\u3002\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u81ea\u5df1\u5b8c\u6210TLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u50cf\u4e0d\u5b58\u5728\u4e00\u6837\u3002\u4e86\u89e3\u4e86Connect\u7684\u539f\u7406\u540e\u770b\u4e00\u4e0b\u6765\u81eaNode.js\u5b98\u65b9\u7684\u4e00\u4e2a\u4f8b\u5b50\u3002 1. const http = require('http'); 2. const net = require('net'); 3. const { URL } = require('url'); 4. // \u521b\u5efa\u4e00\u4e2aHTTP\u670d\u52a1\u5668\u4f5c\u4e3a\u4ee3\u7406\u670d\u52a1\u5668 5. const proxy = http.createServer((req, res) => { 6. res.writeHead(200, { 'Content-Type': 'text/plain' }); 7. res.end('okay'); 8. }); 9. // \u76d1\u542cconnect\u4e8b\u4ef6\uff0c\u6709http connect\u8bf7\u6c42\u65f6\u89e6\u53d1 10. proxy.on('connect', (req, clientSocket, head) => { 11. // \u83b7\u53d6\u771f\u6b63\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u5730\u5740\u5e76\u53d1\u8d77\u8fde\u63a5 12. const { port, hostname } = new URL(`http://${req.url}`); 13. const serverSocket = net.connect(port || 80, hostname, () => { 14. // \u8fde\u63a5\u6210\u529f\u544a\u8bc9\u5ba2\u6237\u7aef 15. clientSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 16. 'Proxy-agent: Node.js-Proxy\\r\\n' + 17. '\\r\\n'); 18. // \u900f\u4f20\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7684\u6570\u636e 19. serverSocket.write(head); 20. serverSocket.pipe(clientSocket); 21. clientSocket.pipe(serverSocket); 22. }); 23. }); 24. 25. proxy.listen(1337, '127.0.0.1', () => { 26. 27. const options = { 28. port: 1337, 29. // \u8fde\u63a5\u7684\u4ee3\u7406\u670d\u52a1\u5668\u5730\u5740 30. host: '127.0.0.1', 31. method: 'CONNECT', 32. // \u6211\u4eec\u9700\u8981\u771f\u6b63\u60f3\u8bbf\u95ee\u7684\u670d\u52a1\u5668\u5730\u5740 33. path: 'www.baidu.com', 34. }; 35. // \u53d1\u8d77http connect\u8bf7\u6c42 36. const req = http.request(options); 37. req.end(); 38. // connect\u8bf7\u6c42\u6210\u529f\u540e\u89e6\u53d1 39. req.on('connect', (res, socket, head) => { 40. // \u53d1\u9001\u771f\u6b63\u7684\u8bf7\u6c42 41. socket.write('GET / HTTP/1.1\\r\\n' + 42. 'Host: www.baidu.com\\r\\n' + 43. 'Connection: close\\r\\n' + 44. '\\r\\n'); 45. socket.on('data', (chunk) => { 46. console.log(chunk.toString()); 47. }); 48. socket.on('end', () => { 49. proxy.close(); 50. }); 51. }); 52. }); \u5b98\u7f51\u7684\u8fd9\u4e2a\u4f8b\u5b50\u5f88\u597d\u5730\u8bf4\u660e\u4e86Connect\u7684\u539f\u7406\uff0c\u5982\u56fe18-6\u6240\u793a\u3002 \u56fe18-6 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dConnect\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4eceHTTP Connect\u8bf7\u6c42\u5f00\u59cb\u3002\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5ba2\u6237\u7aef\u548cNode.js\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0cNode.js\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c 1. // \u8fde\u63a5\u4e0a\u6709\u6570\u636e\u5230\u6765 2. function socketOnData(server, socket, parser, state, d) { 3. // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 4. const ret = parser.execute(d); 5. onParserExecuteCommon(server, socket, parser, state, ret, d); 6. } HTTP\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u56de\u8c03Node.js\u7684\u56de\u8c03\uff0c\u7136\u540e\u6267\u884conParserExecuteCommon\u3002\u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5f53Node.js\u89e3\u6790\u5b8c\u6240\u6709HTTP\u8bf7\u6c42\u5934\u540e\u6267\u884cparserOnHeadersComplete\u3002 1. function parserOnHeadersComplete(versionMajor, versionMinor, headers, method, 2. url, statusCode, statusMessage, upgrade, 3. shouldKeepAlive) { 4. const parser = this; 5. const { socket } = parser; 6. 7. // IncomingMessage 8. const ParserIncomingMessage = (socket && socket.server && 9. socket.server[kIncomingMessage]) || 10. IncomingMessage; 11. // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 12. const incoming = parser.incoming = new ParserIncomingMessage(socket); 13. incoming.httpVersionMajor = versionMajor; 14. incoming.httpVersionMinor = versionMinor; 15. incoming.httpVersion = `${versionMajor}.${versionMinor}`; 16. incoming.url = url; 17. // \u662f\u5426\u662fconnect\u8bf7\u6c42\u6216\u8005upgrade\u8bf7\u6c42 18. incoming.upgrade = upgrade; 19. 20. // \u6267\u884c\u56de\u8c03 21. return parser.onIncoming(incoming, shouldKeepAlive); 22. } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61IncomingMessage\uff0c\u7136\u540e\u56de\u8c03onIncoming\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u8bf7\u6c42\u662f\u5426\u662fconnect\u6216\u8005upgrade 3. if (req.upgrade) { 4. req.upgrade = req.method === 'CONNECT' || 5. server.listenerCount('upgrade') > 0; 6. if (req.upgrade) 7. return 2; 8. } 9. // ... 10. } Node.js\u89e3\u6790\u5b8c\u5934\u90e8\u5e76\u4e14\u6267\u884c\u4e86\u54cd\u5e94\u7684\u94a9\u5b50\u51fd\u6570\u540e\uff0c\u4f1a\u6267\u884conParserExecuteCommon\u3002 1. function onParserExecuteCommon(server, socket, parser, state, ret, d) { 2. if (ret instanceof Error) { 3. prepareError(ret, parser, d); 4. ret.rawPacket = d || parser.getCurrentBuffer(); 5. socketOnError.call(socket, ret); 6. } else if (parser.incoming && parser.incoming.upgrade) { 7. // \u5904\u7406Upgrade\u6216\u8005CONNECT\u8bf7\u6c42 8. const req = parser.incoming; 9. const eventName = req.method === 'CONNECT' ? 10. 'connect' : 'upgrade'; 11. // \u76d1\u542c\u4e86\u5bf9\u5e94\u7684\u4e8b\u4ef6\u5219\u5904\u7406\uff0c\u5426\u5219\u5173\u95ed\u8fde\u63a5 12. if (eventName === 'upgrade' || 13. server.listenerCount(eventName) > 0) { 14. // \u8fd8\u6ca1\u6709\u89e3\u6790\u7684\u6570\u636e 15. const bodyHead = d.slice(ret, d.length); 16. socket.readableFlowing = null; 17. server.emit(eventName, req, socket, bodyHead); 18. } else { 19. socket.destroy(); 20. } 21. } 22. } \u8fd9\u65f6\u5019Node.js\u4f1a\u5224\u65ad\u8bf7\u6c42\u662f\u4e0d\u662fConnect\u6216\u8005\u534f\u8bae\u5347\u7ea7\u7684upgrade\u8bf7\u6c42\uff0c\u662f\u7684\u8bdd\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u6709\u5904\u7406\u8be5\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u6ca1\u6709\u5219\u5173\u95ed\u8fde\u63a5\uff0c\u5426\u5219\u89e6\u53d1\u5bf9\u5e94\u7684\u4e8b\u4ef6\u8fdb\u884c\u5904\u7406\u3002\u6240\u4ee5\u8fd9\u65f6\u5019Node.js\u4f1a\u89e6\u53d1Connect\u65b9\u6cd5\u3002Connect\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u6b63\u5982\u6211\u4eec\u5f00\u59cb\u7ed9\u51fa\u7684\u4f8b\u5b50\u4e2d\u90a3\u6837\u3002\u6211\u4eec\u9996\u5148\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u8fd4\u56de\u54cd\u5e94\u5934\u7ed9\u5ba2\u6237\u7aef\uff0c\u540e\u7eed\u5ba2\u6237\u5c31\u53ef\u4ee5\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u771f\u6b63\u8fdb\u884cTLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u4e86\u3002\u8fd9\u5c31\u662fNode.js\u4e2dConnect\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 \u4e0d\u8fc7\u5728\u4ee3\u7801\u4e2d\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u597d\u73a9\u7684\u5730\u65b9\u3002\u90a3\u5c31\u662f\u5728\u89e6\u53d1connect\u4e8b\u4ef6\u7684\u65f6\u5019\uff0cNode.js\u7ed9\u56de\u8c03\u51fd\u6570\u4f20\u5165\u7684\u53c2\u6570\u3002 1. server.emit('connect', req, socket, bodyHead); \u7b2c\u4e00\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6ca1\u4ec0\u4e48\u7279\u522b\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u4e2a\u53c2\u6570\u5c31\u6709\u610f\u601d\u4e86\uff0cbodyHead\u4ee3\u8868\u7684\u662fHTTP Connect\u8bf7\u6c42\u4e2d\u9664\u4e86\u8bf7\u6c42\u884c\u548cHTTP\u5934\u4e4b\u5916\u7684\u6570\u636e\u3002\u56e0\u4e3aNode.js\u89e3\u6790\u5b8cHTTP\u5934\u540e\u5c31\u4e0d\u7ee7\u7eed\u5904\u7406\u4e86\u3002\u628a\u5269\u4e0b\u7684\u6570\u636e\u4ea4\u7ed9\u4e86\u7528\u6237\u3002\u6211\u4eec\u6765\u505a\u4e00\u4e9b\u597d\u73a9\u7684\u4e8b\u60c5\u3002 1. const http = require('http'); 2. const net = require('net'); 3. const { URL } = require('url'); 4. 5. const proxy = http.createServer((req, res) => { 6. res.writeHead(200, { 'Content-Type': 'text/plain' }); 7. res.end('okay'); 8. }); 9. proxy.on('connect', (req, clientSocket, head) => { 10. const { port, hostname } = new URL(`http://${req.url}`); 11. const serverSocket = net.connect(port || 80, hostname, () => { 12. clientSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 13. 'Proxy-agent: Node.js-Proxy\\r\\n' + 14. '\\r\\n'); 15. // \u628aconnect\u8bf7\u6c42\u5269\u4e0b\u7684\u6570\u636e\u8f6c\u53d1\u7ed9\u670d\u52a1\u5668 16. serverSocket.write(head); 17. serverSocket.pipe(clientSocket); 18. clientSocket.pipe(serverSocket); 19. }); 20. }); 21. 22. proxy.listen(1337, '127.0.0.1', () => { 23. const net = require('net'); 24. const body = 'GET http://www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n'; 25. const length = body.length; 26. const socket = net.connect({host: '127.0.0.1', port: 1337}); 27. socket.write(`CONNECT www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n${body}`); 28. socket.setEncoding('utf-8'); 29. socket.on('data', (chunk) => { 30. console.log(chunk) 31. }); 32. }); \u6211\u4eec\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u7136\u540e\u81ea\u5df1\u6784\u9020HTTP Connect\u62a5\u6587\uff0c\u5e76\u4e14\u5728HTTP\u884c\u540e\u9762\u52a0\u4e00\u4e2a\u989d\u5916\u7684\u5b57\u7b26\u4e32\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u4e24\u4e00\u4e2aHTTP\u8bf7\u6c42\u3002\u5f53Node.js\u670d\u52a1\u5668\u6536\u5230Connect\u8bf7\u6c42\u540e\uff0c\u6211\u4eec\u5728connect\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u628aConnect\u8bf7\u6c42\u591a\u4f59\u7684\u90a3\u4e00\u90e8\u5206\u6570\u636e\u4f20\u7ed9\u771f\u6b63\u7684\u670d\u52a1\u5668\u3002\u8fd9\u6837\u5c31\u8282\u7701\u4e86\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u3002 18.3.3 \u8d85\u65f6\u7ba1\u7406 \u00b6 \u5728\u89e3\u6790HTTP\u534f\u8bae\u6216\u8005\u652f\u6301\u957f\u8fde\u63a5\u7684\u65f6\u5019\uff0cNode.js\u9700\u8981\u8bbe\u7f6e\u4e00\u4e9b\u8d85\u65f6\u7684\u673a\u5236\uff0c\u5426\u5219\u4f1a\u9020\u6210\u653b\u51fb\u6216\u8005\u8d44\u6e90\u6d6a\u8d39\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u670d\u52a1\u5668\u4e2d\u6d89\u53ca\u5230\u8d85\u65f6\u7684\u4e00\u4e9b\u903b\u8f91\u3002 1 \u89e3\u6790HTTP\u5934\u90e8\u8d85\u65f6 \u5f53\u6536\u5230\u4e00\u4e2aHTTP\u8bf7\u6c42\u62a5\u6587\u65f6\uff0c\u4f1a\u4eceHTTP\u8bf7\u6c42\u884c\uff0cHTTP\u5934\uff0cHTTP body\u7684\u987a\u5e8f\u8fdb\u884c\u89e3\u6790\uff0c\u5982\u679c\u7528\u6237\u6784\u9020\u8bf7\u6c42\uff0c\u53ea\u53d1\u9001HTTP\u5934\u7684\u4e00\u90e8\u5206\u3002\u90a3\u4e48HTTP\u89e3\u6790\u5668\u5c31\u4f1a\u4e00\u76f4\u5728\u7b49\u5f85\u540e\u7eed\u6570\u636e\u7684\u5230\u6765\u3002\u8fd9\u4f1a\u5bfc\u81f4DDOS\u653b\u51fb\uff0c\u6240\u4ee5Node.js\u4e2d\u8bbe\u7f6e\u4e86\u89e3\u6790HTTP\u5934\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9608\u503c\u662f60\u79d2\u3002\u5982\u679c60\u79d2\u5185\u6ca1\u6709\u89e3\u6790\u5b8cHTTP\u5934\u90e8\uff0c\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u5982\u679c\u7528\u6237\u4e0d\u5904\u7406\uff0c\u5219Node.js\u4f1a\u81ea\u52a8\u5173\u95ed\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 1. this.headersTimeout = 60 * 1000; // 60 seconds Node.js\u5728\u5efa\u7acbTCP\u8fde\u63a5\u6210\u529f\u540e\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002 1. function connectionListenerInternal(server, socket) { 2. parser.parsingHeadersStart = nowDate(); 3. } \u7136\u540e\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u5224\u65adHTTP\u5934\u90e8\u662f\u5426\u89e3\u6790\u5b8c\u6210\uff0c\u5982\u679c\u6ca1\u6709\u89e3\u6790\u5b8c\u6210\u5e76\u4e14\u8d85\u65f6\u4e86\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002 1. function onParserExecute(server, socket, parser, state, ret) { 2. socket._unrefTimer(); 3. const start = parser.parsingHeadersStart; 4. // start\u7b49\u4e8e0\uff0c\u8bf4\u660eHTTP\u5934\u5df2\u7ecf\u89e3\u6790\u5b8c\u6bd5\uff0c\u5426\u5219\u8bf4\u660e\u6b63\u5728\u89e3\u6790\u5934\uff0c\u7136\u540e\u518d\u5224\u65ad\u89e3\u6790\u65f6\u95f4\u662f\u5426\u8d85\u65f6\u4e86 5. if (start !== 0 && nowDate() - start > server.headersTimeout) { 6. // \u89e6\u53d1timeout\uff0c\u5982\u679c\u6ca1\u6709\u76d1\u542ctimeout\uff0c\u5219\u9ed8\u8ba4\u4f1a\u9500\u6bc1socket\uff0c\u5373\u5173\u95ed\u8fde\u63a5 7. const serverTimeout = server.emit('timeout', socket); 8. 9. if (!serverTimeout) 10. socket.destroy(); 11. return; 12. } 13. 14. onParserExecuteCommon(server, socket, parser, state, ret, undefined); 15. } \u5982\u679c\u5728\u8d85\u65f6\u4e4b\u524d\u89e3\u6790HTTP\u5934\u5b8c\u6210\uff0c\u5219\u628aparsingHeadersStart\u7f6e\u4e3a0\u8868\u793a\u89e3\u6790\u5b8c\u6210\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 3. if (server.keepAliveTimeout > 0) { 4. req.on('end', resetHeadersTimeoutOnReqEnd); 5. } 6. 7. // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 8. socket.parser.parsingHeadersStart = 0; 9. } 10. 11. function resetHeadersTimeoutOnReqEnd() { 12. if (parser) { 13. parser.parsingHeadersStart = nowDate(); 14. } 15. } \u53e6\u5916\u5982\u679c\u652f\u6301\u957f\u8fde\u63a5\uff0c\u5373\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53ef\u4ee5\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\u3002\u5219\u5728\u6bcf\u4e2a\u54cd\u5e94\u7ed3\u675f\u4e4b\u540e\uff0c\u9700\u8981\u91cd\u65b0\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002\u5f53\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u6570\u636e\u5230\u6765\u65f6\u518d\u6b21\u5224\u65ad\u89e3\u6790HTTP\u5934\u90e8\u662f\u5426\u8d85\u65f6\u3002\u8fd9\u91cc\u662f\u54cd\u5e94\u7ed3\u675f\u540e\u5c31\u5f00\u59cb\u8ba1\u7b97\u3002\u800c\u4e0d\u662f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\u65f6\u3002 2 \u652f\u6301\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u95f4\u9694 Node.js\u652f\u6301\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\uff0c\u6240\u4ee5\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5982\u679c\u8d85\u65f6\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u89e6\u53d1\u8d85\u65f6\u4e8b\u4ef6\u3002\u8fd9\u91cc\u6d89\u53ca\u5b9a\u65f6\u5668\u7684\u8bbe\u7f6e\u548c\u91cd\u7f6e\u3002 1. // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 2. if (res._last) { 3. // \u662f\u5219\u9500\u6bc1socket 4. if (typeof socket.destroySoon === 'function') { 5. socket.destroySoon(); 6. } else { 7. socket.end(); 8. } 9. } else if (state.outgoing.length === 0) { 10. // \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 11. if (server.keepAliveTimeout && typeof socket.setTimeout === 'function') { 12. socket.setTimeout(server.keepAliveTimeout); 13. state.keepAliveTimeoutSet = true; 14. } 15. } \u6bcf\u6b21\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u9996\u5148\u4f1a\u5224\u65ad\u5f53\u524d\u54cd\u5e94\u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u4f8b\u5982\u8bfb\u7aef\u4e0d\u53ef\u8bfb\u4e86\uff0c\u8bf4\u660e\u4e0d\u4f1a\u53c8\u8bf7\u6c42\u5230\u6765\u4e86\uff0c\u4e5f\u4e0d\u4f1a\u6709\u54cd\u5e94\u4e86\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u4fdd\u6301\u8fd9\u4e2aTCP\u8fde\u63a5\u3002\u5982\u679c\u5f53\u524d\u54cd\u5e94\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u5219Node.js\u4f1a\u6839\u636ekeepAliveTimeout\u7684\u503c\u505a\u4e0b\u4e00\u6b65\u5224\u65ad\uff0c\u5982\u679ckeepAliveTimeout \u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5982\u679ckeepAliveTimeout \u65f6\u95f4\u5185\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u90a3\u4e48\u5982\u679c\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u9700\u8981\u91cd\u7f6e\u8fd9\u4e2a\u5b9a\u65f6\u5668\u3002Node.js\u5728\u6536\u5230\u65b0\u8bf7\u6c42\u7684\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u5305\u4e2d\uff0c\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\u3002 1. function onParserExecuteCommon(server, socket, parser, state, ret, d) { 2. resetSocketTimeout(server, socket, state); 3. } 4. 5. function resetSocketTimeout(server, socket, state) { 6. if (!state.keepAliveTimeoutSet) 7. return; 8. 9. socket.setTimeout(server.timeout || 0); 10. state.keepAliveTimeoutSet = false; 11. } onParserExecuteCommon\u4f1a\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u65f6\u6267\u884c\uff0c\u7136\u540eNode.js\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\u4e3aserver.timeout\u7684\u503c\u3002 18.4 Agent \u00b6 \u672c\u8282\u6211\u4eec\u5148\u5206\u6790Agent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cAgent\u5bf9TCP\u8fde\u63a5\u8fdb\u884c\u4e86\u6c60\u5316\u7ba1\u7406\u3002\u7b80\u5355\u7684\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u4e4b\u524d\uff0c\u9996\u5148\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u6536\u5230\u54cd\u5e94\u540e\u4f1a\u7acb\u523b\u5173\u95edTCP\u8fde\u63a5\u3002\u4f46\u662f\u6211\u4eec\u77e5\u9053TCP\u7684\u4e09\u6b21\u63e1\u624b\u662f\u6bd4\u8f83\u8017\u65f6\u7684\u3002\u6240\u4ee5\u5982\u679c\u6211\u4eec\u80fd\u590d\u7528TCP\u8fde\u63a5\uff0c\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\u548c\u63a5\u6536\u591a\u4e2aHTTP\u54cd\u5e94\uff0c\u90a3\u4e48\u5728\u6027\u80fd\u4e0a\u9762\u5c31\u4f1a\u5f97\u5230\u5f88\u5927\u7684\u63d0\u5347\u3002Agent\u7684\u4f5c\u7528\u5c31\u662f\u590d\u7528TCP\u8fde\u63a5\u3002\u4e0d\u8fc7Agent\u7684\u6a21\u5f0f\u662f\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u4e32\u884c\u5730\u53d1\u9001\u8bf7\u6c42\u548c\u63a5\u6536\u54cd\u5e94\uff0c\u4e0d\u652f\u6301HTTP PipeLine\u6a21\u5f0f\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u770b\u5b83\u662f\u5982\u4f55\u5b9e\u73b0TCP\u8fde\u63a5\u590d\u7528\u7684\u3002 1. function Agent(options) { 2. if (!(this instanceof Agent)) 3. return new Agent(options); 4. EventEmitter.call(this); 5. this.defaultPort = 80; 6. this.protocol = 'http:'; 7. this.options = { ...options }; 8. // path\u5b57\u6bb5\u8868\u793a\u662f\u672c\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65f6\u4f7f\u7528\u7684\u8def\u5f84\uff0c\u6bd4\u5982Unix\u57df\u8def\u5f84 9. this.options.path = null; 10. // socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u540e\uff0c\u7b49\u5f85\u7a7a\u95f2socket\u7684\u8bf7\u6c42 11. this.requests = {}; 12. // \u6b63\u5728\u4f7f\u7528\u7684socket 13. this.sockets = {}; 14. // \u7a7a\u95f2socket 15. this.freeSockets = {}; 16. // \u7a7a\u95f2socket\u7684\u5b58\u6d3b\u65f6\u95f4 17. this.keepAliveMsecs = this.options.keepAliveMsecs || 1000; 18. /* 19. \u7528\u5b8c\u7684socket\u662f\u5426\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c 20. \u5f00\u542fkeepalive\u624d\u4f1a\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c 21. \u4e0d\u5f00\u542fkeepalive 22. \u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u590d\u7528socket 23. \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u76f4\u63a5\u9500\u6bc1socket 24. */ 25. this.keepAlive = this.options.keepAlive || false; 26. // \u6700\u5927\u7684socket\u4e2a\u6570\uff0c\u5305\u62ec\u6b63\u5728\u4f7f\u7528\u7684\u548c\u7a7a\u95f2\u7684socket 27. this.maxSockets = this.options.maxSockets 28. || Agent.defaultMaxSockets; 29. // \u6700\u5927\u7684\u7a7a\u95f2socket\u4e2a\u6570 30. this.maxFreeSockets = this.options.maxFreeSockets || 256; 31. } Agent\u7ef4\u62a4\u4e86\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u5206\u522b\u662f\u7b49\u5f85socket\u7684\u8bf7\u6c42\u3001\u6b63\u5728\u4f7f\u7528\u7684socket\u3001\u7a7a\u95f2socket\u3002\u6bcf\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5bf9\u8c61\u7684key\u662f\u6839\u636eHTTP\u8bf7\u6c42\u53c2\u6570\u8ba1\u7b97\u7684\u3002\u5bf9\u8c61\u7684\u503c\u662f\u4e00\u4e2a\u961f\u5217\u3002\u5177\u4f53\u7ed3\u6784\u5982\u56fe18-7\u6240\u793a\u3002 \u56fe18-7 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002 18.4.1 key\u7684\u8ba1\u7b97 \u00b6 key\u7684\u8ba1\u7b97\u662f\u6c60\u5316\u7ba1\u7406\u7684\u6838\u5fc3\u3002\u6b63\u786e\u5730\u8bbe\u8ba1key\u7684\u8ba1\u7b97\u89c4\u5219\uff0c\u624d\u80fd\u66f4\u597d\u5730\u5229\u7528\u6c60\u5316\u5e26\u6765\u7684\u597d\u5904\u3002 1. // \u4e00\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684key 2. Agent.prototype.getName = function getName(options) { 3. let name = options.host || 'localhost'; 4. name += ':'; 5. if (options.port) 6. name += options.port; 7. name += ':'; 8. if (options.localAddress) 9. name += options.localAddress; 10. if (options.family === 4 || options.family === 6) 11. name += `:${options.family}`; 12. if (options.socketPath) 13. name += `:${options.socketPath}`; 14. return name; 15. }; \u6211\u4eec\u770b\u5230key\u7531host\u3001port\u3001\u672c\u5730\u5730\u5740\u3001\u5730\u5740\u7c07\u7c7b\u578b\u3001unix\u8def\u5f84\u8ba1\u7b97\u800c\u6765\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8bf7\u6c42\u53ea\u6709\u8fd9\u4e9b\u56e0\u5b50\u90fd\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\u624d\u80fd\u590d\u7528\u8fde\u63a5\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230Agent\u652f\u6301Unix\u57df\u3002 18.4.2 \u521b\u5efa\u4e00\u4e2asocket \u00b6 1. function createSocket(req, options, cb) { 2. options = { ...options, ...this.options }; 3. // \u8ba1\u7b97key 4. const name = this.getName(options); 5. options._agentKey = name; 6. options.encoding = null; 7. let called = false; 8. // \u521b\u5efasocket\u5b8c\u6bd5\u540e\u6267\u884c\u7684\u56de\u8c03 9. const oncreate = (err, s) => { 10. if (called) 11. return; 12. called = true; 13. if (err) 14. return cb(err); 15. if (!this.sockets[name]) { 16. this.sockets[name] = []; 17. } 18. // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 19. this.sockets[name].push(s); 20. // \u76d1\u542csocket\u7684\u4e00\u4e9b\u4e8b\u4ef6\uff0c\u7528\u4e8e\u56de\u6536socket 21. installListeners(this, s, options); 22. // \u6709\u53ef\u7528socket\uff0c\u901a\u77e5\u8c03\u7528\u65b9 23. cb(null, s); 24. }; 25. // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684socket\uff0c\u4f7f\u7528net.createConnection 26. const newSocket = this.createConnection(options, oncreate); 27. if (newSocket) 28. oncreate(null, newSocket); 29. } 30. 31. function installListeners(agent, s, options) { 32. /* 33. socket\u89e6\u53d1\u7a7a\u95f2\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u544a\u8bc9agent\u8be5socket\u7a7a\u95f2\u4e86\uff0c 34. agent\u4f1a\u56de\u6536\u8be5socket\u5230\u7a7a\u95f2\u961f\u5217 35. */ 36. function onFree() { 37. agent.emit('free', s, options); 38. } 39. /* 40. \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6\uff0c\u8c03\u7528\u65b9\u4f7f\u7528\u5b8csocket\u540e\u89e6\u53d1\uff0c 41. \u901a\u77e5agent socket\u7528\u5b8c\u4e86 42. */ 43. s.on('free', onFree); 44. 45. function onClose(err) { 46. agent.removeSocket(s, options); 47. } 48. // socket\u5173\u95ed\u5219agent\u4f1a\u4ecesocket\u961f\u5217\u4e2d\u5220\u9664\u5b83 49. s.on('close', onClose); 50. 51. function onRemove() { 52. agent.removeSocket(s, options); 53. s.removeListener('close', onClose); 54. s.removeListener('free', onFree); 55. s.removeListener('agentRemove', onRemove); 56. } 57. // agent\u88ab\u79fb\u9664 58. s.on('agentRemove', onRemove); 59. 60. } \u521b\u5efasocket\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u8c03\u7528net\u6a21\u5757\u521b\u5efa\u4e00\u4e2asocket\uff08TCP\u6216\u8005Unix\u57df\uff09\uff0c\u7136\u540e\u63d2\u5165\u4f7f\u7528\u4e2d\u7684socket\u961f\u5217\uff0c\u6700\u540e\u901a\u77e5\u8c03\u7528\u65b9socket\u521b\u5efa\u6210\u529f\u3002 2 \u76d1\u542csocket\u7684close\u3001free\u4e8b\u4ef6\u548cagentRemove\u4e8b\u4ef6\uff0c\u89e6\u53d1\u65f6\u4ece\u961f\u5217\u4e2d\u5220\u9664socket\u3002 18.4.3 \u5220\u9664socket \u00b6 1. // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u6216\u8005\u7a7a\u95f2\u961f\u5217\u4e2d\u79fb\u51fa 2. function removeSocket(s, options) { 3. const name = this.getName(options); 4. const sets = [this.sockets]; 5. /* 6. socket\u4e0d\u53ef\u5199\u4e86\uff0c\u5219\u6709\u53ef\u80fd\u662f\u5b58\u5728\u7a7a\u95f2\u7684\u961f\u5217\u4e2d\uff0c 7. \u6240\u4ee5\u9700\u8981\u904d\u5386\u7a7a\u95f2\u961f\u5217\uff0c\u56e0\u4e3aremoveSocket\u53ea\u4f1a\u5728 8. \u4f7f\u7528\u5b8csocket\u6216\u8005socket\u5173\u95ed\u7684\u65f6\u5019\u88ab\u8c03\u7528\uff0c\u524d\u8005\u53ea\u6709\u5728 9. \u53ef\u5199\u72b6\u6001\u65f6\u4f1a\u8c03\u7528\uff0c\u540e\u8005\u662f\u4e0d\u53ef\u5199\u7684 10. */ 11. if (!s.writable) 12. sets.push(this.freeSockets); 13. // \u4ece\u961f\u5217\u4e2d\u5220\u9664\u5bf9\u5e94\u7684socket 14. for (const sockets of sets) { 15. if (sockets[name]) { 16. const index = sockets[name].indexOf(s); 17. if (index !== -1) { 18. sockets[name].splice(index, 1); 19. // Don't leak 20. if (sockets[name].length === 0) 21. delete sockets[name]; 22. } 23. } 24. } 25. /* 26. \u5982\u679c\u8fd8\u6709\u5728\u7b49\u5f85socekt\u7684\u8bf7\u6c42\uff0c\u5219\u521b\u5efasocket\u53bb\u5904\u7406\u5b83\uff0c 27. \u56e0\u4e3asocket\u6570\u5df2\u7ecf\u51cf\u4e00\u4e86\uff0c\u8bf4\u660esocket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c 28. \u4f46\u662f\u8fd9\u91cc\u5e94\u8be5\u5148\u5224\u65ad\u662f\u5426\u8fd8\u6709\u7a7a\u95f2\u7684socket\uff0c\u6709\u5219\u53ef\u4ee5\u590d\u7528\uff0c 29. \u6ca1\u6709\u5219\u521b\u5efa\u65b0\u7684socket 30. */ 31. if (this.requests[name] && this.requests[name].length) { 32. const req = this.requests[name][0]; 33. const socketCreationHandler = handleSocketCreation(this, 34. req, 35. false); 36. this.createSocket(req, options, socketCreationHandler); 37. } 38. }; \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cAgent\u7ef4\u62a4\u4e86\u4e24\u4e2asocket\u961f\u5217\uff0c\u5220\u9664socket\u5c31\u662f\u4ece\u8fd9\u4e24\u4e2a\u961f\u5217\u4e2d\u627e\u5230\u5bf9\u5e94\u7684socket\uff0c\u7136\u540e\u79fb\u9664\u5b83\u3002\u79fb\u9664\u540e\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u5426\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u961f\u5217\uff0c\u6709\u7684\u8bdd\u5c31\u65b0\u5efa\u4e00\u4e2asocket\u53bb\u5904\u7406\u5b83\u3002\u56e0\u4e3a\u79fb\u9664\u4e86\u4e00\u4e2asocket\uff0c\u5c31\u8bf4\u660e\u53ef\u4ee5\u65b0\u589e\u4e00\u4e2asocket\u3002 18.4.4 \u8bbe\u7f6esocket keepalive \u00b6 \u5f53socket\u88ab\u4f7f\u7528\u5b8c\u5e76\u4e14\u88ab\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u540e\uff0c\u9700\u8981\u91cd\u65b0\u8bbe\u7f6esocket\u7684keepalive\u503c\u3002\u7b49\u5230\u8d85\u65f6\u4f1a\u81ea\u52a8\u5173\u95edsocket\u3002\u5728\u4e00\u4e2asocket\u4e0a\u8c03\u7528\u4e00\u6b21setKeepAlive\u5c31\u53ef\u4ee5\u4e86\uff0c\u8fd9\u91cc\u53ef\u80fd\u4f1a\u5bfc\u81f4\u591a\u6b21\u8c03\u7528setKeepAlive\uff0c\u4e0d\u8fc7\u4e5f\u6ca1\u6709\u5f71\u54cd\u3002 1. function keepSocketAlive(socket) { 2. socket.setKeepAlive(true, this.keepAliveMsecs); 3. socket.unref(); 4. return true; 5. }; \u53e6\u5916\u9700\u8981\u8bbe\u7f6eref\u6807\u8bb0\uff0c\u9632\u6b62\u8be5socket\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\uff0c\u56e0\u4e3a\u8be5socket\u662f\u7a7a\u95f2\u7684\uff0c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 18.4.5 \u590d\u7528socket \u00b6 1. function reuseSocket(socket, req) { 2. req.reusedSocket = true; 3. socket.ref(); 4. }; \u91cd\u65b0\u4f7f\u7528\u8be5socket\uff0c\u9700\u8981\u4fee\u6539ref\u6807\u8bb0\uff0c\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u5e76\u6807\u8bb0\u8bf7\u6c42\u4f7f\u7528\u7684\u662f\u590d\u7528socket\u3002 18.4.6 \u9500\u6bc1Agent \u00b6 1. function destroy() { 2. for (const set of [this.freeSockets, this.sockets]) { 3. for (const key of ObjectKeys(set)) { 4. for (const setName of set[key]) { 5. setName.destroy(); 6. } 7. } 8. } 9. }; \u56e0\u4e3aAgent\u672c\u8d28\u4e0a\u662f\u4e00\u4e2asocket\u6c60\uff0c\u9500\u6bc1Agent\u5373\u9500\u6bc1\u6c60\u91cc\u7ef4\u62a4\u7684\u6240\u6709socket\u3002 18.4.7 \u4f7f\u7528\u8fde\u63a5\u6c60 \u00b6 \u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528Agent\u3002 1. function addRequest(req, options, port, localAddress) { 2. // \u53c2\u6570\u5904\u7406 3. if (typeof options === 'string') { 4. options = { 5. host: options, 6. port, 7. localAddress 8. }; 9. } 10. 11. options = { ...options, ...this.options }; 12. if (options.socketPath) 13. options.path = options.socketPath; 14. 15. if (!options.servername && options.servername !== '') 16. options.servername = calculateServerName(options, req); 17. // \u62ff\u5230\u8bf7\u6c42\u5bf9\u5e94\u7684key 18. const name = this.getName(options); 19. // \u8be5key\u8fd8\u6ca1\u6709\u5728\u4f7f\u7528\u7684socekt\u5219\u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784 20. if (!this.sockets[name]) { 21. this.sockets[name] = []; 22. } 23. // \u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5217\u8868 24. const freeLen = this.freeSockets[name] ? 25. this.freeSockets[name].length : 0; 26. // \u8be5key\u5bf9\u5e94\u7684\u6240\u6709socket\u4e2a\u6570 27. const sockLen = freeLen + this.sockets[name].length; 28. // \u8be5key\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socekt 29. if (freeLen) { 30. // \u83b7\u53d6\u4e00\u4e2a\u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket 31. const socket = this.freeSockets[name].shift(); 32. // \u53d6\u5b8c\u4e86\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f 33. if (!this.freeSockets[name].length) 34. delete this.freeSockets[name]; 35. // \u8bbe\u7f6eref\u6807\u8bb0\uff0c\u56e0\u4e3a\u6b63\u5728\u4f7f\u7528\u8be5socket 36. this.reuseSocket(socket, req); 37. // \u8bbe\u7f6e\u8bf7\u6c42\u5bf9\u5e94\u7684socket 38. setRequestSocket(this, req, socket); 39. // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 40. this.sockets[name].push(socket); 41. } else if (sockLen < this.maxSockets) { 42. /* 43. \u5982\u679c\u8be5key\u6ca1\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5e76\u4e14\u4f7f\u7528\u7684 44. socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u5f97\u5230\u9608\u503c\uff0c\u5219\u7ee7\u7eed\u521b\u5efa 45. */ 46. this.createSocket(req, 47. options, 48. handleSocketCreation(this, req, true)); 49. } else { 50. // \u7b49\u5f85\u8be5key\u4e0b\u6709\u7a7a\u95f2\u7684socket 51. if (!this.requests[name]) { 52. this.requests[name] = []; 53. } 54. this.requests[name].push(req); 55. } 56. } \u5f53\u6211\u4eec\u9700\u8981\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7Agent\u7684addRequest\u65b9\u6cd5\u628a\u8bf7\u6c42\u6258\u7ba1\u5230Agent\u4e2d\uff0c\u5f53\u6709\u53ef\u7528\u7684socket\u65f6\uff0cAgent\u4f1a\u901a\u77e5\u6211\u4eec\u3002addRequest\u7684\u4ee3\u7801\u5f88\u957f\uff0c\u4e3b\u8981\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\u3002 1 \u6709\u7a7a\u95f2socket\uff0c\u5219\u76f4\u63a5\u590d\u7528\uff0c\u5e76\u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217\u4e2d \u6211\u4eec\u4e3b\u8981\u770b\u4e00\u4e0bsetRequestSocket\u51fd\u6570 1. function setRequestSocket(agent, req, socket) { 2. // \u901a\u77e5\u8bf7\u6c42socket\u521b\u5efa\u6210\u529f 3. req.onSocket(socket); 4. const agentTimeout = agent.options.timeout || 0; 5. if (req.timeout === undefined || req.timeout === agentTimeout) 6. { 7. return; 8. } 9. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8fc7\u671f\u540e\u89e6\u53d1timeout\u4e8b\u4ef6 10. socket.setTimeout(req.timeout); 11. /* 12. \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u9700\u8981\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c 13. \u5f00\u542f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u7684\u8d85\u65f6\u8ba1\u7b97\uff0c\u5426\u5219\u4f1a\u63d0\u524d\u8fc7\u671f 14. */ 15. req.once('response', (res) => { 16. res.once('end', () => { 17. if (socket.timeout !== agentTimeout) { 18. socket.setTimeout(agentTimeout); 19. } 20. }); 21. }); 22. } setRequestSocket\u51fd\u6570\u901a\u8fc7req.onSocket(socket)\u901a\u77e5\u8c03\u7528\u65b9\u6709\u53ef\u7528socket\u3002\u7136\u540e\u5982\u679c\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u8d85\u65f6\u65f6\u95f4\u5219\u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u8bf7\u6c42\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u6700\u540e\u76d1\u542c\u54cd\u5e94\u7ed3\u675f\u4e8b\u4ef6\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 2 \u6ca1\u6709\u7a7a\u95f2socket\uff0c\u4f46\u662f\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u521b\u5efa\u65b0\u7684socket\u3002 \u6211\u4eec\u4e3b\u8981\u5206\u6790\u521b\u5efasocket\u540e\u7684\u56de\u8c03handleSocketCreation\u3002 1. function handleSocketCreation(agent, request, informRequest) { 2. return function handleSocketCreation_Inner(err, socket) { 3. if (err) { 4. process.nextTick(emitErrorNT, request, err); 5. return; 6. } 7. /* 8. \u662f\u5426\u9700\u8981\u76f4\u63a5\u901a\u77e5\u8bf7\u6c42\u65b9\uff0c\u8fd9\u65f6\u5019request\u4e0d\u662f\u6765\u81ea\u7b49\u5f85 9. socket\u7684requests\u961f\u5217\uff0c \u800c\u662f\u6765\u81ea\u8c03\u7528\u65b9\uff0c\u89c1addRequest 10. */ 11. if (informRequest) 12. setRequestSocket(agent, request, socket); 13. else 14. /* 15. \u4e0d\u76f4\u63a5\u901a\u77e5\uff0c\u5148\u544a\u8bc9agent\u6709\u7a7a\u95f2\u7684socket\uff0c 16. agent\u4f1a\u5224\u65ad\u662f\u5426\u6709\u6b63\u5728\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u6709\u5219\u5904\u7406 17. */ 18. socket.emit('free'); 19. }; 20. } 3 \u4e0d\u6ee1\u8db31,2\uff0c\u5219\u628a\u8bf7\u6c42\u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u3002 \u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u540e\uff0c\u5f53\u6709socket\u7a7a\u95f2\u65f6\u4f1a\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1. // \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6 2. this.on('free', (socket, options) => { 3. const name = this.getName(options); 4. // socket\u8fd8\u53ef\u5199\u5e76\u4e14\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u590d\u7528socket 5. if (socket.writable && 6. this.requests[name] && this.requests[name].length) { 7. // \u62ff\u5230\u4e00\u4e2a\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u77e5\u5b83\u6709socket\u53ef\u7528 8. const req = this.requests[name].shift(); 9. setRequestSocket(this, req, socket); 10. // \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f 11. if (this.requests[name].length === 0) { 12. // don't leak 13. delete this.requests[name]; 14. } 15. } else { 16. // socket\u4e0d\u53ef\u7528\u5199\u6216\u8005\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u4e86 17. const req = socket._httpMessage; 18. // socket\u53ef\u5199\u5e76\u4e14\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u5141\u8bb8\u4f7f\u7528\u590d\u7528\u7684socket 19. if (req && 20. req.shouldKeepAlive && 21. socket.writable && 22. this.keepAlive) { 23. let freeSockets = this.freeSockets[name]; 24. // \u8be5key\u4e0b\u5f53\u524d\u7684\u7a7a\u95f2socket\u4e2a\u6570 25. const freeLen = freeSockets ? freeSockets.length : 0; 26. let count = freeLen; 27. // \u6b63\u5728\u4f7f\u7528\u7684socket\u4e2a\u6570 28. if (this.sockets[name]) 29. count += this.sockets[name].length; 30. /* 31. \u8be5key\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u6216\u8005\u7a7a\u95f2socket\u8fbe\u5230\u9608\u503c\uff0c 32. \u5219\u4e0d\u590d\u7528socket\uff0c\u76f4\u63a5\u9500\u6bc1socket 33. */ 34. if (count > this.maxSockets || freeLen >= this.maxFreeSockets) { 35. socket.destroy(); 36. } else if (this.keepSocketAlive(socket)) { 37. /* 38. \u91cd\u65b0\u8bbe\u7f6esocket\u7684\u5b58\u6d3b\u65f6\u95f4\uff0c\u8bbe\u7f6e\u5931\u8d25\u8bf4\u660e\u65e0\u6cd5\u91cd\u65b0\u8bbe\u7f6e\u5b58\u6d3b\u65f6 39. \u95f4\uff0c\u5219\u8bf4\u660e\u53ef\u80fd\u4e0d\u652f\u6301\u590d\u7528 40. */ 41. freeSockets = freeSockets || []; 42. this.freeSockets[name] = freeSockets; 43. socket[async_id_symbol] = -1; 44. socket._httpMessage = null; 45. // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u4e2d\u79fb\u9664 46. this.removeSocket(socket, options); 47. // \u63d2\u5165socket\u7a7a\u95f2\u961f\u5217 48. freeSockets.push(socket); 49. } else { 50. // \u4e0d\u590d\u7528\u5219\u76f4\u63a5\u9500\u6bc1 51. socket.destroy(); 52. } 53. } else { 54. socket.destroy(); 55. } 56. } 57. }); \u5f53\u6709socket\u7a7a\u95f2\u65f6\uff0c\u5206\u4e3a\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u76f4\u63a5\u590d\u7528socket\u3002 2 \u5982\u679c\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5141\u8bb8\u590d\u7528\u5e76\u4e14socket\u4e2a\u6570\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u3002 3 \u76f4\u63a5\u9500\u6bc1 18.4.8 \u6d4b\u8bd5\u4f8b\u5b50 \u00b6 \u5ba2\u6237\u7aef 1. const http = require('http'); 2. const keepAliveAgent = new http.Agent({ keepAlive: true, maxSockets: 1 }); 3. const options = {port: 10000, method: 'GET', host: '127.0.0.1',} 4. options.agent = keepAliveAgent; 5. http.get(options, () => {}); 6. http.get(options, () => {}); 7. console.log(options.agent.requests) \u670d\u52a1\u5668 1. let i =0; 2. const net = require('net'); 3. net.createServer((socket) => { 4. console.log(++i); 5. }).listen(10000); \u5728\u4f8b\u5b50\u4e2d\uff0c\u9996\u5148\u521b\u5efa\u4e86\u4e00\u4e2atcp\u670d\u52a1\u5668\u3002\u7136\u540e\u5728\u5ba2\u6237\u7aef\u4f7f\u7528agent\u3002\u4f46\u662fmaxSocket\u7684\u503c\u4e3a1\uff0c\u4ee3\u8868\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2asocket\uff0c\u800c\u8fd9\u65f6\u5019\u5ba2\u6237\u7aef\u53d1\u9001\u4e24\u4e2a\u8bf7\u6c42\uff0c\u6240\u4ee5\u6709\u4e00\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u5728\u6392\u961f\u3002\u670d\u52a1\u5668\u4e5f\u53ea\u6536\u5230\u4e86\u4e00\u4e2a\u8fde\u63a5\u3002","title":"18-HTTP"},{"location":"chapter18-HTTP/#181-http","text":"HTTP\u89e3\u6790\u5668\u662fHTTP\u6a21\u5757\u7684\u6838\u5fc3\uff0c\u4e0d\u7ba1\u662f\u4f5c\u4e3a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u8fd8\u662f\u5ba2\u6237\u7aef\u5904\u7406\u54cd\u5e94\u90fd\u9700\u8981\u4f7f\u7528HTTP\u89e3\u6790\u5668\u89e3\u6790HTTP\u534f\u8bae\u3002\u65b0\u7248Node.js\u4f7f\u7528\u4e86\u65b0\u7684HTTP\u89e3\u6790\u5668llhttp\u3002\u6839\u636e\u5b98\u65b9\u8bf4\u660ellhttp\u6bd4\u65e7\u7248\u7684http_parser\u5728\u6027\u80fd\u4e0a\u6709\u4e86\u975e\u5e38\u5927\u7684\u63d0\u9ad8\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u5206\u6790llhttp\u7684\u57fa\u7840\u539f\u7406\u548c\u4f7f\u7528\u3002HTTP\u89e3\u6790\u5668\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u72b6\u6001\u673a\uff0c\u5728\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u4e0b\u9762\u662fllhttp\u652f\u6301\u7684\u94a9\u5b50\u51fd\u6570\u3002\u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u5c31\u4f1a\u88ab\u56de\u8c03\u3002 1. // \u5f00\u59cb\u89e3\u6790HTTP\u534f\u8bae 2. int llhttp__on_message_begin(llhttp_t* s, const char* p, const char* endp) { 3. int err; 4. CALLBACK_MAYBE(s, on_message_begin, s); 5. return err; 6. } 7. 8. // \u89e3\u6790\u51fa\u8bf7\u6c42url\u65f6\u7684\u56de\u8c03\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2aurl 9. int llhttp__on_url(llhttp_t* s, const char* p, const char* endp) { 10. int err; 11. CALLBACK_MAYBE(s, on_url, s, p, endp - p); 12. return err; 13. } 14. 15. // \u89e3\u6790\u51faHTTP\u54cd\u5e94\u72b6\u6001\u7684\u56de\u8c03 16. int llhttp__on_status(llhttp_t* s, const char* p, const char* endp) { 17. int err; 18. CALLBACK_MAYBE(s, on_status, s, p, endp - p); 19. return err; 20. } 21. 22. // \u89e3\u6790\u51fa\u5934\u90e8\u952e\u65f6\u7684\u56de\u8c03 23. int llhttp__on_header_field(llhttp_t* s, const char* p, const char* endp) { 24. int err; 25. CALLBACK_MAYBE(s, on_header_field, s, p, endp - p); 26. return err; 27. } 28. 29. // \u89e3\u6790\u51fa\u5934\u90e8\u503c\u65f6\u7684\u56de\u8c03 30. int llhttp__on_header_value(llhttp_t* s, const char* p, const char* endp) { 31. int err; 32. CALLBACK_MAYBE(s, on_header_value, s, p, endp - p); 33. return err; 34. } 35. 36. // \u89e3\u6790HTTP\u5934\u5b8c\u6210\u65f6\u7684\u56de\u8c03 37. int llhttp__on_headers_complete(llhttp_t* s, const char* p, const char* endp) { 38. int err; 39. CALLBACK_MAYBE(s, on_headers_complete, s); 40. return err; 41. } 42. 43. // \u89e3\u6790\u5b8cbody\u7684\u56de\u8c03 44. int llhttp__on_message_complete(llhttp_t* s, const char* p, const char* endp) { 45. int err; 46. CALLBACK_MAYBE(s, on_message_complete, s); 47. return err; 48. } 49. 50. // \u89e3\u6790body\u65f6\u7684\u56de\u8c03 51. int llhttp__on_body(llhttp_t* s, const char* p, const char* endp) { 52. int err; 53. CALLBACK_MAYBE(s, on_body, s, p, endp - p); 54. return err; 55. } 56. 57. // \u89e3\u6790\u5230\u4e00\u4e2achunk\u7ed3\u6784\u5934\u65f6\u7684\u56de\u8c03 58. int llhttp__on_chunk_header(llhttp_t* s, const char* p, const char* endp) { 59. int err; 60. CALLBACK_MAYBE(s, on_chunk_header, s); 61. return err; 62. } 63. 64. // \u89e3\u6790\u5b8c\u4e00\u4e2achunk\u65f6\u7684\u56de\u8c03 65. int llhttp__on_chunk_complete(llhttp_t* s, const char* p, const char* endp) { 66. int err; 67. CALLBACK_MAYBE(s, on_chunk_complete, s); 68. return err; 69. } Node.js\u5728node_http_parser.cc\u4e2d\u5bf9llhttp\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8be5\u6a21\u5757\u5bfc\u51fa\u4e86\u4e00\u4e2aHTTPParser\u3002 1. Local<FunctionTemplate> t=env->NewFunctionTemplate(Parser::New); 2. t->InstanceTemplate()->SetInternalFieldCount(1); 3. t->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), 4. \"HTTPParser\")); 5. target->Set(env->context(), 6. FIXED_ONE_BYTE_STRING(env->isolate(), \"HTTPParser\"), 7. t->GetFunction(env->context()).ToLocalChecked()).Check(); \u5728Node.js\u4e2d\u6211\u4eec\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528HTTPParser\u3002 1. const parser = new HTTPParser(); 2. 3. cleanParser(parser); 4. parser.onIncoming = null; 5. parser[kOnHeaders] = parserOnHeaders; 6. parser[kOnHeadersComplete] = parserOnHeadersComplete; 7. parser[kOnBody] = parserOnBody; 8. parser[kOnMessageComplete] = parserOnMessageComplete; 9. // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u5904\u7406\u7684\u62a5\u6587\u7c7b\u578b\uff0c\u8fd9\u91cc\u662f\u54cd\u5e94\u62a5\u6587 10. parser.initialize(HTTPParser.RESPONSE, 11. new HTTPClientAsyncResource('HTTPINCOMINGMESSAGE', req), 12. req.maxHeaderSize || 0, 13. req.insecureHTTPParser === undefined ? 14. isLenient() : req.insecureHTTPParser); 15. // \u6536\u5230\u6570\u636e\u540e\u4f20\u7ed9\u89e3\u6790\u5668\u5904\u7406 16. const ret = parser.execute(data); 17. } \u6211\u4eec\u770b\u4e00\u4e0binitialize\u548cexecute\u7684\u4ee3\u7801\u3002Initialize\u51fd\u6570\u7528\u4e8e\u521d\u59cb\u5316llhttp\u3002 1. static void Initialize(const FunctionCallbackInfo<Value>& args) { 2. Environment* env = Environment::GetCurrent(args); 3. bool lenient = args[3]->IsTrue(); 4. 5. uint64_t max_http_header_size = 0; 6. // \u5934\u90e8\u7684\u6700\u5927\u5927\u5c0f 7. if (args.Length() > 2) { 8. max_http_header_size = args[2].As<Number>()->Value(); 9. } 10. // \u6ca1\u6709\u8bbe\u7f6e\u5219\u53d6Node.js\u7684\u9ed8\u8ba4\u503c 11. if (max_http_header_size == 0) { 12. max_http_header_size=env->options()->max_http_header_size; 13. } 14. // \u89e3\u6790\u7684\u62a5\u6587\u7c7b\u578b 15. llhttp_type_t type = 16. static_cast<llhttp_type_t>(args[0].As<Int32>()->Value()); 17. 18. CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE); 19. Parser* parser; 20. ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder()); 21. parser->Init(type, max_http_header_size, lenient); 22. } Initialize\u505a\u4e86\u4e00\u4e9b\u9884\u5904\u7406\u540e\u8c03\u7528Init\u3002 1. void Init(llhttp_type_t type, uint64_t max_http_header_size, bool lenient) { 2. // \u521d\u59cb\u5316llhttp 3. llhttp_init(&parser_, type, &settings); 4. llhttp_set_lenient(&parser_, lenient); 5. header_nread_ = 0; 6. url_.Reset(); 7. status_message_.Reset(); 8. num_fields_ = 0; 9. num_values_ = 0; 10. have_flushed_ = false; 11. got_exception_ = false; 12. max_http_header_size_ = max_http_header_size; 13. } Init\u505a\u4e86\u4e00\u4e9b\u5b57\u6bb5\u7684\u521d\u59cb\u5316\uff0c\u6700\u91cd\u8981\u7684\u662f\u8c03\u7528\u4e86llhttp_init\u5bf9llhttp\u8fdb\u884c\u4e86\u521d\u59cb\u5316\uff0c\u53e6\u5916kOn\u5f00\u5934\u7684\u5c5e\u6027\u662f\u94a9\u5b50\u51fd\u6570\uff0c\u7531node_http_parser.cc\u4e2d\u7684\u56de\u8c03\uff0c\u800cnode_http_parser.cc\u4e5f\u4f1a\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\uff0c\u7531llhttp\u56de\u8c03\uff0c\u6211\u4eec\u770b\u4e00\u4e0bnode_http_parser.cc\u94a9\u5b50\u51fd\u6570\u7684\u5b9a\u4e49\u548c\u5b9e\u73b0\u3002 1. const llhttp_settings_t Parser::settings = { 2. Proxy<Call, &Parser::on_message_begin>::Raw, 3. Proxy<DataCall, &Parser::on_url>::Raw, 4. Proxy<DataCall, &Parser::on_status>::Raw, 5. Proxy<DataCall, &Parser::on_header_field>::Raw, 6. Proxy<DataCall, &Parser::on_header_value>::Raw, 7. Proxy<Call, &Parser::on_headers_complete>::Raw, 8. Proxy<DataCall, &Parser::on_body>::Raw, 9. Proxy<Call, &Parser::on_message_complete>::Raw, 10. Proxy<Call, &Parser::on_chunk_header>::Raw, 11. Proxy<Call, &Parser::on_chunk_complete>::Raw, 12. }; 1 \u5f00\u59cb\u89e3\u6790\u62a5\u6587\u7684\u56de\u8c03 1. // \u5f00\u59cb\u89e3\u6790\u62a5\u6587\uff0c\u4e00\u4e2aTCP\u8fde\u63a5\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u62a5\u6587 2. int on_message_begin() { 3. num_fields_ = num_values_ = 0; 4. url_.Reset(); 5. status_message_.Reset(); 6. return 0; 7. } 2 \u89e3\u6790url\u65f6\u7684\u56de\u8c03 1. int on_url(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. 7. url_.Update(at, length); 8. return 0; 9. } 3\u89e3\u6790HTTP\u54cd\u5e94\u65f6\u7684\u56de\u8c03 1. int on_status(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. 7. status_message_.Update(at, length); 8. return 0; 9. } 4\u89e3\u6790\u5230HTTP\u5934\u7684\u952e\u65f6\u56de\u8c03 1. int on_header_field(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. // \u76f8\u7b49\u8bf4\u660e\u952e\u5bf9\u503c\u7684\u89e3\u6790\u662f\u4e00\u4e00\u5bf9\u5e94\u7684 7. if (num_fields_ == num_values_) { 8. // start of new field name 9. // \u952e\u7684\u6570\u52a0\u4e00 10. num_fields_++; 11. // \u8d85\u8fc7\u9608\u503c\u5219\u5148\u56de\u8c03js\u6d88\u8d39\u6389 12. if (num_fields_ == kMaxHeaderFieldsCount) { 13. // ran out of space - flush to javascript land 14. Flush(); 15. // \u91cd\u65b0\u5f00\u59cb 16. num_fields_ = 1; 17. num_values_ = 0; 18. } 19. // \u521d\u59cb\u5316 20. fields_[num_fields_ - 1].Reset(); 21. } 22. 23. // \u4fdd\u5b58\u952e 24. fields_[num_fields_ - 1].Update(at, length); 25. 26. return 0; 27. } \u5f53\u89e3\u6790\u7684\u5934\u90e8\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u65f6\uff0cNode.js\u4f1a\u5148\u901a\u8fc7Flush\u51fd\u6570\u56de\u8c03JS\u5c42\u4fdd\u5b58\u5f53\u524d\u7684\u4e00\u4e9b\u6570\u636e\u3002 1. void Flush() { 2. HandleScope scope(env()->isolate()); 3. 4. Local<Object> obj = object(); 5. // JS\u5c42\u7684\u94a9\u5b50 6. Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked(); 7. if (!cb->IsFunction()) 8. return; 9. 10. Local<Value> argv[2] = { 11. CreateHeaders(), 12. url_.ToString(env()) 13. }; 14. 15. MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 16. arraysize(argv), 17. argv); 18. url_.Reset(); 19. have_flushed_ = true; 20. } 21. 22. Local<Array> CreateHeaders() { 23. // HTTP\u5934\u7684\u4e2a\u6570\u4e58\u4ee52\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5934\u7531\u952e\u548c\u503c\u7ec4\u6210 24. Local<Value> headers_v[kMaxHeaderFieldsCount * 2]; 25. // \u4fdd\u5b58\u952e\u548c\u503c\u5230HTTP\u5934 26. for (size_t i = 0; i < num_values_; ++i) { 27. headers_v[i * 2] = fields_[i].ToString(env()); 28. headers_v[i * 2 + 1] = values_[i].ToString(env()); 29. } 30. 31. return Array::New(env()->isolate(), headers_v, num_values_ * 2); 32. } 33. Flush\u4f1a\u8c03\u7528JS\u5c42\u7684kOnHeaders\u94a9\u5b50\u51fd\u6570\u3002 5\u89e3\u6790\u5230HTTP\u5934\u7684\u503c\u65f6\u56de\u8c03 1. int on_header_value(const char* at, size_t length) { 2. int rv = TrackHeader(length); 3. if (rv != 0) { 4. return rv; 5. } 6. /* 7. \u503c\u7684\u4e2a\u6570\u4e0d\u7b49\u4e8e\u952e\u7684\u4e2a\u6570\u8bf4\u660e\u6b63\u89e3\u6790\u5230\u952e\u5bf9\u5e94\u7684\u503c\uff0c\u5373\u4e00\u4e00\u5bf9\u5e94\u3002 8. \u5426\u5219\u8bf4\u660e\u4e00\u4e2a\u952e\u5b58\u5728\u591a\u4e2a\u503c\uff0c\u5219\u4e0d\u66f4\u65b0\u503c\u7684\u4e2a\u6570\uff0c\u591a\u4e2a\u503c\u7d2f\u52a0\u5230\u4e00\u4e2aslot 9. */ 10. if (num_values_ != num_fields_) { 11. // start of new header value 12. num_values_++; 13. values_[num_values_ - 1].Reset(); 14. } 15. 16. CHECK_LT(num_values_, arraysize(values_)); 17. CHECK_EQ(num_values_, num_fields_); 18. 19. values_[num_values_ - 1].Update(at, length); 20. 21. return 0; 22. } 6\u89e3\u6790\u5b8cHTTP\u5934\u540e\u7684\u56de\u8c03 1. int on_headers_complete() { 2. header_nread_ = 0; 3. enum on_headers_complete_arg_index { 4. A_VERSION_MAJOR = 0, 5. A_VERSION_MINOR, 6. A_HEADERS, 7. A_METHOD, 8. A_URL, 9. A_STATUS_CODE, 10. A_STATUS_MESSAGE, 11. A_UPGRADE, 12. A_SHOULD_KEEP_ALIVE, 13. A_MAX 14. }; 15. 16. Local<Value> argv[A_MAX]; 17. Local<Object> obj = object(); 18. Local<Value> cb = obj->Get(env()->context(), 19. kOnHeadersComplete).ToLocalChecked(); 20. 21. Local<Value> undefined = Undefined(env()->isolate()); 22. for (size_t i = 0; i < arraysize(argv); i++) 23. argv[i] = undefined; 24. // \u4e4b\u524dflush\u8fc7\uff0c\u5219\u7ee7\u7eedflush\u5230JS\u5c42\uff0c\u5426\u5219\u8fd4\u56de\u5168\u90e8\u5934\u7ed9js 25. if (have_flushed_) { 26. // Slow case, flush remaining headers. 27. Flush(); 28. } else { 29. // Fast case, pass headers and URL to JS land. 30. argv[A_HEADERS] = CreateHeaders(); 31. if (parser_.type == HTTP_REQUEST) 32. argv[A_URL] = url_.ToString(env()); 33. } 34. 35. num_fields_ = 0; 36. num_values_ = 0; 37. 38. // METHOD 39. if (parser_.type == HTTP_REQUEST) { 40. argv[A_METHOD] = 41. Uint32::NewFromUnsigned(env()->isolate(), parser_.method); 42. } 43. 44. // STATUS 45. if (parser_.type == HTTP_RESPONSE) { 46. argv[A_STATUS_CODE] = 47. Integer::New(env()->isolate(), parser_.status_code); 48. argv[A_STATUS_MESSAGE] = status_message_.ToString(env()); 49. } 50. 51. // VERSION 52. argv[A_VERSION_MAJOR] = Integer::New(env()->isolate(), parser_.http_major); 53. argv[A_VERSION_MINOR] = Integer::New(env()->isolate(), parser_.http_minor); 54. 55. bool should_keep_alive; 56. // \u662f\u5426\u5b9a\u4e49\u4e86keepalive\u5934 57. should_keep_alive = llhttp_should_keep_alive(&parser_); 58. 59. argv[A_SHOULD_KEEP_ALIVE] = 60. Boolean::New(env()->isolate(), should_keep_alive); 61. // \u662f\u5426\u662f\u5347\u7ea7\u534f\u8bae 62. argv[A_UPGRADE] = Boolean::New(env()->isolate(), parser_.upgrade); 63. 64. MaybeLocal<Value> head_response; 65. { 66. InternalCallbackScope callback_scope( 67. this, InternalCallbackScope::kSkipTaskQueues); 68. head_response = cb.As<Function>()->Call( 69. env()->context(), object(), arraysize(argv), argv); 70. } 71. 72. int64_t val; 73. 74. if (head_response.IsEmpty() || !head_response.ToLocalChecked() 75. ->IntegerValue(env()->context()) 76. .To(&val)) { 77. got_exception_ = true; 78. return -1; 79. } 80. 81. return val; 82. } on_headers_complete\u4f1a\u6267\u884cJS\u5c42\u7684kOnHeadersComplete\u94a9\u5b50\u3002 7 \u89e3\u6790body\u65f6\u7684\u56de\u8c03 1. int on_body(const char* at, size_t length) { 2. EscapableHandleScope scope(env()->isolate()); 3. 4. Local<Object> obj = object(); 5. Local<Value> cb = obj->Get(env()->context(), kOnBody).ToLocalChecked(); 6. 7. // We came from consumed stream 8. if (current_buffer_.IsEmpty()) { 9. // Make sure Buffer will be in parent HandleScope 10. current_buffer_ = scope.Escape(Buffer::Copy( 11. env()->isolate(), 12. current_buffer_data_, 13. current_buffer_len_).ToLocalChecked()); 14. } 15. 16. Local<Value> argv[3] = { 17. // \u5f53\u524d\u89e3\u6790\u4e2d\u7684\u6570\u636e 18. current_buffer_, 19. // body\u5f00\u59cb\u7684\u4f4d\u7f6e 20. Integer::NewFromUnsigned(env()->isolate(), at - current_buffer_data_), 21. // body\u5f53\u524d\u957f\u5ea6 22. Integer::NewFromUnsigned(env()->isolate(), length) 23. }; 24. 25. MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 26. arraysize(argv), 27. argv); 28. 29. return 0; 30. } Node.js\u4e2d\u5e76\u4e0d\u662f\u6bcf\u6b21\u89e3\u6790HTTP\u62a5\u6587\u7684\u65f6\u5019\u5c31\u65b0\u5efa\u4e00\u4e2aHTTP\u89e3\u6790\u5668\uff0cNode.js\u4f7f\u7528FreeList\u6570\u636e\u7ed3\u6784\u5bf9HTTP\u89e3\u6790\u5668\u5b9e\u4f8b\u8fdb\u884c\u4e86\u7ba1\u7406\u3002 1. class FreeList { 2. constructor(name, max, ctor) { 3. this.name = name; 4. // \u6784\u9020\u51fd\u6570 5. this.ctor = ctor; 6. // \u8282\u70b9\u7684\u6700\u5927\u503c 7. this.max = max; 8. // \u5b9e\u4f8b\u5217\u8868 9. this.list = []; 10. } 11. // \u5206\u914d\u4e00\u4e2a\u5b9e\u4f8b 12. alloc() { 13. // \u6709\u7a7a\u95f2\u7684\u5219\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u65b0\u5efa\u4e00\u4e2a 14. return this.list.length > 0 ? 15. this.list.pop() : 16. ReflectApply(this.ctor, this, arguments); 17. } 18. // \u91ca\u653e\u5b9e\u4f8b 19. free(obj) { 20. // \u5c0f\u4e8e\u9608\u503c\u5219\u653e\u5230\u7a7a\u95f2\u5217\u8868\uff0c\u5426\u5219\u91ca\u653e\uff08\u8c03\u7528\u65b9\u8d1f\u8d23\u91ca\u653e\uff09 21. if (this.list.length < this.max) { 22. this.list.push(obj); 23. return true; 24. } 25. return false; 26. } 27. } \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5bf9FreeList\u7684\u4f7f\u7528\u3002\u3002 1. const parsers = new FreeList('parsers', 1000, function parsersCb() { 2. const parser = new HTTPParser(); 3. // \u521d\u59cb\u5316\u5b57\u6bb5 4. cleanParser(parser); 5. // \u8bbe\u7f6e\u94a9\u5b50 6. parser.onIncoming = null; 7. parser[kOnHeaders] = parserOnHeaders; 8. parser[kOnHeadersComplete] = parserOnHeadersComplete; 9. parser[kOnBody] = parserOnBody; 10. parser[kOnMessageComplete] = parserOnMessageComplete; 11. 12. return parser; 13. }); HTTP\u89e3\u6790\u5668\u7684\u4f7f\u7528 1. var HTTPParser = process.binding('http_parser').HTTPParser; 2. var parser = new HTTPParser(HTTPParser.REQUEST); 3. 4. const kOnHeaders = HTTPParser.kOnHeaders; 5. const kOnHeadersComplete = HTTPParser.kOnHeadersComplete; 6. const kOnBody = HTTPParser.kOnBody; 7. const kOnMessageComplete = HTTPParser.kOnMessageComplete; 8. const kOnExecute = HTTPParser.kOnExecute; 9. 10. parser[kOnHeaders] = function(headers, url) { 11. console.log('kOnHeaders', headers.length, url); 12. } 13. parser[kOnHeadersComplete] = function(versionMajor, versionMinor, headers, method, 14. url, statusCode, statusMessage, upgrade, shouldKeepAlive) { 15. console.log('kOnHeadersComplete', headers); 16. } 17. 18. parser[kOnBody] = function(b, start, len) { 19. console.log('kOnBody', b.slice(start).toString('utf-8')); 20. } 21. parser[kOnMessageComplete] = function() { 22. console.log('kOnMessageComplete'); 23. } 24. parser[kOnExecute] = function() { 25. console.log('kOnExecute'); 26. } 27. 28. parser.execute(Buffer.from( 29. 'GET / HTTP/1.1\\r\\n' + 30. 'Host: http://localhost\\r\\n\\r\\n' 31. )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1. kOnHeadersComplete [ 'Host', 'http://localhost' ] 2. kOnMessageComplete \u6211\u4eec\u770b\u5230\u53ea\u6267\u884c\u4e86kOnHeadersComplete\u548c kOnMessageComplete\u3002\u90a3\u5176\u5b83\u51e0\u4e2a\u56de\u8c03\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770b\u3002\u6211\u4eec\u628a\u8f93\u5165\u6539\u4e00\u4e0b\u3002 1. parser.execute(Buffer.from( 2. 'GET / HTTP/1.1\\r\\n' + 3. 'Host: http://localhost\\r\\n' + 4. 'content-length: 1\\r\\n\\r\\n'+ 5. '1' 6. )); \u4e0a\u9762\u4ee3\u7801\u7684\u8f93\u51fa 1. kOnHeadersComplete [ 'Host', 'http://localhost', 'content-length', '1' ] 2. kOnBody 1 3. kOnMessageComplete \u6211\u4eec\u770b\u5230\u591a\u4e86\u4e00\u4e2a\u56de\u8c03kOnBody\uff0c\u56e0\u4e3a\u6211\u4eec\u52a0\u4e86\u4e00\u4e2aHTTP\u5934content-length\u6307\u793a\u6709body\uff0c\u6240\u4ee5HTTP\u89e3\u6790\u5668\u89e3\u6790\u5230body\u7684\u65f6\u5019\u5c31\u4f1a\u56de\u8c03kOnBody\u3002\u90a3kOnHeaders\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801\u3002 1. parser.execute(Buffer.from( 2. 'GET / HTTP/1.1\\r\\n' + 3. 'Host: http://localhost\\r\\n' + 4. 'a: b\\r\\n'+ 5. // \u5f88\u591a'a: b\\r\\n'+ 6. 'content-length: 1\\r\\n\\r\\n'+ 7. '1' 8. )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1. kOnHeaders 62 / 2. kOnHeaders 22 3. kOnHeadersComplete undefined 4. kOnBody 1 5. kOnMessageComplete \u6211\u4eec\u770b\u5230kOnHeaders\u88ab\u6267\u884c\u4e86\uff0c\u5e76\u4e14\u6267\u884c\u4e86\u4e24\u6b21\u3002\u56e0\u4e3a\u5982\u679cHTTP\u5934\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5728\u89e3\u6790HTTP\u5934\u90e8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u5148flush\u5230JS\u5c42\uff08\u5982\u679c\u591a\u6b21\u8fbe\u5230\u9608\u503c\uff0c\u5219\u56de\u8c03\u591a\u6b21\uff09\uff0c\u5e76\u4e14\u5728\u89e3\u6790\u5b8c\u6240\u6709HTTP\u5934\u540e\uff0c\u4f1a\u5728kOnHeadersComplet\u56de\u8c03\u4e4b\u524d\u518d\u6b21\u56de\u8c03kOnHeaders\uff08\u5982\u679c\u8fd8\u6709\u7684\u8bdd\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u5982\u4f55\u89e6\u53d1\u3002 1. var HTTPParser = process.binding('http_parser').HTTPParser; 2. var parser = new HTTPParser(HTTPParser.REQUEST); 3. var net = require('net'); 4. 5. const kOnHeaders = HTTPParser.kOnHeaders; 6. const kOnHeadersComplete = HTTPParser.kOnHeadersComplete; 7. const kOnBody = HTTPParser.kOnBody; 8. const kOnMessageComplete = HTTPParser.kOnMessageComplete; 9. const kOnExecute = HTTPParser.kOnExecute; 10. 11. parser[kOnHeaders] = function(headers, url) { 12. console.log('kOnHeaders', headers.length, url); 13. } 14. parser[kOnHeadersComplete] = function(versionMajor, versionMinor, headers, method, 15. url, statusCode, statusMessage, upgrade, shouldKeepAlive) { 16. console.log('kOnHeadersComplete', headers); 17. } 18. 19. parser[kOnBody] = function(b, start, len) { 20. console.log('kOnBody', b.slice(start).toString('utf-8')); 21. } 22. parser[kOnMessageComplete] = function() { 23. console.log('kOnMessageComplete'); 24. } 25. parser[kOnExecute] = function(a,b) { 26. console.log('kOnExecute,\u89e3\u6790\u7684\u5b57\u8282\u6570\uff1a',a); 27. } 28. // \u542f\u52a8\u4e00\u4e2a\u670d\u52a1\u5668 29. net.createServer((socket) => { 30. parser.consume(socket._handle); 31. }).listen(80); 32. 33. // \u542f\u52a8\u4e00\u4e2a\u5ba2\u6237\u7aef 34. setTimeout(() => { 35. var socket = net.connect({port: 80}); 36. socket.end('GET / HTTP/1.1\\r\\n' + 37. 'Host: http://localhost\\r\\n' + 38. 'content-length: 1\\r\\n\\r\\n'+ 39. '1'); 40. }, 1000); \u6211\u4eec\u9700\u8981\u8c03\u7528parser.consume\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2aisStreamBase\u7684\u6d41\uff08stream_base.cc\u5b9a\u4e49\uff09\uff0c\u624d\u4f1a\u89e6\u53d1kOnExecute\u3002\u56e0\u4e3akOnExecute\u662f\u5728StreamBase\u6d41\u53ef\u8bfb\u65f6\u89e6\u53d1\u7684\u3002","title":"18.1 HTTP\u89e3\u6790\u5668"},{"location":"chapter18-HTTP/#182-http","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4f7f\u7528Node.js\u4f5c\u4e3a\u5ba2\u6237\u7aef\u7684\u4f8b\u5b50\u3002 1. const data = querystring.stringify({ 2. 'msg': 'hi' 3. }); 4. 5. const options = { 6. hostname: 'your domain', 7. path: '/', 8. method: 'POST', 9. headers: { 10. 'Content-Type': 'application/x-www-form-urlencoded', 11. 'Content-Length': Buffer.byteLength(data) 12. } 13. }; 14. 15. const req = http.request(options, (res) => { 16. res.setEncoding('utf8'); 17. res.on('data', (chunk) => { 18. console.log(`${chunk}`); 19. }); 20. res.on('end', () => { 21. console.log('end'); 22. }); 23. }); 24. 25. req.on('error', (e) => { 26. console.error(`${e.message}`); 27. }); 28. // \u53d1\u9001\u8bf7\u6c42\u7684\u6570\u636e 29. req.write(data); 30. // \u8bbe\u7f6e\u8bf7\u6c42\u7ed3\u675f 31. req.end(); \u6211\u4eec\u770b\u4e00\u4e0bhttp.request\u7684\u5b9e\u73b0\u3002 1. function request(url, options, cb) { 2. return new ClientRequest(url, options, cb); 3. } HTTP\u5ba2\u6237\u7aef\u901a\u8fc7_http_client.js\u7684ClientRequest\u5b9e\u73b0\uff0cClientRequest\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u6211\u4eec\u53ea\u5206\u6790\u6838\u5fc3\u7684\u6d41\u7a0b\u3002\u6211\u4eec\u770b\u521d\u59cb\u5316\u4e00\u4e2a\u8bf7\u6c42\u7684\u903b\u8f91\u3002 1. function ClientRequest(input, options, cb) { 2. // \u7ee7\u627fOutgoingMessage 3. OutgoingMessage.call(this); 4. // \u662f\u5426\u4f7f\u7528agent 5. let agent = options.agent; 6. // \u5ffd\u7565agent\u7684\u5904\u7406\uff0c\u5177\u4f53\u53c2\u8003_http_agent.js\uff0c\u4e3b\u8981\u7528\u4e8e\u590d\u7528TCP\u8fde\u63a5 7. this.agent = agent; 8. // \u5efa\u7acb\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4 9. if (options.timeout !== undefined) 10. this.timeout = getTimerDuration(options.timeout, 'timeout'); 11. // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c 12. const maxHeaderSize = options.maxHeaderSize; 13. this.maxHeaderSize = maxHeaderSize; 14. // \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6 15. if (cb) { 16. this.once('response', cb); 17. } 18. // \u5ffd\u7565\u8bbe\u7f6ehttp\u534f\u8bae\u7684\u8bf7\u6c42\u884c\u6216\u8bf7\u6c42\u5934\u7684\u903b\u8f91 19. // \u5efa\u7acbTCP\u8fde\u63a5\u540e\u7684\u56de\u8c03 20. const oncreate = (err, socket) => { 21. if (called) 22. return; 23. called = true; 24. if (err) { 25. process.nextTick(() => this.emit('error', err)); 26. return; 27. } 28. // \u5efa\u7acb\u8fde\u63a5\u6210\u529f\uff0c\u6267\u884c\u56de\u8c03 29. this.onSocket(socket); 30. // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u6570\u636e 31. this._deferToConnect(null, null, () => this._flush()); 32. }; 33. 34. // \u4f7f\u7528agent\u65f6\uff0csocket\u7531agent\u63d0\u4f9b\uff0c\u5426\u5219\u81ea\u5df1\u521b\u5efasocket 35. if (this.agent) { 36. this.agent.addRequest(this, options); 37. } else { 38. // \u4e0d\u4f7f\u7528agent\u5219\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2asocket\uff0c\u9ed8\u8ba4\u4f7f\u7528net\u6a21\u5757\u7684\u63a5\u53e3 39. if (typeof options.createConnection === 'function') { 40. const newSocket = options.createConnection(options, 41. oncreate); 42. if (newSocket && !called) { 43. called = true; 44. this.onSocket(newSocket); 45. } else { 46. return; 47. } 48. } else { 49. this.onSocket(net.createConnection(options)); 50. } 51. } 52. // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u5f85\u7f13\u5b58\u7684\u6570\u636e 53. this._deferToConnect(null, null, () => this._flush()); 54. } \u83b7\u53d6\u4e00\u4e2aClientRequest\u5b9e\u4f8b\u540e\uff0c\u4e0d\u7ba1\u662f\u901a\u8fc7agent\u8fd8\u662f\u81ea\u5df1\u521b\u5efa\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\u90fd\u4f1a\u6267\u884conSocket\u3002 1. // socket\u53ef\u7528\u65f6\u7684\u56de\u8c03 2. ClientRequest.prototype.onSocket = function onSocket(socket) { 3. process.nextTick(onSocketNT, this, socket); 4. }; 5. 6. function onSocketNT(req, socket) { 7. // \u7533\u8bf7socket\u8fc7\u7a0b\u4e2d\uff0c\u8bf7\u6c42\u5df2\u7ecf\u7ec8\u6b62 8. if (req.aborted) { 9. // \u4e0d\u4f7f\u7528agent\uff0c\u76f4\u63a5\u9500\u6bc1socekt 10. if (!req.agent) { 11. socket.destroy(); 12. } else { 13. // \u4f7f\u7528agent\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u7531agent\u5904\u7406socekt 14. req.emit('close'); 15. socket.emit('free'); 16. } 17. } else { 18. // \u5904\u7406socket 19. tickOnSocket(req, socket); 20. } 21. } \u6211\u4eec\u7ee7\u7eed\u770btickOnSocket 1. // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u548c\u6ce8\u518cdata\u4e8b\u4ef6\u7b49\uff0c\u7b49\u5f85\u54cd\u5e94 2. function tickOnSocket(req, socket) { 3. // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 4. const parser = parsers.alloc(); 5. req.socket = socket; 6. // \u521d\u59cb\u5316\uff0c\u5904\u7406\u54cd\u5e94\u62a5\u6587 7. parser.initialize(HTTPParser.RESPONSE, 8. new HTTPClientAsyncResource('HTTPINCOMINGMESSAGE', req), req.maxHeaderSize || 0, 9. req.insecureHTTPParser === undefined ? 10. isLenient() : req.insecureHTTPParser); 11. parser.socket = socket; 12. parser.outgoing = req; 13. req.parser = parser; 14. 15. socket.parser = parser; 16. // socket\u6b63\u5904\u7406\u7684\u8bf7\u6c42 17. socket._httpMessage = req; 18. 19. // Propagate headers limit from request object to parser 20. if (typeof req.maxHeadersCount === 'number') { 21. parser.maxHeaderPairs = req.maxHeadersCount << 1; 22. } 23. // \u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u56de\u8c03 24. parser.onIncoming = parserOnIncomingClient; 25. socket.removeListener('error', freeSocketErrorListener); 26. socket.on('error', socketErrorListener); 27. socket.on('data', socketOnData); 28. socket.on('end', socketOnEnd); 29. socket.on('close', socketCloseListener); 30. socket.on('drain', ondrain); 31. 32. if ( 33. req.timeout !== undefined || 34. (req.agent && req.agent.options && 35. req.agent.options.timeout) 36. ) { 37. // \u5904\u7406\u8d85\u65f6\u65f6\u95f4 38. listenSocketTimeout(req); 39. } 40. req.emit('socket', socket); 41. } \u62ff\u5230\u4e00\u4e2asocket\u540e\uff0c\u5c31\u5f00\u59cb\u76d1\u542csocket\u4e0ahttp\u62a5\u6587\u7684\u5230\u6765\u3002\u5e76\u4e14\u7533\u8bf7\u4e00\u4e2aHTTP\u89e3\u6790\u5668\u51c6\u5907\u89e3\u6790http\u62a5\u6587\uff0c\u6211\u4eec\u4e3b\u8981\u5206\u6790\u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406\u548cdata\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1 \u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406 1. function listenSocketTimeout(req) { 2. // \u8bbe\u7f6e\u8fc7\u4e86\u5219\u8fd4\u56de 3. if (req.timeoutCb) { 4. return; 5. } 6. // \u8d85\u65f6\u56de\u8c03 7. req.timeoutCb = emitRequestTimeout; 8. // Delegate socket timeout event. 9. // \u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373socket\u4e0a\u4e00\u5b9a\u65f6\u95f4\u540e\u6ca1\u6709\u54cd\u5e94\u5219\u89e6\u53d1\u8d85\u65f6 10. if (req.socket) { 11. req.socket.once('timeout', emitRequestTimeout); 12. } else { 13. req.on('socket', (socket) => { 14. socket.once('timeout', emitRequestTimeout); 15. }); 16. } 17. } 18. 19. function emitRequestTimeout() { 20. const req = this._httpMessage; 21. if (req) { 22. req.emit('timeout'); 23. } 24. } 2 \u5904\u7406\u54cd\u5e94\u6570\u636e 1. function socketOnData(d) { 2. const socket = this; 3. const req = this._httpMessage; 4. const parser = this.parser; 5. // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406 6. const ret = parser.execute(d); 7. // ... 8. } \u5f53Node.js\u6536\u5230\u54cd\u5e94\u62a5\u6587\u65f6\uff0c\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002http\u89e3\u6790\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bJS\u5c42\u5404\u4e2a\u94a9\u5b50\u51fd\u6570\u7684\u903b\u8f91\u3002 1 \u89e3\u6790\u5934\u90e8\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03 1. function parserOnHeaders(headers, url) { 2. // \u4fdd\u5b58\u5934\u548curl 3. if (this.maxHeaderPairs <= 0 || 4. this._headers.length < this.maxHeaderPairs) { 5. this._headers = this._headers.concat(headers); 6. } 7. this._url += url; 8. } 2 \u89e3\u6790\u5b8c\u5934\u90e8\u7684\u56de\u8c03 1. function parserOnHeadersComplete(versionMajor, 2. versionMinor, 3. headers, 4. method, 5. url, 6. statusCode, 7. statusMessage, 8. upgrade, 9. shouldKeepAlive) { 10. const parser = this; 11. const { socket } = parser; 12. // \u5269\u4e0b\u7684HTTP\u5934 13. if (headers === undefined) { 14. headers = parser._headers; 15. parser._headers = []; 16. } 17. 18. if (url === undefined) { 19. url = parser._url; 20. parser._url = ''; 21. } 22. 23. // Parser is also used by http client 24. // IncomingMessage 25. const ParserIncomingMessage=(socket && 26. socket.server && 27. socket.server[kIncomingMessage] 28. ) || 29. IncomingMessage; 30. // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 31. const incoming = parser.incoming = new ParserIncomingMessage(socket); 32. incoming.httpVersionMajor = versionMajor; 33. incoming.httpVersionMinor = versionMinor; 34. incoming.httpVersion = `${versionMajor}.${versionMinor}`; 35. incoming.url = url; 36. incoming.upgrade = upgrade; 37. 38. let n = headers.length; 39. // If parser.maxHeaderPairs <= 0 assume that there's no limit. 40. if (parser.maxHeaderPairs > 0) 41. n = MathMin(n, parser.maxHeaderPairs); 42. // \u66f4\u65b0\u5230\u4fdd\u5b58HTTP\u5934\u7684\u5bf9\u8c61 43. incoming._addHeaderLines(headers, n); 44. // \u8bf7\u6c42\u65b9\u6cd5\u6216\u54cd\u5e94\u884c\u4fe1\u606f 45. if (typeof method === 'number') { 46. // server only 47. incoming.method = methods[method]; 48. } else { 49. // client only 50. incoming.statusCode = statusCode; 51. incoming.statusMessage = statusMessage; 52. } 53. // \u6267\u884c\u56de\u8c03 54. return parser.onIncoming(incoming, shouldKeepAlive); 55. } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8c\u5934\u90e8\u540e\u4f1a\u6267\u884c\u53e6\u4e00\u4e2a\u56de\u8c03onIncoming\uff0c\u5e76\u4f20\u5165IncomingMessage\u5b9e\u4f8b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684res\u3002\u5728\u524d\u9762\u5206\u6790\u8fc7\uff0conIncoming\u8bbe\u7f6e\u7684\u503c\u662fparserOnIncomingClient\u3002 1. function parserOnIncomingClient(res, shouldKeepAlive) { 2. const socket = this.socket; 3. // \u8bf7\u6c42\u5bf9\u8c61 4. const req = socket._httpMessage; 5. // \u670d\u52a1\u5668\u53d1\u9001\u4e86\u591a\u4e2a\u54cd\u5e94 6. if (req.res) { 7. socket.destroy(); 8. return 0; 9. } 10. req.res = res; 11. 12. if (statusIsInformational(res.statusCode)) { 13. req.res = null; 14. // \u8bf7\u6c42\u65f6\u8bbe\u7f6e\u4e86expect\u5934\uff0c\u5219\u54cd\u5e94\u7801\u4e3a100\uff0c\u53ef\u4ee5\u7ee7\u7eed\u53d1\u9001\u6570\u636e 15. if (res.statusCode === 100) { 16. req.emit('continue'); 17. } 18. return 1; 19. } 20. 21. req.res = res; 22. res.req = req; 23. 24. // \u7b49\u5f85\u54cd\u5e94\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u4f1a\u6e05\u9664\u5b9a\u65f6\u5668 25. res.on('end', responseOnEnd); 26. // \u8bf7\u6c42\u7ec8\u6b62\u4e86\u6216\u89e6\u53d1response\u4e8b\u4ef6\uff0c\u8fd4\u56defalse\u8bf4\u660e\u6ca1\u6709\u76d1\u542cresponse\u4e8b\u4ef6\uff0c\u5219\u4e22\u5f03\u6570\u636e 27. if (req.aborted || !req.emit('response', res)) 28. res._dump(); 29. 30. } \u4ece\u6e90\u7801\u4e2d\u6211\u4eec\u770b\u51fa\u5728\u89e3\u6790\u5b8cHTTP\u54cd\u5e94\u5934\u65f6\uff0c\u5c31\u6267\u884c\u4e86http.request\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u3002\u4f8b\u5982\u4e0b\u9762\u4ee3\u7801\u4e2d\u7684\u56de\u8c03\u3002 1. http. request('domain', { agent }, (res) => { 2. // \u89e3\u6790body 3. res.on('data', (data) => { 4. // 5. }); 6. // \u89e3\u6790body\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f 7. res.on('end', (data) => { 8. // 9. }); 10. }); 11. // ... \u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u628ares\u4f5c\u4e3a\u4e00\u4e2a\u6d41\u4f7f\u7528\uff0c\u5728\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cHTTP\u89e3\u6790\u5668\u4f1a\u7ee7\u7eed\u89e3\u6790HTTP body\u3002\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u89e3\u6790\u5668\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03\u3002 1. function parserOnBody(b, start, len) { 2. const stream = this.incoming; 3. if (len > 0 && !stream._dumped) { 4. const slice = b.slice(start, start + len); 5. // \u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 6. const ret = stream.push(slice); 7. // \u6570\u636e\u8fc7\u8f7d\uff0c\u6682\u505c\u63a5\u6536 8. if (!ret) 9. readStop(this.socket); 10. } 11. } \u6700\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u89e3\u6790\u5b8cbody\u65f6HTTP\u89e3\u6790\u5668\u6267\u884c\u7684\u56de\u8c03\u3002 1. function parserOnMessageComplete() { 2. const parser = this; 3. const stream = parser.incoming; 4. 5. if (stream !== null) { 6. // body\u89e3\u6790\u5b8c\u4e86 7. stream.complete = true; 8. // \u5728body\u540e\u53ef\u80fd\u6709trailer\u5934\uff0c\u4fdd\u5b58\u4e0b\u6765 9. const headers = parser._headers; 10. if (headers.length) { 11. stream._addHeaderLines(headers, headers.length); 12. parser._headers = []; 13. parser._url = ''; 14. } 15. // \u6d41\u7ed3\u675f 16. stream.push(null); 17. } 18. 19. // \u8bfb\u53d6\u4e0b\u4e00\u4e2a\u54cd\u5e94\uff0c\u5982\u679c\u6709\u7684\u8bdd 20. readStart(parser.socket); 21. } \u6211\u4eec\u770b\u5230\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5f80\u6d41\u4e2dpush\u6570\u636e\uff0c\u4ece\u800c\u4e0d\u65ad\u89e6\u53d1res\u7684data\u4e8b\u4ef6\uff0c\u6700\u540e\u89e3\u6790body\u7ed3\u675f\u540e\uff0c\u901a\u8fc7push(null)\u901a\u77e5\u6d41\u7ed3\u675f\uff0c\u4ece\u800c\u89e6\u53d1res.end\u4e8b\u4ef6\u3002\u6211\u4eec\u6cbf\u7740onSocket\u51fd\u6570\u5206\u6790\u5b8c\u5904\u7406\u54cd\u5e94\u540e\u6211\u4eec\u518d\u6765\u5206\u6790\u8bf7\u6c42\u7684\u8fc7\u7a0b\u3002\u6267\u884c\u5b8chttp.request\u540e\u6211\u4eec\u4f1a\u5f97\u5230\u4e00\u4e2a\u6807\u8bb0\u8bf7\u6c42\u7684\u5b9e\u4f8b\u3002\u7136\u540e\u6267\u884c\u5b83\u7684write\u65b9\u6cd5\u53d1\u9001\u6570\u636e\u3002 1. OutgoingMessage.prototype.write = function write(chunk, encoding, callback) { 2. const ret = write_(this, chunk, encoding, callback, false); 3. // \u8fd4\u56defalse\u8bf4\u660e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6 4. if (!ret) 5. this[kNeedDrain] = true; 6. return ret; 7. }; 8. 9. function write_(msg, chunk, encoding, callback, fromEnd) { 10. 11. // \u8fd8\u6ca1\u6709\u8bbe\u7f6ethis._header\u5b57\u6bb5\uff0c\u5219\u628a\u8bf7\u6c42\u884c\u548cHTTP\u5934\u62fc\u63a5\u5230this._header\u5b57\u6bb5 12. if (!msg._header) { 13. msg._implicitHeader(); 14. } 15. 16. let ret; 17. // chunk\u6a21\u5f0f\u5219\u9700\u8981\u989d\u5916\u52a0\u4e00\u4e0b\u5b57\u6bb5\uff0c\u5426\u5219\u76f4\u63a5\u53d1\u9001 18. if (msg.chunkedEncoding && chunk.length !== 0) { 19. let len; 20. if (typeof chunk === 'string') 21. len = Buffer.byteLength(chunk, encoding); 22. else 23. len = chunk.length; 24. /* 25. chunk\u6a21\u5f0f\u65f6\uff0chttp\u62a5\u6587\u7684\u683c\u5f0f\u5982\u4e0b 26. chunk\u957f\u5ea6 \u56de\u8f66\u6362\u884c 27. \u6570\u636e \u56de\u8f66\u6362\u884c 28. */ 29. msg._send(len.toString(16), 'latin1', null); 30. msg._send(crlf_buf, null, null); 31. msg._send(chunk, encoding, null); 32. ret = msg._send(crlf_buf, null, callback); 33. } else { 34. ret = msg._send(chunk, encoding, callback); 35. } 36. 37. return ret; 38. } \u6211\u4eec\u63a5\u7740\u770b_send\u51fd\u6570 1. OutgoingMessage.prototype._send = function _send(data, encoding, callback) { 2. // \u5934\u90e8\u8fd8\u6ca1\u6709\u53d1\u9001 3. if (!this._headerSent) { 4. // \u662f\u5b57\u7b26\u4e32\u5219\u8ffd\u52a0\u5230\u5934\u90e8\uff0cthis._header\u4fdd\u5b58\u4e86HTTP\u8bf7\u6c42\u884c\u548cHTTP\u5934 5. if (typeof data === 'string' && 6. (encoding === 'utf8' || 7. encoding === 'latin1' || 8. !encoding)) { 9. data = this._header + data; 10. } else { 11. // \u5426\u5219\u7f13\u5b58\u8d77\u6765 12. const header = this._header; 13. // HTTP\u5934\u9700\u8981\u653e\u5230\u6700\u524d\u9762 14. if (this.outputData.length === 0) { 15. this.outputData = [{ 16. data: header, 17. encoding: 'latin1', 18. callback: null 19. }]; 20. } else { 21. this.outputData.unshift({ 22. data: header, 23. encoding: 'latin1', 24. callback: null 25. }); 26. } 27. // \u66f4\u65b0\u7f13\u5b58\u5927\u5c0f 28. this.outputSize += header.length; 29. this._onPendingData(header.length); 30. } 31. // \u5df2\u7ecf\u5728\u6392\u961f\u7b49\u5f85\u53d1\u9001\u4e86\uff0c\u4e0d\u80fd\u4fee\u6539 32. this._headerSent = true; 33. } 34. return this._writeRaw(data, encoding, callback); 35. }; \u6211\u4eec\u7ee7\u7eed\u770b_writeRaw 1. OutgoingMessage.prototype._writeRaw = function _writeRaw(data, encoding, callback) { 2. 3. // \u53ef\u5199\u7684\u65f6\u5019\u76f4\u63a5\u53d1\u9001 4. if (conn && conn._httpMessage === this && conn.writable) { 5. // There might be pending data in the this.output buffer. 6. // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e 7. if (this.outputData.length) { 8. this._flushOutput(conn); 9. } 10. // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 11. return conn.write(data, encoding, callback); 12. } 13. // \u5426\u5148\u7f13\u5b58 14. this.outputData.push({ data, encoding, callback }); 15. this.outputSize += data.length; 16. this._onPendingData(data.length); 17. return this.outputSize < HIGH_WATER_MARK; 18. } 19. 20. OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) { 21. // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e 22. while (this[kCorked]) { 23. this[kCorked]--; 24. socket.cork(); 25. } 26. 27. const outputLength = this.outputData.length; 28. if (outputLength <= 0) 29. return undefined; 30. 31. const outputData = this.outputData; 32. socket.cork(); 33. // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket 34. let ret; 35. for (let i = 0; i < outputLength; i++) { 36. const { data, encoding, callback } = outputData[i]; 37. ret = socket.write(data, encoding, callback); 38. } 39. socket.uncork(); 40. 41. this.outputData = []; 42. this._onPendingData(-this.outputSize); 43. this.outputSize = 0; 44. 45. return ret; 46. }; \u5199\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u6267\u884cend\u51fd\u6570\u6807\u8bb0HTTP\u8bf7\u6c42\u7684\u7ed3\u675f\u3002 1. OutgoingMessage.prototype.end = function end(chunk, encoding, callback) { 2. // \u8fd8\u6ca1\u7ed3\u675f 3. // \u52a0\u585e 4. if (this.socket) { 5. this.socket.cork(); 6. } 7. 8. // \u6d41\u7ed3\u675f\u540e\u56de\u8c03 9. if (typeof callback === 'function') 10. this.once('finish', callback); 11. // \u6570\u636e\u5199\u5165\u5e95\u5c42\u540e\u7684\u56de\u8c03 12. const finish = onFinish.bind(undefined, this); 13. // chunk\u6a21\u5f0f\u540e\u9762\u9700\u8981\u53d1\u9001\u4e00\u4e2a0\\r\\n\u7ed3\u675f\u6807\u8bb0\uff0c\u5426\u5219\u4e0d\u9700\u8981\u7ed3\u675f\u6807\u8bb0 14. if (this._hasBody && this.chunkedEncoding) { 15. this._send('0\\r\\n' + 16. this._trailer + '\\r\\n', 'latin1', finish); 17. } else { 18. this._send('', 'latin1', finish); 19. } 20. // uncork\u89e3\u9664\u585e\u5b50\uff0c\u53d1\u9001\u6570\u636e 21. if (this.socket) { 22. // Fully uncork connection on end(). 23. this.socket._writableState.corked = 1; 24. this.socket.uncork(); 25. } 26. this[kCorked] = 0; 27. // \u6807\u8bb0\u6267\u884c\u4e86end 28. this.finished = true; 29. // \u6570\u636e\u53d1\u5b8c\u4e86 30. if (this.outputData.length === 0 && 31. this.socket && 32. this.socket._httpMessage === this) { 33. this._finish(); 34. } 35. 36. return this; 37. };","title":"18.2 HTTP\u5ba2\u6237\u7aef"},{"location":"chapter18-HTTP/#183-http","text":"\u672c\u8282\u6211\u4eec\u6765\u5206\u6790\u4f7f\u7528Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u4f8b\u5b50\u3002 1. const http = require('http'); 2. http.createServer((req, res) => { 3. res.write('hello'); 4. res.end(); 5. }) 6. .listen(3000); \u63a5\u7740\u6211\u4eec\u6cbf\u7740createServer\u5206\u6790Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1. function createServer(opts, requestListener) { 2. return new Server(opts, requestListener); 3. } \u6211\u4eec\u770bServer\u7684\u5b9e\u73b0 1. function Server(options, requestListener) { 2. // \u53ef\u4ee5\u81ea\u5b9a\u4e49\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61\u548c\u54cd\u5e94\u7684\u5bf9\u8c61 3. this[kIncomingMessage] = options.IncomingMessage || IncomingMessage; 4. this[kServerResponse] = options.ServerResponse || ServerResponse; 5. // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c 6. const maxHeaderSize = options.maxHeaderSize; 7. this.maxHeaderSize = maxHeaderSize; 8. // \u5141\u8bb8\u534a\u5173\u95ed 9. net.Server.call(this, { allowHalfOpen: true }); 10. // \u6709\u8bf7\u6c42\u65f6\u7684\u56de\u8c03 11. if (requestListener) { 12. this.on('request', requestListener); 13. } 14. // \u670d\u52a1\u5668socket\u8bfb\u7aef\u5173\u95ed\u65f6\u662f\u5426\u5141\u8bb8\u7ee7\u7eed\u5904\u7406\u961f\u5217\u91cc\u7684\u54cd\u5e94\uff08tcp\u4e0a\u6709\u591a\u4e2a\u8bf7\u6c42\uff0c\u7ba1\u9053\u5316\uff09 15. this.httpAllowHalfOpen = false; 16. // \u6709\u8fde\u63a5\u65f6\u7684\u56de\u8c03\uff0c\u7531net\u6a21\u5757\u89e6\u53d1 17. this.on('connection', connectionListener); 18. // \u670d\u52a1\u5668\u4e0b\u6240\u6709\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u8d85\u65f6\u65f6\u95f4 19. this.timeout = 0; 20. // \u540c\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\uff0c\u4e24\u4e2a\u8bf7\u6c42\u4e4b\u524d\u6700\u591a\u95f4\u9694\u7684\u65f6\u95f4 21. this.keepAliveTimeout = 5000; 22. this.maxHeadersCount = null; 23. // \u89e3\u6790\u5934\u90e8\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9632\u6b62ddos 24. this.headersTimeout = 60 * 1000; // 60 seconds 25. } \u63a5\u7740\u8c03\u7528listen\u51fd\u6570\uff0c\u56e0\u4e3aHTTP Server\u7ee7\u627f\u4e8enet.Server\uff0cnet.Server\u7684listen\u51fd\u6570\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u4e0d\u518d\u5206\u6790\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0c\u4f1a\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u4ece\u800c\u6267\u884cconnectionListener\u3002 1. function connectionListener(socket) { 2. defaultTriggerAsyncIdScope( 3. getOrSetAsyncId(socket), connectionListenerInternal, this, socket 4. ); 5. } 6. 7. // socket\u8868\u793a\u65b0\u8fde\u63a5 8. function connectionListenerInternal(server, socket) { 9. // socket\u6240\u5c5eserver 10. socket.server = server; 11. // \u8bbe\u7f6e\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u8d85\u65f6\u5904\u7406\u51fd\u6570\u4e3asocketOnTimeout 12. if (server.timeout && typeof socket.setTimeout === 'function') socket.setTimeout(server.timeout); 13. socket.on('timeout', socketOnTimeout); 14. // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 15. const parser = parsers.alloc(); 16. // \u89e3\u6790\u8bf7\u6c42\u62a5\u6587 17. parser.initialize( 18. HTTPParser.REQUEST, 19. new HTTPServerAsyncResource('HTTPINCOMINGMESSAGE', socket), 20. server.maxHeaderSize || 0, 21. server.insecureHTTPParser === undefined ? 22. isLenient() : server.insecureHTTPParser, 23. ); 24. parser.socket = socket; 25. // \u8bb0\u5f55\u5f00\u59cb\u89e3\u6790\u5934\u90e8\u7684\u5f00\u59cb\u65f6\u95f4 26. parser.parsingHeadersStart = nowDate(); 27. socket.parser = parser; 28. if (typeof server.maxHeadersCount === 'number') { 29. parser.maxHeaderPairs = server.maxHeadersCount << 1; 30. } 31. 32. const state = { 33. onData: null, 34. onEnd: null, 35. onClose: null, 36. onDrain: null, 37. // \u540c\u4e00TCP\u8fde\u63a5\u4e0a\uff0c\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u7684\u961f\u5217\uff0c\u7ebf\u5934\u963b\u585e\u7684\u539f\u7406 38. outgoing: [], 39. incoming: [], 40. // \u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570\uff0c\u5982\u679c\u8d85\u8fc7\u9608\u503c\uff0c\u5219\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u7684\u6570\u636e 41. outgoingData: 0, 42. /* 43. \u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u4e86timeout\uff0c\u7528\u4e8e\u54cd\u5e94\u4e00\u4e2a\u8bf7\u6c42\u65f6\uff0c 44. \u6807\u8bb0\u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u7684\u6807\u8bb0 45. */ 46. keepAliveTimeoutSet: false 47. }; 48. // \u76d1\u542ctcp\u4e0a\u7684\u6570\u636e\uff0c\u5f00\u59cb\u89e3\u6790http\u62a5\u6587 49. state.onData = socketOnData.bind(undefined, 50. server, 51. socket, 52. parser, 53. state); 54. state.onEnd = socketOnEnd.bind(undefined, 55. server, 56. socket, 57. parser, 58. state); 59. state.onClose = socketOnClose.bind(undefined, socket, state); 60. state.onDrain = socketOnDrain.bind(undefined, socket, state); 61. socket.on('data', state.onData); 62. socket.on('error', socketOnError); 63. socket.on('end', state.onEnd); 64. socket.on('close', state.onClose); 65. socket.on('drain', state.onDrain); 66. // \u89e3\u6790HTTP\u5934\u90e8\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 67. parser.onIncoming = parserOnIncoming.bind(undefined, 68. server, 69. socket, 70. state); 71. socket.on('resume', onSocketResume); 72. socket.on('pause', onSocketPause); 73. 74. /* 75. \u5982\u679chandle\u662f\u7ee7\u627fStreamBase\u7684\u6d41\u5219\u6267\u884cconsume\u6d88\u8d39http 76. \u8bf7\u6c42\u62a5\u6587\uff0c\u800c\u4e0d\u662f\u4e0a\u9762\u7684onData\uff0ctcp\u6a21\u5757\u7684isStreamBase\u4e3atrue 77. */ 78. if (socket._handle && socket._handle.isStreamBase && 79. !socket._handle._consumed) { 80. parser._consumed = true; 81. socket._handle._consumed = true; 82. parser.consume(socket._handle); 83. } 84. parser[kOnExecute] = 85. onParserExecute.bind(undefined, 86. server, 87. socket, 88. parser, 89. state); 90. 91. socket._paused = false; 92. } \u6267\u884c\u5b8cconnectionListener\u540e\u5c31\u5f00\u59cb\u7b49\u5f85tcp\u4e0a\u6570\u636e\u7684\u5230\u6765\uff0c\u5373HTTP\u8bf7\u6c42\u62a5\u6587\u3002\u4e0a\u9762\u4ee3\u7801\u4e2dNode.js\u76d1\u542c\u4e86socket\u7684data\u4e8b\u4ef6\uff0c\u540c\u65f6\u6ce8\u518c\u4e86\u94a9\u5b50kOnExecute\u3002data\u4e8b\u4ef6\u6211\u4eec\u90fd\u77e5\u9053\u662f\u6d41\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u89e6\u53d1\u7684\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocketOnData\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1. function socketOnData(server, socket, parser, state, d) { 2. // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 3. const ret = parser.execute(d); 4. onParserExecuteCommon(server, socket, parser, state, ret, d); 5. } socketOnData\u7684\u5904\u7406\u903b\u8f91\u662f\u5f53socket\u4e0a\u6709\u6570\u636e\uff0c\u7136\u540e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002\u8fd9\u770b\u8d77\u6765\u6ca1\u4ec0\u4e48\u95ee\u9898\uff0c\u90a3\u4e48kOnExecute\u662f\u505a\u4ec0\u4e48\u7684\u5462\uff1fkOnExecute\u94a9\u5b50\u51fd\u6570\u7684\u503c\u662fonParserExecute\uff0c\u8fd9\u4e2a\u770b\u8d77\u6765\u4e5f\u662f\u89e3\u6790tcp\u4e0a\u7684\u6570\u636e\u7684\uff0c\u770b\u8d77\u6765\u548conSocketData\u662f\u4e00\u6837\u7684\u4f5c\u7528\uff0c\u96be\u9053tcp\u4e0a\u7684\u6570\u636e\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u3002 1. void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override { 2. 3. Local<Value> ret = Execute(buf.base, nread); 4. Local<Value> cb = 5. object()->Get(env()->context(), kOnExecute).ToLocalChecked(); 6. MakeCallback(cb.As<Function>(), 1, &ret); 7. } OnStreamRead\u662fnode_http_parser.cc\u5b9e\u73b0\u7684\u51fd\u6570\uff0c\u6240\u4ee5kOnExecute\u5728node_http_parser.cc\u4e2d\u7684OnStreamRead\u4e2d\u88ab\u56de\u8c03\uff0c\u90a3\u4e48OnStreamRead\u53c8\u662f\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u5462\uff1f\u5728C++\u5c42\u7ae0\u8282\u6211\u4eec\u5206\u6790\u8fc7\uff0cOnStreamRead\u662fNode.js\u4e2dC++\u5c42\u6d41\u64cd\u4f5c\u7684\u901a\u7528\u51fd\u6570\uff0c\u5f53\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u800c\u4e14OnStreamRead\u4e2d\u4e5f\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u89e3\u6790\u3002\u8fd9\u770b\u8d77\u6765\u771f\u7684\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u8fd9\u5c31\u5f88\u5947\u602a\uff0c\u4e3a\u4ec0\u4e48\u4e00\u4efd\u6570\u636e\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u4e24\u6b21\uff1f 1. if (socket._handle && socket._handle.isStreamBase && !socket._handle._consumed) { 2. parser._consumed = true; 3. socket._handle._consumed = true; 4. parser.consume(socket._handle); 5. } \u56e0\u4e3aTCP\u6d41\u662f\u7ee7\u627fStreamBase\u7c7b\u7684\uff0c\u6240\u4ee5if\u6210\u7acb\u3002\u6211\u4eec\u770b\u4e00\u4e0bconsume\u7684\u5b9e\u73b0\u3002 1. static void Consume(const FunctionCallbackInfo<Value>& args) { 2. Parser* parser; 3. ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder()); 4. CHECK(args[0]->IsObject()); 5. StreamBase* stream = StreamBase::FromObjject(args[0].As<Object>()); 6. CHECK_NOT_NULL(stream); 7. stream->PushStreamListener(parser); 8. } HTTP\u89e3\u6790\u5668\u628a\u81ea\u5df1\u6ce8\u518c\u4e3aTCP stream\u7684\u4e00\u4e2alistener\u3002\u8fd9\u4f1a\u4f7f\u5f97TCP\u6d41\u4e0a\u7684\u6570\u636e\u7531node_http_parser.cc\u7684OnStreamRead\u76f4\u63a5\u6d88\u8d39\uff0c\u800c\u4e0d\u662f\u89e6\u53d1onData\u4e8b\u4ef6\u3002\u5728OnStreamRead\u4e2d\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u76f4\u5230\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u540e\u6267\u884cparserOnIncoming\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u9700\u8981\u91cd\u7f6e\u5b9a\u65f6\u5668 3. resetSocketTimeout(server, socket, state); 4. // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 5. if (server.keepAliveTimeout > 0) { 6. req.on('end', resetHeadersTimeoutOnReqEnd); 7. } 8. 9. // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 10. socket.parser.parsingHeadersStart = 0; 11. 12. // \u8bf7\u6c42\u5165\u961f\uff08\u5f85\u5904\u7406\u7684\u8bf7\u6c42\u961f\u5217\uff09 13. state.incoming.push(req); 14. 15. if (!socket._paused) { 16. const ws = socket._writableState; 17. // \u5f85\u53d1\u9001\u7684\u6570\u636e\u8fc7\u591a\uff0c\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u6570\u636e 18. if (ws.needDrain || 19. state.outgoingData >= socket.writableHighWaterMark) { 20. socket._paused = true; 21. socket.pause(); 22. } 23. } 24. // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61 25. const res = new server[kServerResponse](req); 26. // \u8bbe\u7f6e\u6570\u636e\u5199\u5165\u5f85\u53d1\u9001\u961f\u5217\u65f6\u89e6\u53d1\u7684\u56de\u8c03\uff0c\u89c1OutgoingMessage 27. res._onPendingData = updateOutgoingData.bind(undefined, 28. socket, 29. state); 30. // \u6839\u636e\u8bf7\u6c42\u7684HTTP\u5934\u8bbe\u7f6e\u662f\u5426\u652f\u6301keepalive\uff08\u7ba1\u9053\u5316\uff09 31. res.shouldKeepAlive = keepAlive; 32. /* 33. socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c 34. \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 35. */ 36. if (socket._httpMessage) { 37. state.outgoing.push(res); 38. } else { 39. res.assignSocket(socket); 40. } 41. 42. // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 43. res.on('finish', 44. resOnFinish.bind(undefined, 45. req, 46. res, 47. socket, 48. state, 49. server)); 50. // \u6709expect\u8bf7\u6c42\u5934\uff0c\u5e76\u4e14\u662fhttp1.1 51. if (req.headers.expect !== undefined && 52. (req.httpVersionMajor === 1 && 53. req.httpVersionMinor === 1) 54. ) { 55. // Expect\u5934\u7684\u503c\u662f\u5426\u662f100-continue 56. if (continueExpression.test(req.headers.expect)) { 57. res._expect_continue = true; 58. /* 59. \u76d1\u542c\u4e86checkContinue\u4e8b\u4ef6\u5219\u89e6\u53d1\uff0c 60. \u5426\u5219\u76f4\u63a5\u8fd4\u56de\u5141\u8bb8\u7ee7\u7eed\u8bf7\u6c42\u5e76\u89e6\u53d1request\u4e8b\u4ef6 61. */ 62. if (server.listenerCount('checkContinue') > 0) { 63. server.emit('checkContinue', req, res); 64. } else { 65. res.writeContinue(); 66. server.emit('request', req, res); 67. } 68. } else if (server.listenerCount('checkExpectation') > 0) { 69. /* 70. \u503c\u5f02\u5e38\uff0c\u76d1\u542c\u4e86checkExpectation\u4e8b\u4ef6\uff0c 71. \u5219\u89e6\u53d1\uff0c\u5426\u5219\u8fd4\u56de417\u62d2\u7edd\u8bf7\u6c42 72. */ 73. server.emit('checkExpectation', req, res); 74. } else { 75. res.writeHead(417); 76. res.end(); 77. } 78. } else { 79. // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 80. server.emit('request', req, res); 81. } 82. return 0; // No special treatment. 83. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u7528\u6237\u5c31\u53ef\u4ee5\u5904\u7406\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u89e3\u6790\u5934\u90e8\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u56de\u8c03\uff0c\u901a\u77e5\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5e76\u4f20\u5165request\u548cresponse\u4f5c\u4e3a\u53c2\u6570\uff0c\u5206\u522b\u5bf9\u5e94\u7684\u662f\u8868\u793a\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u8c61\u3002\u53e6\u5916Node.js\u672c\u8eab\u662f\u4e0d\u4f1a\u89e3\u6790body\u90e8\u5206\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u83b7\u53d6body\u7684\u6570\u636e\u3002 1. const server = http.createServer((request, response) => { 2. request.on('data', (chunk) => { 3. // \u5904\u7406body 4. }); 5. request.on('end', () => { 6. // body\u7ed3\u675f 7. }); 8. })","title":"18.3 HTTP\u670d\u52a1\u5668"},{"location":"chapter18-HTTP/#1831-http","text":"HTTP1.0\u7684\u65f6\u5019\uff0c\u4e0d\u652f\u6301\u7ba1\u9053\u5316\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u9996\u5148\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u670d\u52a1\u5668\u8fd4\u56de\u4e00\u4e2a\u54cd\u5e94\uff0c\u6700\u540e\u65ad\u5f00TCP\u8fde\u63a5\uff0c\u8fd9\u79cd\u662f\u6700\u7b80\u5355\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4f46\u662f\u6bcf\u6b21\u53d1\u9001\u8bf7\u6c42\u90fd\u9700\u8981\u8d70\u4e09\u6b21\u63e1\u624b\u663e\u7136\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u65f6\u95f4\u635f\u8017\uff0c\u6240\u4ee5HTTP1.1\u7684\u65f6\u5019\uff0c\u652f\u6301\u4e86\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u7684\u610f\u601d\u5c31\u662f\u53ef\u4ee5\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u6837\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u540c\u65f6\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff0c\u4f46\u662f\u7531\u4e8eHTTP1.1\u7684\u9650\u5236\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\u9700\u8981\u6309\u5e8f\u8fd4\u56de\u3002\u56e0\u4e3a\u5728HTTP1.1\u4e2d\uff0c\u6ca1\u6709\u6807\u8bb0\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u5e94\u5173\u7cfb\u3002\u6240\u4ee5HTTP\u5ba2\u6237\u7aef\u4f1a\u5047\u8bbe\u7b2c\u4e00\u4e2a\u8fd4\u56de\u7684\u54cd\u5e94\u662f\u5bf9\u5e94\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u7684\u3002\u5982\u679c\u4e71\u5e8f\u8fd4\u56de\uff0c\u5c31\u4f1a\u5bfc\u81f4\u95ee\u9898\uff0c\u5982\u56fe18-2\u6240\u793a\u3002 \u56fe18-2 \u800c\u5728HTTP 2.0\u4e2d\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u4f1a\u5206\u914d\u4e00\u4e2aid\uff0c\u54cd\u5e94\u4e2d\u4e5f\u4f1a\u8fd4\u56de\u5bf9\u5e94\u7684id\uff0c\u8fd9\u6837\u5c31\u7b97\u4e71\u5e8f\u8fd4\u56de\uff0cHTTP\u5ba2\u6237\u7aef\u4e5f\u53ef\u4ee5\u77e5\u9053\u54cd\u5e94\u6240\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u5728HTTP 1.1\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cHTTP\u670d\u52a1\u5668\u7684\u5b9e\u73b0\u5c31\u4f1a\u53d8\u5f97\u590d\u6742\uff0c\u670d\u52a1\u5668\u53ef\u4ee5\u4ee5\u4e32\u884c\u7684\u65b9\u5f0f\u5904\u7406\u8bf7\u6c42\uff0c\u5f53\u524d\u9762\u8bf7\u6c42\u7684\u54cd\u5e94\u8fd4\u56de\u5230\u5ba2\u6237\u7aef\u540e\uff0c\u518d\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u76f8\u5bf9\u7b80\u5355\u7684\uff0c\u4f46\u662f\u5f88\u660e\u663e\uff0c\u8fd9\u79cd\u65b9\u5f0f\u76f8\u5bf9\u6765\u8bf4\u8fd8\u662f\u6bd4\u8f83\u4f4e\u6548\u7684\uff0c\u53e6\u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5e76\u884c\u5904\u7406\u8bf7\u6c42\uff0c\u4e32\u884c\u8fd4\u56de\uff0c\u8fd9\u6837\u53ef\u4ee5\u8ba9\u8bf7\u6c42\u5f97\u5230\u5c3d\u5feb\u7684\u5904\u7406\uff0c\u6bd4\u5982\u4e24\u4e2a\u8bf7\u6c42\u90fd\u8bbf\u95ee\u6570\u636e\u5e93\uff0c\u90a3\u5e76\u884c\u5904\u7406\u4e24\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u6bd4\u4e32\u884c\u5feb\u5f97\u591a\uff0c\u4f46\u662f\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0cNode.js\u5c31\u662f\u5c5e\u4e8e\u8fd9\u79cd\u65b9\u5f0f\uff0c\u4e0b\u9762\u6211\u4eec\u6765\u770b\u4e00\u4e0bNode.js\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002\u524d\u9762\u5206\u6790\u8fc7\uff0cNode.js\u5728\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u65f6\u5019\u4f1a\u6267\u884cparserOnIncoming\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 3. socket.parser.parsingHeadersStart = 0; 4. // \u8bf7\u6c42\u5165\u961f 5. state.incoming.push(req); 6. // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61\uff0c\u4e00\u822c\u662fServerResponse 7. const res = new server[kServerResponse](req); 8. /* 9. socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c 10. \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 11. */ 12. if (socket._httpMessage) { 13. state.outgoing.push(res); 14. } else { 15. res.assignSocket(socket); // socket._httpMessage = res; 16. } 17. // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 18. res.on('finish', resOnFinish.bind(undefined, 19. req, 20. res, 21. socket, 22. state, 23. server)); 24. // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 25. server.emit('request', req, res); 26. return 0; 27. } \u5f53Node.js\u89e3\u6790HTTP\u8bf7\u6c42\u5934\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aServerResponse\u5bf9\u8c61\u8868\u793a\u54cd\u5e94\u3002\u7136\u540e\u5224\u65ad\u5f53\u524d\u662f\u5426\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c\u5982\u679c\u6709\u5219\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5426\u5219\u628a\u65b0\u5efa\u7684ServerResponse\u5bf9\u8c61\u4f5c\u4e3a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u54cd\u5e94\u3002\u6700\u540e\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u5c42\u3002\u7528\u6237\u5c31\u53ef\u4ee5\u8fdb\u884c\u8bf7\u6c42\u7684\u5904\u7406\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u7ef4\u62a4\u4e86\u4e24\u4e2a\u961f\u5217\uff0c\u5206\u522b\u662f\u8bf7\u6c42\u548c\u54cd\u5e94\u961f\u5217\uff0c\u5982\u56fe18-3\u6240\u793a\u3002 \u56fe18-3 \u5f53\u524d\u5904\u7406\u7684\u8bf7\u6c42\u5728\u8bf7\u6c42\u961f\u5217\u7684\u961f\u9996\uff0c\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684\u54cd\u5e94\u4f1a\u6302\u8f7d\u5230socket\u7684_httpMessage\u5c5e\u6027\u4e0a\u3002\u4f46\u662f\u6211\u4eec\u770b\u5230Node.js\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u6240\u6709\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0cNode.js\u4f1a\u5e76\u884c\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff08\u5982\u679c\u662fcpu\u5bc6\u96c6\u578b\u7684\u8bf7\u6c42\u5219\u5b9e\u9645\u4e0a\u8fd8\u662f\u4f1a\u53d8\u6210\u4e32\u884c\uff0c\u8fd9\u548cNode.js\u7684\u5355\u7ebf\u7a0b\u76f8\u5173\uff09\u3002\u90a3Node.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u7684\u987a\u5e8f\u7684\u5462\uff1f\u6211\u4eec\u77e5\u9053\u6bcf\u6b21\u89e6\u53d1request\u4e8b\u4ef6\u7684\u65f6\u5019\uff0c\u6211\u4eec\u90fd\u4f1a\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u3002\u6bd4\u5982\u4e0b\u9762\u7684\u4ee3\u7801\u3002 1. http.createServer((req, res) => { 2. // \u4e00\u4e9b\u7f51\u7edcIO 3. res.writeHead(200, { 'Content-Type': 'text/plain' }); 4. res.end('okay'); 5. }); \u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u8bf7\u6c42\u7684\u5904\u7406\u662f\u72ec\u7acb\u7684\u3002\u5047\u8bbe\u6bcf\u4e2a\u8bf7\u6c42\u90fd\u53bb\u64cd\u4f5c\u6570\u636e\u5e93\uff0c\u5982\u679c\u8bf7\u6c422\u6bd4\u8bf7\u6c421\u5148\u5b8c\u6210\u6570\u636e\u5e93\u7684\u64cd\u4f5c\uff0c\u4ece\u800c\u8bf7\u6c422\u5148\u6267\u884cres.write\u548cres.end\u3002\u90a3\u5c82\u4e0d\u662f\u8bf7\u6c422\u5148\u8fd4\u56de\uff1f\u6211\u4eec\u770b\u4e00\u4e0bServerResponse\u548cOutgoingMessage\u7684\u5b9e\u73b0\uff0c\u63ed\u5f00\u8ff7\u96fe\u3002ServerResponse\u662fOutgoingMessage\u7684\u5b50\u7c7b\u3002write\u51fd\u6570\u662f\u5728OutgoingMessage\u4e2d\u5b9e\u73b0\u7684\uff0cwrite\u7684\u8c03\u7528\u94fe\u8def\u5f88\u957f\uff0c\u6211\u4eec\u4e0d\u5c42\u5c42\u5206\u6790\uff0c\u76f4\u63a5\u770b\u6700\u540e\u7684\u8282\u70b9\u3002 1. function _writeRaw(data, encoding, callback) { 2. const conn = this.socket; 3. // socket\u5bf9\u5e94\u7684\u54cd\u5e94\u662f\u81ea\u5df1\u5e76\u4e14\u53ef\u5199 4. if (conn && conn._httpMessage === this && conn.writable) { 5. // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e 6. if (this.outputData.length) { 7. this._flushOutput(conn); 8. } 9. // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 10. return conn.write(data, encoding, callback); 11. } 12. // socket\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u5bf9\u8c61\u4e0d\u662f\u81ea\u5df1\uff0c\u5219\u5148\u7f13\u5b58\u6570\u636e\u3002 13. this.outputData.push({ data, encoding, callback }); 14. this.outputSize += data.length; 15. this._onPendingData(data.length); 16. return this.outputSize < HIGH_WATER_MARK; 17. } \u6211\u4eec\u770b\u5230\u6211\u4eec\u8c03\u7528res.write\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u9996\u5148\u5224\u65ad\uff0cres\u662f\u4e0d\u662f\u5c5e\u4e8e\u5f53\u524d\u5904\u7406\u4e2d\u54cd\u5e94\uff0c\u5982\u679c\u662f\u624d\u4f1a\u771f\u6b63\u53d1\u9001\u6570\u636e\uff0c\u5426\u5219\u4f1a\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\u3002\u5206\u6790\u5230\u8fd9\u91cc\uff0c\u76f8\u4fe1\u5927\u5bb6\u5df2\u7ecf\u5dee\u4e0d\u591a\u660e\u767dNode.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u6309\u5e8f\u8fd4\u56de\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e9b\u7f13\u5b58\u7684\u6570\u636e\u4ec0\u4e48\u65f6\u5019\u4f1a\u88ab\u53d1\u9001\u51fa\u53bb\u3002\u524d\u9762\u4ee3\u7801\u5df2\u7ecf\u8d34\u8fc7\uff0c\u5f53\u4e00\u4e2a\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u505a\u4e00\u4e9b\u5904\u7406\u3002 1. res.on('finish', resOnFinish.bind(undefined, 2. req, 3. res, 4. socket, 5. state, 6. server)); \u6211\u4eec\u770b\u770bresOnFinish 1. function resOnFinish(req, res, socket, state, server) { 2. // \u5220\u9664\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42 3. state.incoming.shift(); 4. clearIncoming(req); 5. // \u89e3\u9664socket\u4e0a\u6302\u8f7d\u7684\u54cd\u5e94\u5bf9\u8c61 6. res.detachSocket(socket); 7. req.emit('close'); 8. process.nextTick(emitCloseNT, res); 9. // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 10. if (res._last) { 11. // \u662f\u5219\u9500\u6bc1socket 12. if (typeof socket.destroySoon === 'function') { 13. socket.destroySoon(); 14. } else { 15. socket.end(); 16. } 17. } else if (state.outgoing.length === 0) { 18. /* 19. \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c 20. \u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 21. */ 22. if (server.keepAliveTimeout && 23. typeof socket.setTimeout === 'function') { 24. socket.setTimeout(server.keepAliveTimeout); 25. state.keepAliveTimeoutSet = true; 26. } 27. } else { 28. // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8981\u5904\u7406\u7684\u54cd\u5e94 29. const m = state.outgoing.shift(); 30. // \u6302\u8f7d\u5230socket\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 31. if (m) { 32. m.assignSocket(socket); 33. } 34. } 35. } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5904\u7406\u5b8c\u4e00\u4e2a\u54cd\u5e94\u540e\uff0c\u4f1a\u505a\u4e00\u4e9b\u5224\u65ad\u3002\u5206\u522b\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002 1 \u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 \u4ec0\u4e48\u60c5\u51b5\u4e0b\uff0c\u4f1a\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\uff1f\u56e0\u4e3a\u54cd\u5e94\u548c\u8bf7\u6c42\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u5c31\u610f\u5473\u7740\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u4e86\uff0c\u90a3\u4e48\u4ec0\u4e48\u65f6\u5019\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u5462\uff1f\u5f53\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u4e00\u4e2a\u54cd\u5e94\uff0c\u7136\u540e\u5173\u95edTCP\u8fde\u63a5\uff0c\u6240\u4ee5\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0ctcp\u4e0a\u7684\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u4e00\u4e2a\u8bf7\u6c42\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u7406\u8bba\u4e0a\u5c31\u6ca1\u6709\u6240\u8c13\u7684\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u3002\u4f46\u662f\u5b9e\u73b0\u4e0a\u4f1a\u505a\u4e00\u4e9b\u9650\u5236\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e00\u4e2a\u54cd\u5e94\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6eHTTP\u54cd\u5e94\u5934connection\u6765\u5b9a\u4e49\u662f\u5426\u53d1\u9001\u8be5\u54cd\u5e94\u540e\u5c31\u65ad\u5f00\u8fde\u63a5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002 1. // \u662f\u5426\u663e\u793a\u5220\u9664\u8fc7connection\u5934\uff0c\u662f\u5219\u54cd\u5e94\u540e\u65ad\u5f00\u8fde\u63a5\uff0c\u5e76\u6807\u8bb0\u5f53\u524d\u54cd\u5e94\u662f\u6700\u540e\u4e00\u4e2a 2. if (this._removedConnection) { 3. this._last = true; 4. this.shouldKeepAlive = false; 5. } else if (!state.connection) { 6. /* 7. \u6ca1\u6709\u663e\u793a\u8bbe\u7f6e\u4e86connection\u5934\uff0c\u5219\u53d6\u9ed8\u8ba4\u884c\u4e3a 8. 1 Node.js\u7684shouldKeepAlive\u9ed8\u8ba4\u4e3atrue\uff0c\u4e5f\u53ef\u4ee5\u6839\u636e\u8bf7\u6c42\u62a5\u6587\u91cc 9. \u7684connection\u5934\u5b9a\u4e49 10. 2 \u8bbe\u7f6econtent-length\u6216\u4f7f\u7528chunk\u6a21\u5f0f\u624d\u80fd\u533a\u5206\u54cd\u5e94\u62a5\u6587\u7f16\u8fb9\u754c\uff0c 11. \u624d\u80fd\u652f\u6301keepalive 12. 3 \u4f7f\u7528\u4e86\u4ee3\u7406\uff0c\u4ee3\u7406\u662f\u590d\u7528TCP\u8fde\u63a5\u7684\uff0c\u652f\u6301keepalive 13. */ 14. const shouldSendKeepAlive = this.shouldKeepAlive && 15. (state.contLen || 16. this.useChunkedEncodingByDefault || 17. this.agent); 18. if (shouldSendKeepAlive) { 19. header += 'Connection: keep-alive\\r\\n'; 20. } else { 21. this._last = true; 22. header += 'Connection: close\\r\\n'; 23. } 24. } \u53e6\u5916\u5f53\u8bfb\u7aef\u5173\u95ed\u7684\u65f6\u5019\uff0c\u4e5f\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\uff0c\u6bd5\u7adf\u4e0d\u4f1a\u518d\u53d1\u9001\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7aef\u5173\u95ed\u7684\u903b\u8f91\u3002 1. function socketOnEnd(server, socket, parser, state) { 2. const ret = parser.finish(); 3. 4. if (ret instanceof Error) { 5. socketOnError.call(socket, ret); 6. return; 7. } 8. // \u4e0d\u5141\u8bb8\u534a\u5f00\u5173\u5219\u7ec8\u6b62\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u4e0d\u54cd\u5e94\uff0c\u5173\u95ed\u5199\u7aef 9. if (!server.httpAllowHalfOpen) { 10. abortIncoming(state.incoming); 11. if (socket.writable) socket.end(); 12. } else if (state.outgoing.length) { 13. /* 14. \u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5e76\u4e14\u8fd8\u6709\u54cd\u5e94\u9700\u8981\u5904\u7406\uff0c 15. \u6807\u8bb0\u54cd\u5e94\u961f\u5217\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u4e3a\u6700\u540e\u7684\u54cd\u5e94\uff0c 16. \u5904\u7406\u5b8c\u5c31\u5173\u95edsocket\u5199\u7aef 17. */ 18. state.outgoing[state.outgoing.length - 1]._last = true; 19. } else if (socket._httpMessage) { 20. /* 21. \u6ca1\u6709\u7b49\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u4f46\u662f\u8fd8\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c 22. \u5219\u6807\u8bb0\u4e3a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 23. */ 24. socket._httpMessage._last = true; 25. } else if (socket.writable) { 26. // \u5426\u5219\u5173\u95edsocket\u5199\u7aef 27. socket.end(); 28. } 29. } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5224\u65ad\u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u60c5\u51b5\uff0c\u5982\u679c\u4e00\u4e2a\u54cd\u5e94\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u90a3\u4e48\u53d1\u9001\u54cd\u5e94\u540e\u5c31\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 2 \u54cd\u5e94\u961f\u5217\u4e3a\u7a7a \u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679c\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u65f6\u5019\uff0cNode.js\u53c8\u662f\u600e\u4e48\u5904\u7406\u7684\u3002\u5982\u679c\u5f53\u524d\u7684\u5f85\u5904\u7406\u54cd\u5e94\u961f\u5217\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u662f\u76ee\u524d\u6700\u540e\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\uff0c\u4f46\u662f\u4e0d\u662fTCP\u8fde\u63a5\u4e0a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u8fd9\u65f6\u5019\uff0cNode.js\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u5982\u679c\u8d85\u65f6\u8fd8\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\uff0c\u5219Node.js\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 3 \u54cd\u5e94\u961f\u5217\u975e\u7a7a \u5982\u679c\u5f53\u524d\u5f85\u5904\u7406\u961f\u5217\u975e\u7a7a\uff0c\u5904\u7406\u5b8c\u5f53\u524d\u8bf7\u6c42\u540e\u4f1a\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u3002\u5e76\u4ece\u961f\u5217\u4e2d\u5220\u9664\u8be5\u54cd\u5e94\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u662f\u5982\u4f55\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u7684\u3002 1. // \u628a\u54cd\u5e94\u5bf9\u8c61\u6302\u8f7d\u5230socket\uff0c\u6807\u8bb0socket\u5f53\u524d\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94 2. ServerResponse.prototype.assignSocket = function assignSocket(socket) { 3. // \u6302\u8f7d\u5230socket\u4e0a\uff0c\u6807\u8bb0\u662f\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 4. socket._httpMessage = this; 5. socket.on('close', onServerResponseClose); 6. this.socket = socket; 7. this.emit('socket', socket); 8. this._flush(); 9. }; \u6211\u4eec\u770b\u5230Node.js\u662f\u901a\u8fc7_httpMessage\u6807\u8bb0\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u7684\uff0c\u914d\u5408\u54cd\u5e94\u961f\u5217\u6765\u5b9e\u73b0\u54cd\u5e94\u7684\u6309\u5e8f\u8fd4\u56de\u3002\u6807\u8bb0\u5b8c\u540e\u6267\u884c_flush\u53d1\u9001\u54cd\u5e94\u7684\u6570\u636e\uff08\u5982\u679c\u8fd9\u65f6\u5019\u8bf7\u6c42\u5df2\u7ecf\u88ab\u5904\u7406\u5b8c\u6210\uff09 1. OutgoingMessage.prototype._flush = function _flush() { 2. const socket = this.socket; 3. if (socket && socket.writable) { 4. const ret = this._flushOutput(socket); 5. }; 6. 7. OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) { 8. // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e 9. while (this[kCorked]) { 10. this[kCorked]--; 11. socket.cork(); 12. } 13. 14. const outputLength = this.outputData.length; 15. // \u6ca1\u6709\u6570\u636e\u9700\u8981\u53d1\u9001 16. if (outputLength <= 0) 17. return undefined; 18. 19. const outputData = this.outputData; 20. // \u52a0\u585e\uff0c\u8ba9\u6570\u636e\u4e00\u8d77\u53d1\u9001\u51fa\u53bb 21. socket.cork(); 22. // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket 23. let ret; 24. for (let i = 0; i < outputLength; i++) { 25. const { data, encoding, callback } = outputData[i]; 26. ret = socket.write(data, encoding, callback); 27. } 28. socket.uncork(); 29. 30. this.outputData = []; 31. this._onPendingData(-this.outputSize); 32. this.outputSize = 0; 33. 34. return ret; 35. } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5bf9\u4e8e\u7ba1\u9053\u5316\u7684\u5b9e\u73b0\u3002","title":"18.3.1 HTTP\u7ba1\u9053\u5316\u7684\u539f\u7406\u548c\u5b9e\u73b0"},{"location":"chapter18-HTTP/#1832-http-connect","text":"\u5206\u6790HTTP Connect\u5b9e\u73b0\u4e4b\u524d\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u9700\u8981HTTP Connect\u65b9\u6cd5\u6216\u8005\u8bf4\u5b83\u51fa\u73b0\u7684\u80cc\u666f\u3002Connect\u65b9\u6cd5\u4e3b\u8981\u7528\u4e8e\u4ee3\u7406\u670d\u52a1\u5668\u7684\u8bf7\u6c42\u8f6c\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f20\u7edfHTTP\u670d\u52a1\u5668\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u5982\u56fe18-4\u6240\u793a\u3002 \u56fe18-4 1 \u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u5ba2\u6237\u7aef\u53d1\u9001HTTP\u8bf7\u6c42\u7ed9\u4ee3\u7406\u670d\u52a1\u5668 3 \u4ee3\u7406\u670d\u52a1\u5668\u89e3\u6790HTTP\u534f\u8bae\uff0c\u6839\u636e\u914d\u7f6e\u62ff\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u7684\u5730\u5740 4 \u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u901a\u8fc7HTTP\u534f\u8bae\u6216\u8005\u5176\u5b83\u534f\u8bae\u8f6c\u53d1\u8bf7\u6c42 5 \u4e1a\u52a1\u670d\u52a1\u5668\u8fd4\u56de\u6570\u636e\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u56de\u590dHTTP\u62a5\u6587\u7ed9\u5ba2\u6237\u7aef\u3002 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bHTTPS\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1 \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u670d\u52a1\u5668\u901a\u8fc7TLS\u62a5\u6587\u8fd4\u56de\u8bc1\u4e66\u4fe1\u606f\uff0c\u5e76\u548c\u5ba2\u6237\u7aef\u5b8c\u6210\u540e\u7eed\u7684TLS\u901a\u4fe1\u3002 3 \u5b8c\u6210TLS\u901a\u4fe1\u540e\uff0c\u540e\u7eed\u53d1\u9001\u7684HTTP\u62a5\u6587\u4f1a\u7ecf\u8fc7TLS\u5c42\u52a0\u5bc6\u89e3\u5bc6\u540e\u518d\u4f20\u8f93\u3002 \u90a3\u4e48\u5982\u679c\u6211\u4eec\u60f3\u5b9e\u73b0\u4e00\u4e2aHTTPS\u7684\u4ee3\u7406\u670d\u52a1\u5668\u600e\u4e48\u505a\u5462\uff1f\u56e0\u4e3a\u5ba2\u6237\u7aef\u53ea\u7ba1\u548c\u76f4\u63a5\u76f8\u8fde\u7684\u670d\u52a1\u5668\u8fdb\u884cHTTPS\u7684\u901a\u4fe1\uff0c\u5982\u679c\u6211\u4eec\u7684\u4e1a\u52a1\u670d\u52a1\u5668\u524d\u9762\u8fd8\u6709\u4ee3\u7406\u670d\u52a1\u5668\uff0c\u90a3\u4e48\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u5fc5\u987b\u8981\u6709\u8bc1\u4e66\u624d\u80fd\u548c\u5ba2\u6237\u7aef\u5b8c\u6210TLS\u63e1\u624b\uff0c\u4ece\u800c\u8fdb\u884cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u4f7f\u7528HTTP\u6216\u8005HTTPS\u8fd8\u662f\u5176\u5b83\u534f\u8bae\u90fd\u53ef\u4ee5\u3002\u8fd9\u6837\u5c31\u610f\u5473\u7740\u6211\u4eec\u6240\u6709\u7684\u670d\u52a1\u7684\u8bc1\u4e66\u90fd\u9700\u8981\u653e\u5230\u4ee3\u7406\u670d\u52a1\u5668\u4e0a\uff0c\u8fd9\u79cd\u573a\u666f\u7684\u9650\u5236\u662f\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u90fd\u7531\u6211\u4eec\u81ea\u5df1\u7ba1\u7406\u6216\u8005\u516c\u53f8\u7edf\u4e00\u7ba1\u7406\u3002\u5982\u679c\u6211\u4eec\u60f3\u52a0\u4e00\u4e2a\u4ee3\u7406\u5bf9\u4e1a\u52a1\u670d\u52a1\u5668\u4e0d\u611f\u77e5\u90a3\u600e\u4e48\u529e\u5462\uff08\u6bd4\u5982\u5199\u4e00\u4e2a\u4ee3\u7406\u670d\u52a1\u5668\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5\uff09\uff1f\u6709\u4e00\u79cd\u65b9\u5f0f\u5c31\u662f\u4e3a\u6211\u4eec\u7684\u4ee3\u7406\u670d\u52a1\u5668\u7533\u8bf7\u4e00\u4e2a\u8bc1\u4e66\uff0c\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u5b8c\u6210\u6b63\u5e38\u7684HTTPS\u901a\u4fe1\u4e86\u3002\u4ece\u800c\u4e5f\u5c31\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\u3002\u53e6\u5916\u4e00\u79cd\u65b9\u5f0f\u5c31\u662fHTTP Connect\u65b9\u6cd5\u3002HTTP Connect\u65b9\u6cd5\u7684\u4f5c\u7528\u662f\u6307\u793a\u670d\u52a1\u5668\u5e2e\u5fd9\u5efa\u7acb\u4e00\u6761TCP\u8fde\u63a5\u5230\u771f\u6b63\u7684\u4e1a\u52a1\u670d\u52a1\u5668\uff0c\u5e76\u4e14\u900f\u4f20\u540e\u7eed\u7684\u6570\u636e\uff0c\u8fd9\u6837\u4e0d\u7533\u8bf7\u8bc1\u4e66\u4e5f\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\uff0c\u5982\u56fe18-5\u6240\u793a\u3002 \u56fe18-5 \u8fd9\u65f6\u5019\u4ee3\u7406\u670d\u52a1\u5668\u53ea\u8d1f\u8d23\u900f\u4f20\u4e24\u7aef\u7684\u6570\u636e\uff0c\u4e0d\u50cf\u4f20\u7edf\u7684\u65b9\u5f0f\u4e00\u6837\u89e3\u6790\u8bf7\u6c42\u7136\u540e\u518d\u8f6c\u53d1\u3002\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u81ea\u5df1\u5b8c\u6210TLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u50cf\u4e0d\u5b58\u5728\u4e00\u6837\u3002\u4e86\u89e3\u4e86Connect\u7684\u539f\u7406\u540e\u770b\u4e00\u4e0b\u6765\u81eaNode.js\u5b98\u65b9\u7684\u4e00\u4e2a\u4f8b\u5b50\u3002 1. const http = require('http'); 2. const net = require('net'); 3. const { URL } = require('url'); 4. // \u521b\u5efa\u4e00\u4e2aHTTP\u670d\u52a1\u5668\u4f5c\u4e3a\u4ee3\u7406\u670d\u52a1\u5668 5. const proxy = http.createServer((req, res) => { 6. res.writeHead(200, { 'Content-Type': 'text/plain' }); 7. res.end('okay'); 8. }); 9. // \u76d1\u542cconnect\u4e8b\u4ef6\uff0c\u6709http connect\u8bf7\u6c42\u65f6\u89e6\u53d1 10. proxy.on('connect', (req, clientSocket, head) => { 11. // \u83b7\u53d6\u771f\u6b63\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u5730\u5740\u5e76\u53d1\u8d77\u8fde\u63a5 12. const { port, hostname } = new URL(`http://${req.url}`); 13. const serverSocket = net.connect(port || 80, hostname, () => { 14. // \u8fde\u63a5\u6210\u529f\u544a\u8bc9\u5ba2\u6237\u7aef 15. clientSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 16. 'Proxy-agent: Node.js-Proxy\\r\\n' + 17. '\\r\\n'); 18. // \u900f\u4f20\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7684\u6570\u636e 19. serverSocket.write(head); 20. serverSocket.pipe(clientSocket); 21. clientSocket.pipe(serverSocket); 22. }); 23. }); 24. 25. proxy.listen(1337, '127.0.0.1', () => { 26. 27. const options = { 28. port: 1337, 29. // \u8fde\u63a5\u7684\u4ee3\u7406\u670d\u52a1\u5668\u5730\u5740 30. host: '127.0.0.1', 31. method: 'CONNECT', 32. // \u6211\u4eec\u9700\u8981\u771f\u6b63\u60f3\u8bbf\u95ee\u7684\u670d\u52a1\u5668\u5730\u5740 33. path: 'www.baidu.com', 34. }; 35. // \u53d1\u8d77http connect\u8bf7\u6c42 36. const req = http.request(options); 37. req.end(); 38. // connect\u8bf7\u6c42\u6210\u529f\u540e\u89e6\u53d1 39. req.on('connect', (res, socket, head) => { 40. // \u53d1\u9001\u771f\u6b63\u7684\u8bf7\u6c42 41. socket.write('GET / HTTP/1.1\\r\\n' + 42. 'Host: www.baidu.com\\r\\n' + 43. 'Connection: close\\r\\n' + 44. '\\r\\n'); 45. socket.on('data', (chunk) => { 46. console.log(chunk.toString()); 47. }); 48. socket.on('end', () => { 49. proxy.close(); 50. }); 51. }); 52. }); \u5b98\u7f51\u7684\u8fd9\u4e2a\u4f8b\u5b50\u5f88\u597d\u5730\u8bf4\u660e\u4e86Connect\u7684\u539f\u7406\uff0c\u5982\u56fe18-6\u6240\u793a\u3002 \u56fe18-6 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dConnect\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4eceHTTP Connect\u8bf7\u6c42\u5f00\u59cb\u3002\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5ba2\u6237\u7aef\u548cNode.js\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0cNode.js\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c 1. // \u8fde\u63a5\u4e0a\u6709\u6570\u636e\u5230\u6765 2. function socketOnData(server, socket, parser, state, d) { 3. // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 4. const ret = parser.execute(d); 5. onParserExecuteCommon(server, socket, parser, state, ret, d); 6. } HTTP\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u56de\u8c03Node.js\u7684\u56de\u8c03\uff0c\u7136\u540e\u6267\u884conParserExecuteCommon\u3002\u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5f53Node.js\u89e3\u6790\u5b8c\u6240\u6709HTTP\u8bf7\u6c42\u5934\u540e\u6267\u884cparserOnHeadersComplete\u3002 1. function parserOnHeadersComplete(versionMajor, versionMinor, headers, method, 2. url, statusCode, statusMessage, upgrade, 3. shouldKeepAlive) { 4. const parser = this; 5. const { socket } = parser; 6. 7. // IncomingMessage 8. const ParserIncomingMessage = (socket && socket.server && 9. socket.server[kIncomingMessage]) || 10. IncomingMessage; 11. // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 12. const incoming = parser.incoming = new ParserIncomingMessage(socket); 13. incoming.httpVersionMajor = versionMajor; 14. incoming.httpVersionMinor = versionMinor; 15. incoming.httpVersion = `${versionMajor}.${versionMinor}`; 16. incoming.url = url; 17. // \u662f\u5426\u662fconnect\u8bf7\u6c42\u6216\u8005upgrade\u8bf7\u6c42 18. incoming.upgrade = upgrade; 19. 20. // \u6267\u884c\u56de\u8c03 21. return parser.onIncoming(incoming, shouldKeepAlive); 22. } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61IncomingMessage\uff0c\u7136\u540e\u56de\u8c03onIncoming\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u8bf7\u6c42\u662f\u5426\u662fconnect\u6216\u8005upgrade 3. if (req.upgrade) { 4. req.upgrade = req.method === 'CONNECT' || 5. server.listenerCount('upgrade') > 0; 6. if (req.upgrade) 7. return 2; 8. } 9. // ... 10. } Node.js\u89e3\u6790\u5b8c\u5934\u90e8\u5e76\u4e14\u6267\u884c\u4e86\u54cd\u5e94\u7684\u94a9\u5b50\u51fd\u6570\u540e\uff0c\u4f1a\u6267\u884conParserExecuteCommon\u3002 1. function onParserExecuteCommon(server, socket, parser, state, ret, d) { 2. if (ret instanceof Error) { 3. prepareError(ret, parser, d); 4. ret.rawPacket = d || parser.getCurrentBuffer(); 5. socketOnError.call(socket, ret); 6. } else if (parser.incoming && parser.incoming.upgrade) { 7. // \u5904\u7406Upgrade\u6216\u8005CONNECT\u8bf7\u6c42 8. const req = parser.incoming; 9. const eventName = req.method === 'CONNECT' ? 10. 'connect' : 'upgrade'; 11. // \u76d1\u542c\u4e86\u5bf9\u5e94\u7684\u4e8b\u4ef6\u5219\u5904\u7406\uff0c\u5426\u5219\u5173\u95ed\u8fde\u63a5 12. if (eventName === 'upgrade' || 13. server.listenerCount(eventName) > 0) { 14. // \u8fd8\u6ca1\u6709\u89e3\u6790\u7684\u6570\u636e 15. const bodyHead = d.slice(ret, d.length); 16. socket.readableFlowing = null; 17. server.emit(eventName, req, socket, bodyHead); 18. } else { 19. socket.destroy(); 20. } 21. } 22. } \u8fd9\u65f6\u5019Node.js\u4f1a\u5224\u65ad\u8bf7\u6c42\u662f\u4e0d\u662fConnect\u6216\u8005\u534f\u8bae\u5347\u7ea7\u7684upgrade\u8bf7\u6c42\uff0c\u662f\u7684\u8bdd\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u6709\u5904\u7406\u8be5\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u6ca1\u6709\u5219\u5173\u95ed\u8fde\u63a5\uff0c\u5426\u5219\u89e6\u53d1\u5bf9\u5e94\u7684\u4e8b\u4ef6\u8fdb\u884c\u5904\u7406\u3002\u6240\u4ee5\u8fd9\u65f6\u5019Node.js\u4f1a\u89e6\u53d1Connect\u65b9\u6cd5\u3002Connect\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u6b63\u5982\u6211\u4eec\u5f00\u59cb\u7ed9\u51fa\u7684\u4f8b\u5b50\u4e2d\u90a3\u6837\u3002\u6211\u4eec\u9996\u5148\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u8fd4\u56de\u54cd\u5e94\u5934\u7ed9\u5ba2\u6237\u7aef\uff0c\u540e\u7eed\u5ba2\u6237\u5c31\u53ef\u4ee5\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u771f\u6b63\u8fdb\u884cTLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u4e86\u3002\u8fd9\u5c31\u662fNode.js\u4e2dConnect\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 \u4e0d\u8fc7\u5728\u4ee3\u7801\u4e2d\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u597d\u73a9\u7684\u5730\u65b9\u3002\u90a3\u5c31\u662f\u5728\u89e6\u53d1connect\u4e8b\u4ef6\u7684\u65f6\u5019\uff0cNode.js\u7ed9\u56de\u8c03\u51fd\u6570\u4f20\u5165\u7684\u53c2\u6570\u3002 1. server.emit('connect', req, socket, bodyHead); \u7b2c\u4e00\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6ca1\u4ec0\u4e48\u7279\u522b\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u4e2a\u53c2\u6570\u5c31\u6709\u610f\u601d\u4e86\uff0cbodyHead\u4ee3\u8868\u7684\u662fHTTP Connect\u8bf7\u6c42\u4e2d\u9664\u4e86\u8bf7\u6c42\u884c\u548cHTTP\u5934\u4e4b\u5916\u7684\u6570\u636e\u3002\u56e0\u4e3aNode.js\u89e3\u6790\u5b8cHTTP\u5934\u540e\u5c31\u4e0d\u7ee7\u7eed\u5904\u7406\u4e86\u3002\u628a\u5269\u4e0b\u7684\u6570\u636e\u4ea4\u7ed9\u4e86\u7528\u6237\u3002\u6211\u4eec\u6765\u505a\u4e00\u4e9b\u597d\u73a9\u7684\u4e8b\u60c5\u3002 1. const http = require('http'); 2. const net = require('net'); 3. const { URL } = require('url'); 4. 5. const proxy = http.createServer((req, res) => { 6. res.writeHead(200, { 'Content-Type': 'text/plain' }); 7. res.end('okay'); 8. }); 9. proxy.on('connect', (req, clientSocket, head) => { 10. const { port, hostname } = new URL(`http://${req.url}`); 11. const serverSocket = net.connect(port || 80, hostname, () => { 12. clientSocket.write('HTTP/1.1 200 Connection Established\\r\\n' + 13. 'Proxy-agent: Node.js-Proxy\\r\\n' + 14. '\\r\\n'); 15. // \u628aconnect\u8bf7\u6c42\u5269\u4e0b\u7684\u6570\u636e\u8f6c\u53d1\u7ed9\u670d\u52a1\u5668 16. serverSocket.write(head); 17. serverSocket.pipe(clientSocket); 18. clientSocket.pipe(serverSocket); 19. }); 20. }); 21. 22. proxy.listen(1337, '127.0.0.1', () => { 23. const net = require('net'); 24. const body = 'GET http://www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n'; 25. const length = body.length; 26. const socket = net.connect({host: '127.0.0.1', port: 1337}); 27. socket.write(`CONNECT www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n${body}`); 28. socket.setEncoding('utf-8'); 29. socket.on('data', (chunk) => { 30. console.log(chunk) 31. }); 32. }); \u6211\u4eec\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u7136\u540e\u81ea\u5df1\u6784\u9020HTTP Connect\u62a5\u6587\uff0c\u5e76\u4e14\u5728HTTP\u884c\u540e\u9762\u52a0\u4e00\u4e2a\u989d\u5916\u7684\u5b57\u7b26\u4e32\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u4e24\u4e00\u4e2aHTTP\u8bf7\u6c42\u3002\u5f53Node.js\u670d\u52a1\u5668\u6536\u5230Connect\u8bf7\u6c42\u540e\uff0c\u6211\u4eec\u5728connect\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u628aConnect\u8bf7\u6c42\u591a\u4f59\u7684\u90a3\u4e00\u90e8\u5206\u6570\u636e\u4f20\u7ed9\u771f\u6b63\u7684\u670d\u52a1\u5668\u3002\u8fd9\u6837\u5c31\u8282\u7701\u4e86\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u3002","title":"18.3.2 HTTP Connect\u65b9\u6cd5\u7684\u539f\u7406\u548c\u5b9e\u73b0"},{"location":"chapter18-HTTP/#1833","text":"\u5728\u89e3\u6790HTTP\u534f\u8bae\u6216\u8005\u652f\u6301\u957f\u8fde\u63a5\u7684\u65f6\u5019\uff0cNode.js\u9700\u8981\u8bbe\u7f6e\u4e00\u4e9b\u8d85\u65f6\u7684\u673a\u5236\uff0c\u5426\u5219\u4f1a\u9020\u6210\u653b\u51fb\u6216\u8005\u8d44\u6e90\u6d6a\u8d39\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u670d\u52a1\u5668\u4e2d\u6d89\u53ca\u5230\u8d85\u65f6\u7684\u4e00\u4e9b\u903b\u8f91\u3002 1 \u89e3\u6790HTTP\u5934\u90e8\u8d85\u65f6 \u5f53\u6536\u5230\u4e00\u4e2aHTTP\u8bf7\u6c42\u62a5\u6587\u65f6\uff0c\u4f1a\u4eceHTTP\u8bf7\u6c42\u884c\uff0cHTTP\u5934\uff0cHTTP body\u7684\u987a\u5e8f\u8fdb\u884c\u89e3\u6790\uff0c\u5982\u679c\u7528\u6237\u6784\u9020\u8bf7\u6c42\uff0c\u53ea\u53d1\u9001HTTP\u5934\u7684\u4e00\u90e8\u5206\u3002\u90a3\u4e48HTTP\u89e3\u6790\u5668\u5c31\u4f1a\u4e00\u76f4\u5728\u7b49\u5f85\u540e\u7eed\u6570\u636e\u7684\u5230\u6765\u3002\u8fd9\u4f1a\u5bfc\u81f4DDOS\u653b\u51fb\uff0c\u6240\u4ee5Node.js\u4e2d\u8bbe\u7f6e\u4e86\u89e3\u6790HTTP\u5934\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9608\u503c\u662f60\u79d2\u3002\u5982\u679c60\u79d2\u5185\u6ca1\u6709\u89e3\u6790\u5b8cHTTP\u5934\u90e8\uff0c\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u5982\u679c\u7528\u6237\u4e0d\u5904\u7406\uff0c\u5219Node.js\u4f1a\u81ea\u52a8\u5173\u95ed\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 1. this.headersTimeout = 60 * 1000; // 60 seconds Node.js\u5728\u5efa\u7acbTCP\u8fde\u63a5\u6210\u529f\u540e\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002 1. function connectionListenerInternal(server, socket) { 2. parser.parsingHeadersStart = nowDate(); 3. } \u7136\u540e\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u5224\u65adHTTP\u5934\u90e8\u662f\u5426\u89e3\u6790\u5b8c\u6210\uff0c\u5982\u679c\u6ca1\u6709\u89e3\u6790\u5b8c\u6210\u5e76\u4e14\u8d85\u65f6\u4e86\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002 1. function onParserExecute(server, socket, parser, state, ret) { 2. socket._unrefTimer(); 3. const start = parser.parsingHeadersStart; 4. // start\u7b49\u4e8e0\uff0c\u8bf4\u660eHTTP\u5934\u5df2\u7ecf\u89e3\u6790\u5b8c\u6bd5\uff0c\u5426\u5219\u8bf4\u660e\u6b63\u5728\u89e3\u6790\u5934\uff0c\u7136\u540e\u518d\u5224\u65ad\u89e3\u6790\u65f6\u95f4\u662f\u5426\u8d85\u65f6\u4e86 5. if (start !== 0 && nowDate() - start > server.headersTimeout) { 6. // \u89e6\u53d1timeout\uff0c\u5982\u679c\u6ca1\u6709\u76d1\u542ctimeout\uff0c\u5219\u9ed8\u8ba4\u4f1a\u9500\u6bc1socket\uff0c\u5373\u5173\u95ed\u8fde\u63a5 7. const serverTimeout = server.emit('timeout', socket); 8. 9. if (!serverTimeout) 10. socket.destroy(); 11. return; 12. } 13. 14. onParserExecuteCommon(server, socket, parser, state, ret, undefined); 15. } \u5982\u679c\u5728\u8d85\u65f6\u4e4b\u524d\u89e3\u6790HTTP\u5934\u5b8c\u6210\uff0c\u5219\u628aparsingHeadersStart\u7f6e\u4e3a0\u8868\u793a\u89e3\u6790\u5b8c\u6210\u3002 1. function parserOnIncoming(server, socket, state, req, keepAlive) { 2. // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 3. if (server.keepAliveTimeout > 0) { 4. req.on('end', resetHeadersTimeoutOnReqEnd); 5. } 6. 7. // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 8. socket.parser.parsingHeadersStart = 0; 9. } 10. 11. function resetHeadersTimeoutOnReqEnd() { 12. if (parser) { 13. parser.parsingHeadersStart = nowDate(); 14. } 15. } \u53e6\u5916\u5982\u679c\u652f\u6301\u957f\u8fde\u63a5\uff0c\u5373\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53ef\u4ee5\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\u3002\u5219\u5728\u6bcf\u4e2a\u54cd\u5e94\u7ed3\u675f\u4e4b\u540e\uff0c\u9700\u8981\u91cd\u65b0\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002\u5f53\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u6570\u636e\u5230\u6765\u65f6\u518d\u6b21\u5224\u65ad\u89e3\u6790HTTP\u5934\u90e8\u662f\u5426\u8d85\u65f6\u3002\u8fd9\u91cc\u662f\u54cd\u5e94\u7ed3\u675f\u540e\u5c31\u5f00\u59cb\u8ba1\u7b97\u3002\u800c\u4e0d\u662f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\u65f6\u3002 2 \u652f\u6301\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u95f4\u9694 Node.js\u652f\u6301\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\uff0c\u6240\u4ee5\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5982\u679c\u8d85\u65f6\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u89e6\u53d1\u8d85\u65f6\u4e8b\u4ef6\u3002\u8fd9\u91cc\u6d89\u53ca\u5b9a\u65f6\u5668\u7684\u8bbe\u7f6e\u548c\u91cd\u7f6e\u3002 1. // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 2. if (res._last) { 3. // \u662f\u5219\u9500\u6bc1socket 4. if (typeof socket.destroySoon === 'function') { 5. socket.destroySoon(); 6. } else { 7. socket.end(); 8. } 9. } else if (state.outgoing.length === 0) { 10. // \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 11. if (server.keepAliveTimeout && typeof socket.setTimeout === 'function') { 12. socket.setTimeout(server.keepAliveTimeout); 13. state.keepAliveTimeoutSet = true; 14. } 15. } \u6bcf\u6b21\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u9996\u5148\u4f1a\u5224\u65ad\u5f53\u524d\u54cd\u5e94\u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u4f8b\u5982\u8bfb\u7aef\u4e0d\u53ef\u8bfb\u4e86\uff0c\u8bf4\u660e\u4e0d\u4f1a\u53c8\u8bf7\u6c42\u5230\u6765\u4e86\uff0c\u4e5f\u4e0d\u4f1a\u6709\u54cd\u5e94\u4e86\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u4fdd\u6301\u8fd9\u4e2aTCP\u8fde\u63a5\u3002\u5982\u679c\u5f53\u524d\u54cd\u5e94\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u5219Node.js\u4f1a\u6839\u636ekeepAliveTimeout\u7684\u503c\u505a\u4e0b\u4e00\u6b65\u5224\u65ad\uff0c\u5982\u679ckeepAliveTimeout \u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5982\u679ckeepAliveTimeout \u65f6\u95f4\u5185\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u90a3\u4e48\u5982\u679c\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u9700\u8981\u91cd\u7f6e\u8fd9\u4e2a\u5b9a\u65f6\u5668\u3002Node.js\u5728\u6536\u5230\u65b0\u8bf7\u6c42\u7684\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u5305\u4e2d\uff0c\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\u3002 1. function onParserExecuteCommon(server, socket, parser, state, ret, d) { 2. resetSocketTimeout(server, socket, state); 3. } 4. 5. function resetSocketTimeout(server, socket, state) { 6. if (!state.keepAliveTimeoutSet) 7. return; 8. 9. socket.setTimeout(server.timeout || 0); 10. state.keepAliveTimeoutSet = false; 11. } onParserExecuteCommon\u4f1a\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u65f6\u6267\u884c\uff0c\u7136\u540eNode.js\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\u4e3aserver.timeout\u7684\u503c\u3002","title":"18.3.3 \u8d85\u65f6\u7ba1\u7406"},{"location":"chapter18-HTTP/#184-agent","text":"\u672c\u8282\u6211\u4eec\u5148\u5206\u6790Agent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cAgent\u5bf9TCP\u8fde\u63a5\u8fdb\u884c\u4e86\u6c60\u5316\u7ba1\u7406\u3002\u7b80\u5355\u7684\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u4e4b\u524d\uff0c\u9996\u5148\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u6536\u5230\u54cd\u5e94\u540e\u4f1a\u7acb\u523b\u5173\u95edTCP\u8fde\u63a5\u3002\u4f46\u662f\u6211\u4eec\u77e5\u9053TCP\u7684\u4e09\u6b21\u63e1\u624b\u662f\u6bd4\u8f83\u8017\u65f6\u7684\u3002\u6240\u4ee5\u5982\u679c\u6211\u4eec\u80fd\u590d\u7528TCP\u8fde\u63a5\uff0c\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\u548c\u63a5\u6536\u591a\u4e2aHTTP\u54cd\u5e94\uff0c\u90a3\u4e48\u5728\u6027\u80fd\u4e0a\u9762\u5c31\u4f1a\u5f97\u5230\u5f88\u5927\u7684\u63d0\u5347\u3002Agent\u7684\u4f5c\u7528\u5c31\u662f\u590d\u7528TCP\u8fde\u63a5\u3002\u4e0d\u8fc7Agent\u7684\u6a21\u5f0f\u662f\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u4e32\u884c\u5730\u53d1\u9001\u8bf7\u6c42\u548c\u63a5\u6536\u54cd\u5e94\uff0c\u4e0d\u652f\u6301HTTP PipeLine\u6a21\u5f0f\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u770b\u5b83\u662f\u5982\u4f55\u5b9e\u73b0TCP\u8fde\u63a5\u590d\u7528\u7684\u3002 1. function Agent(options) { 2. if (!(this instanceof Agent)) 3. return new Agent(options); 4. EventEmitter.call(this); 5. this.defaultPort = 80; 6. this.protocol = 'http:'; 7. this.options = { ...options }; 8. // path\u5b57\u6bb5\u8868\u793a\u662f\u672c\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65f6\u4f7f\u7528\u7684\u8def\u5f84\uff0c\u6bd4\u5982Unix\u57df\u8def\u5f84 9. this.options.path = null; 10. // socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u540e\uff0c\u7b49\u5f85\u7a7a\u95f2socket\u7684\u8bf7\u6c42 11. this.requests = {}; 12. // \u6b63\u5728\u4f7f\u7528\u7684socket 13. this.sockets = {}; 14. // \u7a7a\u95f2socket 15. this.freeSockets = {}; 16. // \u7a7a\u95f2socket\u7684\u5b58\u6d3b\u65f6\u95f4 17. this.keepAliveMsecs = this.options.keepAliveMsecs || 1000; 18. /* 19. \u7528\u5b8c\u7684socket\u662f\u5426\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c 20. \u5f00\u542fkeepalive\u624d\u4f1a\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c 21. \u4e0d\u5f00\u542fkeepalive 22. \u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u590d\u7528socket 23. \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u76f4\u63a5\u9500\u6bc1socket 24. */ 25. this.keepAlive = this.options.keepAlive || false; 26. // \u6700\u5927\u7684socket\u4e2a\u6570\uff0c\u5305\u62ec\u6b63\u5728\u4f7f\u7528\u7684\u548c\u7a7a\u95f2\u7684socket 27. this.maxSockets = this.options.maxSockets 28. || Agent.defaultMaxSockets; 29. // \u6700\u5927\u7684\u7a7a\u95f2socket\u4e2a\u6570 30. this.maxFreeSockets = this.options.maxFreeSockets || 256; 31. } Agent\u7ef4\u62a4\u4e86\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u5206\u522b\u662f\u7b49\u5f85socket\u7684\u8bf7\u6c42\u3001\u6b63\u5728\u4f7f\u7528\u7684socket\u3001\u7a7a\u95f2socket\u3002\u6bcf\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5bf9\u8c61\u7684key\u662f\u6839\u636eHTTP\u8bf7\u6c42\u53c2\u6570\u8ba1\u7b97\u7684\u3002\u5bf9\u8c61\u7684\u503c\u662f\u4e00\u4e2a\u961f\u5217\u3002\u5177\u4f53\u7ed3\u6784\u5982\u56fe18-7\u6240\u793a\u3002 \u56fe18-7 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002","title":"18.4 Agent"},{"location":"chapter18-HTTP/#1841-key","text":"key\u7684\u8ba1\u7b97\u662f\u6c60\u5316\u7ba1\u7406\u7684\u6838\u5fc3\u3002\u6b63\u786e\u5730\u8bbe\u8ba1key\u7684\u8ba1\u7b97\u89c4\u5219\uff0c\u624d\u80fd\u66f4\u597d\u5730\u5229\u7528\u6c60\u5316\u5e26\u6765\u7684\u597d\u5904\u3002 1. // \u4e00\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684key 2. Agent.prototype.getName = function getName(options) { 3. let name = options.host || 'localhost'; 4. name += ':'; 5. if (options.port) 6. name += options.port; 7. name += ':'; 8. if (options.localAddress) 9. name += options.localAddress; 10. if (options.family === 4 || options.family === 6) 11. name += `:${options.family}`; 12. if (options.socketPath) 13. name += `:${options.socketPath}`; 14. return name; 15. }; \u6211\u4eec\u770b\u5230key\u7531host\u3001port\u3001\u672c\u5730\u5730\u5740\u3001\u5730\u5740\u7c07\u7c7b\u578b\u3001unix\u8def\u5f84\u8ba1\u7b97\u800c\u6765\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8bf7\u6c42\u53ea\u6709\u8fd9\u4e9b\u56e0\u5b50\u90fd\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\u624d\u80fd\u590d\u7528\u8fde\u63a5\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230Agent\u652f\u6301Unix\u57df\u3002","title":"18.4.1 key\u7684\u8ba1\u7b97"},{"location":"chapter18-HTTP/#1842-socket","text":"1. function createSocket(req, options, cb) { 2. options = { ...options, ...this.options }; 3. // \u8ba1\u7b97key 4. const name = this.getName(options); 5. options._agentKey = name; 6. options.encoding = null; 7. let called = false; 8. // \u521b\u5efasocket\u5b8c\u6bd5\u540e\u6267\u884c\u7684\u56de\u8c03 9. const oncreate = (err, s) => { 10. if (called) 11. return; 12. called = true; 13. if (err) 14. return cb(err); 15. if (!this.sockets[name]) { 16. this.sockets[name] = []; 17. } 18. // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 19. this.sockets[name].push(s); 20. // \u76d1\u542csocket\u7684\u4e00\u4e9b\u4e8b\u4ef6\uff0c\u7528\u4e8e\u56de\u6536socket 21. installListeners(this, s, options); 22. // \u6709\u53ef\u7528socket\uff0c\u901a\u77e5\u8c03\u7528\u65b9 23. cb(null, s); 24. }; 25. // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684socket\uff0c\u4f7f\u7528net.createConnection 26. const newSocket = this.createConnection(options, oncreate); 27. if (newSocket) 28. oncreate(null, newSocket); 29. } 30. 31. function installListeners(agent, s, options) { 32. /* 33. socket\u89e6\u53d1\u7a7a\u95f2\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u544a\u8bc9agent\u8be5socket\u7a7a\u95f2\u4e86\uff0c 34. agent\u4f1a\u56de\u6536\u8be5socket\u5230\u7a7a\u95f2\u961f\u5217 35. */ 36. function onFree() { 37. agent.emit('free', s, options); 38. } 39. /* 40. \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6\uff0c\u8c03\u7528\u65b9\u4f7f\u7528\u5b8csocket\u540e\u89e6\u53d1\uff0c 41. \u901a\u77e5agent socket\u7528\u5b8c\u4e86 42. */ 43. s.on('free', onFree); 44. 45. function onClose(err) { 46. agent.removeSocket(s, options); 47. } 48. // socket\u5173\u95ed\u5219agent\u4f1a\u4ecesocket\u961f\u5217\u4e2d\u5220\u9664\u5b83 49. s.on('close', onClose); 50. 51. function onRemove() { 52. agent.removeSocket(s, options); 53. s.removeListener('close', onClose); 54. s.removeListener('free', onFree); 55. s.removeListener('agentRemove', onRemove); 56. } 57. // agent\u88ab\u79fb\u9664 58. s.on('agentRemove', onRemove); 59. 60. } \u521b\u5efasocket\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u8c03\u7528net\u6a21\u5757\u521b\u5efa\u4e00\u4e2asocket\uff08TCP\u6216\u8005Unix\u57df\uff09\uff0c\u7136\u540e\u63d2\u5165\u4f7f\u7528\u4e2d\u7684socket\u961f\u5217\uff0c\u6700\u540e\u901a\u77e5\u8c03\u7528\u65b9socket\u521b\u5efa\u6210\u529f\u3002 2 \u76d1\u542csocket\u7684close\u3001free\u4e8b\u4ef6\u548cagentRemove\u4e8b\u4ef6\uff0c\u89e6\u53d1\u65f6\u4ece\u961f\u5217\u4e2d\u5220\u9664socket\u3002","title":"18.4.2 \u521b\u5efa\u4e00\u4e2asocket"},{"location":"chapter18-HTTP/#1843-socket","text":"1. // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u6216\u8005\u7a7a\u95f2\u961f\u5217\u4e2d\u79fb\u51fa 2. function removeSocket(s, options) { 3. const name = this.getName(options); 4. const sets = [this.sockets]; 5. /* 6. socket\u4e0d\u53ef\u5199\u4e86\uff0c\u5219\u6709\u53ef\u80fd\u662f\u5b58\u5728\u7a7a\u95f2\u7684\u961f\u5217\u4e2d\uff0c 7. \u6240\u4ee5\u9700\u8981\u904d\u5386\u7a7a\u95f2\u961f\u5217\uff0c\u56e0\u4e3aremoveSocket\u53ea\u4f1a\u5728 8. \u4f7f\u7528\u5b8csocket\u6216\u8005socket\u5173\u95ed\u7684\u65f6\u5019\u88ab\u8c03\u7528\uff0c\u524d\u8005\u53ea\u6709\u5728 9. \u53ef\u5199\u72b6\u6001\u65f6\u4f1a\u8c03\u7528\uff0c\u540e\u8005\u662f\u4e0d\u53ef\u5199\u7684 10. */ 11. if (!s.writable) 12. sets.push(this.freeSockets); 13. // \u4ece\u961f\u5217\u4e2d\u5220\u9664\u5bf9\u5e94\u7684socket 14. for (const sockets of sets) { 15. if (sockets[name]) { 16. const index = sockets[name].indexOf(s); 17. if (index !== -1) { 18. sockets[name].splice(index, 1); 19. // Don't leak 20. if (sockets[name].length === 0) 21. delete sockets[name]; 22. } 23. } 24. } 25. /* 26. \u5982\u679c\u8fd8\u6709\u5728\u7b49\u5f85socekt\u7684\u8bf7\u6c42\uff0c\u5219\u521b\u5efasocket\u53bb\u5904\u7406\u5b83\uff0c 27. \u56e0\u4e3asocket\u6570\u5df2\u7ecf\u51cf\u4e00\u4e86\uff0c\u8bf4\u660esocket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c 28. \u4f46\u662f\u8fd9\u91cc\u5e94\u8be5\u5148\u5224\u65ad\u662f\u5426\u8fd8\u6709\u7a7a\u95f2\u7684socket\uff0c\u6709\u5219\u53ef\u4ee5\u590d\u7528\uff0c 29. \u6ca1\u6709\u5219\u521b\u5efa\u65b0\u7684socket 30. */ 31. if (this.requests[name] && this.requests[name].length) { 32. const req = this.requests[name][0]; 33. const socketCreationHandler = handleSocketCreation(this, 34. req, 35. false); 36. this.createSocket(req, options, socketCreationHandler); 37. } 38. }; \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cAgent\u7ef4\u62a4\u4e86\u4e24\u4e2asocket\u961f\u5217\uff0c\u5220\u9664socket\u5c31\u662f\u4ece\u8fd9\u4e24\u4e2a\u961f\u5217\u4e2d\u627e\u5230\u5bf9\u5e94\u7684socket\uff0c\u7136\u540e\u79fb\u9664\u5b83\u3002\u79fb\u9664\u540e\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u5426\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u961f\u5217\uff0c\u6709\u7684\u8bdd\u5c31\u65b0\u5efa\u4e00\u4e2asocket\u53bb\u5904\u7406\u5b83\u3002\u56e0\u4e3a\u79fb\u9664\u4e86\u4e00\u4e2asocket\uff0c\u5c31\u8bf4\u660e\u53ef\u4ee5\u65b0\u589e\u4e00\u4e2asocket\u3002","title":"18.4.3 \u5220\u9664socket"},{"location":"chapter18-HTTP/#1844-socket-keepalive","text":"\u5f53socket\u88ab\u4f7f\u7528\u5b8c\u5e76\u4e14\u88ab\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u540e\uff0c\u9700\u8981\u91cd\u65b0\u8bbe\u7f6esocket\u7684keepalive\u503c\u3002\u7b49\u5230\u8d85\u65f6\u4f1a\u81ea\u52a8\u5173\u95edsocket\u3002\u5728\u4e00\u4e2asocket\u4e0a\u8c03\u7528\u4e00\u6b21setKeepAlive\u5c31\u53ef\u4ee5\u4e86\uff0c\u8fd9\u91cc\u53ef\u80fd\u4f1a\u5bfc\u81f4\u591a\u6b21\u8c03\u7528setKeepAlive\uff0c\u4e0d\u8fc7\u4e5f\u6ca1\u6709\u5f71\u54cd\u3002 1. function keepSocketAlive(socket) { 2. socket.setKeepAlive(true, this.keepAliveMsecs); 3. socket.unref(); 4. return true; 5. }; \u53e6\u5916\u9700\u8981\u8bbe\u7f6eref\u6807\u8bb0\uff0c\u9632\u6b62\u8be5socket\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\uff0c\u56e0\u4e3a\u8be5socket\u662f\u7a7a\u95f2\u7684\uff0c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002","title":"18.4.4 \u8bbe\u7f6esocket keepalive"},{"location":"chapter18-HTTP/#1845-socket","text":"1. function reuseSocket(socket, req) { 2. req.reusedSocket = true; 3. socket.ref(); 4. }; \u91cd\u65b0\u4f7f\u7528\u8be5socket\uff0c\u9700\u8981\u4fee\u6539ref\u6807\u8bb0\uff0c\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u5e76\u6807\u8bb0\u8bf7\u6c42\u4f7f\u7528\u7684\u662f\u590d\u7528socket\u3002","title":"18.4.5 \u590d\u7528socket"},{"location":"chapter18-HTTP/#1846-agent","text":"1. function destroy() { 2. for (const set of [this.freeSockets, this.sockets]) { 3. for (const key of ObjectKeys(set)) { 4. for (const setName of set[key]) { 5. setName.destroy(); 6. } 7. } 8. } 9. }; \u56e0\u4e3aAgent\u672c\u8d28\u4e0a\u662f\u4e00\u4e2asocket\u6c60\uff0c\u9500\u6bc1Agent\u5373\u9500\u6bc1\u6c60\u91cc\u7ef4\u62a4\u7684\u6240\u6709socket\u3002","title":"18.4.6 \u9500\u6bc1Agent"},{"location":"chapter18-HTTP/#1847","text":"\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528Agent\u3002 1. function addRequest(req, options, port, localAddress) { 2. // \u53c2\u6570\u5904\u7406 3. if (typeof options === 'string') { 4. options = { 5. host: options, 6. port, 7. localAddress 8. }; 9. } 10. 11. options = { ...options, ...this.options }; 12. if (options.socketPath) 13. options.path = options.socketPath; 14. 15. if (!options.servername && options.servername !== '') 16. options.servername = calculateServerName(options, req); 17. // \u62ff\u5230\u8bf7\u6c42\u5bf9\u5e94\u7684key 18. const name = this.getName(options); 19. // \u8be5key\u8fd8\u6ca1\u6709\u5728\u4f7f\u7528\u7684socekt\u5219\u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784 20. if (!this.sockets[name]) { 21. this.sockets[name] = []; 22. } 23. // \u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5217\u8868 24. const freeLen = this.freeSockets[name] ? 25. this.freeSockets[name].length : 0; 26. // \u8be5key\u5bf9\u5e94\u7684\u6240\u6709socket\u4e2a\u6570 27. const sockLen = freeLen + this.sockets[name].length; 28. // \u8be5key\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socekt 29. if (freeLen) { 30. // \u83b7\u53d6\u4e00\u4e2a\u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket 31. const socket = this.freeSockets[name].shift(); 32. // \u53d6\u5b8c\u4e86\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f 33. if (!this.freeSockets[name].length) 34. delete this.freeSockets[name]; 35. // \u8bbe\u7f6eref\u6807\u8bb0\uff0c\u56e0\u4e3a\u6b63\u5728\u4f7f\u7528\u8be5socket 36. this.reuseSocket(socket, req); 37. // \u8bbe\u7f6e\u8bf7\u6c42\u5bf9\u5e94\u7684socket 38. setRequestSocket(this, req, socket); 39. // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 40. this.sockets[name].push(socket); 41. } else if (sockLen < this.maxSockets) { 42. /* 43. \u5982\u679c\u8be5key\u6ca1\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5e76\u4e14\u4f7f\u7528\u7684 44. socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u5f97\u5230\u9608\u503c\uff0c\u5219\u7ee7\u7eed\u521b\u5efa 45. */ 46. this.createSocket(req, 47. options, 48. handleSocketCreation(this, req, true)); 49. } else { 50. // \u7b49\u5f85\u8be5key\u4e0b\u6709\u7a7a\u95f2\u7684socket 51. if (!this.requests[name]) { 52. this.requests[name] = []; 53. } 54. this.requests[name].push(req); 55. } 56. } \u5f53\u6211\u4eec\u9700\u8981\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7Agent\u7684addRequest\u65b9\u6cd5\u628a\u8bf7\u6c42\u6258\u7ba1\u5230Agent\u4e2d\uff0c\u5f53\u6709\u53ef\u7528\u7684socket\u65f6\uff0cAgent\u4f1a\u901a\u77e5\u6211\u4eec\u3002addRequest\u7684\u4ee3\u7801\u5f88\u957f\uff0c\u4e3b\u8981\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\u3002 1 \u6709\u7a7a\u95f2socket\uff0c\u5219\u76f4\u63a5\u590d\u7528\uff0c\u5e76\u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217\u4e2d \u6211\u4eec\u4e3b\u8981\u770b\u4e00\u4e0bsetRequestSocket\u51fd\u6570 1. function setRequestSocket(agent, req, socket) { 2. // \u901a\u77e5\u8bf7\u6c42socket\u521b\u5efa\u6210\u529f 3. req.onSocket(socket); 4. const agentTimeout = agent.options.timeout || 0; 5. if (req.timeout === undefined || req.timeout === agentTimeout) 6. { 7. return; 8. } 9. // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8fc7\u671f\u540e\u89e6\u53d1timeout\u4e8b\u4ef6 10. socket.setTimeout(req.timeout); 11. /* 12. \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u9700\u8981\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c 13. \u5f00\u542f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u7684\u8d85\u65f6\u8ba1\u7b97\uff0c\u5426\u5219\u4f1a\u63d0\u524d\u8fc7\u671f 14. */ 15. req.once('response', (res) => { 16. res.once('end', () => { 17. if (socket.timeout !== agentTimeout) { 18. socket.setTimeout(agentTimeout); 19. } 20. }); 21. }); 22. } setRequestSocket\u51fd\u6570\u901a\u8fc7req.onSocket(socket)\u901a\u77e5\u8c03\u7528\u65b9\u6709\u53ef\u7528socket\u3002\u7136\u540e\u5982\u679c\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u8d85\u65f6\u65f6\u95f4\u5219\u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u8bf7\u6c42\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u6700\u540e\u76d1\u542c\u54cd\u5e94\u7ed3\u675f\u4e8b\u4ef6\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 2 \u6ca1\u6709\u7a7a\u95f2socket\uff0c\u4f46\u662f\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u521b\u5efa\u65b0\u7684socket\u3002 \u6211\u4eec\u4e3b\u8981\u5206\u6790\u521b\u5efasocket\u540e\u7684\u56de\u8c03handleSocketCreation\u3002 1. function handleSocketCreation(agent, request, informRequest) { 2. return function handleSocketCreation_Inner(err, socket) { 3. if (err) { 4. process.nextTick(emitErrorNT, request, err); 5. return; 6. } 7. /* 8. \u662f\u5426\u9700\u8981\u76f4\u63a5\u901a\u77e5\u8bf7\u6c42\u65b9\uff0c\u8fd9\u65f6\u5019request\u4e0d\u662f\u6765\u81ea\u7b49\u5f85 9. socket\u7684requests\u961f\u5217\uff0c \u800c\u662f\u6765\u81ea\u8c03\u7528\u65b9\uff0c\u89c1addRequest 10. */ 11. if (informRequest) 12. setRequestSocket(agent, request, socket); 13. else 14. /* 15. \u4e0d\u76f4\u63a5\u901a\u77e5\uff0c\u5148\u544a\u8bc9agent\u6709\u7a7a\u95f2\u7684socket\uff0c 16. agent\u4f1a\u5224\u65ad\u662f\u5426\u6709\u6b63\u5728\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u6709\u5219\u5904\u7406 17. */ 18. socket.emit('free'); 19. }; 20. } 3 \u4e0d\u6ee1\u8db31,2\uff0c\u5219\u628a\u8bf7\u6c42\u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u3002 \u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u540e\uff0c\u5f53\u6709socket\u7a7a\u95f2\u65f6\u4f1a\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1. // \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6 2. this.on('free', (socket, options) => { 3. const name = this.getName(options); 4. // socket\u8fd8\u53ef\u5199\u5e76\u4e14\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u590d\u7528socket 5. if (socket.writable && 6. this.requests[name] && this.requests[name].length) { 7. // \u62ff\u5230\u4e00\u4e2a\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u77e5\u5b83\u6709socket\u53ef\u7528 8. const req = this.requests[name].shift(); 9. setRequestSocket(this, req, socket); 10. // \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f 11. if (this.requests[name].length === 0) { 12. // don't leak 13. delete this.requests[name]; 14. } 15. } else { 16. // socket\u4e0d\u53ef\u7528\u5199\u6216\u8005\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u4e86 17. const req = socket._httpMessage; 18. // socket\u53ef\u5199\u5e76\u4e14\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u5141\u8bb8\u4f7f\u7528\u590d\u7528\u7684socket 19. if (req && 20. req.shouldKeepAlive && 21. socket.writable && 22. this.keepAlive) { 23. let freeSockets = this.freeSockets[name]; 24. // \u8be5key\u4e0b\u5f53\u524d\u7684\u7a7a\u95f2socket\u4e2a\u6570 25. const freeLen = freeSockets ? freeSockets.length : 0; 26. let count = freeLen; 27. // \u6b63\u5728\u4f7f\u7528\u7684socket\u4e2a\u6570 28. if (this.sockets[name]) 29. count += this.sockets[name].length; 30. /* 31. \u8be5key\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u6216\u8005\u7a7a\u95f2socket\u8fbe\u5230\u9608\u503c\uff0c 32. \u5219\u4e0d\u590d\u7528socket\uff0c\u76f4\u63a5\u9500\u6bc1socket 33. */ 34. if (count > this.maxSockets || freeLen >= this.maxFreeSockets) { 35. socket.destroy(); 36. } else if (this.keepSocketAlive(socket)) { 37. /* 38. \u91cd\u65b0\u8bbe\u7f6esocket\u7684\u5b58\u6d3b\u65f6\u95f4\uff0c\u8bbe\u7f6e\u5931\u8d25\u8bf4\u660e\u65e0\u6cd5\u91cd\u65b0\u8bbe\u7f6e\u5b58\u6d3b\u65f6 39. \u95f4\uff0c\u5219\u8bf4\u660e\u53ef\u80fd\u4e0d\u652f\u6301\u590d\u7528 40. */ 41. freeSockets = freeSockets || []; 42. this.freeSockets[name] = freeSockets; 43. socket[async_id_symbol] = -1; 44. socket._httpMessage = null; 45. // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u4e2d\u79fb\u9664 46. this.removeSocket(socket, options); 47. // \u63d2\u5165socket\u7a7a\u95f2\u961f\u5217 48. freeSockets.push(socket); 49. } else { 50. // \u4e0d\u590d\u7528\u5219\u76f4\u63a5\u9500\u6bc1 51. socket.destroy(); 52. } 53. } else { 54. socket.destroy(); 55. } 56. } 57. }); \u5f53\u6709socket\u7a7a\u95f2\u65f6\uff0c\u5206\u4e3a\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u76f4\u63a5\u590d\u7528socket\u3002 2 \u5982\u679c\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5141\u8bb8\u590d\u7528\u5e76\u4e14socket\u4e2a\u6570\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u3002 3 \u76f4\u63a5\u9500\u6bc1","title":"18.4.7 \u4f7f\u7528\u8fde\u63a5\u6c60"},{"location":"chapter18-HTTP/#1848","text":"\u5ba2\u6237\u7aef 1. const http = require('http'); 2. const keepAliveAgent = new http.Agent({ keepAlive: true, maxSockets: 1 }); 3. const options = {port: 10000, method: 'GET', host: '127.0.0.1',} 4. options.agent = keepAliveAgent; 5. http.get(options, () => {}); 6. http.get(options, () => {}); 7. console.log(options.agent.requests) \u670d\u52a1\u5668 1. let i =0; 2. const net = require('net'); 3. net.createServer((socket) => { 4. console.log(++i); 5. }).listen(10000); \u5728\u4f8b\u5b50\u4e2d\uff0c\u9996\u5148\u521b\u5efa\u4e86\u4e00\u4e2atcp\u670d\u52a1\u5668\u3002\u7136\u540e\u5728\u5ba2\u6237\u7aef\u4f7f\u7528agent\u3002\u4f46\u662fmaxSocket\u7684\u503c\u4e3a1\uff0c\u4ee3\u8868\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2asocket\uff0c\u800c\u8fd9\u65f6\u5019\u5ba2\u6237\u7aef\u53d1\u9001\u4e24\u4e2a\u8bf7\u6c42\uff0c\u6240\u4ee5\u6709\u4e00\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u5728\u6392\u961f\u3002\u670d\u52a1\u5668\u4e5f\u53ea\u6536\u5230\u4e86\u4e00\u4e2a\u8fde\u63a5\u3002","title":"18.4.8 \u6d4b\u8bd5\u4f8b\u5b50"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/","text":"Node.js\u7684\u6a21\u5757\u5206\u4e3a\u7528\u6237JS\u6a21\u5757\u3001Node.js\u539f\u751fJS\u6a21\u5757\u3001Node.js\u5185\u7f6eC++\u6a21\u5757\u3002\u672c\u7ae0\u4ecb\u7ecd\u8fd9\u4e9b\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\u4ee5\u53caNode.js\u4e2d\u6a21\u5757\u52a0\u8f7d\u5668\u7684\u7c7b\u578b\u548c\u539f\u7406\u3002 \u4e0b\u9762\u6211\u4eec\u4ee5\u4e00\u4e2a\u4f8b\u5b50\u4e3a\u5f00\u59cb\uff0c\u5206\u6790Node.js\u4e2d\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a\u6587\u4ef6demo.js\uff0c\u4ee3\u7801\u5982\u4e0b 1. const myjs= require(\u2018myjs); 2. const net = require(\u2018net\u2019); \u5176\u4e2dmyjs\u7684\u4ee3\u7801\u5982\u4e0b 1. exports.hello = \u2018world\u2019; \u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884cnode demo.js\u7684\u65f6\u5019\uff0c\u8fc7\u7a0b\u662f\u600e\u6837\u7684\u3002\u5728Node.js\u542f\u52a8\u7ae0\u8282\u6211\u4eec\u5206\u6790\u8fc7\uff0cNode.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\u3002 require('internal/modules/cjs/loader').Module.runMain(process.argv[1]) \u5176\u4e2drunMain\u51fd\u6570\u5728pre_execution.js\u7684initializeCJSLoader\u4e2d\u6302\u8f7d 1. function initializeCJSLoader() { 2. const CJSLoader = require('internal/modules/cjs/loader'); 3. CJSLoader.Module._initPaths(); 4. CJSLoader.Module.runMain = 5. require('internal/modules/run_main').executeUserEntryPoint; 6. } \u6211\u4eec\u770b\u5230runMain\u662frun_main.js\u5bfc\u51fa\u7684\u51fd\u6570\u3002\u7ee7\u7eed\u5f80\u4e0b\u770b 1. const CJSLoader = require('internal/modules/cjs/loader'); 2. const { Module } = CJSLoader; 3. function executeUserEntryPoint(main = process.argv[1]) { 4. const resolvedMain = resolveMainPath(main); 5. const useESMLoader = shouldUseESMLoader(resolvedMain); 6. if (useESMLoader) { 7. runMainESM(resolvedMain || main); 8. } else { 9. Module._load(main, null, true); 10. } 11. } 12. 13. module.exports = { 14. executeUserEntryPoint 15. }; process.argv[1]\u5c31\u662f\u6211\u4eec\u8981\u6267\u884c\u7684JS\u6587\u4ef6\u3002\u6700\u540e\u901a\u8fc7cjs/loader.js\u7684Module._load\u52a0\u8f7d\u4e86\u6211\u4eec\u7684JS\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u3002 1. Module._load = function(request, parent, isMain) { 2. const filename = Module._resolveFilename(request, parent, isMain); 3. 4. const cachedModule = Module._cache[filename]; 5. // \u6709\u7f13\u5b58\u5219\u76f4\u63a5\u8fd4\u56de 6. if (cachedModule !== undefined) { 7. updateChildren(parent, cachedModule, true); 8. if (!cachedModule.loaded) 9. return getExportsForCircularRequire(cachedModule); 10. return cachedModule.exports; 11. } 12. // \u662f\u5426\u662f\u53ef\u8bbf\u95ee\u7684\u539f\u751fJS\u6a21\u5757\uff0c\u662f\u5219\u8fd4\u56de 13. const mod = loadNativeModule(filename, request); 14. if (mod && mod.canBeRequiredByUsers) return mod.exports; 15. // \u975e\u539f\u751fJS\u6a21\u5757\uff0c\u5219\u65b0\u5efa\u4e00\u4e2aModule\u8868\u793a\u52a0\u8f7d\u7684\u6a21\u5757 16. const module = new Module(filename, parent); 17. // \u7f13\u5b58 18. Module._cache[filename] = module; 19. // \u52a0\u8f7d 20. module.load(filename); 21. // \u8c03\u7528\u65b9\u62ff\u5230\u7684\u662fmodule.exports\u7684\u503c 22. return module.exports; 23. }; _load\u51fd\u6570\u4e3b\u8981\u662f\u4e09\u4e2a\u903b\u8f91 1 \u5224\u65ad\u662f\u5426\u6709\u7f13\u5b58\uff0c\u6709\u5219\u8fd4\u56de\u3002 2 \u6ca1\u6709\u7f13\u5b58\uff0c\u5219\u5224\u65ad\u662f\u5426\u662f\u539f\u751fJS\u6a21\u5757\uff0c\u662f\u5219\u4ea4\u7ed9\u539f\u751f\u6a21\u5757\u5904\u7406\u3002 1 \u4e0d\u662f\u539f\u751f\u6a21\u5757\uff0c\u5219\u65b0\u5efa\u4e00\u4e2aModule\u8868\u793a\u7528\u6237\u7684JS\u6a21\u5757\uff0c\u7136\u540e\u6267\u884cload\u51fd\u6570\u52a0\u8f7d\u3002 \u8fd9\u91cc\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce83\u7684\u903b\u8f91\uff0c\u5728Node.js\u4e2d\uff0c\u7528\u6237\u5b9a\u4e49\u7684\u6a21\u5757\u4f7f\u7528Module\u8868\u793a\u3002 1. function Module(id = '', parent) { 2. // \u6a21\u5757\u5bf9\u5e94\u7684\u6587\u4ef6\u8def\u5f84 3. this.id = id; 4. this.path = path.dirname(id); 5. // \u5728\u6a21\u5757\u91cc\u4f7f\u7528\u7684exports\u53d8\u91cf 6. this.exports = {}; 7. this.parent = parent; 8. // \u52a0\u5165\u7236\u6a21\u5757\u7684children\u961f\u5217 9. updateChildren(parent, this, false); 10. this.filename = null; 11. // \u662f\u5426\u5df2\u7ecf\u52a0\u8f7d 12. this.loaded = false; 13. this.children = []; 14. } \u63a5\u7740\u770b\u4e00\u4e0bload\u51fd\u6570\u7684\u903b\u8f91\u3002 1. Module.prototype.load = function(filename) { 2. this.filename = filename; 3. // \u62d3\u5c55\u540d 4. const extension = findLongestRegisteredExtension(filename); 5. // \u6839\u636e\u62d3\u5c55\u540d\u4f7f\u7528\u4e0d\u540c\u7684\u52a0\u8f7d\u65b9\u5f0f 6. Module._extensions[extension](this, filename); 7. this.loaded = true; 8. }; Node.js\u4f1a\u6839\u636e\u4e0d\u540c\u7684\u6587\u4ef6\u62d3\u5c55\u540d\u4f7f\u7528\u4e0d\u540c\u7684\u51fd\u6570\u5904\u7406\u3002 19.1 \u52a0\u8f7d\u7528\u6237\u6a21\u5757 \u00b6 \u5728Node.js\u4e2d_extensions\u6709\u4e09\u79cd\uff0c\u5206\u522b\u662fjs\u3001json\u3001node\u3002 19.1.1 \u52a0\u8f7dJSON\u6a21\u5757 \u00b6 \u52a0\u8f7dJSON\u6a21\u5757\u662f\u6bd4\u8f83\u7b80\u5355\u7684 1. Module._extensions['.json'] = function(module, filename) { 2. const content = fs.readFileSync(filename, 'utf8'); 3. 4. try { 5. module.exports = JSONParse(stripBOM(content)); 6. } catch (err) { 7. err.message = filename + ': ' + err.message; 8. throw err; 9. } 10. }; \u76f4\u63a5\u8bfb\u53d6JSON\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u89e3\u6790\u6210\u5bf9\u8c61\u5c31\u884c\u3002 19.1.2 \u52a0\u8f7dJS\u6a21\u5757 \u00b6 1. Module._extensions['.js'] = function(module, filename) { 2. const content = fs.readFileSync(filename, 'utf8'); 3. module._compile(content, filename); 4. }; \u8bfb\u5b8c\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u6267\u884c_compile 1. Module.prototype._compile = function(content, filename) { 2. // \u751f\u6210\u4e00\u4e2a\u51fd\u6570 3. const compiledWrapper = wrapSafe(filename, content, this); 4. const dirname = path.dirname(filename); 5. // require\u662f\u5bf9_load\u51fd\u6570\u7684\u5c01\u88c5 6. const require = (path) => { 7. return this.require(path); 8. }; 9. let result; 10. // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684exports\u53d8\u91cf 11. const exports = this.exports; 12. const thisValue = exports; 13. // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684module\u53d8\u91cf 14. const module = this; 15. // \u6267\u884c\u51fd\u6570 16. result = compiledWrapper.call(thisValue, 17. exports, 18. require, 19. module, 20. filename, 21. dirname); 22. return result; 23. } _compile\u91cc\u9762\u5305\u62ec\u4e86\u51e0\u4e2a\u91cd\u8981\u7684\u903b\u8f91 1 wrapSafe\uff1a\u5305\u88f9\u6211\u4eec\u7684\u4ee3\u7801\u5e76\u751f\u6210\u4e00\u4e2a\u51fd\u6570 2 require\uff1a\u652f\u6301\u5728\u6a21\u5757\u5185\u52a0\u8f7d\u5176\u4ed6\u6a21\u5757 3 \u6267\u884c\u6a21\u5757\u4ee3\u7801 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e09\u4e2a\u903b\u8f91\u3002 1 wrapSafe 1. function wrapSafe(filename, content, cjsModuleInstance) { 2. const wrapper = Module.wrap(content); 3. return vm.runInThisContext(wrapper, { 4. filename, 5. lineOffset: 0, 6. ... 7. }); 8. } 9. 10. const wrapper = [ 11. '(function (exports, require, module, __filename, __dirname) { ', 12. '\\n});' 13. ]; 14. 15. Module.wrap = function(script) { 16. return Module.wrapper[0] + script + Module.wrapper[1]; 17. }; vm.runInThisContext\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u201d(function() {})\u201d\u7684\u65f6\u5019\uff0c\u4f1a\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u3002\u6240\u4ee5\u6267\u884cModule.wrap\u540e\u4f1a\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5185\u5bb9\u5982\u4e0b 2. (function (exports, require, module, __filename, __dirname) { 3. // 4. }); \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0brequire\u51fd\u6570\uff0c\u5373\u6211\u4eec\u5e73\u65f6\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u7684require\u3002 2 require 1. Module.prototype.require = function(id) { 2. requireDepth++; 3. try { 4. return Module._load(id, this, /* isMain */ false); 5. } finally { 6. requireDepth--; 7. } 8. }; require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0cModule._load\u4f1a\u628a\u6a21\u5757\u5bfc\u51fa\u7684\u53d8\u91cf\u901a\u8fc7module.exports\u5c5e\u6027\u8fd4\u56de\u7ed9require\u8c03\u7528\u65b9\u3002\u56e0\u4e3aModule._load\u53ea\u4f1a\u4ece\u539f\u751fJS\u6a21\u5757\u548c\u7528\u6237JS\u6a21\u5757\u4e2d\u67e5\u627e\u7528\u6237\u9700\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6240\u4ee5\u662f\u65e0\u6cd5\u8bbf\u95eeC++\u6a21\u5757\u7684\uff0c\u8bbf\u95eeC++\u6a21\u5757\u53ef\u7528process.bindng\u6216internalBinding\u3002 3 \u6267\u884c\u4ee3\u7801 \u6211\u4eec\u56de\u5230_compile\u51fd\u6570\u3002\u770b\u4e00\u4e0b\u6267\u884cvm.runInThisContext\u8fd4\u56de\u7684\u51fd\u6570\u3002 compiledWrapper.call(exports, exports, require, module, filename, dirname); \u76f8\u5f53\u4e8e\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801 1. (function (exports, require, module, __filename, __dirname) { 2. const myjs= require(\u2018myjs); 3. const net = require(\u2018net\u2019); 4. }); \u81f3\u6b64\uff0cNode.js\u5f00\u59cb\u6267\u884c\u7528\u6237\u7684JS\u4ee3\u7801\u3002\u521a\u624d\u6211\u4eec\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0c\u5f53\u6267\u884crequire\u52a0\u8f7d\u7528\u6237\u6a21\u5757\u65f6\uff0c\u53c8\u56de\u5230\u4e86\u6211\u4eec\u6b63\u5728\u5206\u6790\u7684\u8fd9\u4e2a\u8fc7\u7a0b\u3002 19.1.3 \u52a0\u8f7dnode\u6a21\u5757 \u00b6 Node\u62d3\u5c55\u7684\u6a21\u5757\u672c\u8d28\u4e0a\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u6211\u4eec\u770brequire\u4e00\u4e2a.node\u6a21\u5757\u7684\u65f6\u5019\u7684\u8fc7\u7a0b\u3002\u6211\u4eec\u4ece\u52a0\u8f7d.node\u6a21\u5757\u7684\u6e90\u7801\u5f00\u59cb\u3002 1. Module._extensions['.node'] = function(module, filename) { 2. // ... 3. return process.dlopen(module, path.toNamespacedPath(filename)); 4. }; \u76f4\u63a5\u8c03\u4e86process.dlopen\uff0c\u8be5\u51fd\u6570\u5728node.js\u91cc\u5b9a\u4e49\u3002 1. const rawMethods = internalBinding('process_methods'); 2. process.dlopen = rawMethods.dlopen; \u627e\u5230process_methods\u6a21\u5757\u5bf9\u5e94\u7684\u662fnode_process_methods.cc\u3002 env->SetMethod(target, \"dlopen\", binding::DLOpen); \u4e4b\u524d\u8bf4\u8fc7\uff0cNode.js\u7684\u62d3\u5c55\u6a21\u5757\u5176\u5b9e\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u90a3\u4e48\u6211\u4eec\u5148\u770b\u770b\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u6211\u4eec\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u4ee5\u4e0b\u662f\u793a\u4f8b\u4ee3\u7801\u3002 1. #include <stdio.h> 2. #include <stdlib.h> 3. #include <dlfcn.h> 4. int main(){ 5. // \u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u62ff\u5230\u4e00\u4e2ahandler 6. handler = dlopen('xxx.so',RTLD_LAZY); 7. // \u53d6\u51fa\u52a8\u6001\u94fe\u63a5\u5e93\u91cc\u7684\u51fd\u6570add 8. add = dlsym(handler,\"add\"); 9. // \u6267\u884c 10. printf(\"%d\",add(1,1)); 11. dlclose(handler); 12. return 0; 13. } \u4e86\u89e3\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4f7f\u7528\uff0c\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u521a\u624d\u770b\u5230\u7684DLOpen\u51fd\u6570\u3002 1. void DLOpen(const FunctionCallbackInfo<Value>& args) { 2. 3. int32_t flags = DLib::kDefaultFlags; 4. node::Utf8Value filename(env->isolate(), args[1]); // Cast 5. env->TryLoadAddon(*filename, flags, [&](DLib* dlib) { 6. const bool is_opened = dlib->Open(); 7. node_module* mp = thread_local_modpending; 8. thread_local_modpending = nullptr; 9. // \u7701\u7565\u90e8\u5206\u4ee3\u7801 10. if (mp->nm_context_register_func != nullptr) { 11. mp->nm_context_register_func(exports, 12. module, 13. context, 14. mp->nm_priv); 15. } else if (mp->nm_register_func != nullptr) { 16. mp->nm_register_func(exports, module, mp->nm_priv); 17. } 18. return true; 19. }); 20. } \u6211\u4eec\u770b\u5230\u91cd\u70b9\u662fTryLoadAddon\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5b83\u7684\u7b2c\u4e09\u4e2a\u53c2\u6570\u3002\u6211\u4eec\u53d1\u73b0\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5165\u53c2\u662fDLib\u5bf9\u8c61\u3002\u6240\u4ee5\u6211\u4eec\u5148\u770b\u770b\u8fd9\u4e2a\u7c7b\u3002 1. class DLib { 2. public: 3. static const int kDefaultFlags = RTLD_LAZY; 4. DLib(const char* filename, int flags); 5. 6. bool Open(); 7. void Close(); 8. const std::string filename_; 9. const int flags_; 10. std::string errmsg_; 11. void* handle_; 12. uv_lib_t lib_; 13. }; \u518d\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1. bool DLib::Open() { 2. handle_ = dlopen(filename_.c_str(), flags_); 3. if (handle_ != nullptr) return true; 4. errmsg_ = dlerror(); 5. return false; 6. } DLib\u5c31\u662f\u5bf9\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u5b83\u5c01\u88c5\u4e86\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u6587\u4ef6\u540d\u548c\u64cd\u4f5c\u3002TryLoadAddon\u51fd\u6570\u9996\u5148\u6839\u636erequire\u4f20\u5165\u7684\u6587\u4ef6\u540d\uff0c\u6784\u9020\u4e00\u4e2aDLib\uff0c\u7136\u540e\u6267\u884c const bool is_opened = dlib->Open(); Open\u51fd\u6570\u6253\u5f00\u4e86\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0b\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7a76\u7adf\u53d1\u751f\u4e86\u4ec0\u4e48\u3002\u9996\u5148\u6211\u4eec\u4e00\u822cC++\u63d2\u4ef6\u6700\u540e\u4e00\u53e5\u4ee3\u7801\u7684\u5b9a\u4e49\u3002 NAPI_MODULE(NODE_GYP_MODULE_NAME, init) \u8fd9\u662f\u4e2a\u5b8f\u5b9a\u4e49\u3002 1. #define NAPI_MODULE(modname, regfunc) \\ 2. NAPI_MODULE_X(modname, regfunc, NULL, 0) 3. #define NAPI_MODULE_X(modname, regfunc, priv, flags) \\ 4. static napi_module _module = \\ 5. { \\ 6. NAPI_MODULE_VERSION, \\ 7. flags, \\ 8. __FILE__, \\ 9. regfunc, \\ 10. #modname, \\ 11. priv, \\ 12. {0}, \\ 13. }; \\ 14. static void _register_modname(void) __attribute__((constructor)); \\ 15. static void _register_modname(void) { \\ 16. napi_module_register(&_module); \\ 17. } \u6240\u4ee5\u4e00\u4e2anode\u6269\u5c55\u5c31\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2anapi_module\u6a21\u5757\u548c\u4e00\u4e2aregister_modname\uff08modname\u662f\u6211\u4eec\u5b9a\u4e49\u7684\uff09\u51fd\u6570\u3002__attribute((constructor))\u662f\u4ee3\u8868\u8be5\u51fd\u6570\u4f1a\u5148\u6267\u884c\u7684\u610f\u601d\uff0c\u5177\u4f53\u53ef\u4ee5\u67e5\u9605\u6587\u6863\u3002\u770b\u5230\u8fd9\u91cc\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u6211\u4eec\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c_register_modname\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u6267\u884c\u7684\u662f napi_module_register(&_module); \u6211\u4eec\u7ee7\u7eed\u5c55\u5f00\u3002 1. 2. // Registers a NAPI module. 3. void napi_module_register(napi_module* mod) { 4. node::node_module* nm = new node::node_module { 5. -1, 6. mod->nm_flags | NM_F_DELETEME, 7. nullptr, 8. mod->nm_filename, 9. nullptr, 10. napi_module_register_cb, 11. mod->nm_modname, 12. mod, // priv 13. nullptr, 14. }; 15. node::node_module_register(nm); 16. } Node.js\u628anapi\u6a21\u5757\u8f6c\u6210node_module\u3002\u6700\u540e\u8c03\u7528node_module_register\u3002 1. 2. extern \"C\" void node_module_register(void* m) { 3. struct node_module* mp = reinterpret_cast<struct node_module*>(m); 4. 5. if (mp->nm_flags & NM_F_INTERNAL) { 6. mp->nm_link = modlist_internal; 7. modlist_internal = mp; 8. } else if (!node_is_initialized) { 9. mp->nm_flags = NM_F_LINKED; 10. mp->nm_link = modlist_linked; 11. modlist_linked = mp; 12. } else { 13. thread_local_modpending = mp; 14. } 15. } napi\u6a21\u5757\u4e0d\u662fNM_F_INTERNAL\u6a21\u5757\uff0cnode_is_initialized\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u53d8\u91cf\uff0c\u8fd9\u65f6\u5019\u5df2\u7ecf\u662ftrue\u3002\u6240\u4ee5\u6ce8\u518cnapi\u6a21\u5757\u65f6\uff0c\u4f1a\u6267\u884cthread_local_modpending = mp\u3002thread_local_modpending \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u4fdd\u5b58\u5f53\u524d\u52a0\u8f7d\u7684\u6a21\u5757\u3002\u5206\u6790\u5230\u8fd9\uff0c\u6211\u4eec\u56de\u5230DLOpen\u51fd\u6570\u3002 1. node_module* mp = thread_local_modpending; 2. thread_local_modpending = nullptr; \u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u77e5\u9053\u521a\u624d\u90a3\u4e2a\u53d8\u91cfthread_local_modpending\u7684\u4f5c\u7528\u4e86\u3002node_module* mp = thread_local_modpending\u540e\u6211\u4eec\u62ff\u5230\u4e86\u6211\u4eec\u521a\u624d\u5b9a\u4e49\u7684napi\u6a21\u5757\u7684\u4fe1\u606f\u3002\u63a5\u7740\u6267\u884cnode_module\u7684\u51fd\u6570nm_register_func\u3002 1. if (mp->nm_context_register_func != nullptr) { 2. mp->nm_context_register_func(exports, 3. module, 4. context, 5. mp->nm_priv); 6. } else if (mp->nm_register_func != nullptr) { 7. mp->nm_register_func(exports, module, mp->nm_priv); 8. } \u4ece\u521a\u624d\u7684node_module\u5b9a\u4e49\u4e2d\u6211\u4eec\u770b\u5230\u51fd\u6570\u662fnapi_module_register_cb\u3002 1. static void napi_module_register_cb(v8::Local<v8::Object> exports, 2. v8::Local<v8::Value> module, 3. v8::Local<v8::Context> context, 4. void* priv) { 5. napi_module_register_by_symbol(exports, module, context, 6. static_cast<napi_module*>(priv)->nm_register_func); 7. } \u8be5\u51fd\u6570\u8c03\u7528napi_module_register_by_symbol\u51fd\u6570\uff0c\u5e76\u4f20\u5165napi_module\u7684nm_register_func\u51fd\u6570\u3002 1. void napi_module_register_by_symbol(v8::Local<v8::Object> exports, 2. v8::Local<v8::Value> module, 3. v8::Local<v8::Context> context, 4. napi_addon_register_func init) { 5. 6. // Create a new napi_env for this specific module. 7. napi_env env = v8impl::NewEnv(context); 8. 9. napi_value _exports; 10. env->CallIntoModuleThrow([&](napi_env env) { 11. _exports = init(env, v8impl::JsValueFromV8LocalValue(exports)); 12. }); 13. 14. if (_exports != nullptr && 15. _exports != v8impl::JsValueFromV8LocalValue(exports)) { 16. napi_value _module = v8impl::JsValueFromV8LocalValue(module); 17. napi_set_named_property(env, _module, \"exports\", _exports); 18. } 19. } init\u5c31\u662f\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u3002\u5165\u53c2\u662fenv\u548cexports\uff0c\u53ef\u4ee5\u5bf9\u6bd4\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u7684\u5165\u53c2\u3002\u6700\u540e\u6211\u4eec\u4fee\u6539exports\u53d8\u91cf\u3002\u5373\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5185\u5bb9\u3002\u6700\u540e\u5728JS\u91cc\uff0c\u6211\u4eec\u5c31\u62ff\u5230\u4e86C++\u5c42\u5b9a\u4e49\u7684\u5185\u5bb9\u3002 19.2 \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757 \u00b6 \u4e0a\u4e00\u8282\u6211\u4eec\u4e86\u89e3\u4e86Node.js\u6267\u884cnode demo.js\u7684\u8fc7\u7a0b\uff0c\u5176\u4e2d\u6211\u4eec\u5728demo.js\u4e2d\u4f7f\u7528require\u52a0\u8f7dnet\u6a21\u5757\u3002net\u662f\u539f\u751fJS\u6a21\u5757\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u8fdb\u5165\u539f\u751f\u6a21\u5757\u7684\u5904\u7406\u903b\u8f91\u3002 \u539f\u751f\u6a21\u5757\u662fNode.js\u5185\u90e8\u5b9e\u73b0\u7684JS\u6a21\u5757\u3002\u4f7f\u7528NativeModule\u6765\u8868\u793a\u3002 1. class NativeModule { 2. // \u539f\u751fJS\u6a21\u5757\u7684map 3. static map = new Map(moduleIds.map((id) => [id, new NativeModule(id)])); 4. 5. constructor(id) { 6. this.filename = `${id}.js`; 7. this.id = id; 8. this.canBeRequiredByUsers = !id.startsWith('internal/'); 9. this.exports = {}; 10. this.loaded = false; 11. this.loading = false; 12. this.module = undefined; 13. this.exportKeys = undefined; 14. } 15. } \u5f53\u6211\u4eec\u6267\u884crequire(\u2018net\u2019)\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165_load\u51fd\u6570\u3002_load\u51fd\u6570\u5224\u65ad\u8981\u52a0\u8f7d\u7684\u6a21\u5757\u662f\u539f\u751fJS\u6a21\u5757\u540e\uff0c\u4f1a\u901a\u8fc7loadNativeModule\u51fd\u6570\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u3002\u6211\u4eec\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1. function loadNativeModule(filename, request) { 2. const mod = NativeModule.map.get(filename); 3. if (mod) { 4. mod.compileForPublicLoader(); 5. return mod; 6. } 7. } \u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\u6211\u4eec\u5206\u6790\u8fc7\uff0cmod\u662f\u4e00\u4e2aNativeModule\u5bf9\u8c61\uff0c\u63a5\u7740\u770bcompileForPublicLoader\u3002 1. compileForPublicLoader() { 2. this.compileForInternalLoader(); 3. return this.exports; 4. } 5. 6. compileForInternalLoader() { 7. if (this.loaded || this.loading) { 8. return this.exports; 9. } 10. // id\u5c31\u662f\u6211\u4eec\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6bd4\u5982net 11. const id = this.id; 12. this.loading = true; 13. try { 14. const fn = compileFunction(id); 15. fn(this.exports, 16. // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 17. nativeModuleRequire, 18. this, 19. process, 20. // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 21. internalBinding, 22. primordials); 23. this.loaded = true; 24. } finally { 25. this.loading = false; 26. } 27. return this.exports; 28. } \u6211\u4eec\u91cd\u70b9\u770bcompileFunction\u8fd9\u91cc\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u662fnode_native_module_env.cc\u6a21\u5757\u5bfc\u51fa\u7684\u51fd\u6570\u3002\u5177\u4f53\u7684\u4ee3\u7801\u5c31\u4e0d\u8d34\u4e86\uff0c\u901a\u8fc7\u5c42\u5c42\u67e5\u627e\uff0c\u6700\u540e\u5230node_native_module.cc \u7684NativeModuleLoader::CompileAsModule 1. MaybeLocal<Function> NativeModuleLoader::CompileAsModule( 2. Local<Context> context, 3. const char* id, 4. NativeModuleLoader::Result* result) { 5. 6. Isolate* isolate = context->GetIsolate(); 7. // \u51fd\u6570\u7684\u5f62\u53c2 8. std::vector<Local<String>> parameters = { 9. FIXED_ONE_BYTE_STRING(isolate, \"exports\"), 10. FIXED_ONE_BYTE_STRING(isolate, \"require\"), 11. FIXED_ONE_BYTE_STRING(isolate, \"module\"), 12. FIXED_ONE_BYTE_STRING(isolate, \"process\"), 13. FIXED_ONE_BYTE_STRING(isolate, \"internalBinding\"), 14. FIXED_ONE_BYTE_STRING(isolate, \"primordials\")}; 15. // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 16. return LookupAndCompile(context, id, &parameters, result); 17. } \u6211\u4eec\u7ee7\u7eed\u770bLookupAndCompile\u3002 1. MaybeLocal<Function> NativeModuleLoader::LookupAndCompile( 2. Local<Context> context, 3. const char* id, 4. std::vector<Local<String>>* parameters, 5. NativeModuleLoader::Result* result) { 6. 7. Isolate* isolate = context->GetIsolate(); 8. EscapableHandleScope scope(isolate); 9. 10. Local<String> source; 11. // \u627e\u5230\u539f\u751fJS\u6a21\u5757\u5185\u5bb9\u6240\u5728\u7684\u5185\u5b58\u5730\u5740 12. if (!LoadBuiltinModuleSource(isolate, id).ToLocal(&source)) { 13. return {}; 14. } 15. // \u2018net\u2019 + \u2018.js\u2019 16. std::string filename_s = id + std::string(\".js\"); 17. Local<String> filename = 18. OneByteString(isolate, 19. filename_s.c_str(), 20. filename_s.size()); 21. // \u7701\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406 22. // \u811a\u672c\u6e90\u7801 23. ScriptCompiler::Source script_source(source, origin, cached_data); 24. // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 25. MaybeLocal<Function> maybe_fun = 26. ScriptCompiler::CompileFunctionInContext(context, 27. &script_source, 28. parameters->size(), 29. parameters->data(), 30. 0, 31. nullptr, 32. options); 33. Local<Function> fun = maybe_fun.ToLocalChecked(); 34. return scope.Escape(fun); 35. } LookupAndCompile\u51fd\u6570\u9996\u5148\u627e\u5230\u52a0\u8f7d\u6a21\u5757\u7684\u6e90\u7801\uff0c\u7136\u540e\u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bLoadBuiltinModuleSource\u5982\u4f55\u67e5\u627e\u6a21\u5757\u6e90\u7801\u7684\u3002 1. MaybeLocal<String> NativeModuleLoader::LoadBuiltinModuleSource(Isolate* isolate, const char* id) { 2. const auto source_it = source_.find(id); 3. return source_it->second.ToStringChecked(isolate); 4. } \u8fd9\u91cc\u662fid\u662fnet\uff0c\u901a\u8fc7\u8be5id\u4ece_source\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6570\u636e\uff0c\u90a3\u4e48_source\u662f\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3aNode.js\u4e3a\u4e86\u63d0\u9ad8\u6548\u7387\uff0c\u628a\u539f\u751fJS\u6a21\u5757\u7684\u6e90\u7801\u5b57\u7b26\u4e32\u76f4\u63a5\u8f6c\u6210ASCII\u7801\u5b58\u5230\u5185\u5b58\u91cc\u3002\u8fd9\u6837\u52a0\u8f7d\u8fd9\u4e9b\u6a21\u5757\u7684\u65f6\u5019\uff0c\u5c31\u4e0d\u9700\u8981\u786c\u76d8IO\u4e86\u3002\u76f4\u63a5\u4ece\u5185\u5b58\u8bfb\u53d6\u5c31\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0b_source\u7684\u5b9a\u4e49\uff08\u5728\u7f16\u8bd1Node.js\u6e90\u7801\u6216\u8005\u6267\u884cjs2c.py\u751f\u6210\u7684node_javascript.cc\u4e2d\uff09\u3002 1. source_.emplace(\"net\", UnionBytes{net_raw, 46682}); 2. source_.emplace(\"cyb\", UnionBytes{cyb_raw, 63}); 3. source_.emplace(\"os\", UnionBytes{os_raw, 7548}); cyb\u662f\u6211\u589e\u52a0\u7684\u6d4b\u8bd5\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u4e00\u4e0b\u8be5\u6a21\u5757\u7684\u5185\u5bb9\u3002 1. static const uint8_t cyb_raw[] = { 2. 99,111,110,115,116, 32, 99,121, 98, 32, 61, 32,105,110,116,101,114,110, 97,108, 66,105,110,100,105,110,103, 40, 39, 99, 3. 121, 98, 95,119,114, 97,112, 39, 41, 59, 32, 10,109,111,100,117,108,101, 46,101,120,112,111,114,116,115, 32, 61, 32, 99, 4. 121, 98, 59 5. }; \u6211\u4eec\u8f6c\u6210\u5b57\u7b26\u4e32\u770b\u4e00\u4e0b\u662f\u4ec0\u4e48 1. Buffer.from([99,111,110,115,116, 32, 99,121, 98, 32, 61, 32,105,110,116,101,114,110, 97,108, 66,105,110,100,105,110,103, 40, 39, 99, 2. 121, 98, 95,119,114, 97,112, 39, 41, 59, 32, 10,109,111,100,117,108,101, 46,101,120,112,111,114,116,115, 32, 61, 32, 99, 3. 121, 98, 59].join(',').split(',')).toString('utf-8') \u8f93\u51fa 1. const cyb = internalBinding('cyb_wrap'); 2. module.exports = cyb; \u6240\u4ee5\u6211\u4eec\u6267\u884crequire('net')\u65f6\uff0c\u901a\u8fc7NativeModule\u7684compileForInternalLoader\uff0c\u6700\u7ec8\u4f1a\u5728_source\u4e2d\u627e\u5230net\u6a21\u5757\u5bf9\u5e94\u7684\u6e90\u7801\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7f16\u8bd1\u6210\u4e00\u4e2a\u51fd\u6570\u3002 1. const fn = compileFunction(id); 2. fn(this.exports, 3. // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 4. nativeModuleRequire, 5. this, 6. process, 7. // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 8. internalBinding, 9. primordials); \u7531fn\u7684\u5165\u53c2\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u5728net\uff08\u6216\u5176\u5b83\u539f\u751fJS\u6a21\u5757\u4e2d\uff09\u53ea\u80fd\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u548c\u5185\u7f6e\u7684C++\u6a21\u5757\u3002\u5f53fn\u6267\u884c\u5b8c\u6bd5\u540e\uff0c\u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668\u5c31\u4f1a\u628amod.exports\u7684\u503c\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\u3002 19.3 \u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757 \u5728\u539f\u751fJS\u6a21\u5757\u4e2d\u6211\u4eec\u4e00\u822c\u4f1a\u52a0\u8f7d\u4e00\u4e9b\u5185\u7f6e\u7684C++\u6a21\u5757\uff0c\u8fd9\u662fNode.js\u62d3\u5c55JS\u529f\u80fd\u7684\u5173\u952e\u4e4b\u5904\u3002\u6bd4\u5982\u6211\u4eecrequire(\u2018net\u2019)\u7684\u65f6\u5019\uff0cnet\u6a21\u5757\u4f1a\u52a0\u8f7dtcp_wrap\u6a21\u5757\u3002 1. const { 2. TCP, 3. TCPConnectWrap, 4. constants: TCPConstants 5. } = internalBinding('tcp_wrap') C++\u6a21\u5757\u52a0\u8f7d\u5668\u4e5f\u662f\u5728internal/bootstrap/loaders.js\u4e2d\u5b9a\u4e49\u7684\uff0c\u5206\u4e3a\u4e09\u79cd\u3002 1 internalBinding\uff1a\u4e0d\u66b4\u9732\u7ed9\u7528\u6237\u7684\u8bbf\u95ee\u7684\u63a5\u53e3\uff0c\u53ea\u80fd\u5728Node.js\u4ee3\u7801\u4e2d\u8bbf\u95ee\uff0c\u6bd4\u5982\u539f\u751fJS\u6a21\u5757\uff08flag\u4e3aNM_F_INTERNAL\uff09\u3002 1. let internalBinding; 2. { 3. const bindingObj = ObjectCreate(null); 4. internalBinding = function internalBinding(module) { 5. let mod = bindingObj[module]; 6. if (typeof mod !== 'object') { 7. mod = bindingObj[module] = getInternalBinding(module); 8. moduleLoadList.push(`Internal Binding ${module}`); 9. } 10. return mod; 11. }; 12. } internalBinding\u662f\u5728getInternalBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\u3002getInternalBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9JS\u66b4\u9732\u7684\u63a5\u53e3\u540d\u3002\u5b83\u7684\u4f5c\u7528\u662f\u4eceC++\u6a21\u5757\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002 2 process.binding\uff1a\u66b4\u9732\u7ed9\u7528\u6237\u8c03\u7528C++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u4f46\u662f\u53ea\u80fd\u8bbf\u95ee\u90e8\u5206C++\u6a21\u5757\uff08flag\u4e3aNM_F_BUILTIN\u7684C++\u6a21\u5757\uff09\u3002 1. process.binding = function binding(module) { 2. module = String(module); 3. if (internalBindingWhitelist.has(module)) { 4. return internalBinding(module); 5. } 6. throw new Error(`No such module: ${module}`); 7. }; binding\u662f\u5728internalBinding\u7684\u57fa\u7840\u4e0a\u52a0\u4e86\u767d\u540d\u5355\u7684\u903b\u8f91\uff0c\u53ea\u5bf9\u5916\u66b4\u9732\u90e8\u5206\u6a21\u5757\u3002 1. const internalBindingWhitelist = new SafeSet([ 2. 'async_wrap', 3. 'buffer', 4. 'cares_wrap', 5. 'config', 6. 'constants', 7. 'contextify', 8. 'crypto', 9. 'fs', 10. 'fs_event_wrap', 11. 'http_parser', 12. 'icu', 13. 'inspector', 14. 'js_stream', 15. 'natives', 16. 'os', 17. 'pipe_wrap', 18. 'process_wrap', 19. 'signal_wrap', 20. 'spawn_sync', 21. 'stream_wrap', 22. 'tcp_wrap', 23. 'tls_wrap', 24. 'tty_wrap', 25. 'udp_wrap', 26. 'url', 27. 'util', 28. 'uv', 29. 'v8', 30. 'zlib' 31. ]); 3 process._linkedBinding: \u66b4\u9732\u7ed9\u7528\u6237\u8bbf\u95eeC++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u7528\u4e8e\u8bbf\u95ee\u7528\u6237\u81ea\u5df1\u6dfb\u52a0\u7684\u4f46\u662f\u6ca1\u6709\u52a0\u5230\u5185\u7f6e\u6a21\u5757\u7684C++\u6a21\u5757\uff08flag\u4e3aNM_F_LINKED\uff09\u3002 1. const bindingObj = ObjectCreate(null); 2. process._linkedBinding = function _linkedBinding(module) { 3. module = String(module); 4. let mod = bindingObj[module]; 5. if (typeof mod !== 'object') 6. mod = bindingObj[module] = getLinkedBinding(module); 7. return mod; 8. }; _linkedBinding\u662f\u5728getLinkedBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\uff0cgetLinkedBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9\u5916\u66b4\u9732\u7684\u540d\u5b57\u3002getLinkedBinding\u4ece\u53e6\u4e00\u4e2aC++\u6a21\u5757\u94fe\u8868\u4e2d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757\u3002 \u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cinternalBinding\u662f\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u65f6\u4f20\u5165\u7684\u5b9e\u53c2\u3002internalBinding\u662f\u5bf9getInternalBinding\u7684\u5c01\u88c5\u3002getInternalBinding\u5bf9\u5e94\u7684\u662fbinding::GetInternalBinding\uff08node_binding.cc\uff09\u3002 1. // \u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757 2. void GetInternalBinding(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. // \u6a21\u5757\u540d 5. Local<String> module = args[0].As<String>(); 6. node::Utf8Value module_v(env->isolate(), module); 7. Local<Object> exports; 8. // \u4eceC++\u5185\u90e8\u6a21\u5757\u627e 9. node_module* mod = FindModule(modlist_internal, 10. *module_v, 11. NM_F_INTERNAL); 12. // \u627e\u5230\u5219\u521d\u59cb\u5316 13. if (mod != nullptr) { 14. exports = InitModule(env, mod, module); 15. } else { 16. // \u7701\u7565 17. } 18. 19. args.GetReturnValue().Set(exports); 20. } modlist_internal\u662f\u4e00\u6761\u94fe\u8868\uff0c\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7684\u65f6\u5019\uff0c\u7531\u5404\u4e2aC++\u6a21\u5757\u8fde\u6210\u7684\u94fe\u8868\u3002\u901a\u8fc7\u6a21\u5757\u540d\u627e\u5230\u5bf9\u5e94\u7684C++\u6a21\u5757\u540e\uff0c\u6267\u884cInitModule\u521d\u59cb\u5316\u6a21\u5757\u3002 1. // \u521d\u59cb\u5316\u4e00\u4e2a\u6a21\u5757\uff0c\u5373\u6267\u884c\u5b83\u91cc\u9762\u7684\u6ce8\u518c\u51fd\u6570 2. static Local<Object> InitModule(Environment* env, 3. node_module* mod, 4. Local<String> module) { 5. Local<Object> exports = Object::New(env->isolate()); 6. Local<Value> unused = Undefined(env->isolate()); 7. mod->nm_context_register_func(exports, unused, env->context(), mod->nm_priv); 8. return exports; 9. } \u6267\u884cC++\u6a21\u5757\u7684nm_context_register_func\u6307\u5411\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u51fd\u6570\u5c31\u662f\u5728C++\u6a21\u5757\u6700\u540e\u4e00\u884c\u5b9a\u4e49\u7684Initialize\u51fd\u6570\u3002Initialize\u4f1a\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u6211\u4eec\u4eceJS\u53ef\u4ee5\u8bbf\u95eeInitialize\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002V8\u4e2d\uff0cJS\u8c03\u7528C++\u51fd\u6570\u7684\u89c4\u5219\u662f\u51fd\u6570\u5165\u53c2const FunctionCallbackInfo & args\uff08\u62ff\u5230JS\u4f20\u8fc7\u6765\u7684\u5185\u5bb9\uff09\u548c\u8bbe\u7f6e\u8fd4\u56de\u503cargs.GetReturnValue().Set(\u7ed9JS\u8fd4\u56de\u7684\u5185\u5bb9), GetInternalBinding\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5bf9\u5e94\u6a21\u5757\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u5e76\u4f20\u4e00\u4e2aexports\u53d8\u91cf\u8fdb\u53bb\uff0c\u7136\u540e\u94a9\u5b50\u51fd\u6570\u4f1a\u4fee\u6539exports\u7684\u503c\uff0c\u8be5exports\u7684\u503c\u5c31\u662fJS\u5c42\u80fd\u62ff\u5230\u7684\u503c\u3002","title":"19-\u6a21\u5757\u52a0\u8f7d"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#191","text":"\u5728Node.js\u4e2d_extensions\u6709\u4e09\u79cd\uff0c\u5206\u522b\u662fjs\u3001json\u3001node\u3002","title":"19.1 \u52a0\u8f7d\u7528\u6237\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#1911-json","text":"\u52a0\u8f7dJSON\u6a21\u5757\u662f\u6bd4\u8f83\u7b80\u5355\u7684 1. Module._extensions['.json'] = function(module, filename) { 2. const content = fs.readFileSync(filename, 'utf8'); 3. 4. try { 5. module.exports = JSONParse(stripBOM(content)); 6. } catch (err) { 7. err.message = filename + ': ' + err.message; 8. throw err; 9. } 10. }; \u76f4\u63a5\u8bfb\u53d6JSON\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u89e3\u6790\u6210\u5bf9\u8c61\u5c31\u884c\u3002","title":"19.1.1 \u52a0\u8f7dJSON\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#1912-js","text":"1. Module._extensions['.js'] = function(module, filename) { 2. const content = fs.readFileSync(filename, 'utf8'); 3. module._compile(content, filename); 4. }; \u8bfb\u5b8c\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u6267\u884c_compile 1. Module.prototype._compile = function(content, filename) { 2. // \u751f\u6210\u4e00\u4e2a\u51fd\u6570 3. const compiledWrapper = wrapSafe(filename, content, this); 4. const dirname = path.dirname(filename); 5. // require\u662f\u5bf9_load\u51fd\u6570\u7684\u5c01\u88c5 6. const require = (path) => { 7. return this.require(path); 8. }; 9. let result; 10. // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684exports\u53d8\u91cf 11. const exports = this.exports; 12. const thisValue = exports; 13. // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684module\u53d8\u91cf 14. const module = this; 15. // \u6267\u884c\u51fd\u6570 16. result = compiledWrapper.call(thisValue, 17. exports, 18. require, 19. module, 20. filename, 21. dirname); 22. return result; 23. } _compile\u91cc\u9762\u5305\u62ec\u4e86\u51e0\u4e2a\u91cd\u8981\u7684\u903b\u8f91 1 wrapSafe\uff1a\u5305\u88f9\u6211\u4eec\u7684\u4ee3\u7801\u5e76\u751f\u6210\u4e00\u4e2a\u51fd\u6570 2 require\uff1a\u652f\u6301\u5728\u6a21\u5757\u5185\u52a0\u8f7d\u5176\u4ed6\u6a21\u5757 3 \u6267\u884c\u6a21\u5757\u4ee3\u7801 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e09\u4e2a\u903b\u8f91\u3002 1 wrapSafe 1. function wrapSafe(filename, content, cjsModuleInstance) { 2. const wrapper = Module.wrap(content); 3. return vm.runInThisContext(wrapper, { 4. filename, 5. lineOffset: 0, 6. ... 7. }); 8. } 9. 10. const wrapper = [ 11. '(function (exports, require, module, __filename, __dirname) { ', 12. '\\n});' 13. ]; 14. 15. Module.wrap = function(script) { 16. return Module.wrapper[0] + script + Module.wrapper[1]; 17. }; vm.runInThisContext\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u201d(function() {})\u201d\u7684\u65f6\u5019\uff0c\u4f1a\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u3002\u6240\u4ee5\u6267\u884cModule.wrap\u540e\u4f1a\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5185\u5bb9\u5982\u4e0b 2. (function (exports, require, module, __filename, __dirname) { 3. // 4. }); \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0brequire\u51fd\u6570\uff0c\u5373\u6211\u4eec\u5e73\u65f6\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u7684require\u3002 2 require 1. Module.prototype.require = function(id) { 2. requireDepth++; 3. try { 4. return Module._load(id, this, /* isMain */ false); 5. } finally { 6. requireDepth--; 7. } 8. }; require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0cModule._load\u4f1a\u628a\u6a21\u5757\u5bfc\u51fa\u7684\u53d8\u91cf\u901a\u8fc7module.exports\u5c5e\u6027\u8fd4\u56de\u7ed9require\u8c03\u7528\u65b9\u3002\u56e0\u4e3aModule._load\u53ea\u4f1a\u4ece\u539f\u751fJS\u6a21\u5757\u548c\u7528\u6237JS\u6a21\u5757\u4e2d\u67e5\u627e\u7528\u6237\u9700\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6240\u4ee5\u662f\u65e0\u6cd5\u8bbf\u95eeC++\u6a21\u5757\u7684\uff0c\u8bbf\u95eeC++\u6a21\u5757\u53ef\u7528process.bindng\u6216internalBinding\u3002 3 \u6267\u884c\u4ee3\u7801 \u6211\u4eec\u56de\u5230_compile\u51fd\u6570\u3002\u770b\u4e00\u4e0b\u6267\u884cvm.runInThisContext\u8fd4\u56de\u7684\u51fd\u6570\u3002 compiledWrapper.call(exports, exports, require, module, filename, dirname); \u76f8\u5f53\u4e8e\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801 1. (function (exports, require, module, __filename, __dirname) { 2. const myjs= require(\u2018myjs); 3. const net = require(\u2018net\u2019); 4. }); \u81f3\u6b64\uff0cNode.js\u5f00\u59cb\u6267\u884c\u7528\u6237\u7684JS\u4ee3\u7801\u3002\u521a\u624d\u6211\u4eec\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0c\u5f53\u6267\u884crequire\u52a0\u8f7d\u7528\u6237\u6a21\u5757\u65f6\uff0c\u53c8\u56de\u5230\u4e86\u6211\u4eec\u6b63\u5728\u5206\u6790\u7684\u8fd9\u4e2a\u8fc7\u7a0b\u3002","title":"19.1.2 \u52a0\u8f7dJS\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#1913-node","text":"Node\u62d3\u5c55\u7684\u6a21\u5757\u672c\u8d28\u4e0a\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u6211\u4eec\u770brequire\u4e00\u4e2a.node\u6a21\u5757\u7684\u65f6\u5019\u7684\u8fc7\u7a0b\u3002\u6211\u4eec\u4ece\u52a0\u8f7d.node\u6a21\u5757\u7684\u6e90\u7801\u5f00\u59cb\u3002 1. Module._extensions['.node'] = function(module, filename) { 2. // ... 3. return process.dlopen(module, path.toNamespacedPath(filename)); 4. }; \u76f4\u63a5\u8c03\u4e86process.dlopen\uff0c\u8be5\u51fd\u6570\u5728node.js\u91cc\u5b9a\u4e49\u3002 1. const rawMethods = internalBinding('process_methods'); 2. process.dlopen = rawMethods.dlopen; \u627e\u5230process_methods\u6a21\u5757\u5bf9\u5e94\u7684\u662fnode_process_methods.cc\u3002 env->SetMethod(target, \"dlopen\", binding::DLOpen); \u4e4b\u524d\u8bf4\u8fc7\uff0cNode.js\u7684\u62d3\u5c55\u6a21\u5757\u5176\u5b9e\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u90a3\u4e48\u6211\u4eec\u5148\u770b\u770b\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u6211\u4eec\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u4ee5\u4e0b\u662f\u793a\u4f8b\u4ee3\u7801\u3002 1. #include <stdio.h> 2. #include <stdlib.h> 3. #include <dlfcn.h> 4. int main(){ 5. // \u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u62ff\u5230\u4e00\u4e2ahandler 6. handler = dlopen('xxx.so',RTLD_LAZY); 7. // \u53d6\u51fa\u52a8\u6001\u94fe\u63a5\u5e93\u91cc\u7684\u51fd\u6570add 8. add = dlsym(handler,\"add\"); 9. // \u6267\u884c 10. printf(\"%d\",add(1,1)); 11. dlclose(handler); 12. return 0; 13. } \u4e86\u89e3\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4f7f\u7528\uff0c\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u521a\u624d\u770b\u5230\u7684DLOpen\u51fd\u6570\u3002 1. void DLOpen(const FunctionCallbackInfo<Value>& args) { 2. 3. int32_t flags = DLib::kDefaultFlags; 4. node::Utf8Value filename(env->isolate(), args[1]); // Cast 5. env->TryLoadAddon(*filename, flags, [&](DLib* dlib) { 6. const bool is_opened = dlib->Open(); 7. node_module* mp = thread_local_modpending; 8. thread_local_modpending = nullptr; 9. // \u7701\u7565\u90e8\u5206\u4ee3\u7801 10. if (mp->nm_context_register_func != nullptr) { 11. mp->nm_context_register_func(exports, 12. module, 13. context, 14. mp->nm_priv); 15. } else if (mp->nm_register_func != nullptr) { 16. mp->nm_register_func(exports, module, mp->nm_priv); 17. } 18. return true; 19. }); 20. } \u6211\u4eec\u770b\u5230\u91cd\u70b9\u662fTryLoadAddon\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5b83\u7684\u7b2c\u4e09\u4e2a\u53c2\u6570\u3002\u6211\u4eec\u53d1\u73b0\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5165\u53c2\u662fDLib\u5bf9\u8c61\u3002\u6240\u4ee5\u6211\u4eec\u5148\u770b\u770b\u8fd9\u4e2a\u7c7b\u3002 1. class DLib { 2. public: 3. static const int kDefaultFlags = RTLD_LAZY; 4. DLib(const char* filename, int flags); 5. 6. bool Open(); 7. void Close(); 8. const std::string filename_; 9. const int flags_; 10. std::string errmsg_; 11. void* handle_; 12. uv_lib_t lib_; 13. }; \u518d\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1. bool DLib::Open() { 2. handle_ = dlopen(filename_.c_str(), flags_); 3. if (handle_ != nullptr) return true; 4. errmsg_ = dlerror(); 5. return false; 6. } DLib\u5c31\u662f\u5bf9\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u5b83\u5c01\u88c5\u4e86\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u6587\u4ef6\u540d\u548c\u64cd\u4f5c\u3002TryLoadAddon\u51fd\u6570\u9996\u5148\u6839\u636erequire\u4f20\u5165\u7684\u6587\u4ef6\u540d\uff0c\u6784\u9020\u4e00\u4e2aDLib\uff0c\u7136\u540e\u6267\u884c const bool is_opened = dlib->Open(); Open\u51fd\u6570\u6253\u5f00\u4e86\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0b\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7a76\u7adf\u53d1\u751f\u4e86\u4ec0\u4e48\u3002\u9996\u5148\u6211\u4eec\u4e00\u822cC++\u63d2\u4ef6\u6700\u540e\u4e00\u53e5\u4ee3\u7801\u7684\u5b9a\u4e49\u3002 NAPI_MODULE(NODE_GYP_MODULE_NAME, init) \u8fd9\u662f\u4e2a\u5b8f\u5b9a\u4e49\u3002 1. #define NAPI_MODULE(modname, regfunc) \\ 2. NAPI_MODULE_X(modname, regfunc, NULL, 0) 3. #define NAPI_MODULE_X(modname, regfunc, priv, flags) \\ 4. static napi_module _module = \\ 5. { \\ 6. NAPI_MODULE_VERSION, \\ 7. flags, \\ 8. __FILE__, \\ 9. regfunc, \\ 10. #modname, \\ 11. priv, \\ 12. {0}, \\ 13. }; \\ 14. static void _register_modname(void) __attribute__((constructor)); \\ 15. static void _register_modname(void) { \\ 16. napi_module_register(&_module); \\ 17. } \u6240\u4ee5\u4e00\u4e2anode\u6269\u5c55\u5c31\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2anapi_module\u6a21\u5757\u548c\u4e00\u4e2aregister_modname\uff08modname\u662f\u6211\u4eec\u5b9a\u4e49\u7684\uff09\u51fd\u6570\u3002__attribute((constructor))\u662f\u4ee3\u8868\u8be5\u51fd\u6570\u4f1a\u5148\u6267\u884c\u7684\u610f\u601d\uff0c\u5177\u4f53\u53ef\u4ee5\u67e5\u9605\u6587\u6863\u3002\u770b\u5230\u8fd9\u91cc\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u6211\u4eec\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c_register_modname\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u6267\u884c\u7684\u662f napi_module_register(&_module); \u6211\u4eec\u7ee7\u7eed\u5c55\u5f00\u3002 1. 2. // Registers a NAPI module. 3. void napi_module_register(napi_module* mod) { 4. node::node_module* nm = new node::node_module { 5. -1, 6. mod->nm_flags | NM_F_DELETEME, 7. nullptr, 8. mod->nm_filename, 9. nullptr, 10. napi_module_register_cb, 11. mod->nm_modname, 12. mod, // priv 13. nullptr, 14. }; 15. node::node_module_register(nm); 16. } Node.js\u628anapi\u6a21\u5757\u8f6c\u6210node_module\u3002\u6700\u540e\u8c03\u7528node_module_register\u3002 1. 2. extern \"C\" void node_module_register(void* m) { 3. struct node_module* mp = reinterpret_cast<struct node_module*>(m); 4. 5. if (mp->nm_flags & NM_F_INTERNAL) { 6. mp->nm_link = modlist_internal; 7. modlist_internal = mp; 8. } else if (!node_is_initialized) { 9. mp->nm_flags = NM_F_LINKED; 10. mp->nm_link = modlist_linked; 11. modlist_linked = mp; 12. } else { 13. thread_local_modpending = mp; 14. } 15. } napi\u6a21\u5757\u4e0d\u662fNM_F_INTERNAL\u6a21\u5757\uff0cnode_is_initialized\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u53d8\u91cf\uff0c\u8fd9\u65f6\u5019\u5df2\u7ecf\u662ftrue\u3002\u6240\u4ee5\u6ce8\u518cnapi\u6a21\u5757\u65f6\uff0c\u4f1a\u6267\u884cthread_local_modpending = mp\u3002thread_local_modpending \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u4fdd\u5b58\u5f53\u524d\u52a0\u8f7d\u7684\u6a21\u5757\u3002\u5206\u6790\u5230\u8fd9\uff0c\u6211\u4eec\u56de\u5230DLOpen\u51fd\u6570\u3002 1. node_module* mp = thread_local_modpending; 2. thread_local_modpending = nullptr; \u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u77e5\u9053\u521a\u624d\u90a3\u4e2a\u53d8\u91cfthread_local_modpending\u7684\u4f5c\u7528\u4e86\u3002node_module* mp = thread_local_modpending\u540e\u6211\u4eec\u62ff\u5230\u4e86\u6211\u4eec\u521a\u624d\u5b9a\u4e49\u7684napi\u6a21\u5757\u7684\u4fe1\u606f\u3002\u63a5\u7740\u6267\u884cnode_module\u7684\u51fd\u6570nm_register_func\u3002 1. if (mp->nm_context_register_func != nullptr) { 2. mp->nm_context_register_func(exports, 3. module, 4. context, 5. mp->nm_priv); 6. } else if (mp->nm_register_func != nullptr) { 7. mp->nm_register_func(exports, module, mp->nm_priv); 8. } \u4ece\u521a\u624d\u7684node_module\u5b9a\u4e49\u4e2d\u6211\u4eec\u770b\u5230\u51fd\u6570\u662fnapi_module_register_cb\u3002 1. static void napi_module_register_cb(v8::Local<v8::Object> exports, 2. v8::Local<v8::Value> module, 3. v8::Local<v8::Context> context, 4. void* priv) { 5. napi_module_register_by_symbol(exports, module, context, 6. static_cast<napi_module*>(priv)->nm_register_func); 7. } \u8be5\u51fd\u6570\u8c03\u7528napi_module_register_by_symbol\u51fd\u6570\uff0c\u5e76\u4f20\u5165napi_module\u7684nm_register_func\u51fd\u6570\u3002 1. void napi_module_register_by_symbol(v8::Local<v8::Object> exports, 2. v8::Local<v8::Value> module, 3. v8::Local<v8::Context> context, 4. napi_addon_register_func init) { 5. 6. // Create a new napi_env for this specific module. 7. napi_env env = v8impl::NewEnv(context); 8. 9. napi_value _exports; 10. env->CallIntoModuleThrow([&](napi_env env) { 11. _exports = init(env, v8impl::JsValueFromV8LocalValue(exports)); 12. }); 13. 14. if (_exports != nullptr && 15. _exports != v8impl::JsValueFromV8LocalValue(exports)) { 16. napi_value _module = v8impl::JsValueFromV8LocalValue(module); 17. napi_set_named_property(env, _module, \"exports\", _exports); 18. } 19. } init\u5c31\u662f\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u3002\u5165\u53c2\u662fenv\u548cexports\uff0c\u53ef\u4ee5\u5bf9\u6bd4\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u7684\u5165\u53c2\u3002\u6700\u540e\u6211\u4eec\u4fee\u6539exports\u53d8\u91cf\u3002\u5373\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5185\u5bb9\u3002\u6700\u540e\u5728JS\u91cc\uff0c\u6211\u4eec\u5c31\u62ff\u5230\u4e86C++\u5c42\u5b9a\u4e49\u7684\u5185\u5bb9\u3002","title":"19.1.3 \u52a0\u8f7dnode\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#192-js","text":"\u4e0a\u4e00\u8282\u6211\u4eec\u4e86\u89e3\u4e86Node.js\u6267\u884cnode demo.js\u7684\u8fc7\u7a0b\uff0c\u5176\u4e2d\u6211\u4eec\u5728demo.js\u4e2d\u4f7f\u7528require\u52a0\u8f7dnet\u6a21\u5757\u3002net\u662f\u539f\u751fJS\u6a21\u5757\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u8fdb\u5165\u539f\u751f\u6a21\u5757\u7684\u5904\u7406\u903b\u8f91\u3002 \u539f\u751f\u6a21\u5757\u662fNode.js\u5185\u90e8\u5b9e\u73b0\u7684JS\u6a21\u5757\u3002\u4f7f\u7528NativeModule\u6765\u8868\u793a\u3002 1. class NativeModule { 2. // \u539f\u751fJS\u6a21\u5757\u7684map 3. static map = new Map(moduleIds.map((id) => [id, new NativeModule(id)])); 4. 5. constructor(id) { 6. this.filename = `${id}.js`; 7. this.id = id; 8. this.canBeRequiredByUsers = !id.startsWith('internal/'); 9. this.exports = {}; 10. this.loaded = false; 11. this.loading = false; 12. this.module = undefined; 13. this.exportKeys = undefined; 14. } 15. } \u5f53\u6211\u4eec\u6267\u884crequire(\u2018net\u2019)\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165_load\u51fd\u6570\u3002_load\u51fd\u6570\u5224\u65ad\u8981\u52a0\u8f7d\u7684\u6a21\u5757\u662f\u539f\u751fJS\u6a21\u5757\u540e\uff0c\u4f1a\u901a\u8fc7loadNativeModule\u51fd\u6570\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u3002\u6211\u4eec\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1. function loadNativeModule(filename, request) { 2. const mod = NativeModule.map.get(filename); 3. if (mod) { 4. mod.compileForPublicLoader(); 5. return mod; 6. } 7. } \u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\u6211\u4eec\u5206\u6790\u8fc7\uff0cmod\u662f\u4e00\u4e2aNativeModule\u5bf9\u8c61\uff0c\u63a5\u7740\u770bcompileForPublicLoader\u3002 1. compileForPublicLoader() { 2. this.compileForInternalLoader(); 3. return this.exports; 4. } 5. 6. compileForInternalLoader() { 7. if (this.loaded || this.loading) { 8. return this.exports; 9. } 10. // id\u5c31\u662f\u6211\u4eec\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6bd4\u5982net 11. const id = this.id; 12. this.loading = true; 13. try { 14. const fn = compileFunction(id); 15. fn(this.exports, 16. // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 17. nativeModuleRequire, 18. this, 19. process, 20. // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 21. internalBinding, 22. primordials); 23. this.loaded = true; 24. } finally { 25. this.loading = false; 26. } 27. return this.exports; 28. } \u6211\u4eec\u91cd\u70b9\u770bcompileFunction\u8fd9\u91cc\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u662fnode_native_module_env.cc\u6a21\u5757\u5bfc\u51fa\u7684\u51fd\u6570\u3002\u5177\u4f53\u7684\u4ee3\u7801\u5c31\u4e0d\u8d34\u4e86\uff0c\u901a\u8fc7\u5c42\u5c42\u67e5\u627e\uff0c\u6700\u540e\u5230node_native_module.cc \u7684NativeModuleLoader::CompileAsModule 1. MaybeLocal<Function> NativeModuleLoader::CompileAsModule( 2. Local<Context> context, 3. const char* id, 4. NativeModuleLoader::Result* result) { 5. 6. Isolate* isolate = context->GetIsolate(); 7. // \u51fd\u6570\u7684\u5f62\u53c2 8. std::vector<Local<String>> parameters = { 9. FIXED_ONE_BYTE_STRING(isolate, \"exports\"), 10. FIXED_ONE_BYTE_STRING(isolate, \"require\"), 11. FIXED_ONE_BYTE_STRING(isolate, \"module\"), 12. FIXED_ONE_BYTE_STRING(isolate, \"process\"), 13. FIXED_ONE_BYTE_STRING(isolate, \"internalBinding\"), 14. FIXED_ONE_BYTE_STRING(isolate, \"primordials\")}; 15. // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 16. return LookupAndCompile(context, id, &parameters, result); 17. } \u6211\u4eec\u7ee7\u7eed\u770bLookupAndCompile\u3002 1. MaybeLocal<Function> NativeModuleLoader::LookupAndCompile( 2. Local<Context> context, 3. const char* id, 4. std::vector<Local<String>>* parameters, 5. NativeModuleLoader::Result* result) { 6. 7. Isolate* isolate = context->GetIsolate(); 8. EscapableHandleScope scope(isolate); 9. 10. Local<String> source; 11. // \u627e\u5230\u539f\u751fJS\u6a21\u5757\u5185\u5bb9\u6240\u5728\u7684\u5185\u5b58\u5730\u5740 12. if (!LoadBuiltinModuleSource(isolate, id).ToLocal(&source)) { 13. return {}; 14. } 15. // \u2018net\u2019 + \u2018.js\u2019 16. std::string filename_s = id + std::string(\".js\"); 17. Local<String> filename = 18. OneByteString(isolate, 19. filename_s.c_str(), 20. filename_s.size()); 21. // \u7701\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406 22. // \u811a\u672c\u6e90\u7801 23. ScriptCompiler::Source script_source(source, origin, cached_data); 24. // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 25. MaybeLocal<Function> maybe_fun = 26. ScriptCompiler::CompileFunctionInContext(context, 27. &script_source, 28. parameters->size(), 29. parameters->data(), 30. 0, 31. nullptr, 32. options); 33. Local<Function> fun = maybe_fun.ToLocalChecked(); 34. return scope.Escape(fun); 35. } LookupAndCompile\u51fd\u6570\u9996\u5148\u627e\u5230\u52a0\u8f7d\u6a21\u5757\u7684\u6e90\u7801\uff0c\u7136\u540e\u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bLoadBuiltinModuleSource\u5982\u4f55\u67e5\u627e\u6a21\u5757\u6e90\u7801\u7684\u3002 1. MaybeLocal<String> NativeModuleLoader::LoadBuiltinModuleSource(Isolate* isolate, const char* id) { 2. const auto source_it = source_.find(id); 3. return source_it->second.ToStringChecked(isolate); 4. } \u8fd9\u91cc\u662fid\u662fnet\uff0c\u901a\u8fc7\u8be5id\u4ece_source\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6570\u636e\uff0c\u90a3\u4e48_source\u662f\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3aNode.js\u4e3a\u4e86\u63d0\u9ad8\u6548\u7387\uff0c\u628a\u539f\u751fJS\u6a21\u5757\u7684\u6e90\u7801\u5b57\u7b26\u4e32\u76f4\u63a5\u8f6c\u6210ASCII\u7801\u5b58\u5230\u5185\u5b58\u91cc\u3002\u8fd9\u6837\u52a0\u8f7d\u8fd9\u4e9b\u6a21\u5757\u7684\u65f6\u5019\uff0c\u5c31\u4e0d\u9700\u8981\u786c\u76d8IO\u4e86\u3002\u76f4\u63a5\u4ece\u5185\u5b58\u8bfb\u53d6\u5c31\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0b_source\u7684\u5b9a\u4e49\uff08\u5728\u7f16\u8bd1Node.js\u6e90\u7801\u6216\u8005\u6267\u884cjs2c.py\u751f\u6210\u7684node_javascript.cc\u4e2d\uff09\u3002 1. source_.emplace(\"net\", UnionBytes{net_raw, 46682}); 2. source_.emplace(\"cyb\", UnionBytes{cyb_raw, 63}); 3. source_.emplace(\"os\", UnionBytes{os_raw, 7548}); cyb\u662f\u6211\u589e\u52a0\u7684\u6d4b\u8bd5\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u4e00\u4e0b\u8be5\u6a21\u5757\u7684\u5185\u5bb9\u3002 1. static const uint8_t cyb_raw[] = { 2. 99,111,110,115,116, 32, 99,121, 98, 32, 61, 32,105,110,116,101,114,110, 97,108, 66,105,110,100,105,110,103, 40, 39, 99, 3. 121, 98, 95,119,114, 97,112, 39, 41, 59, 32, 10,109,111,100,117,108,101, 46,101,120,112,111,114,116,115, 32, 61, 32, 99, 4. 121, 98, 59 5. }; \u6211\u4eec\u8f6c\u6210\u5b57\u7b26\u4e32\u770b\u4e00\u4e0b\u662f\u4ec0\u4e48 1. Buffer.from([99,111,110,115,116, 32, 99,121, 98, 32, 61, 32,105,110,116,101,114,110, 97,108, 66,105,110,100,105,110,103, 40, 39, 99, 2. 121, 98, 95,119,114, 97,112, 39, 41, 59, 32, 10,109,111,100,117,108,101, 46,101,120,112,111,114,116,115, 32, 61, 32, 99, 3. 121, 98, 59].join(',').split(',')).toString('utf-8') \u8f93\u51fa 1. const cyb = internalBinding('cyb_wrap'); 2. module.exports = cyb; \u6240\u4ee5\u6211\u4eec\u6267\u884crequire('net')\u65f6\uff0c\u901a\u8fc7NativeModule\u7684compileForInternalLoader\uff0c\u6700\u7ec8\u4f1a\u5728_source\u4e2d\u627e\u5230net\u6a21\u5757\u5bf9\u5e94\u7684\u6e90\u7801\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7f16\u8bd1\u6210\u4e00\u4e2a\u51fd\u6570\u3002 1. const fn = compileFunction(id); 2. fn(this.exports, 3. // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 4. nativeModuleRequire, 5. this, 6. process, 7. // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 8. internalBinding, 9. primordials); \u7531fn\u7684\u5165\u53c2\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u5728net\uff08\u6216\u5176\u5b83\u539f\u751fJS\u6a21\u5757\u4e2d\uff09\u53ea\u80fd\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u548c\u5185\u7f6e\u7684C++\u6a21\u5757\u3002\u5f53fn\u6267\u884c\u5b8c\u6bd5\u540e\uff0c\u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668\u5c31\u4f1a\u628amod.exports\u7684\u503c\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\u3002 19.3 \u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757 \u5728\u539f\u751fJS\u6a21\u5757\u4e2d\u6211\u4eec\u4e00\u822c\u4f1a\u52a0\u8f7d\u4e00\u4e9b\u5185\u7f6e\u7684C++\u6a21\u5757\uff0c\u8fd9\u662fNode.js\u62d3\u5c55JS\u529f\u80fd\u7684\u5173\u952e\u4e4b\u5904\u3002\u6bd4\u5982\u6211\u4eecrequire(\u2018net\u2019)\u7684\u65f6\u5019\uff0cnet\u6a21\u5757\u4f1a\u52a0\u8f7dtcp_wrap\u6a21\u5757\u3002 1. const { 2. TCP, 3. TCPConnectWrap, 4. constants: TCPConstants 5. } = internalBinding('tcp_wrap') C++\u6a21\u5757\u52a0\u8f7d\u5668\u4e5f\u662f\u5728internal/bootstrap/loaders.js\u4e2d\u5b9a\u4e49\u7684\uff0c\u5206\u4e3a\u4e09\u79cd\u3002 1 internalBinding\uff1a\u4e0d\u66b4\u9732\u7ed9\u7528\u6237\u7684\u8bbf\u95ee\u7684\u63a5\u53e3\uff0c\u53ea\u80fd\u5728Node.js\u4ee3\u7801\u4e2d\u8bbf\u95ee\uff0c\u6bd4\u5982\u539f\u751fJS\u6a21\u5757\uff08flag\u4e3aNM_F_INTERNAL\uff09\u3002 1. let internalBinding; 2. { 3. const bindingObj = ObjectCreate(null); 4. internalBinding = function internalBinding(module) { 5. let mod = bindingObj[module]; 6. if (typeof mod !== 'object') { 7. mod = bindingObj[module] = getInternalBinding(module); 8. moduleLoadList.push(`Internal Binding ${module}`); 9. } 10. return mod; 11. }; 12. } internalBinding\u662f\u5728getInternalBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\u3002getInternalBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9JS\u66b4\u9732\u7684\u63a5\u53e3\u540d\u3002\u5b83\u7684\u4f5c\u7528\u662f\u4eceC++\u6a21\u5757\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002 2 process.binding\uff1a\u66b4\u9732\u7ed9\u7528\u6237\u8c03\u7528C++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u4f46\u662f\u53ea\u80fd\u8bbf\u95ee\u90e8\u5206C++\u6a21\u5757\uff08flag\u4e3aNM_F_BUILTIN\u7684C++\u6a21\u5757\uff09\u3002 1. process.binding = function binding(module) { 2. module = String(module); 3. if (internalBindingWhitelist.has(module)) { 4. return internalBinding(module); 5. } 6. throw new Error(`No such module: ${module}`); 7. }; binding\u662f\u5728internalBinding\u7684\u57fa\u7840\u4e0a\u52a0\u4e86\u767d\u540d\u5355\u7684\u903b\u8f91\uff0c\u53ea\u5bf9\u5916\u66b4\u9732\u90e8\u5206\u6a21\u5757\u3002 1. const internalBindingWhitelist = new SafeSet([ 2. 'async_wrap', 3. 'buffer', 4. 'cares_wrap', 5. 'config', 6. 'constants', 7. 'contextify', 8. 'crypto', 9. 'fs', 10. 'fs_event_wrap', 11. 'http_parser', 12. 'icu', 13. 'inspector', 14. 'js_stream', 15. 'natives', 16. 'os', 17. 'pipe_wrap', 18. 'process_wrap', 19. 'signal_wrap', 20. 'spawn_sync', 21. 'stream_wrap', 22. 'tcp_wrap', 23. 'tls_wrap', 24. 'tty_wrap', 25. 'udp_wrap', 26. 'url', 27. 'util', 28. 'uv', 29. 'v8', 30. 'zlib' 31. ]); 3 process._linkedBinding: \u66b4\u9732\u7ed9\u7528\u6237\u8bbf\u95eeC++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u7528\u4e8e\u8bbf\u95ee\u7528\u6237\u81ea\u5df1\u6dfb\u52a0\u7684\u4f46\u662f\u6ca1\u6709\u52a0\u5230\u5185\u7f6e\u6a21\u5757\u7684C++\u6a21\u5757\uff08flag\u4e3aNM_F_LINKED\uff09\u3002 1. const bindingObj = ObjectCreate(null); 2. process._linkedBinding = function _linkedBinding(module) { 3. module = String(module); 4. let mod = bindingObj[module]; 5. if (typeof mod !== 'object') 6. mod = bindingObj[module] = getLinkedBinding(module); 7. return mod; 8. }; _linkedBinding\u662f\u5728getLinkedBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\uff0cgetLinkedBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9\u5916\u66b4\u9732\u7684\u540d\u5b57\u3002getLinkedBinding\u4ece\u53e6\u4e00\u4e2aC++\u6a21\u5757\u94fe\u8868\u4e2d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757\u3002 \u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cinternalBinding\u662f\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u65f6\u4f20\u5165\u7684\u5b9e\u53c2\u3002internalBinding\u662f\u5bf9getInternalBinding\u7684\u5c01\u88c5\u3002getInternalBinding\u5bf9\u5e94\u7684\u662fbinding::GetInternalBinding\uff08node_binding.cc\uff09\u3002 1. // \u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757 2. void GetInternalBinding(const FunctionCallbackInfo<Value>& args) { 3. Environment* env = Environment::GetCurrent(args); 4. // \u6a21\u5757\u540d 5. Local<String> module = args[0].As<String>(); 6. node::Utf8Value module_v(env->isolate(), module); 7. Local<Object> exports; 8. // \u4eceC++\u5185\u90e8\u6a21\u5757\u627e 9. node_module* mod = FindModule(modlist_internal, 10. *module_v, 11. NM_F_INTERNAL); 12. // \u627e\u5230\u5219\u521d\u59cb\u5316 13. if (mod != nullptr) { 14. exports = InitModule(env, mod, module); 15. } else { 16. // \u7701\u7565 17. } 18. 19. args.GetReturnValue().Set(exports); 20. } modlist_internal\u662f\u4e00\u6761\u94fe\u8868\uff0c\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7684\u65f6\u5019\uff0c\u7531\u5404\u4e2aC++\u6a21\u5757\u8fde\u6210\u7684\u94fe\u8868\u3002\u901a\u8fc7\u6a21\u5757\u540d\u627e\u5230\u5bf9\u5e94\u7684C++\u6a21\u5757\u540e\uff0c\u6267\u884cInitModule\u521d\u59cb\u5316\u6a21\u5757\u3002 1. // \u521d\u59cb\u5316\u4e00\u4e2a\u6a21\u5757\uff0c\u5373\u6267\u884c\u5b83\u91cc\u9762\u7684\u6ce8\u518c\u51fd\u6570 2. static Local<Object> InitModule(Environment* env, 3. node_module* mod, 4. Local<String> module) { 5. Local<Object> exports = Object::New(env->isolate()); 6. Local<Value> unused = Undefined(env->isolate()); 7. mod->nm_context_register_func(exports, unused, env->context(), mod->nm_priv); 8. return exports; 9. } \u6267\u884cC++\u6a21\u5757\u7684nm_context_register_func\u6307\u5411\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u51fd\u6570\u5c31\u662f\u5728C++\u6a21\u5757\u6700\u540e\u4e00\u884c\u5b9a\u4e49\u7684Initialize\u51fd\u6570\u3002Initialize\u4f1a\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u6211\u4eec\u4eceJS\u53ef\u4ee5\u8bbf\u95eeInitialize\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002V8\u4e2d\uff0cJS\u8c03\u7528C++\u51fd\u6570\u7684\u89c4\u5219\u662f\u51fd\u6570\u5165\u53c2const FunctionCallbackInfo & args\uff08\u62ff\u5230JS\u4f20\u8fc7\u6765\u7684\u5185\u5bb9\uff09\u548c\u8bbe\u7f6e\u8fd4\u56de\u503cargs.GetReturnValue().Set(\u7ed9JS\u8fd4\u56de\u7684\u5185\u5bb9), GetInternalBinding\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5bf9\u5e94\u6a21\u5757\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u5e76\u4f20\u4e00\u4e2aexports\u53d8\u91cf\u8fdb\u53bb\uff0c\u7136\u540e\u94a9\u5b50\u51fd\u6570\u4f1a\u4fee\u6539exports\u7684\u503c\uff0c\u8be5exports\u7684\u503c\u5c31\u662fJS\u5c42\u80fd\u62ff\u5230\u7684\u503c\u3002","title":"19.2 \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/","text":"\u62d3\u5c55Node.js\u4ece\u5b8f\u89c2\u6765\u8bf4\uff0c\u6709\u51e0\u79cd\u65b9\u5f0f\uff0c\u5305\u62ec\u76f4\u63a5\u4fee\u6539Node.js\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u5206\u53d1\u3001\u63d0\u4f9bnpm\u5305\u3002npm\u5305\u53c8\u53ef\u4ee5\u5206\u4e3aJS\u548cC++\u62d3\u5c55\u3002\u672c\u7ae0\u4e3b\u8981\u662f\u4ecb\u7ecd\u4fee\u6539Node.js\u5185\u6838\u548c\u5199C++\u63d2\u4ef6\u3002 20.1 \u4fee\u6539Node.js\u5185\u6838 \u00b6 \u4fee\u6539Node.js\u5185\u6838\u7684\u65b9\u5f0f\u4e5f\u6709\u5f88\u591a\u79cd\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539JS\u5c42\u3001C++\u3001C\u8bed\u8a00\u5c42\u7684\u4ee3\u7801\uff0c\u4e5f\u53ef\u4ee5\u65b0\u589e\u4e00\u4e9b\u529f\u80fd\u6216\u6a21\u5757\u3002\u672c\u8282\u5206\u522b\u4ecb\u7ecd\u5982\u4f55\u65b0\u589e\u4e00\u4e2aNode.js\u7684C++\u6a21\u5757\u548c\u4fee\u6539Node.js\u5185\u6838\u3002\u76f8\u6bd4\u4fee\u6539Node.js\u5185\u6838\u4ee3\u7801\uff0c\u65b0\u589e\u4e00\u4e2aNode.js\u5185\u7f6e\u6a21\u5757\u9700\u8981\u4e86\u89e3\u66f4\u591a\u7684\u77e5\u8bc6\u3002 20.1.1 \u65b0\u589e\u4e00\u4e2a\u5185\u7f6eC++\u6a21\u5757 \u00b6 1.\u9996\u5148\u5728src\u6587\u4ef6\u5939\u4e0b\u65b0\u589e\u4e24\u4e2a\u6587\u4ef6\u3002 cyb.h 1. #ifndef SRC_CYB_H_ 2. #define SRC_CYB_H_ 3. #include \"v8.h\" 4. 5. namespace node { 6. class Environment; 7. class Cyb { 8. public: 9. static void Initialize(v8::Local<v8::Object> target, 10. v8::Local<v8::Value> unused, 11. v8::Local<v8::Context> context, 12. void* priv); 13. private: 14. static void Console(const v8::FunctionCallbackInfo<v8::Value>& args); 15. }; 16. } // namespace node 17. #endif cyb.cc 1. #include \"cyb.h\" 2. #include \"env-inl.h\" 3. #include \"util-inl.h\" 4. #include \"node_internals.h\" 5. 6. namespace node { 7. using v8::Context; 8. using v8::Function; 9. using v8::FunctionCallbackInfo; 10. using v8::FunctionTemplate; 11. using v8::Local; 12. using v8::Object; 13. using v8::String; 14. using v8::Value; 15. 16. void Cyb::Initialize(Local<Object> target, 17. Local<Value> unused, 18. Local<Context> context, 19. void* priv) { 20. Environment* env = Environment::GetCurrent(context); 21. // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u5757\uff0c\u6a21\u677f\u51fd\u6570\u662fConsole 22. Local<FunctionTemplate> t = env->NewFunctionTemplate(Console); 23. // \u7533\u8bf7\u4e00\u4e2a\u5b57\u7b26\u4e32 24. Local<String> str = FIXED_ONE_BYTE_STRING(env->isolate(), 25. \"console\"); 26. // \u8bbe\u7f6e\u51fd\u6570\u540d 27. t->SetClassName(str); 28. // \u5bfc\u51fa\u51fd\u6570\uff0ctarget\u5373exports 29. target->Set(env->context(), 30. str, 31. t->GetFunction(env->context()).ToLocalChecke 32. d()).Check(); 33. } 34. 35. void Cyb::Console(const FunctionCallbackInfo<Value>& args) { 36. v8::Isolate* isolate = args.GetIsolate(); 37. v8::Local<String> str = String::NewFromUtf8(isolate, 38. \"hello world\"); 39. args.GetReturnValue().Set(str); 40. } 41. 42. } // namespace node 43. // \u58f0\u660e\u8be5\u6a21\u5757 44. NODE_MODULE_CONTEXT_AWARE_INTERNAL(cyb_wrap, node::Cyb::Initialize) \u6211\u4eec\u65b0\u5b9a\u4e49\u4e00\u4e2a\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u81ea\u52a8\u6dfb\u52a0\u5230Node.js\u5185\u6838\u7684\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u989d\u5916\u7684\u64cd\u4f5c\u3002 1 \u9996\u5148\u6211\u4eec\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\u3002\u628a\u6211\u4eec\u65b0\u589e\u7684\u6587\u4ef6\u52a0\u5230\u914d\u7f6e\u91cc\uff0c\u5426\u5219\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u4e0d\u4f1a\u7f16\u8bd1\u8fd9\u4e2a\u65b0\u589e\u7684\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u5728node.gyp\u6587\u4ef6\u4e2d\u627e\u5230src/tcp_wrap.cc,\u7136\u540e\u5728\u5b83\u540e\u9762\u52a0\u5165\u6211\u4eec\u7684\u6587\u4ef6\u5c31\u884c\u3002 1. src/cyb_wrap.cc 2. src/cyb_wrap.h \u8fd9\u65f6\u5019Node.js\u4f1a\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\u4e86\u3002\u4f46\u662fNode.js\u7684\u5185\u7f6e\u6a21\u5757\u6709\u4e00\u5b9a\u7684\u673a\u5236\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u52a0\u5165\u4e86Node.js\u5185\u6838\uff0c\u4e0d\u4ee3\u8868\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8c03\u7528RegisterBuiltinModules\u51fd\u6570\u6ce8\u518c\u6240\u6709\u7684\u5185\u7f6eC++\u6a21\u5757\u3002 1. void RegisterBuiltinModules() { 2. #define V(modname) _register_##modname(); 3. NODE_BUILTIN_MODULES(V) 4. #undef V 5. } \u6211\u4eec\u770b\u5230\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u5b8f\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b8f\u3002 1. void RegisterBuiltinModules() { 2. #define V(modname) _register_##modname(); 3. NODE_BUILTIN_MODULES(V) 4. #undef V 5. } 6. #define NODE_BUILTIN_MODULES(V) \\ 7. NODE_BUILTIN_STANDARD_MODULES(V) \\ 8. NODE_BUILTIN_OPENSSL_MODULES(V) \\ 9. NODE_BUILTIN_ICU_MODULES(V) \\ 10. NODE_BUILTIN_REPORT_MODULES(V) \\ 11. NODE_BUILTIN_PROFILER_MODULES(V) \\ 12. NODE_BUILTIN_DTRACE_MODULES(V) \u5b8f\u91cc\u9762\u53c8\u662f\u4e00\u5806\u5b8f\u3002\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u4fee\u6539\u8fd9\u4e2a\u5b8f\u3002\u56e0\u4e3a\u6211\u4eec\u662f\u81ea\u5b9a\u4e49\u7684\u5185\u7f6e\u6a21\u5757\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u589e\u52a0\u4e00\u4e2a\u5b8f\u3002 1. #define NODE_BUILTIN_EXTEND_MODULES(V) \\ 2. V(cyb_wrap) \u7136\u540e\u628a\u8fd9\u4e2a\u5b8f\u8ffd\u52a0\u5230\u90a3\u4e00\u5806\u5b8f\u540e\u9762\u3002 1. #define NODE_BUILTIN_MODULES(V) \\ 2. NODE_BUILTIN_STANDARD_MODULES(V) \\ 3. NODE_BUILTIN_OPENSSL_MODULES(V) \\ 4. NODE_BUILTIN_ICU_MODULES(V) \\ 5. NODE_BUILTIN_REPORT_MODULES(V) \\ 6. NODE_BUILTIN_PROFILER_MODULES(V) \\ 7. NODE_BUILTIN_DTRACE_MODULES(V) \\ 8. NODE_BUILTIN_EXTEND_MODULES(V) \u8fd9\u65f6\u5019\uff0cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\uff0c\u8fd8\u4f1a\u628a\u6211\u4eec\u4ee3\u7801\u4e2d\u5b9a\u4e49\u7684\u6a21\u5757\u6ce8\u518c\u5230\u5185\u7f6eC++\u6a21\u5757\u91cc\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u4f7f\u7528C++\u6a21\u5757\u4e86\u3002 2 \u5728lib\u6587\u4ef6\u5939\u65b0\u5efa\u4e00\u4e2acyb.js\uff0c\u4f5c\u4e3aNode.js\u539f\u751f\u6a21\u5757 1. const cyb = internalBinding('cyb_wrap'); 2. module.exports = cyb; \u65b0\u589e\u539f\u751f\u6a21\u5757\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\uff0c\u5426\u5219\u4ee3\u7801\u4e5f\u4e0d\u4f1a\u88ab\u7f16\u8bd1\u8fdbnode\u5185\u6838\u3002\u6211\u4eec\u627e\u5230node.gyp\u6587\u4ef6\u7684lib/net.js\uff0c\u5728\u540e\u9762\u8ffd\u52a0lib/cyb.js\u3002\u8be5\u914d\u7f6e\u4e0b\u7684\u6587\u4ef6\u662f\u7ed9js2c.py\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\uff0c\u6211\u4eec\u5728require\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u627e\u4e0d\u5230\u8be5\u6a21\u5757\u3002\u6700\u540e\u6211\u4eec\u5728lib/internal/bootstrap/loader\u6587\u4ef6\u91cc\u627e\u5230internalBindingWhitelist\u53d8\u91cf\uff0c\u5728\u6570\u7ec4\u6700\u540e\u589e\u52a0cyb_wrap\uff0c\u8fd9\u4e2a\u914d\u7f6e\u662f\u7ed9process.binding\u51fd\u6570\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\u8fd9\u4e2a\u914d\u7f6e\uff0c\u901a\u8fc7process.binding\u5c31\u627e\u4e0d\u5230\u6211\u4eec\u7684\u6a21\u5757\u3002process.binding\u662f\u53ef\u4ee5\u5728\u7528\u6237JS\u91cc\u4f7f\u7528\u7684\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u6240\u6709\u7684\u4fee\u6539\u5de5\u4f5c\uff0c\u91cd\u65b0\u7f16\u8bd1Node.js\u3002\u7136\u540e\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8f\u3002 3 \u65b0\u5efa\u4e00\u4e2a\u6d4b\u8bd5\u6587\u4ef6testcyb.js 1. // const cyb = process.binding('cyb_wrap'); 2. const cyb = require('cyb'); 3. console.log(cyb.console()) \u53ef\u4ee5\u770b\u5230\uff0c\u4f1a\u8f93\u51fahello world\u3002 20.1.2 \u4fee\u6539Node.js\u5185\u6838 \u00b6 \u672c\u8282\u4ecb\u7ecd\u5982\u4f55\u4fee\u6539Node.js\u5185\u6838\u3002\u4fee\u6539\u7684\u90e8\u5206\u4e3b\u8981\u662f\u4e3a\u4e86\u5b8c\u5584Node.js\u7684TCP keepalive\u529f\u80fd\u3002\u76ee\u524dNode.js\u7684keepalive\u53ea\u652f\u6301\u8bbe\u7f6e\u5f00\u5173\u4ee5\u53ca\u7a7a\u95f2\u591a\u4e45\u540e\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u5728\u65b0\u7248Linux\u5185\u6838\u4e2d\uff0cTCP keepalive\u5305\u62ec\u4ee5\u4e0b\u914d\u7f6e\u3002 1 \u591a\u4e45\u6ca1\u6709\u901a\u4fe1\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 4 TCP_USER_TIMEOUT\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 Node.js\u53ea\u652f\u6301\u7b2c\u4e00\u6761\uff0c\u6240\u4ee5\u6211\u4eec\u7684\u76ee\u7684\u662f\u652f\u63012,3,4\u3002\u56e0\u4e3a\u8fd9\u4e2a\u529f\u80fd\u662f\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\uff0c\u6240\u4ee5\u9996\u5148\u9700\u8981\u4fee\u6539Libuv\u7684\u4ee3\u7801\u3002 1 \u4fee\u6539src/unix/tcp.c \u5728tcp.c\u52a0\u5165\u4ee5\u4e0b\u4ee3\u7801 1. int uv_tcp_keepalive_ex(uv_tcp_t* handle, 2. int on, 3. unsigned int delay, 4. unsigned int interval, 5. unsigned int count) { 6. int err; 7. 8. if (uv__stream_fd(handle) != -1) { 9. err =uv__tcp_keepalive_ex(uv__stream_fd(handle), 10. on, 11. delay, 12. interval, 13. count); 14. if (err) 15. return err; 16. } 17. 18. if (on) 19. handle->flags |= UV_HANDLE_TCP_KEEPALIVE; 20. else 21. handle->flags &= ~UV_HANDLE_TCP_KEEPALIVE; 22. return 0; 23. } 24. 25. int uv_tcp_timeout(uv_tcp_t* handle, unsigned int timeout) { 26. #ifdef TCP_USER_TIMEOUT 27. int fd = uv__stream_fd(handle); 28. if (fd != -1 && setsockopt(fd, 29. IPPROTO_TCP, 30. TCP_USER_TIMEOUT, 31. &timeout, 32. sizeof(timeout))) { 33. return UV__ERR(errno); 34. } 35. #endif 36. return 0; 37. } 38. 39. int uv__tcp_keepalive_ex(int fd, 40. int on, 41. unsigned int delay, 42. unsigned int interval, 43. unsigned int count) { 44. if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on))) 45. return UV__ERR(errno); 46. 47. #ifdef TCP_KEEPIDLE 48. if (on && delay &&setsockopt(fd, 49. IPPROTO_TCP, 50. TCP_KEEPIDLE, 51. &delay, 52. sizeof(delay))) 53. return UV__ERR(errno); 54. #endif 55. #ifdef TCP_KEEPINTVL 56. if (on && interval && setsockopt(fd, 57. IPPROTO_TCP, 58. TCP_KEEPINTVL, 59. &interval, 60. sizeof(interval))) 61. return UV__ERR(errno); 62. #endif 63. #ifdef TCP_KEEPCNT 64. if (on && count && setsockopt(fd, 65. IPPROTO_TCP, 66. TCP_KEEPCNT, 67. &count, 68. sizeof(count))) 69. return UV__ERR(errno); 70. #endif 71. /* Solaris/SmartOS, if you don't support keep-alive, 72. * then don't advertise it in your system headers... 73. */ 74. /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ 75. #if defined(TCP_KEEPALIVE) && !defined(__sun) 76. if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &delay, sizeof(delay))) 77. return UV__ERR(errno); 78. #endif 79. 80. return 0; 81. } 2 \u4fee\u6539include/uv.h \u628a\u5728tcp.c\u4e2d\u52a0\u5165\u7684\u63a5\u53e3\u66b4\u9732\u51fa\u6765\u3002 1. UV_EXTERN int uv_tcp_keepalive_ex(uv_tcp_t* handle, 2. int enable, 3. unsigned int delay, 4. unsigned int interval, 5. unsigned int count); 6. UV_EXTERN int uv_tcp_timeout(uv_tcp_t* handle, unsigned int timeout); \u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u4fee\u6539\u5b8cLibuv\u7684\u4ee3\u7801\uff0c\u4e5f\u5bf9\u5916\u66b4\u9732\u4e86\u8bbe\u7f6e\u7684\u63a5\u53e3\uff0c\u63a5\u7740\u6211\u4eec\u4fee\u6539\u4e0a\u5c42\u7684C++\u548cJS\u4ee3\u7801\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u4f7f\u7528\u8be5\u529f\u80fd\u3002 3 \u4fee\u6539src/tcp_wrap.cc \u4fee\u6539TCPWrap::Initialize\u51fd\u6570\u7684\u4ee3\u7801\u3002 1. env->SetProtoMethod(t, \"setKeepAliveEx\", SetKeepAliveEx); 2. env->SetProtoMethod(t, \"setKeepAliveTimeout\", SetKeepAliveTimeout); \u9996\u5148\u5bf9JS\u5c42\u66b4\u9732\u4e24\u4e2a\u65b0\u7684API\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e24\u4e2aAPI\u7684\u5b9a\u4e49\u3002 1. void TCPWrap::SetKeepAliveEx(const FunctionCallbackInfo<Value>& args) { 2. TCPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. Environment* env = wrap->env(); 7. int enable; 8. if (!args[0]->Int32Value(env->context()).To(&enable)) return; 9. unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value()); 10. unsigned int detal = static_cast<unsigned int>(args[2].As<Uint32>()->Value()); 11. unsigned int count = static_cast<unsigned int>(args[3].As<Uint32>()->Value()); 12. int err = uv_tcp_keepalive_ex(&wrap->handle_, enable, delay, detal, count); 13. args.GetReturnValue().Set(err); 14. } 15. 16. void TCPWrap::SetKeepAliveTimeout(const FunctionCallbackInfo<Value>& args) { 17. TCPWrap* wrap; 18. ASSIGN_OR_RETURN_UNWRAP(&wrap, 19. args.Holder(), 20. args.GetReturnValue().Set(UV_EBADF)); 21. unsigned int time = static_cast<unsigned int>(args[0].As<Uint32>()->Value()); 22. int err = uv_tcp_timeout(&wrap->handle_, time); 23. args.GetReturnValue().Set(err); 24. } \u540c\u65f6\u8fd8\u9700\u8981\u5728src/tcp_wrap.h\u4e2d\u58f0\u660e\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1. static void SetKeepAliveEx(const v8::FunctionCallbackInfo<v8::Value>& args); 2. static void SetKeepAliveTimeout(const v8::FunctionCallbackInfo<v8::Value>& args); 4 \u4fee\u6539lib/net.js 1. Socket.prototype.setKeepAliveEx = function(setting, 2. secs, 3. interval, 4. count) { 5. if (!this._handle) { 6. this.once('connect', () => this.setKeepAliveEx(setting, 7. secs, 8. interval, 9. count)); 10. return this; 11. } 12. 13. if (this._handle.setKeepAliveEx) 14. this._handle.setKeepAliveEx(setting, 15. ~~secs > 0 ? ~~secs : 0, 16. ~~interval > 0 ? ~~interval : 0, 17. ~~count > 0 ? ~~count : 0); 18. 19. return this; 20. }; 21. 22. Socket.prototype.setKeepAliveTimeout = function(timeout) { 23. if (!this._handle) { 24. this.once('connect', () => this.setKeepAliveTimeout(timeout)); 25. return this; 26. } 27. 28. if (this._handle.setKeepAliveTimeout) 29. this._handle.setKeepAliveTimeout(~~timeout > 0 ? ~~timeout : 0); 30. 31. return this; 32. }; \u91cd\u65b0\u7f16\u8bd1Node.js\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e24\u4e2a\u65b0\u7684API\u66f4\u7075\u6d3b\u5730\u63a7\u5236TCP\u7684keepalive\u4e86\u3002 1. const net = require('net'); 2. net.createServer((socket) => { 3. socket.setKeepAliveEx(true, 1,2,3); 4. // socket.setKeepAliveTimeout(4); 5. }).listen(1101); 20.2 \u4f7f\u7528N-API\u7f16\u5199C++\u63d2\u4ef6 \u00b6 \u672c\u5c0f\u8282\u4ecb\u7ecd\u4f7f\u7528N_API\u7f16\u5199C++\u63d2\u4ef6\u77e5\u8bc6\u3002Node.js C++\u63d2\u4ef6\u672c\u8d28\u662f\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5199\u5b8c\u7f16\u8bd1\u540e\uff0c\u751f\u6210\u4e00\u4e2a.node\u6587\u4ef6\u3002\u6211\u4eec\u5728Node.js\u91cc\u76f4\u63a5require\u4f7f\u7528\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406\u4e00\u5207\u3002 \u9996\u5148\u5efa\u7acb\u4e00\u4e2atest.cc\u6587\u4ef6 1. // hello.cc using N-API 2. #include <node_api.h> 3. 4. namespace demo { 5. 6. napi_value Method(napi_env env, napi_callback_info args) { 7. napi_value greeting; 8. napi_status status; 9. 10. status = napi_create_string_utf8(env, \"world\", NAPI_AUTO_LENGTH, &greeting); 11. if (status != napi_ok) return nullptr; 12. return greeting; 13. } 14. 15. napi_value init(napi_env env, napi_value exports) { 16. napi_status status; 17. napi_value fn; 18. 19. status = napi_create_function(env, nullptr, 0, Method, nullptr, &fn); 20. if (status != napi_ok) return nullptr; 21. 22. status = napi_set_named_property(env, exports, \"hello\", fn); 23. if (status != napi_ok) return nullptr; 24. return exports; 25. } 26. 27. NAPI_MODULE(NODE_GYP_MODULE_NAME, init) 28. 29. } // namespace demo \u6211\u4eec\u4e0d\u9700\u8981\u5177\u4f53\u4e86\u89e3\u4ee3\u7801\u7684\u610f\u601d\uff0c\u4f46\u662f\u4ece\u4ee3\u7801\u4e2d\u6211\u4eec\u5927\u81f4\u77e5\u9053\u5b83\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u7684API\u6587\u6863\u5c31\u53ef\u4ee5\u3002\u63a5\u7740\u6211\u4eec\u65b0\u5efa\u4e00\u4e2abinding.gyp\u6587\u4ef6\u3002gyp\u6587\u4ef6\u662fnode-gyp\u7684\u914d\u7f6e\u6587\u4ef6\u3002node-gyp\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u9488\u5bf9\u4e0d\u540c\u5e73\u53f0\u751f\u4ea7\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u6587\u4ef6\u3002\u6bd4\u5982Linux\u4e0b\u7684makefile\u3002 1. { 2. \"targets\": [ 3. { 4. \"target_name\": \"test\", 5. \"sources\": [ \"./test.cc\" ] 6. } 7. ] 8. } \u8bed\u6cd5\u548cmakefile\u6709\u70b9\u50cf\uff0c\u5c31\u662f\u5b9a\u4e49\u6211\u4eec\u7f16\u8bd1\u540e\u7684\u76ee\u524d\u6587\u4ef6\u540d\uff0c\u4f9d\u8d56\u54ea\u4e9b\u6e90\u6587\u4ef6\u3002\u7136\u540e\u6211\u4eec\u5b89\u88c5node-gyp\u3002 npm install node-gyp -g Node.js\u6e90\u7801\u4e2d\u4e5f\u6709\u4e00\u4e2anode-gyp\uff0c\u5b83\u662f\u5e2e\u52a9npm\u5b89\u88c5\u62d3\u5c55\u6a21\u5757\u65f6\uff0c\u5c31\u5730\u7f16\u8bd1\u7528\u7684\u3002\u6211\u4eec\u5b89\u88c5\u7684node-gyp\u662f\u5e2e\u52a9\u6211\u4eec\u751f\u6210\u914d\u7f6e\u6587\u4ef6\u5e76\u7f16\u8bd1\u7528\u7684\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003Node.js\u6587\u6863\u3002\u4e00\u5207\u51c6\u5907\u5c31\u7eea\u3002\u6211\u4eec\u5f00\u59cb\u7f16\u8bd1\u3002\u76f4\u63a5\u6267\u884c node-gyp configure node-gyp build \u5728\u8def\u5f84./build/Release/\u4e0b\u751f\u6210\u4e86test.node\u6587\u4ef6\u3002\u8fd9\u5c31\u662f\u6211\u4eec\u7684\u62d3\u5c55\u6a21\u5757\u3002\u6211\u4eec\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8fapp.js\u3002 1. var addon = require(\"./build/Release/test\"); 2. console.log(addon.hello()); \u6267\u884c \u2003 Node.js app.js \u6211\u4eec\u770b\u5230\u8f93\u51faworld\u3002\u6211\u4eec\u5df2\u7ecf\u5b66\u4f1a\u4e86\u5982\u4f55\u7f16\u5199\u4e00\u4e2aNode.js\u7684\u62d3\u5c55\u6a21\u5757\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u6587\u6863\uff0c\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u7f16\u5199\u4e0d\u540c\u7684\u6a21\u5757\u3002","title":"24-\u62d3\u5c55Node.js"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#201-nodejs","text":"\u4fee\u6539Node.js\u5185\u6838\u7684\u65b9\u5f0f\u4e5f\u6709\u5f88\u591a\u79cd\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539JS\u5c42\u3001C++\u3001C\u8bed\u8a00\u5c42\u7684\u4ee3\u7801\uff0c\u4e5f\u53ef\u4ee5\u65b0\u589e\u4e00\u4e9b\u529f\u80fd\u6216\u6a21\u5757\u3002\u672c\u8282\u5206\u522b\u4ecb\u7ecd\u5982\u4f55\u65b0\u589e\u4e00\u4e2aNode.js\u7684C++\u6a21\u5757\u548c\u4fee\u6539Node.js\u5185\u6838\u3002\u76f8\u6bd4\u4fee\u6539Node.js\u5185\u6838\u4ee3\u7801\uff0c\u65b0\u589e\u4e00\u4e2aNode.js\u5185\u7f6e\u6a21\u5757\u9700\u8981\u4e86\u89e3\u66f4\u591a\u7684\u77e5\u8bc6\u3002","title":"20.1 \u4fee\u6539Node.js\u5185\u6838"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#2011-c","text":"1.\u9996\u5148\u5728src\u6587\u4ef6\u5939\u4e0b\u65b0\u589e\u4e24\u4e2a\u6587\u4ef6\u3002 cyb.h 1. #ifndef SRC_CYB_H_ 2. #define SRC_CYB_H_ 3. #include \"v8.h\" 4. 5. namespace node { 6. class Environment; 7. class Cyb { 8. public: 9. static void Initialize(v8::Local<v8::Object> target, 10. v8::Local<v8::Value> unused, 11. v8::Local<v8::Context> context, 12. void* priv); 13. private: 14. static void Console(const v8::FunctionCallbackInfo<v8::Value>& args); 15. }; 16. } // namespace node 17. #endif cyb.cc 1. #include \"cyb.h\" 2. #include \"env-inl.h\" 3. #include \"util-inl.h\" 4. #include \"node_internals.h\" 5. 6. namespace node { 7. using v8::Context; 8. using v8::Function; 9. using v8::FunctionCallbackInfo; 10. using v8::FunctionTemplate; 11. using v8::Local; 12. using v8::Object; 13. using v8::String; 14. using v8::Value; 15. 16. void Cyb::Initialize(Local<Object> target, 17. Local<Value> unused, 18. Local<Context> context, 19. void* priv) { 20. Environment* env = Environment::GetCurrent(context); 21. // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u5757\uff0c\u6a21\u677f\u51fd\u6570\u662fConsole 22. Local<FunctionTemplate> t = env->NewFunctionTemplate(Console); 23. // \u7533\u8bf7\u4e00\u4e2a\u5b57\u7b26\u4e32 24. Local<String> str = FIXED_ONE_BYTE_STRING(env->isolate(), 25. \"console\"); 26. // \u8bbe\u7f6e\u51fd\u6570\u540d 27. t->SetClassName(str); 28. // \u5bfc\u51fa\u51fd\u6570\uff0ctarget\u5373exports 29. target->Set(env->context(), 30. str, 31. t->GetFunction(env->context()).ToLocalChecke 32. d()).Check(); 33. } 34. 35. void Cyb::Console(const FunctionCallbackInfo<Value>& args) { 36. v8::Isolate* isolate = args.GetIsolate(); 37. v8::Local<String> str = String::NewFromUtf8(isolate, 38. \"hello world\"); 39. args.GetReturnValue().Set(str); 40. } 41. 42. } // namespace node 43. // \u58f0\u660e\u8be5\u6a21\u5757 44. NODE_MODULE_CONTEXT_AWARE_INTERNAL(cyb_wrap, node::Cyb::Initialize) \u6211\u4eec\u65b0\u5b9a\u4e49\u4e00\u4e2a\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u81ea\u52a8\u6dfb\u52a0\u5230Node.js\u5185\u6838\u7684\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u989d\u5916\u7684\u64cd\u4f5c\u3002 1 \u9996\u5148\u6211\u4eec\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\u3002\u628a\u6211\u4eec\u65b0\u589e\u7684\u6587\u4ef6\u52a0\u5230\u914d\u7f6e\u91cc\uff0c\u5426\u5219\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u4e0d\u4f1a\u7f16\u8bd1\u8fd9\u4e2a\u65b0\u589e\u7684\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u5728node.gyp\u6587\u4ef6\u4e2d\u627e\u5230src/tcp_wrap.cc,\u7136\u540e\u5728\u5b83\u540e\u9762\u52a0\u5165\u6211\u4eec\u7684\u6587\u4ef6\u5c31\u884c\u3002 1. src/cyb_wrap.cc 2. src/cyb_wrap.h \u8fd9\u65f6\u5019Node.js\u4f1a\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\u4e86\u3002\u4f46\u662fNode.js\u7684\u5185\u7f6e\u6a21\u5757\u6709\u4e00\u5b9a\u7684\u673a\u5236\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u52a0\u5165\u4e86Node.js\u5185\u6838\uff0c\u4e0d\u4ee3\u8868\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8c03\u7528RegisterBuiltinModules\u51fd\u6570\u6ce8\u518c\u6240\u6709\u7684\u5185\u7f6eC++\u6a21\u5757\u3002 1. void RegisterBuiltinModules() { 2. #define V(modname) _register_##modname(); 3. NODE_BUILTIN_MODULES(V) 4. #undef V 5. } \u6211\u4eec\u770b\u5230\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u5b8f\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b8f\u3002 1. void RegisterBuiltinModules() { 2. #define V(modname) _register_##modname(); 3. NODE_BUILTIN_MODULES(V) 4. #undef V 5. } 6. #define NODE_BUILTIN_MODULES(V) \\ 7. NODE_BUILTIN_STANDARD_MODULES(V) \\ 8. NODE_BUILTIN_OPENSSL_MODULES(V) \\ 9. NODE_BUILTIN_ICU_MODULES(V) \\ 10. NODE_BUILTIN_REPORT_MODULES(V) \\ 11. NODE_BUILTIN_PROFILER_MODULES(V) \\ 12. NODE_BUILTIN_DTRACE_MODULES(V) \u5b8f\u91cc\u9762\u53c8\u662f\u4e00\u5806\u5b8f\u3002\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u4fee\u6539\u8fd9\u4e2a\u5b8f\u3002\u56e0\u4e3a\u6211\u4eec\u662f\u81ea\u5b9a\u4e49\u7684\u5185\u7f6e\u6a21\u5757\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u589e\u52a0\u4e00\u4e2a\u5b8f\u3002 1. #define NODE_BUILTIN_EXTEND_MODULES(V) \\ 2. V(cyb_wrap) \u7136\u540e\u628a\u8fd9\u4e2a\u5b8f\u8ffd\u52a0\u5230\u90a3\u4e00\u5806\u5b8f\u540e\u9762\u3002 1. #define NODE_BUILTIN_MODULES(V) \\ 2. NODE_BUILTIN_STANDARD_MODULES(V) \\ 3. NODE_BUILTIN_OPENSSL_MODULES(V) \\ 4. NODE_BUILTIN_ICU_MODULES(V) \\ 5. NODE_BUILTIN_REPORT_MODULES(V) \\ 6. NODE_BUILTIN_PROFILER_MODULES(V) \\ 7. NODE_BUILTIN_DTRACE_MODULES(V) \\ 8. NODE_BUILTIN_EXTEND_MODULES(V) \u8fd9\u65f6\u5019\uff0cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\uff0c\u8fd8\u4f1a\u628a\u6211\u4eec\u4ee3\u7801\u4e2d\u5b9a\u4e49\u7684\u6a21\u5757\u6ce8\u518c\u5230\u5185\u7f6eC++\u6a21\u5757\u91cc\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u4f7f\u7528C++\u6a21\u5757\u4e86\u3002 2 \u5728lib\u6587\u4ef6\u5939\u65b0\u5efa\u4e00\u4e2acyb.js\uff0c\u4f5c\u4e3aNode.js\u539f\u751f\u6a21\u5757 1. const cyb = internalBinding('cyb_wrap'); 2. module.exports = cyb; \u65b0\u589e\u539f\u751f\u6a21\u5757\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\uff0c\u5426\u5219\u4ee3\u7801\u4e5f\u4e0d\u4f1a\u88ab\u7f16\u8bd1\u8fdbnode\u5185\u6838\u3002\u6211\u4eec\u627e\u5230node.gyp\u6587\u4ef6\u7684lib/net.js\uff0c\u5728\u540e\u9762\u8ffd\u52a0lib/cyb.js\u3002\u8be5\u914d\u7f6e\u4e0b\u7684\u6587\u4ef6\u662f\u7ed9js2c.py\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\uff0c\u6211\u4eec\u5728require\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u627e\u4e0d\u5230\u8be5\u6a21\u5757\u3002\u6700\u540e\u6211\u4eec\u5728lib/internal/bootstrap/loader\u6587\u4ef6\u91cc\u627e\u5230internalBindingWhitelist\u53d8\u91cf\uff0c\u5728\u6570\u7ec4\u6700\u540e\u589e\u52a0cyb_wrap\uff0c\u8fd9\u4e2a\u914d\u7f6e\u662f\u7ed9process.binding\u51fd\u6570\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\u8fd9\u4e2a\u914d\u7f6e\uff0c\u901a\u8fc7process.binding\u5c31\u627e\u4e0d\u5230\u6211\u4eec\u7684\u6a21\u5757\u3002process.binding\u662f\u53ef\u4ee5\u5728\u7528\u6237JS\u91cc\u4f7f\u7528\u7684\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u6240\u6709\u7684\u4fee\u6539\u5de5\u4f5c\uff0c\u91cd\u65b0\u7f16\u8bd1Node.js\u3002\u7136\u540e\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8f\u3002 3 \u65b0\u5efa\u4e00\u4e2a\u6d4b\u8bd5\u6587\u4ef6testcyb.js 1. // const cyb = process.binding('cyb_wrap'); 2. const cyb = require('cyb'); 3. console.log(cyb.console()) \u53ef\u4ee5\u770b\u5230\uff0c\u4f1a\u8f93\u51fahello world\u3002","title":"20.1.1 \u65b0\u589e\u4e00\u4e2a\u5185\u7f6eC++\u6a21\u5757"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#2012-nodejs","text":"\u672c\u8282\u4ecb\u7ecd\u5982\u4f55\u4fee\u6539Node.js\u5185\u6838\u3002\u4fee\u6539\u7684\u90e8\u5206\u4e3b\u8981\u662f\u4e3a\u4e86\u5b8c\u5584Node.js\u7684TCP keepalive\u529f\u80fd\u3002\u76ee\u524dNode.js\u7684keepalive\u53ea\u652f\u6301\u8bbe\u7f6e\u5f00\u5173\u4ee5\u53ca\u7a7a\u95f2\u591a\u4e45\u540e\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u5728\u65b0\u7248Linux\u5185\u6838\u4e2d\uff0cTCP keepalive\u5305\u62ec\u4ee5\u4e0b\u914d\u7f6e\u3002 1 \u591a\u4e45\u6ca1\u6709\u901a\u4fe1\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 4 TCP_USER_TIMEOUT\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 Node.js\u53ea\u652f\u6301\u7b2c\u4e00\u6761\uff0c\u6240\u4ee5\u6211\u4eec\u7684\u76ee\u7684\u662f\u652f\u63012,3,4\u3002\u56e0\u4e3a\u8fd9\u4e2a\u529f\u80fd\u662f\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\uff0c\u6240\u4ee5\u9996\u5148\u9700\u8981\u4fee\u6539Libuv\u7684\u4ee3\u7801\u3002 1 \u4fee\u6539src/unix/tcp.c \u5728tcp.c\u52a0\u5165\u4ee5\u4e0b\u4ee3\u7801 1. int uv_tcp_keepalive_ex(uv_tcp_t* handle, 2. int on, 3. unsigned int delay, 4. unsigned int interval, 5. unsigned int count) { 6. int err; 7. 8. if (uv__stream_fd(handle) != -1) { 9. err =uv__tcp_keepalive_ex(uv__stream_fd(handle), 10. on, 11. delay, 12. interval, 13. count); 14. if (err) 15. return err; 16. } 17. 18. if (on) 19. handle->flags |= UV_HANDLE_TCP_KEEPALIVE; 20. else 21. handle->flags &= ~UV_HANDLE_TCP_KEEPALIVE; 22. return 0; 23. } 24. 25. int uv_tcp_timeout(uv_tcp_t* handle, unsigned int timeout) { 26. #ifdef TCP_USER_TIMEOUT 27. int fd = uv__stream_fd(handle); 28. if (fd != -1 && setsockopt(fd, 29. IPPROTO_TCP, 30. TCP_USER_TIMEOUT, 31. &timeout, 32. sizeof(timeout))) { 33. return UV__ERR(errno); 34. } 35. #endif 36. return 0; 37. } 38. 39. int uv__tcp_keepalive_ex(int fd, 40. int on, 41. unsigned int delay, 42. unsigned int interval, 43. unsigned int count) { 44. if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on))) 45. return UV__ERR(errno); 46. 47. #ifdef TCP_KEEPIDLE 48. if (on && delay &&setsockopt(fd, 49. IPPROTO_TCP, 50. TCP_KEEPIDLE, 51. &delay, 52. sizeof(delay))) 53. return UV__ERR(errno); 54. #endif 55. #ifdef TCP_KEEPINTVL 56. if (on && interval && setsockopt(fd, 57. IPPROTO_TCP, 58. TCP_KEEPINTVL, 59. &interval, 60. sizeof(interval))) 61. return UV__ERR(errno); 62. #endif 63. #ifdef TCP_KEEPCNT 64. if (on && count && setsockopt(fd, 65. IPPROTO_TCP, 66. TCP_KEEPCNT, 67. &count, 68. sizeof(count))) 69. return UV__ERR(errno); 70. #endif 71. /* Solaris/SmartOS, if you don't support keep-alive, 72. * then don't advertise it in your system headers... 73. */ 74. /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ 75. #if defined(TCP_KEEPALIVE) && !defined(__sun) 76. if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &delay, sizeof(delay))) 77. return UV__ERR(errno); 78. #endif 79. 80. return 0; 81. } 2 \u4fee\u6539include/uv.h \u628a\u5728tcp.c\u4e2d\u52a0\u5165\u7684\u63a5\u53e3\u66b4\u9732\u51fa\u6765\u3002 1. UV_EXTERN int uv_tcp_keepalive_ex(uv_tcp_t* handle, 2. int enable, 3. unsigned int delay, 4. unsigned int interval, 5. unsigned int count); 6. UV_EXTERN int uv_tcp_timeout(uv_tcp_t* handle, unsigned int timeout); \u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u4fee\u6539\u5b8cLibuv\u7684\u4ee3\u7801\uff0c\u4e5f\u5bf9\u5916\u66b4\u9732\u4e86\u8bbe\u7f6e\u7684\u63a5\u53e3\uff0c\u63a5\u7740\u6211\u4eec\u4fee\u6539\u4e0a\u5c42\u7684C++\u548cJS\u4ee3\u7801\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u4f7f\u7528\u8be5\u529f\u80fd\u3002 3 \u4fee\u6539src/tcp_wrap.cc \u4fee\u6539TCPWrap::Initialize\u51fd\u6570\u7684\u4ee3\u7801\u3002 1. env->SetProtoMethod(t, \"setKeepAliveEx\", SetKeepAliveEx); 2. env->SetProtoMethod(t, \"setKeepAliveTimeout\", SetKeepAliveTimeout); \u9996\u5148\u5bf9JS\u5c42\u66b4\u9732\u4e24\u4e2a\u65b0\u7684API\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e24\u4e2aAPI\u7684\u5b9a\u4e49\u3002 1. void TCPWrap::SetKeepAliveEx(const FunctionCallbackInfo<Value>& args) { 2. TCPWrap* wrap; 3. ASSIGN_OR_RETURN_UNWRAP(&wrap, 4. args.Holder(), 5. args.GetReturnValue().Set(UV_EBADF)); 6. Environment* env = wrap->env(); 7. int enable; 8. if (!args[0]->Int32Value(env->context()).To(&enable)) return; 9. unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value()); 10. unsigned int detal = static_cast<unsigned int>(args[2].As<Uint32>()->Value()); 11. unsigned int count = static_cast<unsigned int>(args[3].As<Uint32>()->Value()); 12. int err = uv_tcp_keepalive_ex(&wrap->handle_, enable, delay, detal, count); 13. args.GetReturnValue().Set(err); 14. } 15. 16. void TCPWrap::SetKeepAliveTimeout(const FunctionCallbackInfo<Value>& args) { 17. TCPWrap* wrap; 18. ASSIGN_OR_RETURN_UNWRAP(&wrap, 19. args.Holder(), 20. args.GetReturnValue().Set(UV_EBADF)); 21. unsigned int time = static_cast<unsigned int>(args[0].As<Uint32>()->Value()); 22. int err = uv_tcp_timeout(&wrap->handle_, time); 23. args.GetReturnValue().Set(err); 24. } \u540c\u65f6\u8fd8\u9700\u8981\u5728src/tcp_wrap.h\u4e2d\u58f0\u660e\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1. static void SetKeepAliveEx(const v8::FunctionCallbackInfo<v8::Value>& args); 2. static void SetKeepAliveTimeout(const v8::FunctionCallbackInfo<v8::Value>& args); 4 \u4fee\u6539lib/net.js 1. Socket.prototype.setKeepAliveEx = function(setting, 2. secs, 3. interval, 4. count) { 5. if (!this._handle) { 6. this.once('connect', () => this.setKeepAliveEx(setting, 7. secs, 8. interval, 9. count)); 10. return this; 11. } 12. 13. if (this._handle.setKeepAliveEx) 14. this._handle.setKeepAliveEx(setting, 15. ~~secs > 0 ? ~~secs : 0, 16. ~~interval > 0 ? ~~interval : 0, 17. ~~count > 0 ? ~~count : 0); 18. 19. return this; 20. }; 21. 22. Socket.prototype.setKeepAliveTimeout = function(timeout) { 23. if (!this._handle) { 24. this.once('connect', () => this.setKeepAliveTimeout(timeout)); 25. return this; 26. } 27. 28. if (this._handle.setKeepAliveTimeout) 29. this._handle.setKeepAliveTimeout(~~timeout > 0 ? ~~timeout : 0); 30. 31. return this; 32. }; \u91cd\u65b0\u7f16\u8bd1Node.js\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e24\u4e2a\u65b0\u7684API\u66f4\u7075\u6d3b\u5730\u63a7\u5236TCP\u7684keepalive\u4e86\u3002 1. const net = require('net'); 2. net.createServer((socket) => { 3. socket.setKeepAliveEx(true, 1,2,3); 4. // socket.setKeepAliveTimeout(4); 5. }).listen(1101);","title":"20.1.2 \u4fee\u6539Node.js\u5185\u6838"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#202-n-apic","text":"\u672c\u5c0f\u8282\u4ecb\u7ecd\u4f7f\u7528N_API\u7f16\u5199C++\u63d2\u4ef6\u77e5\u8bc6\u3002Node.js C++\u63d2\u4ef6\u672c\u8d28\u662f\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5199\u5b8c\u7f16\u8bd1\u540e\uff0c\u751f\u6210\u4e00\u4e2a.node\u6587\u4ef6\u3002\u6211\u4eec\u5728Node.js\u91cc\u76f4\u63a5require\u4f7f\u7528\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406\u4e00\u5207\u3002 \u9996\u5148\u5efa\u7acb\u4e00\u4e2atest.cc\u6587\u4ef6 1. // hello.cc using N-API 2. #include <node_api.h> 3. 4. namespace demo { 5. 6. napi_value Method(napi_env env, napi_callback_info args) { 7. napi_value greeting; 8. napi_status status; 9. 10. status = napi_create_string_utf8(env, \"world\", NAPI_AUTO_LENGTH, &greeting); 11. if (status != napi_ok) return nullptr; 12. return greeting; 13. } 14. 15. napi_value init(napi_env env, napi_value exports) { 16. napi_status status; 17. napi_value fn; 18. 19. status = napi_create_function(env, nullptr, 0, Method, nullptr, &fn); 20. if (status != napi_ok) return nullptr; 21. 22. status = napi_set_named_property(env, exports, \"hello\", fn); 23. if (status != napi_ok) return nullptr; 24. return exports; 25. } 26. 27. NAPI_MODULE(NODE_GYP_MODULE_NAME, init) 28. 29. } // namespace demo \u6211\u4eec\u4e0d\u9700\u8981\u5177\u4f53\u4e86\u89e3\u4ee3\u7801\u7684\u610f\u601d\uff0c\u4f46\u662f\u4ece\u4ee3\u7801\u4e2d\u6211\u4eec\u5927\u81f4\u77e5\u9053\u5b83\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u7684API\u6587\u6863\u5c31\u53ef\u4ee5\u3002\u63a5\u7740\u6211\u4eec\u65b0\u5efa\u4e00\u4e2abinding.gyp\u6587\u4ef6\u3002gyp\u6587\u4ef6\u662fnode-gyp\u7684\u914d\u7f6e\u6587\u4ef6\u3002node-gyp\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u9488\u5bf9\u4e0d\u540c\u5e73\u53f0\u751f\u4ea7\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u6587\u4ef6\u3002\u6bd4\u5982Linux\u4e0b\u7684makefile\u3002 1. { 2. \"targets\": [ 3. { 4. \"target_name\": \"test\", 5. \"sources\": [ \"./test.cc\" ] 6. } 7. ] 8. } \u8bed\u6cd5\u548cmakefile\u6709\u70b9\u50cf\uff0c\u5c31\u662f\u5b9a\u4e49\u6211\u4eec\u7f16\u8bd1\u540e\u7684\u76ee\u524d\u6587\u4ef6\u540d\uff0c\u4f9d\u8d56\u54ea\u4e9b\u6e90\u6587\u4ef6\u3002\u7136\u540e\u6211\u4eec\u5b89\u88c5node-gyp\u3002 npm install node-gyp -g Node.js\u6e90\u7801\u4e2d\u4e5f\u6709\u4e00\u4e2anode-gyp\uff0c\u5b83\u662f\u5e2e\u52a9npm\u5b89\u88c5\u62d3\u5c55\u6a21\u5757\u65f6\uff0c\u5c31\u5730\u7f16\u8bd1\u7528\u7684\u3002\u6211\u4eec\u5b89\u88c5\u7684node-gyp\u662f\u5e2e\u52a9\u6211\u4eec\u751f\u6210\u914d\u7f6e\u6587\u4ef6\u5e76\u7f16\u8bd1\u7528\u7684\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003Node.js\u6587\u6863\u3002\u4e00\u5207\u51c6\u5907\u5c31\u7eea\u3002\u6211\u4eec\u5f00\u59cb\u7f16\u8bd1\u3002\u76f4\u63a5\u6267\u884c node-gyp configure node-gyp build \u5728\u8def\u5f84./build/Release/\u4e0b\u751f\u6210\u4e86test.node\u6587\u4ef6\u3002\u8fd9\u5c31\u662f\u6211\u4eec\u7684\u62d3\u5c55\u6a21\u5757\u3002\u6211\u4eec\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8fapp.js\u3002 1. var addon = require(\"./build/Release/test\"); 2. console.log(addon.hello()); \u6267\u884c \u2003 Node.js app.js \u6211\u4eec\u770b\u5230\u8f93\u51faworld\u3002\u6211\u4eec\u5df2\u7ecf\u5b66\u4f1a\u4e86\u5982\u4f55\u7f16\u5199\u4e00\u4e2aNode.js\u7684\u62d3\u5c55\u6a21\u5757\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u6587\u6863\uff0c\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u7f16\u5199\u4e0d\u540c\u7684\u6a21\u5757\u3002","title":"20.2 \u4f7f\u7528N-API\u7f16\u5199C++\u63d2\u4ef6"},{"location":"chapter21-JS%20Stream/","text":"\u6d41\u662f\u5bf9\u751f\u4ea7\u6570\u636e\u548c\u6d88\u8d39\u6570\u636e\u8fc7\u7a0b\u7684\u62bd\u8c61\uff0c\u6d41\u672c\u8eab\u4e0d\u751f\u4ea7\u548c\u6d88\u8d39\u6570\u636e\uff0c\u5b83\u53ea\u662f\u5b9a\u4e49\u4e86\u6570\u636e\u5904\u7406\u7684\u6d41\u7a0b\u3002\u53ef\u8bfb\u6d41\u662f\u5bf9\u6570\u636e\u6e90\u6d41\u5411\u5176\u5b83\u5730\u65b9\u7684\u8fc7\u7a0b\u62bd\u8c61\uff0c\u5c5e\u4e8e\u751f\u4ea7\u8005\uff0c\u53ef\u8bfb\u6d41\u662f\u5bf9\u6570\u636e\u6d41\u5411\u67d0\u4e00\u76ee\u7684\u5730\u7684\u8fc7\u7a0b\u7684\u62bd\u8c61\u3002Node.js\u4e2d\u7684\u6d41\u5206\u4e3a\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u53ef\u8bfb\u5199\u3001\u8f6c\u6362\u6d41\u3002\u4e0b\u9762\u6211\u5148\u770b\u4e00\u4e0b\u6d41\u7684\u57fa\u7c7b\u3002 21.1 \u6d41\u57fa\u7c7b\u548c\u6d41\u901a\u7528\u903b\u8f91 \u00b6 1. const EE = require('events'); 2. const util = require('util'); 3. // \u6d41\u7684\u57fa\u7c7b 4. function Stream() { 5. EE.call(this); 6. } 7. // \u7ee7\u627f\u4e8b\u4ef6\u8ba2\u9605\u5206\u53d1\u7684\u80fd\u529b 8. util.inherits(Stream, EE); \u6d41\u7684\u57fa\u7c7b\u53ea\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570\u5c31\u662fpipe\u3002\u7528\u4e8e\u5b9e\u73b0\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u662f\u5bf9\u6570\u636e\u4ece\u4e00\u4e2a\u5730\u65b9\u6d41\u5411\u53e6\u4e00\u4e2a\u5730\u65b9\u7684\u62bd\u8c61\u3002\u8fd9\u4e2a\u65b9\u6cd5\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5206\u5f00\u8bf4\u3002 21.1.1\u5904\u7406\u6570\u636e\u4e8b\u4ef6 \u00b6 1. // \u6570\u636e\u6e90\u5bf9\u8c61 2. var source = this; 3. 4. // \u76d1\u542cdata\u4e8b\u4ef6\uff0c\u53ef\u8bfb\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 5. source.on('data', ondata); 6. function ondata(chunk) { 7. // \u6e90\u6d41\u6709\u6570\u636e\u5230\u8fbe\uff0c\u5e76\u4e14\u76ee\u7684\u6d41\u53ef\u5199 8. if (dest.writable) { 9. /* 10. \u76ee\u7684\u6d41\u8fc7\u8f7d\u5e76\u4e14\u6e90\u6d41\u5b9e\u73b0\u4e86pause\u65b9\u6cd5\uff0c 11. \u90a3\u5c31\u6682\u505c\u53ef\u8bfb\u6d41\u7684\u8bfb\u53d6\u64cd\u4f5c\uff0c\u7b49\u5f85\u76ee\u7684\u6d41\u89e6\u53d1drain\u4e8b\u4ef6 12. */ 13. if (false === dest.write(chunk) && source.pause) { 14. source.pause(); 15. } 16. } 17. } 18. 19. // \u76d1\u542cdrain\u4e8b\u4ef6\uff0c\u76ee\u7684\u6d41\u53ef\u4ee5\u6d88\u8d39\u6570\u636e\u4e86\u5c31\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6 20. dest.on('drain', ondrain); 21. function ondrain() { 22. // \u76ee\u7684\u6d41\u53ef\u7ee7\u7eed\u5199\u4e86\uff0c\u5e76\u4e14\u53ef\u8bfb\u6d41\u53ef\u8bfb\uff0c\u5207\u6362\u6210\u81ea\u52a8\u8bfb\u53d6\u6a21\u5f0f 23. if (source.readable && source.resume) { 24. source.resume(); 25. } 26. } \u8fd9\u662f\u7ba1\u9053\u5316\u65f6\u6d41\u63a7\u5b9e\u73b0\u7684\u5730\u65b9\uff0c\u4e3b\u8981\u662f\u5229\u7528\u4e86write\u8fd4\u56de\u503c\u548cdrain\u4e8b\u4ef6\u3002 21.1.2\u6d41\u5173\u95ed/\u7ed3\u675f\u5904\u7406 \u00b6 1. /* 2. 1 dest._isStdio\u662ftrue\u8868\u793a\u76ee\u7684\u6d41\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\uff08\u89c1 3. process/stdio.js\uff09\uff0c 4. 2 \u914d\u7f6e\u7684end\u5b57\u6bb5\u4ee3\u8868\u53ef\u8bfb\u6d41\u89e6\u53d1end\u6216close\u4e8b\u4ef6\u65f6\uff0c\u662f\u5426\u81ea\u52a8\u5173\u95ed\u53ef\u5199 5. \u6d41\uff0c\u9ed8\u8ba4\u662f\u81ea\u52a8\u5173\u95ed\u3002\u5982\u679c\u914d\u7f6e\u4e86end\u662ffalse\uff0c\u5219\u53ef\u8bfb\u6d41\u8fd9\u4e24\u4e2a\u4e8b\u4ef6\u89e6\u53d1 6. \u65f6\uff0c\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5173\u95ed\u53ef\u5199\u6d41\u3002 7. 3 \u6211\u4eec\u770b\u5230\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u53ef\u5199\u6d41\u662f\u4e0d\u4f1a\u88ab\u81ea\u52a8\u5173\u95ed\u7684\uff0c\u9700\u8981\u6211 8. \u4eec\u81ea\u5df1\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u624b\u52a8\u5173\u95ed\u53ef\u5199\u6d41\u3002\u6240\u4ee5if\u7684\u5224\u65ad\u610f\u601d 9. \u662f\u4e0d\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\u6d41\uff0c\u5e76\u4e14\u6ca1\u6709\u914d\u7f6eend\u662ffalse\u7684\u65f6\u5019\uff0c\u4f1a\u81ea\u52a8 10. \u5173\u95ed\u53ef\u5199\u6d41\u3002\u800c\u6807\u51c6\u8f93\u51fa\u548c\u6807\u51c6\u9519\u8bef\u6d41\u662f\u5728\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u624d\u88ab\u5173\u95ed\u7684\u3002 11. */ 12. if (!dest._isStdio && (!options || options.end !== false)) { 13. // \u6e90\u6d41\u6ca1\u6709\u6570\u636e\u53ef\u8bfb\u4e86\uff0c\u6267\u884cend\u56de\u8c03 14. source.on('end', onend); 15. // \u6e90\u6d41\u5173\u95ed\u4e86\uff0c\u6267\u884cclose\u56de\u8c03 16. source.on('close', onclose); 17. } 18. 19. var didOnEnd = false; 20. function onend() { 21. if (didOnEnd) return; 22. didOnEnd = true; 23. // \u6267\u884c\u76ee\u7684\u6d41\u7684end\uff0c\u8bf4\u660e\u5199\u6570\u636e\u5b8c\u6bd5 24. dest.end(); 25. } 26. 27. function onclose() { 28. if (didOnEnd) return; 29. didOnEnd = true; 30. // \u9500\u6bc1\u76ee\u7684\u6d41 31. if (typeof dest.destroy === 'function') dest.destroy(); 32. } \u4e0a\u9762\u662f\u53ef\u8bfb\u6e90\u6d41\u7ed3\u675f\u6216\u5173\u95ed\u540e\uff0c\u5982\u4f55\u5904\u7406\u53ef\u5199\u6d41\u7684\u903b\u8f91\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u53ef\u5199\u6d41\u7684\u5173\u95ed\u64cd\u4f5c\u3002 21.1.3 \u9519\u8bef\u5904\u7406 \u00b6 1. // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u51fa\u9519\u7684\u65f6\u5019\u90fd\u9700\u8981\u505c\u6b62\u6570\u636e\u7684\u5904\u7406 2. source.on('error', onerror); 3. dest.on('error', onerror); 4. // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u89e6\u53d1error\u4e8b\u4ef6\u65f6\u7684\u5904\u7406\u903b\u8f91 5. function onerror(er) { 6. // \u51fa\u9519\u4e86\uff0c\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u5305\u62ec\u6b63\u5728\u6267\u884c\u7684onerror\u51fd\u6570 7. cleanup(); 8. /* 9. \u5982\u679c\u7528\u6237\u6ca1\u6709\u76d1\u542c\u6d41\u7684error\u4e8b\u4ef6\uff0c\u5219\u629b\u51fa\u9519\u8bef\uff0c 10. \u6240\u4ee5\u6211\u4eec\u4e1a\u52a1\u4ee3\u7801\u9700\u8981\u76d1\u542cerror\u4e8b\u4ef6 11. */ 12. if (EE.listenerCount(this, 'error') === 0) { 13. throw er; // Unhandled stream error in pipe. 14. } 15. } \u5728error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7cleanup\u51fd\u6570\u6e05\u9664\u4e86Node.js\u672c\u8eab\u6ce8\u518c\u7684error\u4e8b\u4ef6\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\uff0c\u5219error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0,\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6ce8\u518cerror\u4e8b\u4ef6\u3002\u4e0b\u9762\u6211\u4eec\u518d\u5206\u6790cleanup\u51fd\u6570\u7684\u903b\u8f91\u3002 21.1.4 \u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6 \u00b6 1. // \u4fdd\u8bc1\u6e90\u6d41\u5173\u95ed\u3001\u6570\u636e\u8bfb\u5b8c\u3001\u76ee\u7684\u6d41\u5173\u95ed\u65f6\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6 2. source.on('end', cleanup); 3. source.on('close', cleanup); 4. dest.on('close', cleanup); 5. // \u6e05\u9664\u6240\u6709\u53ef\u80fd\u4f1a\u7ed1\u5b9a\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\uff0c\u6267\u884c\u6e05\u9664\u4e5f\u662f\u65e0\u5bb3\u7684 6. function cleanup() { 7. source.removeListener('data', ondata); 8. dest.removeListener('drain', ondrain); 9. 10. source.removeListener('end', onend); 11. source.removeListener('close', onclose); 12. 13. source.removeListener('error', onerror); 14. dest.removeListener('error', onerror); 15. 16. source.removeListener('end', cleanup); 17. source.removeListener('close', cleanup); 18. 19. dest.removeListener('close', cleanup); 20. } 21. 22. // \u89e6\u53d1\u76ee\u7684\u6d41\u7684pipe\u4e8b\u4ef6 23. dest.emit('pipe', source); 24. // \u652f\u6301\u8fde\u7eed\u7684\u7ba1\u9053\u5316A.pipe(B).pipe(C) 25. return dest; 21.1.5 \u6d41\u7684\u9608\u503c \u00b6 \u901a\u8fc7getHighWaterMark\uff08lib\\internal\\streams\\state.js\uff09\u51fd\u6570\u53ef\u4ee5\u8ba1\u7b97\u51fa\u6d41\u7684\u9608\u503c\uff0c\u9608\u503c\u7528\u4e8e\u63a7\u5236\u7528\u6237\u8bfb\u5199\u6570\u636e\u7684\u901f\u5ea6\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. function getHighWaterMark(state, options, duplexKey, isDuplex) { // \u7528\u6237\u5b9a\u4e49\u7684\u9608\u503c 2. let hwm = options.highWaterMark; 3. // \u7528\u6237\u5b9a\u4e49\u4e86\uff0c\u5219\u6821\u9a8c\u662f\u5426\u5408\u6cd5 4. if (hwm != null) { 5. if (typeof hwm !== 'number' || !(hwm >= 0)) 6. throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 7. 'highWaterMark', 8. hwm); 9. return Math.floor(hwm); 10. } else if (isDuplex) { 11. // \u7528\u6237\u6ca1\u6709\u5b9a\u4e49\u516c\u5171\u7684\u9608\u503c\uff0c\u5373\u8bfb\u5199\u6d41\u516c\u7528\u7684\u9608\u503c 12. // \u7528\u6237\u662f\u5426\u5b9a\u4e49\u4e86\u6d41\u5355\u72ec\u7684\u9608\u503c\uff0c\u6bd4\u5982\u8bfb\u6d41\u7684\u9608\u503c\u6216\u8005\u5199\u6d41\u7684\u9608\u503c 13. hwm = options[duplexKey]; 14. // \u7528\u6237\u6709\u5b9a\u4e49 15. if (hwm != null) { 16. if (typeof hwm !== 'number' || !(hwm >= 0)) 17. throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 18. duplexKey, 19. hwm); 20. return Math.floor(hwm); 21. } 22. } 23. 24. // \u9ed8\u8ba4\u503c\uff0c\u5bf9\u8c61\u662f16\u4e2a\uff0cbuffer\u662f16KB 25. return state.objectMode ? 16 : 16 * 1024; 26. } getHighWaterMark\u51fd\u6570\u903b\u8f91\u5982\u4e0b 1 \u7528\u6237\u5b9a\u4e49\u4e86\u5408\u6cd5\u7684\u9608\u503c\uff0c\u5219\u53d6\u7528\u6237\u5b9a\u4e49\u7684\uff08\u53ef\u8bfb\u6d41\u3001\u53ef\u5199\u6d41\u3001\u53cc\u5411\u6d41\uff09\u3002 2 \u5982\u679c\u662f\u53cc\u5411\u6d41\uff0c\u5e76\u4e14\u7528\u6237\u6ca1\u6709\u53ef\u8bfb\u6d41\u53ef\u5199\u6d41\u5171\u4eab\u7684\u5b9a\u4e49\u9608\u503c\uff0c\u6839\u636e\u5f53\u524d\u662f\u53ef\u8bfb\u6d41\u8fd8\u662f\u53ef\u5199\u6d41\uff0c\u5224\u65ad\u7528\u6237\u662f\u5426\u8bbe\u7f6e\u5bf9\u5e94\u6d41\u7684\u9608\u503c\u3002\u6709\u5219\u53d6\u7528\u6237\u8bbe\u7f6e\u7684\u503c\u4f5c\u4e3a\u9608\u503c\u3002 3 \u5982\u679c\u4e0d\u6ee1\u8db31,2\uff0c\u5219\u8fd4\u56de\u9ed8\u8ba4\u503c\u3002 21.1.6 \u9500\u6bc1\u6d41 \u00b6 \u901a\u8fc7\u8c03\u7528destroy\u51fd\u6570\u53ef\u4ee5\u9500\u6bc1\u4e00\u4e2a\u6d41\uff0c\u5305\u62ec\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u3002\u5e76\u4e14\u53ef\u4ee5\u5b9e\u73b0_ destroy\u51fd\u6570\u81ea\u5b9a\u4e49\u9500\u6bc1\u7684\u884c\u4e3a\u3002\u6211\u4eec\u770b\u770b\u53ef\u5199\u6d41\u7684destroy\u51fd\u6570\u5b9a\u4e49\u3002 1. function destroy(err, cb) { 2. // \u8bfb\u6d41\u3001\u5199\u6d41\u3001\u53cc\u5411\u6d41 3. const readableDestroyed = this._readableState && 4. this._readableState.destroyed; 5. const writableDestroyed = this._writableState && 6. this._writableState.destroyed; 7. // \u6d41\u662f\u5426\u5df2\u7ecf\u9500\u6bc1\uff0c\u662f\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03 8. if (readableDestroyed || writableDestroyed) { 9. // \u4f20\u4e86cb\uff0c\u5219\u6267\u884c\uff0c\u53ef\u9009\u5730\u4f20\u5165err\uff0c\u7528\u6237\u5b9a\u4e49\u7684err 10. if (cb) { 11. cb(err); 12. } else if (err && 13. (!this._writableState || 14. !this._writableState.errorEmitted)) { 15. /* \u4f20\u4e86err\uff0c\u662f\u8bfb\u6d41\u6216\u8005\u6ca1\u6709\u89e6\u53d1\u8fc7error\u4e8b\u4ef6\u7684\u5199\u6d41\uff0c 16. \u5219\u89e6\u53d1error\u4e8b\u4ef6 17. */ 18. process.nextTick(emitErrorNT, this, err); 19. } 20. return this; 21. } 22. 23. // \u8fd8\u6ca1\u6709\u9500\u6bc1\u5219\u5f00\u59cb\u9500\u6bc1\u6d41\u7a0b 24. if (this._readableState) { 25. this._readableState.destroyed = true; 26. } 27. 28. if (this._writableState) { 29. this._writableState.destroyed = true; 30. } 31. // \u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49_destroy\u51fd\u6570 32. this._destroy(err || null, (err) => { 33. // \u6ca1\u6709cb\u4f46\u662f\u6709error\uff0c\u5219\u89e6\u53d1error\u4e8b\u4ef6 34. if (!cb && err) { 35. process.nextTick(emitErrorNT, this, err); 36. // \u53ef\u5199\u6d41\u5219\u6807\u8bb0\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 37. if (this._writableState) { 38. this._writableState.errorEmitted = true; 39. } 40. } else if (cb) { // \u6709cb\u6216\u8005\u6ca1\u6709err 41. cb(err); 42. } 43. }); 44. 45. return this; 46. } destroy\u51fd\u6570\u9500\u6bc1\u6d41\u7684\u901a\u7528\u903b\u8f91\u3002\u5176\u4e2d_destroy\u51fd\u6570\u4e0d\u540c\u7684\u6d41\u4e0d\u4e00\u6837\uff0c\u4e0b\u9762\u5206\u522b\u662f\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1 \u53ef\u8bfb\u6d41 1. Readable.prototype._destroy = function(err, cb) { 2. this.push(null); 3. cb(err); 4. }; 2 \u53ef\u5199\u6d41 1. Writable.prototype._destroy = function(err, cb) { 2. this.end(); 3. cb(err); 4. }; 21.2 \u53ef\u8bfb\u6d41 \u00b6 Node.js\u4e2d\u53ef\u8bfb\u6d41\u6709\u4e24\u79cd\u5de5\u4f5c\u6a21\u5f0f\uff1a\u6d41\u5f0f\u548c\u6682\u505c\u5f0f\uff0c\u6d41\u5f0f\u5c31\u662f\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u56de\u8c03\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4f20\u7ed9\u56de\u8c03\uff0c\u6682\u505c\u5f0f\u5c31\u662f\u9700\u8981\u7528\u6237\u81ea\u5df1\u624b\u52a8\u6267\u884c\u8bfb\u53d6\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u901a\u8fc7\u6e90\u7801\u53bb\u4e86\u89e3\u4e00\u4e0b\u53ef\u8bfb\u6d41\u5b9e\u73b0\u7684\u4e00\u4e9b\u903b\u8f91\u3002\u56e0\u4e3a\u5b9e\u73b0\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u903b\u8f91\u4e5f\u6bd4\u8f83\u7ed5\uff0c\u672c\u6587\u53ea\u5206\u6790\u4e00\u4e9b\u4e3b\u8981\u7684\u903b\u8f91\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bReadableState\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u8868\u793a\u53ef\u8bfb\u6d41\u7684\u4e00\u4e9b\u72b6\u6001\u548c\u5c5e\u6027\u7684\u3002 1. function ReadableState(options, stream) { 2. options = options || {}; 3. // \u662f\u5426\u662f\u53cc\u5411\u6d41 4. var isDuplex = stream instanceof Stream.Duplex; 5. // \u6570\u636e\u6a21\u5f0f 6. this.objectMode = !!options.objectMode; 7. // \u53cc\u5411\u6d41\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u8bfb\u7aef\u7684\u6a21\u5f0f 8. if (isDuplex) 9. this.objectMode = this.objectMode || 10. !!options.readableObjectMode; 11. // \u8bfb\u5230highWaterMark\u4e2a\u5b57\u8282\u5219\u505c\u6b62\uff0c\u5bf9\u8c61\u6a21\u5f0f\u7684\u8bdd\u5219\u662f16\u4e2a\u5bf9\u8c61 12. this.highWaterMark = getHighWaterMark(this, 13. options, 'readableHighWaterMark', 14. isDuplex); 15. // \u5b58\u50a8\u6570\u636e\u7684\u7f13\u51b2\u533a 16. this.buffer = new BufferList(); 17. // \u53ef\u8bfb\u6570\u636e\u7684\u957f\u5ea6 18. this.length = 0; 19. // \u7ba1\u9053\u7684\u76ee\u7684\u6e90\u548c\u4e2a\u6570 20. this.pipes = null; 21. this.pipesCount = 0; 22. // \u5de5\u4f5c\u6a21\u5f0f 23. this.flowing = null; 24. // \u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f 25. this.ended = false; 26. // \u662f\u5426\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\u4e86 27. this.endEmitted = false; 28. // \u662f\u5426\u6b63\u5728\u8bfb\u53d6\u6570\u636e 29. this.reading = false; 30. // \u662f\u5426\u540c\u6b65\u6267\u884c\u4e8b\u4ef6 31. this.sync = true; 32. // \u662f\u5426\u9700\u8981\u89e6\u53d1readable\u4e8b\u4ef6 33. this.needReadable = false; 34. // \u662f\u5426\u89e6\u53d1\u4e86readable\u4e8b\u4ef6 35. this.emittedReadable = false; 36. // \u662f\u5426\u76d1\u542c\u4e86readable\u4e8b\u4ef6 37. this.readableListening = false; 38. // \u662f\u5426\u6b63\u5728\u6267\u884cresume\u7684\u8fc7\u7a0b 39. this.resumeScheduled = false; 40. // \u6d41\u662f\u5426\u5df2\u9500\u6bc1 41. this.destroyed = false; 42. // \u6570\u636e\u7f16\u7801\u683c\u5f0f 43. this.defaultEncoding = options.defaultEncoding || 'utf8'; 44. /* 45. \u5728\u7ba1\u9053\u5316\u4e2d\uff0c\u6709\u591a\u5c11\u4e2a\u5199\u8005\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c 46. \u9700\u8981\u7b49\u5f85\u89e6\u53d1drain\u4e8b\u4ef6,awaitDrain\u8bb0\u5f55\u8fbe\u5230\u9608\u503c\u7684\u5199\u8005\u4e2a\u6570 47. */ 48. this.awaitDrain = 0; 49. // \u6267\u884cmaybeReadMore\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e3atrue 50. this.readingMore = false; 51. this.decoder = null; 52. this.encoding = null; 53. // \u7f16\u7801\u89e3\u7801\u5668 54. if (options.encoding) { 55. if (!StringDecoder) 56. StringDecoder = require('string_decoder').StringDecoder; 57. this.decoder = new StringDecoder(options.encoding); 58. this.encoding = options.encoding; 59. } 60. } ReadableState\u91cc\u5305\u542b\u4e86\u4e00\u5927\u5806\u5b57\u6bb5\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4e0d\u7ba1\u5b83\uff0c\u7b49\u5f85\u7528\u5230\u7684\u65f6\u5019\uff0c\u518d\u56de\u5934\u770b\u3002\u63a5\u7740\u6211\u4eec\u5f00\u59cb\u770b\u53ef\u8bfb\u6d41\u7684\u5b9e\u73b0\u3002 1. function Readable(options) { 2. if (!(this instanceof Readable)) 3. return new Readable(options); 4. 5. this._readableState = new ReadableState(options, this); 6. // \u53ef\u8bfb 7. this.readable = true; 8. // \u7528\u6237\u5b9e\u73b0\u7684\u4e24\u4e2a\u51fd\u6570 9. if (options) { 10. if (typeof options.read === 'function') 11. this._read = options.read; 12. if (typeof options.destroy === 'function') 13. this._destroy = options.destroy; 14. } 15. // \u521d\u59cb\u5316\u7236\u7c7b 16. Stream.call(this); 17. } \u4e0a\u9762\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u9700\u8981\u5173\u6ce8\u7684\u662fread\u548cdestroy\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u6211\u4eec\u662f\u76f4\u63a5\u4f7f\u7528Readable\u4f7f\u7528\u53ef\u8bfb\u6d41\uff0c\u90a3\u5728options\u91cc\u662f\u5fc5\u987b\u4f20read\u51fd\u6570\u7684\uff0cdestroy\u662f\u53ef\u9009\u7684\u3002\u5982\u679c\u6211\u4eec\u662f\u4ee5\u7ee7\u627f\u7684\u65b9\u5f0f\u4f7f\u7528Readable\uff0c\u90a3\u5fc5\u987b\u5b9e\u73b0_read\u51fd\u6570\u3002Node.js\u53ea\u662f\u62bd\u8c61\u4e86\u6d41\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u64cd\u4f5c\uff08\u6bd4\u5982\u53ef\u8bfb\u6d41\u5c31\u662f\u8bfb\u53d6\u6570\u636e\uff09\u662f\u7531\u7528\u6237\u81ea\u5df1\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u8bfb\u53d6\u64cd\u4f5c\u662f\u4e1a\u52a1\u76f8\u5173\u7684\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u53ef\u8bfb\u6d41\u7684\u64cd\u4f5c\u3002 21.2.1 \u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u83b7\u53d6\u6570\u636e \u00b6 \u5bf9\u7528\u6237\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u662f\u7528\u6237\u83b7\u53d6\u6570\u636e\u7684\u5730\u65b9\uff0c\u4f46\u662f\u5bf9\u53ef\u8bfb\u6d41\u6765\u8bf4\uff0c\u5b83\u63d0\u4f9b\u6570\u636e\u7ed9\u7528\u6237\u7684\u524d\u63d0\u662f\u5b83\u81ea\u5df1\u6709\u6570\u636e\uff0c\u6240\u4ee5\u53ef\u8bfb\u6d41\u9996\u5148\u9700\u8981\u751f\u4ea7\u6570\u636e\u3002\u751f\u4ea7\u6570\u636e\u7684\u903b\u8f91\u7531_read\u51fd\u6570\u5b9e\u73b0\u3002_read\u51fd\u6570\u7684\u903b\u8f91\u5927\u6982\u662f 1. const data = getSomeData(); 2. readableStream.push(data); \u901a\u8fc7push\u51fd\u6570\uff0c\u5f80\u53ef\u8bfb\u6d41\u91cc\u5199\u5165\u6570\u636e\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u4e3a\u7528\u6237\u63d0\u4f9b\u6570\u636e\uff0c\u6211\u4eec\u770b\u770bpush\u7684\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u4e3b\u8981\u903b\u8f91\u3002 1. Read able.prototype.push = function(chunk, encoding) { 2. // \u7701\u7565\u4e86\u7f16\u7801\u5904\u7406\u7684\u4ee3\u7801 3. return readableAddChunk(this, 4. chunk, 5. encoding, 6. false, 7. skipChunkCheck); 8. }; 9. 10. function readableAddChunk(stream, 11. chunk, 12. encoding, 13. addToFront, 14. skipChunkCheck) { 15. var state = stream._readableState; 16. // push null\u4ee3\u8868\u6d41\u7ed3\u675f 17. if (chunk === null) { 18. state.reading = false; 19. onEofChunk(stream, state); 20. } else { 21. addChunk(stream, state, chunk, false); 22. } 23. // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u66f4\u591a\u6570\u636e 24. return needMoreData(state); 25. } 26. 27. function addChunk(stream, state, chunk, addToFront) { 28. // \u662f\u6d41\u6a21\u5f0f\u5e76\u4e14\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u76f4\u63a5\u89e6\u53d1data\u4e8b\u4ef6 29. if (state.flowing && state.length === 0 && !state.sync) { 30. stream.emit('data', chunk); 31. } else { 32. // \u5426\u5219\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765 33. state.length += state.objectMode ? 1 : chunk.length; 34. if (addToFront) 35. state.buffer.unshift(chunk); 36. else 37. state.buffer.push(chunk); 38. // \u76d1\u542c\u4e86readable\u4e8b\u4ef6\u5219\u89e6\u53d1readable\u4e8b\u4ef6\uff0c\u901a\u8fc7read\u4e3b\u52a8\u8bfb\u53d6 39. if (state.needReadable) 40. emitReadable(stream); 41. } 42. // \u7ee7\u7eed\u8bfb\u53d6\u6570\u636e\uff0c\u5982\u679c\u53ef\u4ee5\u7684\u8bdd 43. maybeReadMore(stream, state); 44. } \u603b\u7684\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u9996\u5148\u8981\u4ece\u67d0\u4e2a\u5730\u65b9\u83b7\u53d6\u6570\u636e\uff0c\u6839\u636e\u5f53\u524d\u7684\u5de5\u4f5c\u6a21\u5f0f\uff0c\u76f4\u63a5\u4ea4\u4ed8\u7ed9\u7528\u6237\uff0c\u6216\u8005\u5148\u7f13\u5b58\u8d77\u6765\u3002\u53ef\u4ee5\u7684\u60c5\u51b5\u4e0b\uff0c\u7ee7\u7eed\u83b7\u53d6\u6570\u636e\u3002 21.2.2 \u7528\u6237\u4ece\u53ef\u8bfb\u6d41\u83b7\u53d6\u6570\u636e \u00b6 \u7528\u6237\u53ef\u4ee5\u901a\u8fc7read\u51fd\u6570\u6216\u8005\u76d1\u542cdata\u4e8b\u4ef6\u6765\u4ece\u53ef\u8bfb\u6d41\u4e2d\u83b7\u53d6\u6570\u636e 1. Readable.prototype.read = function(n) { 2. n = parseInt(n, 10); 3. var state = this._readableState; 4. // \u8ba1\u7b97\u53ef\u8bfb\u7684\u5927\u5c0f 5. n = howMuchToRead(n, state); 6. var ret; 7. // \u9700\u8981\u8bfb\u53d6\u7684\u5927\u4e8e0\uff0c\u5219\u53d6\u8bfb\u53d6\u6570\u636e\u5230ret\u8fd4\u56de 8. if (n > 0) 9. ret = fromList(n, state); 10. else 11. ret = null; 12. // \u51cf\u53bb\u521a\u8bfb\u53d6\u7684\u957f\u5ea6 13. state.length -= n; 14. /* 15. \u5982\u679c\u7f13\u5b58\u91cc\u6ca1\u6709\u6570\u636e\u6216\u8005\u8bfb\u5b8c\u540e\u5c0f\u4e8e\u9608\u503c\u4e86\uff0c 16. \u5219\u53ef\u8bfb\u6d41\u53ef\u4ee5\u7ee7\u7eed\u4ece\u5e95\u5c42\u8d44\u6e90\u91cc\u83b7\u53d6\u6570\u636e 17. */ 18. if (state.length === 0 || 19. state.length - n < state.highWaterMark) { 20. this._read(state.highWaterMark); 21. } 22. // \u89e6\u53d1data\u4e8b\u4ef6 23. if (ret !== null) 24. this.emit('data', ret); 25. return ret; 26. }; \u8bfb\u53d6\u6570\u636e\u7684\u64cd\u4f5c\u5c31\u662f\u8ba1\u7b97\u7f13\u5b58\u91cc\u6709\u591a\u5c11\u6570\u636e\u53ef\u4ee5\u8bfb\uff0c\u548c\u7528\u6237\u9700\u8981\u7684\u6570\u636e\u5927\u5c0f\uff0c\u53d6\u5c0f\u7684\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u7528\u6237\uff0c\u5e76\u89e6\u53d1data\u4e8b\u4ef6\u3002\u5982\u679c\u6570\u636e\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u89e6\u53d1\u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u4e2d\u83b7\u53d6\u6570\u636e\u3002\u4ece\u800c\u6e90\u6e90\u4e0d\u65ad\u5730\u751f\u6210\u6570\u636e\u3002 21.3 \u53ef\u5199\u6d41 \u00b6 \u53ef\u5199\u6d41\u662f\u5bf9\u6570\u636e\u6d41\u5411\u7684\u62bd\u8c61\uff0c\u7528\u6237\u8c03\u7528\u53ef\u5199\u6d41\u7684\u63a5\u53e3\uff0c\u53ef\u5199\u6d41\u8d1f\u8d23\u63a7\u5236\u6570\u636e\u7684\u5199\u5165\u3002\u6d41\u7a0b\u5982\u56fe21-1\u6240\u793a\u3002 \u56fe21-1 \u4e0b\u9762\u662f\u53ef\u5199\u6d41\u7684\u4ee3\u7801\u903b\u8f91\u56fe\u5982\u56fe21-2\u6240\u793a\u3002 \u56fe21-2 \u6211\u4eec\u770b\u4e00\u4e0b\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 21.3.1 WritableState \u00b6 WritableState\u662f\u7ba1\u7406\u53ef\u5199\u6d41\u914d\u7f6e\u7684\u7c7b\u3002\u91cc\u9762\u5305\u542b\u4e86\u975e\u5e38\u7684\u5b57\u6bb5\uff0c\u5177\u4f53\u542b\u4e49\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u5206\u6790\u7684\u65f6\u5019\u8bb2\u89e3\u3002 1. function WritableState(options, stream) { 2. options = options || {}; 3. 4. // \u662f\u4e0d\u662f\u53cc\u5411\u6d41 5. var isDuplex = stream instanceof Stream.Duplex; 6. 7. // \u6570\u636e\u6a21\u5f0f 8. this.objectMode = !!options.objectMode; 9. /* 10. \u53cc\u5411\u6d41\u7684\u6d41\u9ed8\u8ba4\u5171\u4eabobjectMode\u914d\u7f6e\uff0c 11. \u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u914d\u7f6e\u6210\u975e\u5171\u4eab\uff0c\u5373\u8bfb\u6d41\u548c\u5199\u6d41\u7684\u6570\u636e\u6a21\u5f0f\u72ec\u7acb 12. */ 13. if (isDuplex) 14. this.objectMode = this.objectMode || 15. !!options.writableObjectMode; 16. 17. /* 18. \u9608\u503c\uff0c\u8d85\u8fc7\u540e\u8bf4\u660e\u9700\u8981\u6682\u505c\u8c03\u7528write\uff0c0\u4ee3\u8868\u6bcf\u6b21\u8c03\u7528write 19. \u7684\u65f6\u5019\u90fd\u8fd4\u56defalse\uff0c\u7528\u6237\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u6267\u884cwrite 20. */ 21. this.highWaterMark = getHighWaterMark(this, 22. options, 'writableHighWaterMark',isDuplex); 23. 24. // \u662f\u5426\u8c03\u7528\u4e86_final\u51fd\u6570 25. this.finalCalled = false; 26. 27. // \u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u91cd\u65b0\u9a71\u52a8\u751f\u4ea7\u8005 28. this.needDrain = false; 29. 30. // \u6b63\u5728\u6267\u884cend\u6d41\u7a0b 31. this.ending = false; 32. 33. // \u662f\u5426\u6267\u884c\u8fc7end\u51fd\u6570 34. this.ended = false; 35. 36. // \u662f\u5426\u89e6\u53d1\u4e86finish\u4e8b\u4ef6 37. this.finished = false; 38. 39. // \u6d41\u662f\u5426\u88ab\u9500\u6bc1\u4e86 40. this.destroyed = false; 41. 42. var noDecode = options.decodeStrings === false; 43. // \u662f\u5426\u9700\u8981decode\u6d41\u6570\u636e\u540e\u5728\u6267\u884c\u5199\uff08\u8c03\u7528\u7528\u6237\u5b9a\u4e49\u7684_write\uff09 44. this.decodeStrings = !noDecode; 45. 46. // \u7f16\u7801\u7c7b\u578b 47. this.defaultEncoding = options.defaultEncoding || 'utf8'; 48. 49. // \u5f85\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 50. this.length = 0; 51. 52. // \u6b63\u5728\u5f80\u5e95\u5c42\u5199 53. this.writing = false; 54. 55. // \u52a0\u585e\uff0c\u7f13\u5b58\u751f\u4ea7\u8005\u7684\u6570\u636e\uff0c\u505c\u6b62\u5f80\u5e95\u5c42\u5199\u5165 56. this.corked = 0; 57. 58. // \u7528\u6237\u5b9a\u4e49\u7684_write\u6216\u8005_writev\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u8c03\u7528\u53ef\u5199\u6d41\u7684\u56de\u8c03\u51fd\u6570onwrite 59. this.sync = true; 60. 61. // \u662f\u5426\u6b63\u5728\u5904\u7406\u7f13\u5b58\u7684\u6570\u636e 62. this.bufferProcessing = false; 63. 64. // \u7528\u6237\u5b9e\u73b0\u7684\u94a9\u5b50_write\u51fd\u6570\u91cc\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\uff0c\u544a\u8bc9\u5199\u6d41\u5199\u5b8c\u6210\u4e86 65. this.onwrite = onwrite.bind(undefined, stream); 66. 67. // \u5f53\u524d\u5199\u64cd\u4f5c\u5bf9\u5e94\u7684\u56de\u8c03 68. this.writecb = null; 69. 70. // \u5f53\u524d\u5199\u64cd\u4f5c\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 71. this.writelen = 0; 72. 73. // \u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u5934\u6307\u9488 74. this.bufferedRequest = null; 75. 76. // \u6307\u5411\u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9 77. this.lastBufferedRequest = null; 78. 79. // \u5f85\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570\u4e2a\u6570 80. this.pendingcb = 0; 81. 82. // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7prefinished\u4e8b\u4ef6 83. this.prefinished = false; 84. 85. // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 86. this.errorEmitted = false; 87. 88. // count buffered requests 89. // \u7f13\u5b58\u7684buffer\u6570 90. this.bufferedRequestCount = 0; 91. 92. /* 93. \u7a7a\u95f2\u7684\u8282\u70b9\u94fe\u8868\uff0c\u5f53\u628a\u7f13\u5b58\u6570\u636e\u5199\u5165\u5e95\u5c42\u65f6\uff0ccorkReq\u4fdd\u6570\u636e\u7684\u4e0a\u4e0b\u6587\uff08\u5982 94. \u7528\u6237\u56de\u8c03\uff09\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\uff0c\u7f13\u5b58\u94fe\u8868\u5df2\u7ecf\u88ab\u6e05\u7a7a\uff0c 95. this.corkedRequestsFree\u59cb\u7ec8\u7ef4\u62a4\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6700\u591a\u4e24\u4e2a 96. */ 97. var corkReq = { next: null, entry: null, finish: undefined }; 98. corkReq.finish = onCorkedFinish.bind(undefined, corkReq, this); 99. this.corkedRequestsFree = corkReq; 100. } 21.3.2 Writable \u00b6 Writable\u662f\u53ef\u5199\u6d41\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528Writable\u4f5c\u4e3a\u53ef\u5199\u6d41\u6765\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u7ee7\u627fWritable\u5b9e\u73b0\u81ea\u5df1\u7684\u53ef\u5199\u6d41\u3002 1. function Writable(options) { 2. this._writableState = new WritableState(options, this); 3. // \u53ef\u5199 4. this.writable = true; 5. // \u652f\u6301\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u94a9\u5b50 6. if (options) { 7. if (typeof options.write === 'function') 8. this._write = options.write; 9. 10. if (typeof options.writev === 'function') 11. this._writev = options.writev; 12. 13. if (typeof options.destroy === 'function') 14. this._destroy = options.destroy; 15. 16. if (typeof options.final === 'function') 17. this._final = options.final; 18. } 19. 20. Stream.call(this); 21. } \u53ef\u5199\u6d41\u7ee7\u627f\u4e8e\u6d41\u57fa\u7c7b\uff0c\u63d0\u4f9b\u51e0\u4e2a\u94a9\u5b50\u51fd\u6570\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\u5b9e\u73b0\u81ea\u5df1\u7684\u903b\u8f91\u3002\u5982\u679c\u7528\u6237\u662f\u76f4\u63a5\u4f7f\u7528Writable\u7c7b\u4f5c\u4e3a\u53ef\u5199\u6d41\uff0c\u5219options.write\u51fd\u6570\u662f\u5fc5\u987b\u4f20\u7684\uff0coptions.wirte\u51fd\u6570\u63a7\u5236\u6570\u636e\u5f80\u54ea\u91cc\u5199\uff0c\u5e76\u4e14\u901a\u77e5\u53ef\u5199\u6d41\u662f\u5426\u5199\u5b8c\u6210\u4e86\u3002\u5982\u679c\u7528\u6237\u662f\u4ee5\u7ee7\u627fWritable\u7c7b\u7684\u5f62\u5f0f\u4f7f\u7528\u53ef\u5199\u6d41\uff0c\u5219_write\u51fd\u6570\u662f\u5fc5\u987b\u5b9e\u73b0\u7684\uff0c_write\u51fd\u6570\u548coptions.write\u51fd\u6570\u7684\u4f5c\u7528\u662f\u4e00\u6837\u7684\u3002 21.3.3 \u6570\u636e\u5199\u5165 \u00b6 \u53ef\u5199\u6d41\u63d0\u4f9bwrite\u51fd\u6570\u7ed9\u7528\u6237\u5b9e\u73b0\u6570\u636e\u7684\u5199\u5165\uff0c\u5199\u5165\u6709\u4e24\u79cd\u65b9\u5f0f\u3002\u4e00\u4e2a\u662f\u9010\u4e2a\u5199\uff0c\u4e00\u4e2a\u662f\u6279\u91cf\u5199\uff0c\u6279\u91cf\u5199\u662f\u53ef\u9009\u7684\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff0c\u5982\u679c\u7528\u6237\u76f4\u63a5\u4f7f\u7528Writable\u5219\u9700\u8981\u4f20\u5165writev\uff0c\u5982\u679c\u662f\u7ee7\u627f\u65b9\u5f0f\u4f7f\u7528Writable\u5219\u5b9e\u73b0_writev\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bwrite\u51fd\u6570\u7684\u5b9e\u73b0 1. Writable.prototype.write = function(chunk, encoding, cb) { 2. var state = this._writableState; 3. // \u544a\u8bc9\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write 4. var ret = false; 5. // \u6570\u636e\u683c\u5f0f 6. var isBuf = !state.objectMode && Stream._isUint8Array(chunk); 7. // \u662f\u5426\u9700\u8981\u8f6c\u6210buffer\u683c\u5f0f 8. if (isBuf && Object.getPrototypeOf(chunk) !== Buffer.prototype) { 9. chunk = Stream._uint8ArrayToBuffer(chunk); 10. } 11. // \u53c2\u6570\u5904\u7406\uff0c\u4f20\u4e86\u6570\u636e\u548c\u56de\u8c03\uff0c\u6ca1\u6709\u4f20\u7f16\u7801\u7c7b\u578b 12. if (typeof encoding === 'function') { 13. cb = encoding; 14. encoding = null; 15. } 16. // \u662fbuffer\u7c7b\u578b\u5219\u8bbe\u7f6e\u6210buffer\uff0c\u5426\u5219\u5982\u679c\u6ca1\u4f20\u5219\u53d6\u9ed8\u8ba4\u7f16\u7801 17. if (isBuf) 18. encoding = 'buffer'; 19. else if (!encoding) 20. encoding = state.defaultEncoding; 21. 22. if (typeof cb !== 'function') 23. cb = nop; 24. // \u6b63\u5728\u6267\u884cend\uff0c\u518d\u6267\u884cwrite\uff0c\u62a5\u9519 25. if (state.ending) 26. writeAfterEnd(this, cb); 27. else if (isBuf || validChunk(this, state, chunk, cb)) { 28. // \u5f85\u6267\u884c\u7684\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373cb 29. state.pendingcb++; 30. // \u5199\u5165\u6216\u7f13\u5b58\uff0c\u89c1\u8be5\u51fd\u6570 31. ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb); 32. } 33. /// \u8fd8\u80fd\u4e0d\u80fd\u7ee7\u7eed\u5199 34. return ret; 35. }; write\u51fd\u6570\u9996\u5148\u505a\u4e86\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u548c\u6570\u636e\u8f6c\u6362\uff0c\u7136\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u6d41\u7ed3\u675f\u518d\u6267\u884c\u5199\u5165\uff0c\u5219\u4f1a\u62a5\u9519\u3002\u5982\u679c\u6d41\u6ca1\u6709\u7ed3\u675f\u5219\u6267\u884c\u5199\u5165\u6216\u8005\u7f13\u5b58\u5904\u7406\u3002\u6700\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write\u5199\u5165\u6570\u636e\uff08\u6211\u4eec\u770b\u5230\u5982\u679c\u5199\u5165\u7684\u6570\u636e\u6bd4\u9608\u503c\u5927\uff0c\u53ef\u5199\u6d41\u8fd8\u662f\u4f1a\u6267\u884c\u5199\u5165\u64cd\u4f5c\uff0c\u4f46\u662f\u4f1a\u8fd4\u56defalse\u544a\u8bc9\u7528\u6237\u4e9b\u4e0d\u8981\u5199\u5165\u4e86\uff0c\u5982\u679c\u8c03\u7528\u65b9\u7ee7\u7eed\u5199\u5165\u7684\u8bdd\uff0c\u4e5f\u662f\u6ca1\u4f1a\u7ee7\u7eed\u5199\u5165\u7684\uff0c\u4f46\u662f\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5199\u5165\u7aef\u538b\u529b\u8fc7\u5927\uff09\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bwriteAfterEnd\u7684\u903b\u8f91\u3002\u7136\u540e\u518d\u770bwriteOrBuffer\u3002 1. function writeAfterEnd(stream, cb) { 2. var er = new errors.Error('ERR_STREAM_WRITE_AFTER_END'); 3. stream.emit('error', er); 4. process.nextTick(cb, er); 5. } writeAfterEnd\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u89e6\u53d1\u53ef\u5199\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u4e0b\u4e00\u4e2atick\u7684\u65f6\u5019\u6267\u884c\u7528\u6237\u5728\u8c03\u7528write\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bwriteOrBuffer\u3002writeOrBuffer\u51fd\u6570\u4f1a\u5bf9\u6570\u636e\u8fdb\u884c\u7f13\u5b58\u6216\u8005\u76f4\u63a5\u5199\u5165\u76ee\u7684\u5730\uff08\u76ee\u7684\u5730\u53ef\u4ee5\u662f\u6587\u4ef6\u3001socket\u3001\u5185\u5b58\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff09\uff0c\u53d6\u51b3\u4e8e\u5f53\u524d\u53ef\u5199\u6d41\u7684\u72b6\u6001\u3002 1. function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) { 2. // \u6570\u636e\u5904\u7406 3. if (!isBuf) { 4. var newChunk = decodeChunk(state, chunk, encoding); 5. if (chunk !== newChunk) { 6. isBuf = true; 7. encoding = 'buffer'; 8. chunk = newChunk; 9. } 10. } 11. // \u5bf9\u8c61\u6a21\u5f0f\u7684\u7b97\u4e00\u4e2a 12. var len = state.objectMode ? 1 : chunk.length; 13. // \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u4e2a\u6570 14. state.length += len; 15. // \u5f85\u5199\u5165\u7684\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c 16. var ret = state.length < state.highWaterMark; 17. 18. /* 19. \u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u5219\u8bbe\u7f6e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6\u6807\u8bb0\uff0c 20. \u8fd9\u65f6\u5019\u7528\u6237\u4e0d\u5e94\u8be5\u518d\u6267\u884cwrite\uff0c\u800c\u662f\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1 21. */ 22. if (!ret) 23. state.needDrain = true; 24. // \u5982\u679c\u6b63\u5728\u5199\u6216\u8005\u8bbe\u7f6e\u4e86\u963b\u585e\u5219\u5148\u7f13\u5b58\u6570\u636e\uff0c\u5426\u5219\u76f4\u63a5\u5199\u5165 25. if (state.writing || state.corked) { 26. // \u6307\u5411\u5f53\u524d\u7684\u5c3e\u8282\u70b9 27. var last = state.lastBufferedRequest; 28. // \u63d2\u5165\u65b0\u7684\u5c3e\u7ed3\u70b9 29. state.lastBufferedRequest = { 30. chunk, 31. encoding, 32. isBuf, 33. callback: cb, 34. next: null 35. }; 36. /* 37. \u4e4b\u524d\u8fd8\u6709\u8282\u70b9\u7684\u8bdd\uff0c\u65e7\u7684\u5c3e\u8282\u70b9\u7684next\u6307\u9488\u6307\u5411\u65b0\u7684\u5c3e\u8282\u70b9\uff0c 38. \u5f62\u6210\u94fe\u8868 39. */ 40. if (last) { 41. last.next = state.lastBufferedRequest; 42. } else { 43. /* 44. \u6307\u5411buffer\u94fe\u8868\uff0cbufferedRequest\u76f8\u7b49\u4e8e\u5934\u6307\u9488\uff0c 45. \u63d2\u5165\u7b2c\u4e00\u4e2abuffer\u8282\u70b9\u7684\u65f6\u5019\u6267\u884c\u5230\u8fd9 46. */ 47. state.bufferedRequest = state.lastBufferedRequest; 48. } 49. // \u7f13\u5b58\u7684buffer\u4e2a\u6570\u52a0\u4e00 50. state.bufferedRequestCount += 1; 51. } else { 52. // \u76f4\u63a5\u5199\u5165 53. doWrite(stream, state, false, len, chunk, encoding, cb); 54. } 55. // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u6267\u884cwirte\uff0c\u5982\u679c\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u53ef\u4ee5\u7ee7\u7eed\u5199 56. return ret; 57. } writeOrBuffer\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u7684\u957f\u5ea6\uff0c\u5224\u65ad\u662f\u5426\u8fbe\u5230\u9608\u503c\uff0c\u7136\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u6267\u884cwrite\u7ee7\u7eed\u5199\u5165\u3002 2 \u5224\u65ad\u5f53\u524d\u662f\u5426\u6b63\u5728\u5199\u5165\u6216\u8005\u5904\u4e8ecork\u6a21\u5f0f\u3002\u662f\u7684\u8bdd\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\uff0c\u5426\u5219\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u7f13\u5b58\u7684\u903b\u8f91\u548c\u5f62\u6210\u7684\u6570\u636e\u7ed3\u6784\u3002 \u7f13\u5b58\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-3\u6240\u793a\u3002 \u56fe21-3 \u7f13\u5b58\u7b2c\u4e8c\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-4\u6240\u793a\u3002 \u56fe21-4 \u7f13\u5b58\u7b2c\u4e09\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-5 \u56fe21-5 \u6211\u4eec\u770b\u5230\uff0c\u51fd\u6570\u7684\u6570\u636e\u662f\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u7ba1\u7406\u7684\uff0c\u5176\u4e2dbufferedRequest\u662f\u94fe\u8868\u5934\u7ed3\u70b9\uff0clastBufferedRequest\u6307\u5411\u5c3e\u8282\u70b9\u3002\u5047\u8bbe\u5f53\u524d\u53ef\u5199\u6d41\u4e0d\u5904\u4e8e\u5199\u5165\u6216\u8005cork\u72b6\u6001\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5199\u5165\u7684\u903b\u8f91\u3002 1. function doWrite(stream, state, writev, len, chunk, encoding, cb) { 2. // \u672c\u6b21\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6 3. state.writelen = len; 4. // \u672c\u6b21\u5199\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 5. state.writecb = cb; 6. // \u6b63\u5728\u5199\u5165 7. state.writing = true; 8. // \u5047\u8bbe\u7528\u6237\u5b9a\u4e49\u7684_writev\u6216\u8005_write\u51fd\u6570\u662f\u540c\u6b65\u56de\u8c03onwrite 9. state.sync = true; 10. if (writev) 11. // chunk\u4e3a\u7f13\u5b58\u5f85\u5199\u5165\u7684buffer\u8282\u70b9\u6570\u7ec4 12. stream._writev(chunk, state.onwrite); 13. else 14. // \u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684\u5199\u51fd\u6570\uff0conwrite\u662fNode.js\u5b9a\u4e49\u7684\uff0c\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u8be5\u51fd\u6570 15. stream._write(chunk, encoding, state.onwrite); 16. /* 17. \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u56de\u8c03onwrite\uff0c\u5219\u8fd9\u53e5\u4ee3\u7801\u6ca1\u6709\u610f\u4e49\uff0c 18. \u5982\u679c\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u8fd9\u53e5\u4ee3\u7801\u4f1a\u5728onwrite\u4e4b\u524d\u6267\u884c\uff0c 19. \u5b83\u6807\u8bb0\u7528\u6237\u662f\u5f02\u6b65\u56de\u8c03\u6a21\u5f0f\uff0c\u5728onwrite\u4e2d\u9700\u8981\u5224\u65ad\u56de\u8c03\u6a21\u5f0f\uff0c\u5373sync\u7684\u503c 20. */ 21. state.sync = false; 22. } doWrite\u51fd\u6570\u8bb0\u5f55\u4e86\u672c\u6b21\u5199\u5165\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u957f\u5ea6\uff0c\u56de\u8c03\uff0c\u7136\u540e\u8bbe\u7f6e\u6b63\u5728\u5199\u6807\u8bb0\u3002\u6700\u540e\u6267\u884c\u5199\u5165\u3002\u5982\u679c\u5f53\u524d\u5f85\u5199\u5165\u7684\u6570\u636e\u662f\u7f13\u5b58\u7684\u6570\u636e\u5e76\u4e14\u7528\u6237\u5b9e\u73b0\u4e86_writev\u51fd\u6570\uff0c\u5219\u8c03\u7528_writev\u3002\u5426\u5219\u8c03\u7528_write\u3002\u4e0b\u9762\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u4f8b\u5b50\uff0c\u628a\u8fd9\u91cc\u7684\u903b\u8f91\u4e32\u8d77\u6765\u3002 1. const { Writable } = require('stream'); 2. class DemoWritable extends Writable { 3. constructor() { 4. super(); 5. this.data = null; 6. } 7. _write(chunk, encoding, cb) { 8. // \u4fdd\u5b58\u6570\u636e 9. this.data = this.data ? Buffer.concat([this.data, chunk]) : chunk; 10. // \u6267\u884c\u56de\u8c03\u544a\u8bc9\u53ef\u5199\u6d41\u5199\u5b8c\u6210\u4e86\uff0cfalse\u4ee3\u8868\u5199\u6210\u529f\uff0ctrue\u4ee3\u8868\u5199\u5931\u8d25 11. cb(null); 12. } 13. } DemoWritable\u5b9a\u4e49\u4e86\u6570\u636e\u6d41\u5411\u7684\u76ee\u7684\u5730\uff0c\u5728\u7528\u6237\u8c03\u7528write\u7684\u65f6\u5019\uff0c\u53ef\u5199\u6d41\u4f1a\u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684_write\uff0c_write\u4fdd\u5b58\u4e86\u6570\u636e\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u5e76\u4f20\u5165\u53c2\u6570\uff0c\u901a\u77e5\u53ef\u5199\u6d41\u6570\u636e\u5199\u5b8c\u6210\u4e86\uff0c\u5e76\u901a\u8fc7\u53c2\u6570\u6807\u8bb0\u5199\u6210\u529f\u8fd8\u662f\u5931\u8d25\u3002\u8fd9\u65f6\u5019\u56de\u5230\u53ef\u5199\u6d41\u4fa7\u3002\u6211\u4eec\u770b\u5230\u53ef\u5199\u6d41\u8bbe\u7f6e\u7684\u56de\u8c03\u662fonwrite\uff0conwrite\u662f\u5728\u521d\u59cb\u5316\u53ef\u5199\u6d41\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u3002 1. this.onwrite = onwrite.bind(undefined, stream); \u6211\u4eec\u63a5\u7740\u770bonwrite\u7684\u5b9e\u73b0\u3002 1. function onwrite(stream, er) { 2. var state = stream._writableState; 3. var sync = state.sync; 4. // \u672c\u6b21\u5199\u5b8c\u65f6\u6267\u884c\u7684\u56de\u8c03 5. var cb = state.writecb; 6. // \u91cd\u7f6e\u5185\u90e8\u5b57\u6bb5\u7684\u503c 7. // \u5199\u5b8c\u4e86\uff0c\u91cd\u7f6e\u56de\u8c03\uff0c\u8fd8\u6709\u591a\u5c11\u5355\u4f4d\u7684\u6570\u636e\u6ca1\u6709\u5199\u5165\uff0c\u6570\u636e\u5199\u5b8c\uff0c\u91cd\u7f6e\u672c\u6b21\u5f85\u5199\u5165\u7684\u6570\u636e\u6570\u4e3a0 8. state.writing = false; 9. state.writecb = null; 10. state.length -= state.writelen; 11. state.writelen = 0; 12. // \u5199\u51fa\u9519 13. if (er) 14. onwriteError(stream, state, sync, er, cb); 15. else { 16. // Check if we're actually ready to finish, but don't emit yet 17. // \u662f\u5426\u5df2\u7ecf\u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u4e5f\u5199\u5b8c\u4e86\uff08\u63d0\u4ea4\u5199\u64cd\u4f5c\u548c\u6700\u540e\u771f\u6b63\u6267\u884c\u4e2d\u95f4\u53ef\u80fd\u6267\u884c\u4e86end\uff09 18. var finished = needFinish(state); 19. // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u963b\u585e\u6807\u8bb0\uff0c\u4e5f\u4e0d\u5728\u5904\u7406buffer\uff0c\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u7f13\u5b58\u6570\u636e\uff0c\u5219\u8fdb\u884c\u5199\u5165 20. if (!finished && 21. !state.corked && 22. !state.bufferProcessing && 23. state.bufferedRequest) { 24. clearBuffer(stream, state); 25. } 26. // \u7528\u6237\u540c\u6b65\u56de\u8c03onwrite\u5219Node.js\u5f02\u6b65\u6267\u884c\u7528\u6237\u56de\u8c03 27. if (sync) { 28. process.nextTick(afterWrite, stream, state, finished, cb); 29. } else { 30. afterWrite(stream, state, finished, cb); 31. } 32. } 33. } onwrite\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u53ef\u5199\u6d41\u7684\u72b6\u6001\u548c\u6570\u636e 2 \u5199\u51fa\u9519\u5219\u89e6\u53d1error\u4e8b\u4ef6\u548c\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5199\u6210\u529f\u5219\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u7ee7\u7eed\u6267\u884c\u5199\u64cd\u4f5c\uff0c\u662f\u7684\u8bdd\u5219\u7ee7\u7eed\u5199\uff0c\u5426\u5219\u6267\u884c\u7528\u6237\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0bclearBuffer\u51fd\u6570\u7684\u903b\u8f91\uff0c\u8be5\u903b\u8f91\u4e3b\u8981\u662f\u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230\u76ee\u7684\u5730\u3002 1. function clearBuffer(stream, state) { 2. // \u6b63\u5728\u5904\u7406buffer 3. state.bufferProcessing = true; 4. // \u6307\u5411\u5934\u7ed3\u70b9 5. var entry = state.bufferedRequest; 6. // \u5b9e\u73b0\u4e86_writev\u5e76\u4e14\u6709\u4e24\u4e2a\u4ee5\u4e0a\u7684\u6570\u636e\u5757\uff0c\u5219\u6279\u91cf\u5199\u5165\uff0c\u5373\u4e00\u6b21\u628a\u6240\u6709\u7f13\u5b58\u7684buffer\u90fd\u5199\u5165 7. if (stream._writev && entry && entry.next) { 8. // Fast case, write everything using _writev() 9. var l = state.bufferedRequestCount; 10. var buffer = new Array(l); 11. var holder = state.corkedRequestsFree; 12. // \u6307\u5411\u5f85\u5199\u5165\u6570\u636e\u7684\u94fe\u8868 13. holder.entry = entry; 14. 15. var count = 0; 16. // \u6570\u636e\u662f\u5426\u5168\u90e8\u90fd\u662fbuffer\u683c\u5f0f 17. var allBuffers = true; 18. // \u628a\u7f13\u5b58\u7684\u8282\u70b9\u653e\u5230buffer\u6570\u7ec4\u4e2d 19. while (entry) { 20. buffer[count] = entry; 21. if (!entry.isBuf) 22. allBuffers = false; 23. entry = entry.next; 24. count += 1; 25. } 26. buffer.allBuffers = allBuffers; 27. 28. doWrite(stream, state, true, state.length, buffer, '', holder.finish); 29. 30. // \u5f85\u6267\u884c\u7684cb\u52a0\u4e00\uff0c\u5373holder.finish 31. state.pendingcb++; 32. // \u6e05\u7a7a\u7f13\u5b58\u961f\u5217 33. state.lastBufferedRequest = null; 34. // \u8fd8\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u66f4\u65b0\u6307\u9488,\u4e0b\u6b21\u4f7f\u7528 35. if (holder.next) { 36. state.corkedRequestsFree = holder.next; 37. holder.next = null; 38. } else { 39. // \u6ca1\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u6062\u590d\u503c\uff0c\u89c1\u521d\u59cb\u5316\u65f6\u7684\u8bbe\u7f6e 40. var corkReq = { next: null, entry: null, finish: undefined }; 41. corkReq.finish = onCorkedFinish.bind(undefined, corkReq, state); 42. state.corkedRequestsFree = corkReq; 43. } 44. state.bufferedRequestCount = 0; 45. } else { 46. // \u6162\u6162\u5199\uff0c\u5373\u4e00\u4e2a\u4e2abuffer\u5199\uff0c\u5199\u5b8c\u540e\u7b49\u9700\u8981\u6267\u884c\u7528\u6237\u7684cb\uff0c\u9a71\u52a8\u4e0b\u4e00\u4e2a\u5199 47. // Slow case, write chunks one-by-one 48. while (entry) { 49. var chunk = entry.chunk; 50. var encoding = entry.encoding; 51. var cb = entry.callback; 52. var len = state.objectMode ? 1 : chunk.length; 53. // \u6267\u884c\u5199\u5165 54. doWrite(stream, state, false, len, chunk, encoding, cb); 55. entry = entry.next; 56. // \u5904\u7406\u5b8c\u4e00\u4e2a\uff0c\u51cf\u4e00 57. state.bufferedRequestCount--; 58. 59. /* 60. \u5728onwrite\u91cc\u6e05\u9664\u8fd9\u4e2a\u6807\u8bb0\uff0conwrite\u4f9d\u8d56\u4e8e\u7528\u6237\u6267\u884c\uff0c\u5982\u679c\u7528\u6237\u6ca1\u8c03\uff0c 61. \u6216\u8005\u4e0d\u662f\u540c\u6b65\u8c03\uff0c\u5219\u9000\u51fa\uff0c\u7b49\u5f85\u6267\u884conwrite\u7684\u65f6\u5019\u518d\u7ee7\u7eed\u5199 62. */ 63. if (state.writing) { 64. break; 65. } 66. } 67. // \u5199\u5b8c\u4e86\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u66f4\u65b0\u6307\u9488 68. if (entry === null) 69. state.lastBufferedRequest = null; 70. } 71. /* 72. \u66f4\u65b0\u7f13\u5b58\u6570\u636e\u94fe\u8868\u7684\u5934\u7ed3\u70b9\u6307\u5411\uff0c 73. 1 \u5982\u679c\u662f\u6279\u91cf\u5199\u5219entry\u4e3anull 74. 2 \u5982\u679c\u5355\u4e2a\u5199\uff0c\u5219\u53ef\u80fd\u8fd8\u6709\u503c\uff08\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u8c03\u7528onwrite\u7684\u8bdd\uff09 75. */ 76. state.bufferedRequest = entry; 77. // \u672c\u8f6e\u5904\u7406\u5b8c\u6bd5\uff08\u5904\u7406\u5b8c\u4e00\u4e2a\u6216\u5168\u90e8\uff09 78. state.bufferProcessing = false; 79. } clearBuffer\u7684\u903b\u8f91\u770b\u8d77\u6765\u975e\u5e38\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u7b97\u5f88\u590d\u6742\u3002\u4e3b\u8981\u5206\u4e3a\u4e24\u4e2a\u5206\u652f\u3002 1 \u7528\u6237\u5b9e\u73b0\u4e86\u6279\u91cf\u5199\u51fd\u6570\uff0c\u5219\u4e00\u6b21\u628a\u7f13\u5b58\u7684\u65f6\u5019\u5199\u5165\u76ee\u7684\u5730\u3002\u9996\u5148\u628a\u7f13\u5b58\u7684\u6570\u636e\uff08\u94fe\u8868\uff09\u5168\u90e8\u6536\u96c6\u8d77\u6765\uff0c\u7136\u540e\u6267\u884c\u6267\u884c\u5199\u5165\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u662ffinish\u51fd\u6570\u3002corkedRequestsFree\u5b57\u6bb5\u6307\u5411\u4e00\u4e2a\u8282\u70b9\u6570\u6700\u5c11\u4e3a\u4e00\uff0c\u6700\u591a\u4e3a\u4e8c\u7684\u94fe\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u6279\u91cf\u5199\u7684\u6570\u636e\u7684\u4e0a\u4e0b\u6587\u3002\u6279\u91cf\u5199\u65f6\u7684\u6570\u636e\u7ed3\u6784\u56fe\u5982\u56fe21-6\u548c21-7\u6240\u793a\uff08\u4e24\u79cd\u573a\u666f\uff09\u3002 \u56fe21-6 \u56fe21-7 corkedRequestsFree\u4fdd\u8bc1\u6700\u5c11\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u7528\u4e8e\u4e00\u6b21\u6279\u91cf\u5199\uff0c\u5f53\u4f7f\u7528\u5b8c\u7684\u65f6\u5019\uff0c\u4f1a\u6700\u591a\u4fdd\u5b58\u4e24\u4e2a\u7a7a\u95f2\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u6210\u529f\u540e\uff0c\u56de\u8c03\u51fd\u6570onCorkedFinish\u7684\u903b\u8f91\u3002 1. function onCorkedFinish(corkReq, state, err) { 2. // corkReq.entry\u6307\u5411\u5f53\u524d\u5904\u7406\u7684buffer\u94fe\u8868\u5934\u7ed3\u70b9 3. var entry = corkReq.entry; 4. corkReq.entry = null; 5. // \u904d\u5386\u6267\u884c\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u56de\u8c03 6. while (entry) { 7. var cb = entry.callback; 8. state.pendingcb--; 9. cb(err); 10. entry = entry.next; 11. } 12. 13. // \u56de\u6536corkReq\uff0cstate.corkedRequestsFree\u8fd9\u65f6\u5019\u5df2\u7ecf\u7b49\u4e8e\u65b0\u7684corkReq\uff0c\u6307\u5411\u521a\u7528\u5b8c\u7684\u8fd9\u4e2acorkReq\uff0c\u5171\u4fdd\u5b58\u4e24\u4e2a 14. state.corkedRequestsFree.next = corkReq; 15. } onCorkedFinish\u9996\u5148\u4ece\u672c\u6b21\u6279\u91cf\u5199\u7684\u6570\u636e\u4e0a\u4e0b\u6587\u53d6\u51fa\u56de\u8c03\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u3002\u6700\u540e\u56de\u6536\u8282\u70b9\u3002corkedRequestsFree\u603b\u662f\u6307\u5411\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6240\u4ee5\u5982\u679c\u8282\u70b9\u8d85\u8fc7\u4e24\u4e2a\u65f6\uff0c\u6bcf\u6b21\u4f1a\u628a\u5c3e\u8282\u70b9\u4e22\u5f03\uff0c\u5982\u56fe21-8\u6240\u793a\u3002 \u56fe21-8 2 \u63a5\u7740\u6211\u4eec\u770b\u5355\u4e2a\u5199\u7684\u573a\u666f \u5355\u4e2a\u5199\u7684\u65f6\u5019\uff0c\u5c31\u662f\u901a\u8fc7doWrite\u628a\u6570\u636e\u9010\u4e2a\u5199\u5230\u76ee\u7684\u5730\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u5730\u65b9\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\uff08\u901a\u8fc7writing\u5b57\u6bb5\uff0c\u56e0\u4e3aonwrite\u4f1a\u7f6ewriting\u4e3atrue\uff0c\u5982\u679c\u6267\u884c\u5b8cdoWrite\uff0cwriting\u4e3afalse\u8bf4\u660e\u662f\u5f02\u6b65\u56de\u8c03\uff09\uff0c\u5219\u5199\u5165\u4e00\u4e2a\u6570\u636e\u540e\u5c31\u4e0d\u518d\u6267\u884cdoWrite\u8fdb\u884c\u5199\uff0c\u800c\u662f\u9700\u8981\u7b49\u5230onwrite\u56de\u8c03\u88ab\u5f02\u6b65\u6267\u884c\u65f6\uff0c\u518d\u6267\u884c\u4e0b\u4e00\u6b21\u5199\uff0c\u56e0\u4e3a\u53ef\u5199\u6d41\u662f\u4e32\u884c\u5730\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u4e0b\u9762\u8bb2\u4e00\u4e0bsync\u5b57\u6bb5\u7684\u4f5c\u7528\u3002sync\u5b57\u6bb5\u662f\u7528\u4e8e\u6807\u8bb0\u6267\u884c\u7528\u6237\u81ea\u5b9a\u4e49\u7684write\u51fd\u6570\u65f6\uff0cwrite\u51fd\u6570\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\u3002\u4e3b\u8981\u7528\u4e8e\u63a7\u5236\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002\u5e76\u4e14\u9700\u8981\u4fdd\u8bc1\u56de\u8c03\u8981\u6309\u7167\u5b9a\u4e49\u7684\u987a\u5e8f\u6267\u884c\u3002\u6709\u4e24\u4e2a\u5730\u65b9\u6d89\u53ca\u4e86\u8fd9\u4e2a\u903b\u8f91\uff0c\u7b2c\u4e00\u4e2a\u662fwirte\u7684\u65f6\u5019\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u7684\u8c03\u7528\u5173\u7cfb\uff0c\u5982\u56fe21-9\u6240\u793a\u3002 \u56fe21-9 \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u6267\u884conwrite\uff0c\u5219\u6570\u636e\u4f1a\u88ab\u5b9e\u65f6\u5730\u6d88\u8d39\uff0c\u4e0d\u5b58\u5728\u7f13\u5b58\u6570\u636e\u7684\u60c5\u51b5\uff0c\u8fd9\u65f6\u5019Node.js\u5f02\u6b65\u5e76\u4e14\u6709\u5e8f\u5730\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u5982\u679c\u7528\u6237\u8fde\u7eed\u4e24\u6b21\u8c03\u7528\u4e86write\u5199\u5165\u6570\u636e\uff0c\u5e76\u4e14\u662f\u4ee5\u5f02\u6b65\u6267\u884c\u56de\u8c03onwrite\uff0c\u5219\u7b2c\u4e00\u6b21\u6267\u884conwrite\u7684\u65f6\u5019\uff0c\u4f1a\u5b58\u5728\u7f13\u5b58\u7684\u6570\u636e\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6765\u5f97\u53ca\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5c31\u4f1a\u5148\u53d1\u751f\u7b2c\u4e8c\u6b21\u5199\u5165\u64cd\u4f5c\uff0c\u540c\u6837\uff0c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\u4e5f\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u6240\u4ee5\u63a5\u4e0b\u6765\u5c31\u4f1a\u540c\u6b65\u6267\u884c\u7684\u7528\u6237\u56de\u8c03\u3002\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u7528\u6237\u56de\u8c03\u7684\u987a\u5e8f\u6267\u884c\u3002\u7b2c\u4e8c\u79cd\u573a\u666f\u662funcork\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u5173\u7cfb\u56fe\uff0c\u5982\u56fe21-10\u6240\u793a\u3002 \u56fe21-10 \u5728uncork\u7684\u6267\u884c\u6d41\u7a0b\u4e2d\uff0c\u5982\u679conwrite\u662f\u88ab\u540c\u6b65\u56de\u8c03\uff0c\u5219\u5728onwrite\u4e2d\u4e0d\u4f1a\u518d\u6b21\u8c03\u7528clearBuffer\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u7684bufferProcessing\u4e3atrue\u3002\u8fd9\u65f6\u5019\u4f1a\u5148\u628a\u7528\u6237\u7684\u56de\u8c03\u5165\u961f\uff0c\u7136\u540e\u518d\u6b21\u6267\u884cdoWrite\u53d1\u8d77\u4e0b\u4e00\u6b21\u5199\u64cd\u4f5c\u3002\u5982\u679conwrite\u662f\u88ab\u5f02\u6b65\u6267\u884c\uff0c\u5728\u6267\u884cclearBuffer\u4e2d\uff0c\u7b2c\u4e00\u6b21\u6267\u884cdoWrite\u5b8c\u6bd5\u540e\uff0cclearBuffer\u5c31\u4f1a\u9000\u51fa\uff0c\u5e76\u4e14\u8fd9\u65f6\u5019bufferProcessing\u4e3afalse\u3002\u7b49\u5230onwrite\u88ab\u56de\u8c03\u7684\u65f6\u5019\uff0c\u518d\u6b21\u6267\u884cclearBuffer\uff0c\u540c\u6837\u6267\u884c\u5b8cdoWrite\u7684\u65f6\u5019\u9000\u51fa\uff0c\u7b49\u5f85\u5f02\u6b65\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u7528\u6237\u56de\u8c03\u88ab\u6267\u884c\u3002 \u6211\u4eec\u7ee7\u7eed\u5206\u6790onwrite\u7684\u4ee3\u7801\uff0conwrite\u6700\u540e\u4f1a\u8c03\u7528afterWrite\u51fd\u6570\u3002 1. function afterWrite(stream, state, finished, cb) { 2. // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u770b\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6 3. if (!finished) 4. onwriteDrain(stream, state); 5. // \u51c6\u5907\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5f85\u6267\u884c\u7684\u56de\u8c03\u51cf\u4e00 6. state.pendingcb--; 7. cb(); 8. finishMaybe(stream, state); 9. } 10. 11. function onwriteDrain(stream, state) { 12. // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u4e86\uff0c\u5e76\u4e14\u6d41\u5728\u963b\u585e\u4e2d\u7b49\u5f85drain\u4e8b\u4ef6 13. if (state.length === 0 && state.needDrain) { 14. // \u89e6\u53d1drain\u4e8b\u4ef6\u7136\u540e\u6e05\u7a7a\u6807\u8bb0 15. state.needDrain = false; 16. stream.emit('drain'); 17. } 18. } 19. afterWrite\u4e3b\u8981\u662f\u5224\u65ad\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u6700\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\uff08\u5728\u5f02\u6b65\u56de\u8c03onwrite\u7684\u60c5\u51b5\u4e0b\uff0c\u7528\u6237\u8c03\u7528\u56de\u8c03\u4e4b\u524d\uff0c\u53ef\u80fd\u6267\u884c\u4e86end\uff09\u3002\u6d41\u7ed3\u675f\u7684\u903b\u8f91\u6211\u4eec\u540e\u9762\u7ae0\u8282\u5355\u72ec\u5206\u6790\u3002 21.3.4 cork\u548cuncork \u00b6 cork\u548cuncork\u7c7b\u4f3ctcp\u4e2d\u7684negal\u7b97\u6cd5\uff0c\u4e3b\u8981\u7528\u4e8e\u7d2f\u79ef\u6570\u636e\u540e\u4e00\u6b21\u6027\u5199\u5165\u76ee\u7684\u5730\u3002\u800c\u4e0d\u662f\u6709\u4e00\u5757\u5c31\u5b9e\u65f6\u5199\u5165\u3002\u6bd4\u5982\u5728tcp\u4e2d\uff0c\u6bcf\u6b21\u53d1\u9001\u4e00\u4e2a\u5b57\u8282\uff0c\u800c\u534f\u8bae\u5934\u8fdc\u8fdc\u5927\u4e8e\u4e00\u5b57\u8282\uff0c\u6709\u6548\u6570\u636e\u5360\u6bd4\u975e\u5e38\u4f4e\u3002\u4f7f\u7528cork\u7684\u65f6\u5019\u6700\u597d\u540c\u65f6\u63d0\u4f9bwritev\u5b9e\u73b0\uff0c\u5426\u5219\u6700\u540ecork\u5c31\u6ca1\u6709\u610f\u4e49\uff0c\u56e0\u4e3a\u6700\u7ec8\u8fd8\u662f\u9700\u8981\u4e00\u5757\u5757\u7684\u6570\u636e\u8fdb\u884c\u5199\u5165\u3002\u6211\u4eec\u770b\u770bcork\u7684\u4ee3\u7801\u3002 1. Writable.prototype.cork = function() { 2. var state = this._writableState; 3. state.corked++; 4. }; cork\u7684\u4ee3\u7801\u975e\u5e38\u7b80\u5355\uff0c\u8fd9\u91cc\u4f7f\u7528\u4e00\u4e2a\u6574\u6570\u800c\u4e0d\u662f\u6807\u8bb0\u4f4d\uff0c\u6240\u4ee5cork\u548cuncork\u9700\u8981\u914d\u5bf9\u4f7f\u7528\u3002\u6211\u4eec\u770b\u770buncork\u3002 1. Writable.prototype.uncork = function() { 2. var state = this._writableState; 3. 4. if (state.corked) { 5. state.corked--; 6. /* 7. \u6ca1\u6709\u5728\u8fdb\u884c\u5199\u64cd\u4f5c\uff08\u5982\u679c\u8fdb\u884c\u5199\u64cd\u4f5c\u5219\u5728\u5199\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03\u91cc\u4f1a\u6267\u884cclearBuffer\uff09\uff0c 8. corked=0\uff0c 9. \u6ca1\u6709\u5728\u5904\u7406\u7f13\u5b58\u6570\u636e\uff08writing\u4e3afalse\u5df2\u7ecf\u8bf4\u660e\uff09\uff0c 10. \u6709\u7f13\u5b58\u7684\u6570\u636e\u5f85\u5904\u7406 11. */ 12. if (!state.writing && 13. !state.corked && 14. !state.bufferProcessing && 15. state.bufferedRequest) 16. clearBuffer(this, state); 17. } 18. }; 21.3.5 \u6d41\u7ed3\u675f \u00b6 \u6d41\u7ed3\u675f\u9996\u5148\u4f1a\u628a\u5f53\u524d\u7f13\u5b58\u7684\u6570\u636e\u5199\u5165\u76ee\u7684\u5730\uff0c\u5e76\u4e14\u5141\u8bb8\u518d\u6267\u884c\u989d\u5916\u7684\u4e00\u6b21\u5199\u64cd\u4f5c\uff0c\u7136\u540e\u628a\u53ef\u5199\u6d41\u7f6e\u4e3a\u4e0d\u53ef\u5199\u548c\u7ed3\u675f\u72b6\u6001\uff0c\u5e76\u4e14\u89e6\u53d1\u4e00\u7cfb\u5217\u4e8b\u4ef6\u3002\u4e0b\u9762\u662f\u7ed3\u675f\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u51fd\u6570\u5173\u7cfb\u56fe\u3002\u5982\u56fe21-11\u6240\u793a\u3002 \u56fe21-11 \u901a\u8fc7end\u51fd\u6570\u53ef\u4ee5\u7ed3\u675f\u53ef\u5199\u6d41\uff0c\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1. Writable.prototype.end = function(chunk, encoding, cb) { 2. var state = this._writableState; 3. 4. if (typeof chunk === 'function') { 5. cb = chunk; 6. chunk = null; 7. encoding = null; 8. } else if (typeof encoding === 'function') { 9. cb = encoding; 10. encoding = null; 11. } 12. // \u6700\u540e\u4e00\u6b21\u5199\u5165\u7684\u673a\u4f1a\uff0c\u53ef\u80fd\u76f4\u63a5\u5199\u5165\uff0c\u4e5f\u53ef\u4ee5\u4f1a\u88ab\u7f13\u5b58\uff08\u6b63\u5728\u5199\u62a4\u7740\u5904\u4e8ecorked\u72b6\u6001\uff09 13. if (chunk !== null && chunk !== undefined) 14. this.write(chunk, encoding); 15. 16. // \u5982\u679c\u5904\u4e8ecorked\u72b6\u6001\uff0c\u5219\u4e0a\u9762\u7684\u5199\u64cd\u4f5c\u4f1a\u88ab\u7f13\u5b58\uff0cuncork\u548cwrite\u4fdd\u5b58\u53ef\u4ee5\u5bf9\u5269\u4f59\u6570\u636e\u6267\u884c\u5199\u64cd\u4f5c 17. if (state.corked) { 18. // \u7f6e1\uff0c\u4e3a\u4e86uncork\u80fd\u6b63\u786e\u6267\u884c,\u53ef\u4ee5\u6709\u673a\u4f1a\u5199\u5165\u7f13\u5b58\u7684\u6570\u636e 19. state.corked = 1; 20. this.uncork(); 21. } 22. 23. if (!state.ending) 24. endWritable(this, state, cb); 25. }; \u6211\u4eec\u63a5\u7740\u770bendWritable\u51fd\u6570 1. function endWritable(stream, state, cb) { 2. // \u6b63\u5728\u6267\u884cend\u51fd\u6570 3. state.ending = true; 4. // \u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u4e86 5. finishMaybe(stream, state); 6. if (cb) { 7. // \u5df2\u7ecf\u89e6\u53d1\u4e86finish\u4e8b\u4ef6\u5219\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884ccb\uff0c\u5426\u5219\u7b49\u5f85finish\u4e8b\u4ef6 8. if (state.finished) 9. process.nextTick(cb); 10. else 11. stream.once('finish', cb); 12. } 13. // \u6d41\u7ed3\u675f\uff0c\u6d41\u4e0d\u53ef\u5199 14. state.ended = true; 15. stream.writable = false; 16. } endWritable\u51fd\u6570\u6807\u8bb0\u6d41\u4e0d\u53ef\u5199\u5e76\u4e14\u5904\u4e8e\u7ed3\u675f\u72b6\u6001\u3002\u4f46\u662f\u53ea\u662f\u4ee3\u8868\u4e0d\u80fd\u518d\u8c03\u7528write\u5199\u6570\u636e\u4e86\uff0c\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e\u9700\u8981\u88ab\u5199\u5b8c\u540e\u624d\u80fd\u771f\u6b63\u5730\u7ed3\u675f\u6d41\u3002\u6211\u4eec\u770bfinishMaybe\u51fd\u6570\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u7528\u4e8e\u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u3002 1. function needFinish(state) { 2. /* 3. \u6267\u884c\u4e86end\u51fd\u6570\u5219\u8bbe\u7f6eending=true\uff0c 4. \u5f53\u524d\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86\uff0c 5. \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c 6. \u8fd8\u6ca1\u6709\u89e6\u53d1finish\u4e8b\u4ef6\uff0c 7. \u6ca1\u6709\u6b63\u5728\u8fdb\u884c\u5199\u5165 8. */ 9. return (state.ending && 10. state.length === 0 && 11. state.bufferedRequest === null && 12. !state.finished && 13. !state.writing); 14. } 15. 16. // \u6bcf\u6b21\u5199\u5b8c\u6210\u7684\u65f6\u5019\u4e5f\u4f1a\u8c03\u7528\u8be5\u51fd\u6570 17. function finishMaybe(stream, state) { 18. // \u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f 19. var need = needFinish(state); 20. // \u662f\u5219\u5148\u5904\u7406prefinish\u4e8b\u4ef6\uff0c\u5426\u5219\u5148\u4e0d\u7ba1\uff0c\u7b49\u5f85\u5199\u5b8c\u6210\u518d\u8c03\u7528\u8be5\u51fd\u6570 21. if (need) { 22. prefinish(stream, state); 23. // \u5982\u679c\u6ca1\u6709\u5f85\u6267\u884c\u7684\u56de\u8c03\uff0c\u5219\u89e6\u53d1finish\u4e8b\u4ef6 24. if (state.pendingcb === 0) { 25. state.finished = true; 26. stream.emit('finish'); 27. } 28. } 29. return need; 30. } \u5f53\u53ef\u5199\u6d41\u4e2d\u6240\u6709\u6570\u636e\u548c\u56de\u8c03\u90fd\u6267\u884c\u4e86\u624d\u80fd\u7ed3\u675f\u6d41\uff0c\u5728\u7ed3\u675f\u6d41\u4e4b\u524d\u4f1a\u5148\u5904\u7406prefinish\u4e8b\u4ef6\u3002 1. function callFinal(stream, state) { 2. // \u6267\u884c\u7528\u6237\u7684final\u51fd\u6570 3. stream._final((err) => { 4. // \u6267\u884c\u4e86callFinal\u51fd\u6570\uff0ccb\u51cf\u4e00 5. state.pendingcb--; 6. if (err) { 7. stream.emit('error', err); 8. } 9. // \u6267\u884cprefinish 10. state.prefinished = true; 11. stream.emit('prefinish'); 12. // \u662f\u5426\u53ef\u4ee5\u89e6\u53d1finish\u4e8b\u4ef6 13. finishMaybe(stream, state); 14. }); 15. } 16. function prefinish(stream, state) { 17. // \u8fd8\u6ca1\u89e6\u53d1prefinish\u5e76\u4e14\u6ca1\u6709\u6267\u884cfinalcall 18. if (!state.prefinished && !state.finalCalled) { 19. // \u7528\u6237\u4f20\u4e86final\u51fd\u6570\u5219\uff0c\u5f85\u6267\u884c\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373callFinal\uff0c\u5426\u5219\u76f4\u63a5\u89e6\u53d1prefinish 20. if (typeof stream._final === 'function') { 21. state.pendingcb++; 22. state.finalCalled = true; 23. process.nextTick(callFinal, stream, state); 24. } else { 25. state.prefinished = true; 26. stream.emit('prefinish'); 27. } 28. } 29. } \u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86_final\u51fd\u6570\uff0c\u5219\u5148\u6267\u884c\u8be5\u51fd\u6570\uff08\u8fd9\u65f6\u5019\u4f1a\u963b\u6b62finish\u4e8b\u4ef6\u7684\u89e6\u53d1\uff09\uff0c\u6267\u884c\u5b8c\u540e\u89e6\u53d1prefinish\uff0c\u518d\u89e6\u53d1finish\u3002\u5982\u679c\u6ca1\u6709\u5b9a\u4e49_final\uff0c\u5219\u76f4\u63a5\u89e6\u53d1prefinish\u4e8b\u4ef6\u3002\u6700\u540e\u89e6\u53d1finish\u4e8b\u4ef6\u3002 21.4 \u53cc\u5411\u6d41 \u00b6 \u53cc\u5411\u6d41\u662f\u7ee7\u627f\u53ef\u8bfb\u3001\u53ef\u5199\u7684\u6d41\u3002 1. util.inherits(Duplex, Readable); 2. 3. { 4. // \u628a\u53ef\u5199\u6d41\u4e2d\u5b58\u5728\uff0c\u5e76\u4e14\u5728\u53ef\u8bfb\u6d41\u548cDuplex\u91cc\u90fd\u4e0d\u5b58\u5728\u7684\u65b9\u6cd5\u52a0\u5165\u5230Duplex 5. const keys = Object.keys(Writable.prototype); 6. for (var v = 0; v < keys.length; v++) { 7. const method = keys[v]; 8. if (!Duplex.prototype[method]) 9. Duplex.prototype[method] = Writable.prototype[method]; 10. } 11. } 1. function Duplex(options) { 2. if (!(this instanceof Duplex)) 3. return new Duplex(options); 4. 5. Readable.call(this, options); 6. Writable.call(this, options); 7. // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u8bfb 8. if (options && options.readable === false) 9. this.readable = false; 10. // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u5199 11. if (options && options.writable === false) 12. this.writable = false; 13. // \u9ed8\u8ba4\u5141\u8bb8\u534a\u5f00\u5173 14. this.allowHalfOpen = true; 15. if (options && options.allowHalfOpen === false) 16. this.allowHalfOpen = false; 17. 18. this.once('end', onend); 19. } \u53cc\u5411\u6d41\u7ee7\u627f\u4e86\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u80fd\u529b\u3002\u53cc\u5411\u6d41\u5b9e\u73b0\u4e86\u4ee5\u4e0b\u529f\u80fd 21.4.1 \u9500\u6bc1 \u00b6 \u5982\u679c\u8bfb\u5199\u4e24\u7aef\u90fd\u9500\u6bc1\uff0c\u5219\u53cc\u5411\u6d41\u9500\u6bc1\u3002 1. Object.defineProperty(Duplex.prototype, 'destroyed', { 2. enumerable: false, 3. get() { 4. if (this._readableState === undefined || 5. this._writableState === undefined) { 6. return false; 7. } 8. return this._readableState.destroyed && this._writableState.destroyed; 9. } 10. } \u6211\u4eec\u770b\u5982\u4f55\u9500\u6bc1\u4e00\u4e2a\u53cc\u5411\u6d41\u3002 1. Duplex.prototype._destroy = function(err, cb) { 2. // \u5173\u95ed\u8bfb\u7aef 3. this.push(null); 4. // \u5173\u95ed\u5199\u7aef 5. this.end(); 6. // \u6267\u884c\u56de\u8c03 7. process.nextTick(cb, err); 8. }; \u53cc\u5411\u6d41\u8fd8\u6709\u4e00\u4e2a\u7279\u6027\u662f\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5373\u53ef\u8bfb\u6216\u53ef\u5199\u3002onend\u662f\u8bfb\u7aef\u5173\u95ed\u65f6\u6267\u884c\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1. // \u5173\u95ed\u5199\u6d41 2. function onend() { 3. // \u5141\u8bb8\u534a\u5f00\u5173\u6216\u5199\u6d41\u5df2\u7ecf\u7ed3\u675f\u5219\u8fd4\u56de 4. if (this.allowHalfOpen || this._writableState.ended) 5. return; 6. // \u4e0b\u4e00\u4e2atick\u518d\u5173\u95ed\u5199\u6d41\uff0c\u6267\u884c\u5b8c\u8fd9\u6bb5\u4ee3\u7801\uff0c\u7528\u6237\u8fd8\u53ef\u4ee5\u5199 7. process.nextTick(onEndNT, this); 8. } 9. 10. function onEndNT(self) { 11. // \u8c03\u7528\u5199\u7aef\u7684end\u51fd\u6570 12. self.end(); 13. } \u5f53\u53cc\u5411\u6d41\u5141\u8bb8\u534a\u5f00\u5173\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5173\u95ed\u65f6\uff0c\u53ef\u5199\u6d41\u53ef\u4ee5\u4e0d\u5173\u95ed\u3002","title":"20-JS Stream"},{"location":"chapter21-JS%20Stream/#211","text":"1. const EE = require('events'); 2. const util = require('util'); 3. // \u6d41\u7684\u57fa\u7c7b 4. function Stream() { 5. EE.call(this); 6. } 7. // \u7ee7\u627f\u4e8b\u4ef6\u8ba2\u9605\u5206\u53d1\u7684\u80fd\u529b 8. util.inherits(Stream, EE); \u6d41\u7684\u57fa\u7c7b\u53ea\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570\u5c31\u662fpipe\u3002\u7528\u4e8e\u5b9e\u73b0\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u662f\u5bf9\u6570\u636e\u4ece\u4e00\u4e2a\u5730\u65b9\u6d41\u5411\u53e6\u4e00\u4e2a\u5730\u65b9\u7684\u62bd\u8c61\u3002\u8fd9\u4e2a\u65b9\u6cd5\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5206\u5f00\u8bf4\u3002","title":"21.1 \u6d41\u57fa\u7c7b\u548c\u6d41\u901a\u7528\u903b\u8f91"},{"location":"chapter21-JS%20Stream/#2111","text":"1. // \u6570\u636e\u6e90\u5bf9\u8c61 2. var source = this; 3. 4. // \u76d1\u542cdata\u4e8b\u4ef6\uff0c\u53ef\u8bfb\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 5. source.on('data', ondata); 6. function ondata(chunk) { 7. // \u6e90\u6d41\u6709\u6570\u636e\u5230\u8fbe\uff0c\u5e76\u4e14\u76ee\u7684\u6d41\u53ef\u5199 8. if (dest.writable) { 9. /* 10. \u76ee\u7684\u6d41\u8fc7\u8f7d\u5e76\u4e14\u6e90\u6d41\u5b9e\u73b0\u4e86pause\u65b9\u6cd5\uff0c 11. \u90a3\u5c31\u6682\u505c\u53ef\u8bfb\u6d41\u7684\u8bfb\u53d6\u64cd\u4f5c\uff0c\u7b49\u5f85\u76ee\u7684\u6d41\u89e6\u53d1drain\u4e8b\u4ef6 12. */ 13. if (false === dest.write(chunk) && source.pause) { 14. source.pause(); 15. } 16. } 17. } 18. 19. // \u76d1\u542cdrain\u4e8b\u4ef6\uff0c\u76ee\u7684\u6d41\u53ef\u4ee5\u6d88\u8d39\u6570\u636e\u4e86\u5c31\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6 20. dest.on('drain', ondrain); 21. function ondrain() { 22. // \u76ee\u7684\u6d41\u53ef\u7ee7\u7eed\u5199\u4e86\uff0c\u5e76\u4e14\u53ef\u8bfb\u6d41\u53ef\u8bfb\uff0c\u5207\u6362\u6210\u81ea\u52a8\u8bfb\u53d6\u6a21\u5f0f 23. if (source.readable && source.resume) { 24. source.resume(); 25. } 26. } \u8fd9\u662f\u7ba1\u9053\u5316\u65f6\u6d41\u63a7\u5b9e\u73b0\u7684\u5730\u65b9\uff0c\u4e3b\u8981\u662f\u5229\u7528\u4e86write\u8fd4\u56de\u503c\u548cdrain\u4e8b\u4ef6\u3002","title":"21.1.1\u5904\u7406\u6570\u636e\u4e8b\u4ef6"},{"location":"chapter21-JS%20Stream/#2112","text":"1. /* 2. 1 dest._isStdio\u662ftrue\u8868\u793a\u76ee\u7684\u6d41\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\uff08\u89c1 3. process/stdio.js\uff09\uff0c 4. 2 \u914d\u7f6e\u7684end\u5b57\u6bb5\u4ee3\u8868\u53ef\u8bfb\u6d41\u89e6\u53d1end\u6216close\u4e8b\u4ef6\u65f6\uff0c\u662f\u5426\u81ea\u52a8\u5173\u95ed\u53ef\u5199 5. \u6d41\uff0c\u9ed8\u8ba4\u662f\u81ea\u52a8\u5173\u95ed\u3002\u5982\u679c\u914d\u7f6e\u4e86end\u662ffalse\uff0c\u5219\u53ef\u8bfb\u6d41\u8fd9\u4e24\u4e2a\u4e8b\u4ef6\u89e6\u53d1 6. \u65f6\uff0c\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5173\u95ed\u53ef\u5199\u6d41\u3002 7. 3 \u6211\u4eec\u770b\u5230\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u53ef\u5199\u6d41\u662f\u4e0d\u4f1a\u88ab\u81ea\u52a8\u5173\u95ed\u7684\uff0c\u9700\u8981\u6211 8. \u4eec\u81ea\u5df1\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u624b\u52a8\u5173\u95ed\u53ef\u5199\u6d41\u3002\u6240\u4ee5if\u7684\u5224\u65ad\u610f\u601d 9. \u662f\u4e0d\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\u6d41\uff0c\u5e76\u4e14\u6ca1\u6709\u914d\u7f6eend\u662ffalse\u7684\u65f6\u5019\uff0c\u4f1a\u81ea\u52a8 10. \u5173\u95ed\u53ef\u5199\u6d41\u3002\u800c\u6807\u51c6\u8f93\u51fa\u548c\u6807\u51c6\u9519\u8bef\u6d41\u662f\u5728\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u624d\u88ab\u5173\u95ed\u7684\u3002 11. */ 12. if (!dest._isStdio && (!options || options.end !== false)) { 13. // \u6e90\u6d41\u6ca1\u6709\u6570\u636e\u53ef\u8bfb\u4e86\uff0c\u6267\u884cend\u56de\u8c03 14. source.on('end', onend); 15. // \u6e90\u6d41\u5173\u95ed\u4e86\uff0c\u6267\u884cclose\u56de\u8c03 16. source.on('close', onclose); 17. } 18. 19. var didOnEnd = false; 20. function onend() { 21. if (didOnEnd) return; 22. didOnEnd = true; 23. // \u6267\u884c\u76ee\u7684\u6d41\u7684end\uff0c\u8bf4\u660e\u5199\u6570\u636e\u5b8c\u6bd5 24. dest.end(); 25. } 26. 27. function onclose() { 28. if (didOnEnd) return; 29. didOnEnd = true; 30. // \u9500\u6bc1\u76ee\u7684\u6d41 31. if (typeof dest.destroy === 'function') dest.destroy(); 32. } \u4e0a\u9762\u662f\u53ef\u8bfb\u6e90\u6d41\u7ed3\u675f\u6216\u5173\u95ed\u540e\uff0c\u5982\u4f55\u5904\u7406\u53ef\u5199\u6d41\u7684\u903b\u8f91\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u53ef\u5199\u6d41\u7684\u5173\u95ed\u64cd\u4f5c\u3002","title":"21.1.2\u6d41\u5173\u95ed/\u7ed3\u675f\u5904\u7406"},{"location":"chapter21-JS%20Stream/#2113","text":"1. // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u51fa\u9519\u7684\u65f6\u5019\u90fd\u9700\u8981\u505c\u6b62\u6570\u636e\u7684\u5904\u7406 2. source.on('error', onerror); 3. dest.on('error', onerror); 4. // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u89e6\u53d1error\u4e8b\u4ef6\u65f6\u7684\u5904\u7406\u903b\u8f91 5. function onerror(er) { 6. // \u51fa\u9519\u4e86\uff0c\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u5305\u62ec\u6b63\u5728\u6267\u884c\u7684onerror\u51fd\u6570 7. cleanup(); 8. /* 9. \u5982\u679c\u7528\u6237\u6ca1\u6709\u76d1\u542c\u6d41\u7684error\u4e8b\u4ef6\uff0c\u5219\u629b\u51fa\u9519\u8bef\uff0c 10. \u6240\u4ee5\u6211\u4eec\u4e1a\u52a1\u4ee3\u7801\u9700\u8981\u76d1\u542cerror\u4e8b\u4ef6 11. */ 12. if (EE.listenerCount(this, 'error') === 0) { 13. throw er; // Unhandled stream error in pipe. 14. } 15. } \u5728error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7cleanup\u51fd\u6570\u6e05\u9664\u4e86Node.js\u672c\u8eab\u6ce8\u518c\u7684error\u4e8b\u4ef6\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\uff0c\u5219error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0,\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6ce8\u518cerror\u4e8b\u4ef6\u3002\u4e0b\u9762\u6211\u4eec\u518d\u5206\u6790cleanup\u51fd\u6570\u7684\u903b\u8f91\u3002","title":"21.1.3 \u9519\u8bef\u5904\u7406"},{"location":"chapter21-JS%20Stream/#2114","text":"1. // \u4fdd\u8bc1\u6e90\u6d41\u5173\u95ed\u3001\u6570\u636e\u8bfb\u5b8c\u3001\u76ee\u7684\u6d41\u5173\u95ed\u65f6\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6 2. source.on('end', cleanup); 3. source.on('close', cleanup); 4. dest.on('close', cleanup); 5. // \u6e05\u9664\u6240\u6709\u53ef\u80fd\u4f1a\u7ed1\u5b9a\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\uff0c\u6267\u884c\u6e05\u9664\u4e5f\u662f\u65e0\u5bb3\u7684 6. function cleanup() { 7. source.removeListener('data', ondata); 8. dest.removeListener('drain', ondrain); 9. 10. source.removeListener('end', onend); 11. source.removeListener('close', onclose); 12. 13. source.removeListener('error', onerror); 14. dest.removeListener('error', onerror); 15. 16. source.removeListener('end', cleanup); 17. source.removeListener('close', cleanup); 18. 19. dest.removeListener('close', cleanup); 20. } 21. 22. // \u89e6\u53d1\u76ee\u7684\u6d41\u7684pipe\u4e8b\u4ef6 23. dest.emit('pipe', source); 24. // \u652f\u6301\u8fde\u7eed\u7684\u7ba1\u9053\u5316A.pipe(B).pipe(C) 25. return dest;","title":"21.1.4 \u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6"},{"location":"chapter21-JS%20Stream/#2115","text":"\u901a\u8fc7getHighWaterMark\uff08lib\\internal\\streams\\state.js\uff09\u51fd\u6570\u53ef\u4ee5\u8ba1\u7b97\u51fa\u6d41\u7684\u9608\u503c\uff0c\u9608\u503c\u7528\u4e8e\u63a7\u5236\u7528\u6237\u8bfb\u5199\u6570\u636e\u7684\u901f\u5ea6\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1. function getHighWaterMark(state, options, duplexKey, isDuplex) { // \u7528\u6237\u5b9a\u4e49\u7684\u9608\u503c 2. let hwm = options.highWaterMark; 3. // \u7528\u6237\u5b9a\u4e49\u4e86\uff0c\u5219\u6821\u9a8c\u662f\u5426\u5408\u6cd5 4. if (hwm != null) { 5. if (typeof hwm !== 'number' || !(hwm >= 0)) 6. throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 7. 'highWaterMark', 8. hwm); 9. return Math.floor(hwm); 10. } else if (isDuplex) { 11. // \u7528\u6237\u6ca1\u6709\u5b9a\u4e49\u516c\u5171\u7684\u9608\u503c\uff0c\u5373\u8bfb\u5199\u6d41\u516c\u7528\u7684\u9608\u503c 12. // \u7528\u6237\u662f\u5426\u5b9a\u4e49\u4e86\u6d41\u5355\u72ec\u7684\u9608\u503c\uff0c\u6bd4\u5982\u8bfb\u6d41\u7684\u9608\u503c\u6216\u8005\u5199\u6d41\u7684\u9608\u503c 13. hwm = options[duplexKey]; 14. // \u7528\u6237\u6709\u5b9a\u4e49 15. if (hwm != null) { 16. if (typeof hwm !== 'number' || !(hwm >= 0)) 17. throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 18. duplexKey, 19. hwm); 20. return Math.floor(hwm); 21. } 22. } 23. 24. // \u9ed8\u8ba4\u503c\uff0c\u5bf9\u8c61\u662f16\u4e2a\uff0cbuffer\u662f16KB 25. return state.objectMode ? 16 : 16 * 1024; 26. } getHighWaterMark\u51fd\u6570\u903b\u8f91\u5982\u4e0b 1 \u7528\u6237\u5b9a\u4e49\u4e86\u5408\u6cd5\u7684\u9608\u503c\uff0c\u5219\u53d6\u7528\u6237\u5b9a\u4e49\u7684\uff08\u53ef\u8bfb\u6d41\u3001\u53ef\u5199\u6d41\u3001\u53cc\u5411\u6d41\uff09\u3002 2 \u5982\u679c\u662f\u53cc\u5411\u6d41\uff0c\u5e76\u4e14\u7528\u6237\u6ca1\u6709\u53ef\u8bfb\u6d41\u53ef\u5199\u6d41\u5171\u4eab\u7684\u5b9a\u4e49\u9608\u503c\uff0c\u6839\u636e\u5f53\u524d\u662f\u53ef\u8bfb\u6d41\u8fd8\u662f\u53ef\u5199\u6d41\uff0c\u5224\u65ad\u7528\u6237\u662f\u5426\u8bbe\u7f6e\u5bf9\u5e94\u6d41\u7684\u9608\u503c\u3002\u6709\u5219\u53d6\u7528\u6237\u8bbe\u7f6e\u7684\u503c\u4f5c\u4e3a\u9608\u503c\u3002 3 \u5982\u679c\u4e0d\u6ee1\u8db31,2\uff0c\u5219\u8fd4\u56de\u9ed8\u8ba4\u503c\u3002","title":"21.1.5 \u6d41\u7684\u9608\u503c"},{"location":"chapter21-JS%20Stream/#2116","text":"\u901a\u8fc7\u8c03\u7528destroy\u51fd\u6570\u53ef\u4ee5\u9500\u6bc1\u4e00\u4e2a\u6d41\uff0c\u5305\u62ec\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u3002\u5e76\u4e14\u53ef\u4ee5\u5b9e\u73b0_ destroy\u51fd\u6570\u81ea\u5b9a\u4e49\u9500\u6bc1\u7684\u884c\u4e3a\u3002\u6211\u4eec\u770b\u770b\u53ef\u5199\u6d41\u7684destroy\u51fd\u6570\u5b9a\u4e49\u3002 1. function destroy(err, cb) { 2. // \u8bfb\u6d41\u3001\u5199\u6d41\u3001\u53cc\u5411\u6d41 3. const readableDestroyed = this._readableState && 4. this._readableState.destroyed; 5. const writableDestroyed = this._writableState && 6. this._writableState.destroyed; 7. // \u6d41\u662f\u5426\u5df2\u7ecf\u9500\u6bc1\uff0c\u662f\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03 8. if (readableDestroyed || writableDestroyed) { 9. // \u4f20\u4e86cb\uff0c\u5219\u6267\u884c\uff0c\u53ef\u9009\u5730\u4f20\u5165err\uff0c\u7528\u6237\u5b9a\u4e49\u7684err 10. if (cb) { 11. cb(err); 12. } else if (err && 13. (!this._writableState || 14. !this._writableState.errorEmitted)) { 15. /* \u4f20\u4e86err\uff0c\u662f\u8bfb\u6d41\u6216\u8005\u6ca1\u6709\u89e6\u53d1\u8fc7error\u4e8b\u4ef6\u7684\u5199\u6d41\uff0c 16. \u5219\u89e6\u53d1error\u4e8b\u4ef6 17. */ 18. process.nextTick(emitErrorNT, this, err); 19. } 20. return this; 21. } 22. 23. // \u8fd8\u6ca1\u6709\u9500\u6bc1\u5219\u5f00\u59cb\u9500\u6bc1\u6d41\u7a0b 24. if (this._readableState) { 25. this._readableState.destroyed = true; 26. } 27. 28. if (this._writableState) { 29. this._writableState.destroyed = true; 30. } 31. // \u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49_destroy\u51fd\u6570 32. this._destroy(err || null, (err) => { 33. // \u6ca1\u6709cb\u4f46\u662f\u6709error\uff0c\u5219\u89e6\u53d1error\u4e8b\u4ef6 34. if (!cb && err) { 35. process.nextTick(emitErrorNT, this, err); 36. // \u53ef\u5199\u6d41\u5219\u6807\u8bb0\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 37. if (this._writableState) { 38. this._writableState.errorEmitted = true; 39. } 40. } else if (cb) { // \u6709cb\u6216\u8005\u6ca1\u6709err 41. cb(err); 42. } 43. }); 44. 45. return this; 46. } destroy\u51fd\u6570\u9500\u6bc1\u6d41\u7684\u901a\u7528\u903b\u8f91\u3002\u5176\u4e2d_destroy\u51fd\u6570\u4e0d\u540c\u7684\u6d41\u4e0d\u4e00\u6837\uff0c\u4e0b\u9762\u5206\u522b\u662f\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1 \u53ef\u8bfb\u6d41 1. Readable.prototype._destroy = function(err, cb) { 2. this.push(null); 3. cb(err); 4. }; 2 \u53ef\u5199\u6d41 1. Writable.prototype._destroy = function(err, cb) { 2. this.end(); 3. cb(err); 4. };","title":"21.1.6 \u9500\u6bc1\u6d41"},{"location":"chapter21-JS%20Stream/#212","text":"Node.js\u4e2d\u53ef\u8bfb\u6d41\u6709\u4e24\u79cd\u5de5\u4f5c\u6a21\u5f0f\uff1a\u6d41\u5f0f\u548c\u6682\u505c\u5f0f\uff0c\u6d41\u5f0f\u5c31\u662f\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u56de\u8c03\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4f20\u7ed9\u56de\u8c03\uff0c\u6682\u505c\u5f0f\u5c31\u662f\u9700\u8981\u7528\u6237\u81ea\u5df1\u624b\u52a8\u6267\u884c\u8bfb\u53d6\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u901a\u8fc7\u6e90\u7801\u53bb\u4e86\u89e3\u4e00\u4e0b\u53ef\u8bfb\u6d41\u5b9e\u73b0\u7684\u4e00\u4e9b\u903b\u8f91\u3002\u56e0\u4e3a\u5b9e\u73b0\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u903b\u8f91\u4e5f\u6bd4\u8f83\u7ed5\uff0c\u672c\u6587\u53ea\u5206\u6790\u4e00\u4e9b\u4e3b\u8981\u7684\u903b\u8f91\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bReadableState\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u8868\u793a\u53ef\u8bfb\u6d41\u7684\u4e00\u4e9b\u72b6\u6001\u548c\u5c5e\u6027\u7684\u3002 1. function ReadableState(options, stream) { 2. options = options || {}; 3. // \u662f\u5426\u662f\u53cc\u5411\u6d41 4. var isDuplex = stream instanceof Stream.Duplex; 5. // \u6570\u636e\u6a21\u5f0f 6. this.objectMode = !!options.objectMode; 7. // \u53cc\u5411\u6d41\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u8bfb\u7aef\u7684\u6a21\u5f0f 8. if (isDuplex) 9. this.objectMode = this.objectMode || 10. !!options.readableObjectMode; 11. // \u8bfb\u5230highWaterMark\u4e2a\u5b57\u8282\u5219\u505c\u6b62\uff0c\u5bf9\u8c61\u6a21\u5f0f\u7684\u8bdd\u5219\u662f16\u4e2a\u5bf9\u8c61 12. this.highWaterMark = getHighWaterMark(this, 13. options, 'readableHighWaterMark', 14. isDuplex); 15. // \u5b58\u50a8\u6570\u636e\u7684\u7f13\u51b2\u533a 16. this.buffer = new BufferList(); 17. // \u53ef\u8bfb\u6570\u636e\u7684\u957f\u5ea6 18. this.length = 0; 19. // \u7ba1\u9053\u7684\u76ee\u7684\u6e90\u548c\u4e2a\u6570 20. this.pipes = null; 21. this.pipesCount = 0; 22. // \u5de5\u4f5c\u6a21\u5f0f 23. this.flowing = null; 24. // \u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f 25. this.ended = false; 26. // \u662f\u5426\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\u4e86 27. this.endEmitted = false; 28. // \u662f\u5426\u6b63\u5728\u8bfb\u53d6\u6570\u636e 29. this.reading = false; 30. // \u662f\u5426\u540c\u6b65\u6267\u884c\u4e8b\u4ef6 31. this.sync = true; 32. // \u662f\u5426\u9700\u8981\u89e6\u53d1readable\u4e8b\u4ef6 33. this.needReadable = false; 34. // \u662f\u5426\u89e6\u53d1\u4e86readable\u4e8b\u4ef6 35. this.emittedReadable = false; 36. // \u662f\u5426\u76d1\u542c\u4e86readable\u4e8b\u4ef6 37. this.readableListening = false; 38. // \u662f\u5426\u6b63\u5728\u6267\u884cresume\u7684\u8fc7\u7a0b 39. this.resumeScheduled = false; 40. // \u6d41\u662f\u5426\u5df2\u9500\u6bc1 41. this.destroyed = false; 42. // \u6570\u636e\u7f16\u7801\u683c\u5f0f 43. this.defaultEncoding = options.defaultEncoding || 'utf8'; 44. /* 45. \u5728\u7ba1\u9053\u5316\u4e2d\uff0c\u6709\u591a\u5c11\u4e2a\u5199\u8005\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c 46. \u9700\u8981\u7b49\u5f85\u89e6\u53d1drain\u4e8b\u4ef6,awaitDrain\u8bb0\u5f55\u8fbe\u5230\u9608\u503c\u7684\u5199\u8005\u4e2a\u6570 47. */ 48. this.awaitDrain = 0; 49. // \u6267\u884cmaybeReadMore\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e3atrue 50. this.readingMore = false; 51. this.decoder = null; 52. this.encoding = null; 53. // \u7f16\u7801\u89e3\u7801\u5668 54. if (options.encoding) { 55. if (!StringDecoder) 56. StringDecoder = require('string_decoder').StringDecoder; 57. this.decoder = new StringDecoder(options.encoding); 58. this.encoding = options.encoding; 59. } 60. } ReadableState\u91cc\u5305\u542b\u4e86\u4e00\u5927\u5806\u5b57\u6bb5\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4e0d\u7ba1\u5b83\uff0c\u7b49\u5f85\u7528\u5230\u7684\u65f6\u5019\uff0c\u518d\u56de\u5934\u770b\u3002\u63a5\u7740\u6211\u4eec\u5f00\u59cb\u770b\u53ef\u8bfb\u6d41\u7684\u5b9e\u73b0\u3002 1. function Readable(options) { 2. if (!(this instanceof Readable)) 3. return new Readable(options); 4. 5. this._readableState = new ReadableState(options, this); 6. // \u53ef\u8bfb 7. this.readable = true; 8. // \u7528\u6237\u5b9e\u73b0\u7684\u4e24\u4e2a\u51fd\u6570 9. if (options) { 10. if (typeof options.read === 'function') 11. this._read = options.read; 12. if (typeof options.destroy === 'function') 13. this._destroy = options.destroy; 14. } 15. // \u521d\u59cb\u5316\u7236\u7c7b 16. Stream.call(this); 17. } \u4e0a\u9762\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u9700\u8981\u5173\u6ce8\u7684\u662fread\u548cdestroy\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u6211\u4eec\u662f\u76f4\u63a5\u4f7f\u7528Readable\u4f7f\u7528\u53ef\u8bfb\u6d41\uff0c\u90a3\u5728options\u91cc\u662f\u5fc5\u987b\u4f20read\u51fd\u6570\u7684\uff0cdestroy\u662f\u53ef\u9009\u7684\u3002\u5982\u679c\u6211\u4eec\u662f\u4ee5\u7ee7\u627f\u7684\u65b9\u5f0f\u4f7f\u7528Readable\uff0c\u90a3\u5fc5\u987b\u5b9e\u73b0_read\u51fd\u6570\u3002Node.js\u53ea\u662f\u62bd\u8c61\u4e86\u6d41\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u64cd\u4f5c\uff08\u6bd4\u5982\u53ef\u8bfb\u6d41\u5c31\u662f\u8bfb\u53d6\u6570\u636e\uff09\u662f\u7531\u7528\u6237\u81ea\u5df1\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u8bfb\u53d6\u64cd\u4f5c\u662f\u4e1a\u52a1\u76f8\u5173\u7684\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u53ef\u8bfb\u6d41\u7684\u64cd\u4f5c\u3002","title":"21.2 \u53ef\u8bfb\u6d41"},{"location":"chapter21-JS%20Stream/#2121","text":"\u5bf9\u7528\u6237\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u662f\u7528\u6237\u83b7\u53d6\u6570\u636e\u7684\u5730\u65b9\uff0c\u4f46\u662f\u5bf9\u53ef\u8bfb\u6d41\u6765\u8bf4\uff0c\u5b83\u63d0\u4f9b\u6570\u636e\u7ed9\u7528\u6237\u7684\u524d\u63d0\u662f\u5b83\u81ea\u5df1\u6709\u6570\u636e\uff0c\u6240\u4ee5\u53ef\u8bfb\u6d41\u9996\u5148\u9700\u8981\u751f\u4ea7\u6570\u636e\u3002\u751f\u4ea7\u6570\u636e\u7684\u903b\u8f91\u7531_read\u51fd\u6570\u5b9e\u73b0\u3002_read\u51fd\u6570\u7684\u903b\u8f91\u5927\u6982\u662f 1. const data = getSomeData(); 2. readableStream.push(data); \u901a\u8fc7push\u51fd\u6570\uff0c\u5f80\u53ef\u8bfb\u6d41\u91cc\u5199\u5165\u6570\u636e\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u4e3a\u7528\u6237\u63d0\u4f9b\u6570\u636e\uff0c\u6211\u4eec\u770b\u770bpush\u7684\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u4e3b\u8981\u903b\u8f91\u3002 1. Read able.prototype.push = function(chunk, encoding) { 2. // \u7701\u7565\u4e86\u7f16\u7801\u5904\u7406\u7684\u4ee3\u7801 3. return readableAddChunk(this, 4. chunk, 5. encoding, 6. false, 7. skipChunkCheck); 8. }; 9. 10. function readableAddChunk(stream, 11. chunk, 12. encoding, 13. addToFront, 14. skipChunkCheck) { 15. var state = stream._readableState; 16. // push null\u4ee3\u8868\u6d41\u7ed3\u675f 17. if (chunk === null) { 18. state.reading = false; 19. onEofChunk(stream, state); 20. } else { 21. addChunk(stream, state, chunk, false); 22. } 23. // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u66f4\u591a\u6570\u636e 24. return needMoreData(state); 25. } 26. 27. function addChunk(stream, state, chunk, addToFront) { 28. // \u662f\u6d41\u6a21\u5f0f\u5e76\u4e14\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u76f4\u63a5\u89e6\u53d1data\u4e8b\u4ef6 29. if (state.flowing && state.length === 0 && !state.sync) { 30. stream.emit('data', chunk); 31. } else { 32. // \u5426\u5219\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765 33. state.length += state.objectMode ? 1 : chunk.length; 34. if (addToFront) 35. state.buffer.unshift(chunk); 36. else 37. state.buffer.push(chunk); 38. // \u76d1\u542c\u4e86readable\u4e8b\u4ef6\u5219\u89e6\u53d1readable\u4e8b\u4ef6\uff0c\u901a\u8fc7read\u4e3b\u52a8\u8bfb\u53d6 39. if (state.needReadable) 40. emitReadable(stream); 41. } 42. // \u7ee7\u7eed\u8bfb\u53d6\u6570\u636e\uff0c\u5982\u679c\u53ef\u4ee5\u7684\u8bdd 43. maybeReadMore(stream, state); 44. } \u603b\u7684\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u9996\u5148\u8981\u4ece\u67d0\u4e2a\u5730\u65b9\u83b7\u53d6\u6570\u636e\uff0c\u6839\u636e\u5f53\u524d\u7684\u5de5\u4f5c\u6a21\u5f0f\uff0c\u76f4\u63a5\u4ea4\u4ed8\u7ed9\u7528\u6237\uff0c\u6216\u8005\u5148\u7f13\u5b58\u8d77\u6765\u3002\u53ef\u4ee5\u7684\u60c5\u51b5\u4e0b\uff0c\u7ee7\u7eed\u83b7\u53d6\u6570\u636e\u3002","title":"21.2.1 \u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u83b7\u53d6\u6570\u636e"},{"location":"chapter21-JS%20Stream/#2122","text":"\u7528\u6237\u53ef\u4ee5\u901a\u8fc7read\u51fd\u6570\u6216\u8005\u76d1\u542cdata\u4e8b\u4ef6\u6765\u4ece\u53ef\u8bfb\u6d41\u4e2d\u83b7\u53d6\u6570\u636e 1. Readable.prototype.read = function(n) { 2. n = parseInt(n, 10); 3. var state = this._readableState; 4. // \u8ba1\u7b97\u53ef\u8bfb\u7684\u5927\u5c0f 5. n = howMuchToRead(n, state); 6. var ret; 7. // \u9700\u8981\u8bfb\u53d6\u7684\u5927\u4e8e0\uff0c\u5219\u53d6\u8bfb\u53d6\u6570\u636e\u5230ret\u8fd4\u56de 8. if (n > 0) 9. ret = fromList(n, state); 10. else 11. ret = null; 12. // \u51cf\u53bb\u521a\u8bfb\u53d6\u7684\u957f\u5ea6 13. state.length -= n; 14. /* 15. \u5982\u679c\u7f13\u5b58\u91cc\u6ca1\u6709\u6570\u636e\u6216\u8005\u8bfb\u5b8c\u540e\u5c0f\u4e8e\u9608\u503c\u4e86\uff0c 16. \u5219\u53ef\u8bfb\u6d41\u53ef\u4ee5\u7ee7\u7eed\u4ece\u5e95\u5c42\u8d44\u6e90\u91cc\u83b7\u53d6\u6570\u636e 17. */ 18. if (state.length === 0 || 19. state.length - n < state.highWaterMark) { 20. this._read(state.highWaterMark); 21. } 22. // \u89e6\u53d1data\u4e8b\u4ef6 23. if (ret !== null) 24. this.emit('data', ret); 25. return ret; 26. }; \u8bfb\u53d6\u6570\u636e\u7684\u64cd\u4f5c\u5c31\u662f\u8ba1\u7b97\u7f13\u5b58\u91cc\u6709\u591a\u5c11\u6570\u636e\u53ef\u4ee5\u8bfb\uff0c\u548c\u7528\u6237\u9700\u8981\u7684\u6570\u636e\u5927\u5c0f\uff0c\u53d6\u5c0f\u7684\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u7528\u6237\uff0c\u5e76\u89e6\u53d1data\u4e8b\u4ef6\u3002\u5982\u679c\u6570\u636e\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u89e6\u53d1\u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u4e2d\u83b7\u53d6\u6570\u636e\u3002\u4ece\u800c\u6e90\u6e90\u4e0d\u65ad\u5730\u751f\u6210\u6570\u636e\u3002","title":"21.2.2 \u7528\u6237\u4ece\u53ef\u8bfb\u6d41\u83b7\u53d6\u6570\u636e"},{"location":"chapter21-JS%20Stream/#213","text":"\u53ef\u5199\u6d41\u662f\u5bf9\u6570\u636e\u6d41\u5411\u7684\u62bd\u8c61\uff0c\u7528\u6237\u8c03\u7528\u53ef\u5199\u6d41\u7684\u63a5\u53e3\uff0c\u53ef\u5199\u6d41\u8d1f\u8d23\u63a7\u5236\u6570\u636e\u7684\u5199\u5165\u3002\u6d41\u7a0b\u5982\u56fe21-1\u6240\u793a\u3002 \u56fe21-1 \u4e0b\u9762\u662f\u53ef\u5199\u6d41\u7684\u4ee3\u7801\u903b\u8f91\u56fe\u5982\u56fe21-2\u6240\u793a\u3002 \u56fe21-2 \u6211\u4eec\u770b\u4e00\u4e0b\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002","title":"21.3 \u53ef\u5199\u6d41"},{"location":"chapter21-JS%20Stream/#2131-writablestate","text":"WritableState\u662f\u7ba1\u7406\u53ef\u5199\u6d41\u914d\u7f6e\u7684\u7c7b\u3002\u91cc\u9762\u5305\u542b\u4e86\u975e\u5e38\u7684\u5b57\u6bb5\uff0c\u5177\u4f53\u542b\u4e49\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u5206\u6790\u7684\u65f6\u5019\u8bb2\u89e3\u3002 1. function WritableState(options, stream) { 2. options = options || {}; 3. 4. // \u662f\u4e0d\u662f\u53cc\u5411\u6d41 5. var isDuplex = stream instanceof Stream.Duplex; 6. 7. // \u6570\u636e\u6a21\u5f0f 8. this.objectMode = !!options.objectMode; 9. /* 10. \u53cc\u5411\u6d41\u7684\u6d41\u9ed8\u8ba4\u5171\u4eabobjectMode\u914d\u7f6e\uff0c 11. \u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u914d\u7f6e\u6210\u975e\u5171\u4eab\uff0c\u5373\u8bfb\u6d41\u548c\u5199\u6d41\u7684\u6570\u636e\u6a21\u5f0f\u72ec\u7acb 12. */ 13. if (isDuplex) 14. this.objectMode = this.objectMode || 15. !!options.writableObjectMode; 16. 17. /* 18. \u9608\u503c\uff0c\u8d85\u8fc7\u540e\u8bf4\u660e\u9700\u8981\u6682\u505c\u8c03\u7528write\uff0c0\u4ee3\u8868\u6bcf\u6b21\u8c03\u7528write 19. \u7684\u65f6\u5019\u90fd\u8fd4\u56defalse\uff0c\u7528\u6237\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u6267\u884cwrite 20. */ 21. this.highWaterMark = getHighWaterMark(this, 22. options, 'writableHighWaterMark',isDuplex); 23. 24. // \u662f\u5426\u8c03\u7528\u4e86_final\u51fd\u6570 25. this.finalCalled = false; 26. 27. // \u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u91cd\u65b0\u9a71\u52a8\u751f\u4ea7\u8005 28. this.needDrain = false; 29. 30. // \u6b63\u5728\u6267\u884cend\u6d41\u7a0b 31. this.ending = false; 32. 33. // \u662f\u5426\u6267\u884c\u8fc7end\u51fd\u6570 34. this.ended = false; 35. 36. // \u662f\u5426\u89e6\u53d1\u4e86finish\u4e8b\u4ef6 37. this.finished = false; 38. 39. // \u6d41\u662f\u5426\u88ab\u9500\u6bc1\u4e86 40. this.destroyed = false; 41. 42. var noDecode = options.decodeStrings === false; 43. // \u662f\u5426\u9700\u8981decode\u6d41\u6570\u636e\u540e\u5728\u6267\u884c\u5199\uff08\u8c03\u7528\u7528\u6237\u5b9a\u4e49\u7684_write\uff09 44. this.decodeStrings = !noDecode; 45. 46. // \u7f16\u7801\u7c7b\u578b 47. this.defaultEncoding = options.defaultEncoding || 'utf8'; 48. 49. // \u5f85\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 50. this.length = 0; 51. 52. // \u6b63\u5728\u5f80\u5e95\u5c42\u5199 53. this.writing = false; 54. 55. // \u52a0\u585e\uff0c\u7f13\u5b58\u751f\u4ea7\u8005\u7684\u6570\u636e\uff0c\u505c\u6b62\u5f80\u5e95\u5c42\u5199\u5165 56. this.corked = 0; 57. 58. // \u7528\u6237\u5b9a\u4e49\u7684_write\u6216\u8005_writev\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u8c03\u7528\u53ef\u5199\u6d41\u7684\u56de\u8c03\u51fd\u6570onwrite 59. this.sync = true; 60. 61. // \u662f\u5426\u6b63\u5728\u5904\u7406\u7f13\u5b58\u7684\u6570\u636e 62. this.bufferProcessing = false; 63. 64. // \u7528\u6237\u5b9e\u73b0\u7684\u94a9\u5b50_write\u51fd\u6570\u91cc\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\uff0c\u544a\u8bc9\u5199\u6d41\u5199\u5b8c\u6210\u4e86 65. this.onwrite = onwrite.bind(undefined, stream); 66. 67. // \u5f53\u524d\u5199\u64cd\u4f5c\u5bf9\u5e94\u7684\u56de\u8c03 68. this.writecb = null; 69. 70. // \u5f53\u524d\u5199\u64cd\u4f5c\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 71. this.writelen = 0; 72. 73. // \u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u5934\u6307\u9488 74. this.bufferedRequest = null; 75. 76. // \u6307\u5411\u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9 77. this.lastBufferedRequest = null; 78. 79. // \u5f85\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570\u4e2a\u6570 80. this.pendingcb = 0; 81. 82. // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7prefinished\u4e8b\u4ef6 83. this.prefinished = false; 84. 85. // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 86. this.errorEmitted = false; 87. 88. // count buffered requests 89. // \u7f13\u5b58\u7684buffer\u6570 90. this.bufferedRequestCount = 0; 91. 92. /* 93. \u7a7a\u95f2\u7684\u8282\u70b9\u94fe\u8868\uff0c\u5f53\u628a\u7f13\u5b58\u6570\u636e\u5199\u5165\u5e95\u5c42\u65f6\uff0ccorkReq\u4fdd\u6570\u636e\u7684\u4e0a\u4e0b\u6587\uff08\u5982 94. \u7528\u6237\u56de\u8c03\uff09\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\uff0c\u7f13\u5b58\u94fe\u8868\u5df2\u7ecf\u88ab\u6e05\u7a7a\uff0c 95. this.corkedRequestsFree\u59cb\u7ec8\u7ef4\u62a4\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6700\u591a\u4e24\u4e2a 96. */ 97. var corkReq = { next: null, entry: null, finish: undefined }; 98. corkReq.finish = onCorkedFinish.bind(undefined, corkReq, this); 99. this.corkedRequestsFree = corkReq; 100. }","title":"21.3.1 WritableState"},{"location":"chapter21-JS%20Stream/#2132-writable","text":"Writable\u662f\u53ef\u5199\u6d41\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528Writable\u4f5c\u4e3a\u53ef\u5199\u6d41\u6765\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u7ee7\u627fWritable\u5b9e\u73b0\u81ea\u5df1\u7684\u53ef\u5199\u6d41\u3002 1. function Writable(options) { 2. this._writableState = new WritableState(options, this); 3. // \u53ef\u5199 4. this.writable = true; 5. // \u652f\u6301\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u94a9\u5b50 6. if (options) { 7. if (typeof options.write === 'function') 8. this._write = options.write; 9. 10. if (typeof options.writev === 'function') 11. this._writev = options.writev; 12. 13. if (typeof options.destroy === 'function') 14. this._destroy = options.destroy; 15. 16. if (typeof options.final === 'function') 17. this._final = options.final; 18. } 19. 20. Stream.call(this); 21. } \u53ef\u5199\u6d41\u7ee7\u627f\u4e8e\u6d41\u57fa\u7c7b\uff0c\u63d0\u4f9b\u51e0\u4e2a\u94a9\u5b50\u51fd\u6570\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\u5b9e\u73b0\u81ea\u5df1\u7684\u903b\u8f91\u3002\u5982\u679c\u7528\u6237\u662f\u76f4\u63a5\u4f7f\u7528Writable\u7c7b\u4f5c\u4e3a\u53ef\u5199\u6d41\uff0c\u5219options.write\u51fd\u6570\u662f\u5fc5\u987b\u4f20\u7684\uff0coptions.wirte\u51fd\u6570\u63a7\u5236\u6570\u636e\u5f80\u54ea\u91cc\u5199\uff0c\u5e76\u4e14\u901a\u77e5\u53ef\u5199\u6d41\u662f\u5426\u5199\u5b8c\u6210\u4e86\u3002\u5982\u679c\u7528\u6237\u662f\u4ee5\u7ee7\u627fWritable\u7c7b\u7684\u5f62\u5f0f\u4f7f\u7528\u53ef\u5199\u6d41\uff0c\u5219_write\u51fd\u6570\u662f\u5fc5\u987b\u5b9e\u73b0\u7684\uff0c_write\u51fd\u6570\u548coptions.write\u51fd\u6570\u7684\u4f5c\u7528\u662f\u4e00\u6837\u7684\u3002","title":"21.3.2 Writable"},{"location":"chapter21-JS%20Stream/#2133","text":"\u53ef\u5199\u6d41\u63d0\u4f9bwrite\u51fd\u6570\u7ed9\u7528\u6237\u5b9e\u73b0\u6570\u636e\u7684\u5199\u5165\uff0c\u5199\u5165\u6709\u4e24\u79cd\u65b9\u5f0f\u3002\u4e00\u4e2a\u662f\u9010\u4e2a\u5199\uff0c\u4e00\u4e2a\u662f\u6279\u91cf\u5199\uff0c\u6279\u91cf\u5199\u662f\u53ef\u9009\u7684\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff0c\u5982\u679c\u7528\u6237\u76f4\u63a5\u4f7f\u7528Writable\u5219\u9700\u8981\u4f20\u5165writev\uff0c\u5982\u679c\u662f\u7ee7\u627f\u65b9\u5f0f\u4f7f\u7528Writable\u5219\u5b9e\u73b0_writev\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bwrite\u51fd\u6570\u7684\u5b9e\u73b0 1. Writable.prototype.write = function(chunk, encoding, cb) { 2. var state = this._writableState; 3. // \u544a\u8bc9\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write 4. var ret = false; 5. // \u6570\u636e\u683c\u5f0f 6. var isBuf = !state.objectMode && Stream._isUint8Array(chunk); 7. // \u662f\u5426\u9700\u8981\u8f6c\u6210buffer\u683c\u5f0f 8. if (isBuf && Object.getPrototypeOf(chunk) !== Buffer.prototype) { 9. chunk = Stream._uint8ArrayToBuffer(chunk); 10. } 11. // \u53c2\u6570\u5904\u7406\uff0c\u4f20\u4e86\u6570\u636e\u548c\u56de\u8c03\uff0c\u6ca1\u6709\u4f20\u7f16\u7801\u7c7b\u578b 12. if (typeof encoding === 'function') { 13. cb = encoding; 14. encoding = null; 15. } 16. // \u662fbuffer\u7c7b\u578b\u5219\u8bbe\u7f6e\u6210buffer\uff0c\u5426\u5219\u5982\u679c\u6ca1\u4f20\u5219\u53d6\u9ed8\u8ba4\u7f16\u7801 17. if (isBuf) 18. encoding = 'buffer'; 19. else if (!encoding) 20. encoding = state.defaultEncoding; 21. 22. if (typeof cb !== 'function') 23. cb = nop; 24. // \u6b63\u5728\u6267\u884cend\uff0c\u518d\u6267\u884cwrite\uff0c\u62a5\u9519 25. if (state.ending) 26. writeAfterEnd(this, cb); 27. else if (isBuf || validChunk(this, state, chunk, cb)) { 28. // \u5f85\u6267\u884c\u7684\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373cb 29. state.pendingcb++; 30. // \u5199\u5165\u6216\u7f13\u5b58\uff0c\u89c1\u8be5\u51fd\u6570 31. ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb); 32. } 33. /// \u8fd8\u80fd\u4e0d\u80fd\u7ee7\u7eed\u5199 34. return ret; 35. }; write\u51fd\u6570\u9996\u5148\u505a\u4e86\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u548c\u6570\u636e\u8f6c\u6362\uff0c\u7136\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u6d41\u7ed3\u675f\u518d\u6267\u884c\u5199\u5165\uff0c\u5219\u4f1a\u62a5\u9519\u3002\u5982\u679c\u6d41\u6ca1\u6709\u7ed3\u675f\u5219\u6267\u884c\u5199\u5165\u6216\u8005\u7f13\u5b58\u5904\u7406\u3002\u6700\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write\u5199\u5165\u6570\u636e\uff08\u6211\u4eec\u770b\u5230\u5982\u679c\u5199\u5165\u7684\u6570\u636e\u6bd4\u9608\u503c\u5927\uff0c\u53ef\u5199\u6d41\u8fd8\u662f\u4f1a\u6267\u884c\u5199\u5165\u64cd\u4f5c\uff0c\u4f46\u662f\u4f1a\u8fd4\u56defalse\u544a\u8bc9\u7528\u6237\u4e9b\u4e0d\u8981\u5199\u5165\u4e86\uff0c\u5982\u679c\u8c03\u7528\u65b9\u7ee7\u7eed\u5199\u5165\u7684\u8bdd\uff0c\u4e5f\u662f\u6ca1\u4f1a\u7ee7\u7eed\u5199\u5165\u7684\uff0c\u4f46\u662f\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5199\u5165\u7aef\u538b\u529b\u8fc7\u5927\uff09\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bwriteAfterEnd\u7684\u903b\u8f91\u3002\u7136\u540e\u518d\u770bwriteOrBuffer\u3002 1. function writeAfterEnd(stream, cb) { 2. var er = new errors.Error('ERR_STREAM_WRITE_AFTER_END'); 3. stream.emit('error', er); 4. process.nextTick(cb, er); 5. } writeAfterEnd\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u89e6\u53d1\u53ef\u5199\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u4e0b\u4e00\u4e2atick\u7684\u65f6\u5019\u6267\u884c\u7528\u6237\u5728\u8c03\u7528write\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bwriteOrBuffer\u3002writeOrBuffer\u51fd\u6570\u4f1a\u5bf9\u6570\u636e\u8fdb\u884c\u7f13\u5b58\u6216\u8005\u76f4\u63a5\u5199\u5165\u76ee\u7684\u5730\uff08\u76ee\u7684\u5730\u53ef\u4ee5\u662f\u6587\u4ef6\u3001socket\u3001\u5185\u5b58\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff09\uff0c\u53d6\u51b3\u4e8e\u5f53\u524d\u53ef\u5199\u6d41\u7684\u72b6\u6001\u3002 1. function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) { 2. // \u6570\u636e\u5904\u7406 3. if (!isBuf) { 4. var newChunk = decodeChunk(state, chunk, encoding); 5. if (chunk !== newChunk) { 6. isBuf = true; 7. encoding = 'buffer'; 8. chunk = newChunk; 9. } 10. } 11. // \u5bf9\u8c61\u6a21\u5f0f\u7684\u7b97\u4e00\u4e2a 12. var len = state.objectMode ? 1 : chunk.length; 13. // \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u4e2a\u6570 14. state.length += len; 15. // \u5f85\u5199\u5165\u7684\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c 16. var ret = state.length < state.highWaterMark; 17. 18. /* 19. \u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u5219\u8bbe\u7f6e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6\u6807\u8bb0\uff0c 20. \u8fd9\u65f6\u5019\u7528\u6237\u4e0d\u5e94\u8be5\u518d\u6267\u884cwrite\uff0c\u800c\u662f\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1 21. */ 22. if (!ret) 23. state.needDrain = true; 24. // \u5982\u679c\u6b63\u5728\u5199\u6216\u8005\u8bbe\u7f6e\u4e86\u963b\u585e\u5219\u5148\u7f13\u5b58\u6570\u636e\uff0c\u5426\u5219\u76f4\u63a5\u5199\u5165 25. if (state.writing || state.corked) { 26. // \u6307\u5411\u5f53\u524d\u7684\u5c3e\u8282\u70b9 27. var last = state.lastBufferedRequest; 28. // \u63d2\u5165\u65b0\u7684\u5c3e\u7ed3\u70b9 29. state.lastBufferedRequest = { 30. chunk, 31. encoding, 32. isBuf, 33. callback: cb, 34. next: null 35. }; 36. /* 37. \u4e4b\u524d\u8fd8\u6709\u8282\u70b9\u7684\u8bdd\uff0c\u65e7\u7684\u5c3e\u8282\u70b9\u7684next\u6307\u9488\u6307\u5411\u65b0\u7684\u5c3e\u8282\u70b9\uff0c 38. \u5f62\u6210\u94fe\u8868 39. */ 40. if (last) { 41. last.next = state.lastBufferedRequest; 42. } else { 43. /* 44. \u6307\u5411buffer\u94fe\u8868\uff0cbufferedRequest\u76f8\u7b49\u4e8e\u5934\u6307\u9488\uff0c 45. \u63d2\u5165\u7b2c\u4e00\u4e2abuffer\u8282\u70b9\u7684\u65f6\u5019\u6267\u884c\u5230\u8fd9 46. */ 47. state.bufferedRequest = state.lastBufferedRequest; 48. } 49. // \u7f13\u5b58\u7684buffer\u4e2a\u6570\u52a0\u4e00 50. state.bufferedRequestCount += 1; 51. } else { 52. // \u76f4\u63a5\u5199\u5165 53. doWrite(stream, state, false, len, chunk, encoding, cb); 54. } 55. // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u6267\u884cwirte\uff0c\u5982\u679c\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u53ef\u4ee5\u7ee7\u7eed\u5199 56. return ret; 57. } writeOrBuffer\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u7684\u957f\u5ea6\uff0c\u5224\u65ad\u662f\u5426\u8fbe\u5230\u9608\u503c\uff0c\u7136\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u6267\u884cwrite\u7ee7\u7eed\u5199\u5165\u3002 2 \u5224\u65ad\u5f53\u524d\u662f\u5426\u6b63\u5728\u5199\u5165\u6216\u8005\u5904\u4e8ecork\u6a21\u5f0f\u3002\u662f\u7684\u8bdd\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\uff0c\u5426\u5219\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u7f13\u5b58\u7684\u903b\u8f91\u548c\u5f62\u6210\u7684\u6570\u636e\u7ed3\u6784\u3002 \u7f13\u5b58\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-3\u6240\u793a\u3002 \u56fe21-3 \u7f13\u5b58\u7b2c\u4e8c\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-4\u6240\u793a\u3002 \u56fe21-4 \u7f13\u5b58\u7b2c\u4e09\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-5 \u56fe21-5 \u6211\u4eec\u770b\u5230\uff0c\u51fd\u6570\u7684\u6570\u636e\u662f\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u7ba1\u7406\u7684\uff0c\u5176\u4e2dbufferedRequest\u662f\u94fe\u8868\u5934\u7ed3\u70b9\uff0clastBufferedRequest\u6307\u5411\u5c3e\u8282\u70b9\u3002\u5047\u8bbe\u5f53\u524d\u53ef\u5199\u6d41\u4e0d\u5904\u4e8e\u5199\u5165\u6216\u8005cork\u72b6\u6001\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5199\u5165\u7684\u903b\u8f91\u3002 1. function doWrite(stream, state, writev, len, chunk, encoding, cb) { 2. // \u672c\u6b21\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6 3. state.writelen = len; 4. // \u672c\u6b21\u5199\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 5. state.writecb = cb; 6. // \u6b63\u5728\u5199\u5165 7. state.writing = true; 8. // \u5047\u8bbe\u7528\u6237\u5b9a\u4e49\u7684_writev\u6216\u8005_write\u51fd\u6570\u662f\u540c\u6b65\u56de\u8c03onwrite 9. state.sync = true; 10. if (writev) 11. // chunk\u4e3a\u7f13\u5b58\u5f85\u5199\u5165\u7684buffer\u8282\u70b9\u6570\u7ec4 12. stream._writev(chunk, state.onwrite); 13. else 14. // \u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684\u5199\u51fd\u6570\uff0conwrite\u662fNode.js\u5b9a\u4e49\u7684\uff0c\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u8be5\u51fd\u6570 15. stream._write(chunk, encoding, state.onwrite); 16. /* 17. \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u56de\u8c03onwrite\uff0c\u5219\u8fd9\u53e5\u4ee3\u7801\u6ca1\u6709\u610f\u4e49\uff0c 18. \u5982\u679c\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u8fd9\u53e5\u4ee3\u7801\u4f1a\u5728onwrite\u4e4b\u524d\u6267\u884c\uff0c 19. \u5b83\u6807\u8bb0\u7528\u6237\u662f\u5f02\u6b65\u56de\u8c03\u6a21\u5f0f\uff0c\u5728onwrite\u4e2d\u9700\u8981\u5224\u65ad\u56de\u8c03\u6a21\u5f0f\uff0c\u5373sync\u7684\u503c 20. */ 21. state.sync = false; 22. } doWrite\u51fd\u6570\u8bb0\u5f55\u4e86\u672c\u6b21\u5199\u5165\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u957f\u5ea6\uff0c\u56de\u8c03\uff0c\u7136\u540e\u8bbe\u7f6e\u6b63\u5728\u5199\u6807\u8bb0\u3002\u6700\u540e\u6267\u884c\u5199\u5165\u3002\u5982\u679c\u5f53\u524d\u5f85\u5199\u5165\u7684\u6570\u636e\u662f\u7f13\u5b58\u7684\u6570\u636e\u5e76\u4e14\u7528\u6237\u5b9e\u73b0\u4e86_writev\u51fd\u6570\uff0c\u5219\u8c03\u7528_writev\u3002\u5426\u5219\u8c03\u7528_write\u3002\u4e0b\u9762\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u4f8b\u5b50\uff0c\u628a\u8fd9\u91cc\u7684\u903b\u8f91\u4e32\u8d77\u6765\u3002 1. const { Writable } = require('stream'); 2. class DemoWritable extends Writable { 3. constructor() { 4. super(); 5. this.data = null; 6. } 7. _write(chunk, encoding, cb) { 8. // \u4fdd\u5b58\u6570\u636e 9. this.data = this.data ? Buffer.concat([this.data, chunk]) : chunk; 10. // \u6267\u884c\u56de\u8c03\u544a\u8bc9\u53ef\u5199\u6d41\u5199\u5b8c\u6210\u4e86\uff0cfalse\u4ee3\u8868\u5199\u6210\u529f\uff0ctrue\u4ee3\u8868\u5199\u5931\u8d25 11. cb(null); 12. } 13. } DemoWritable\u5b9a\u4e49\u4e86\u6570\u636e\u6d41\u5411\u7684\u76ee\u7684\u5730\uff0c\u5728\u7528\u6237\u8c03\u7528write\u7684\u65f6\u5019\uff0c\u53ef\u5199\u6d41\u4f1a\u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684_write\uff0c_write\u4fdd\u5b58\u4e86\u6570\u636e\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u5e76\u4f20\u5165\u53c2\u6570\uff0c\u901a\u77e5\u53ef\u5199\u6d41\u6570\u636e\u5199\u5b8c\u6210\u4e86\uff0c\u5e76\u901a\u8fc7\u53c2\u6570\u6807\u8bb0\u5199\u6210\u529f\u8fd8\u662f\u5931\u8d25\u3002\u8fd9\u65f6\u5019\u56de\u5230\u53ef\u5199\u6d41\u4fa7\u3002\u6211\u4eec\u770b\u5230\u53ef\u5199\u6d41\u8bbe\u7f6e\u7684\u56de\u8c03\u662fonwrite\uff0conwrite\u662f\u5728\u521d\u59cb\u5316\u53ef\u5199\u6d41\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u3002 1. this.onwrite = onwrite.bind(undefined, stream); \u6211\u4eec\u63a5\u7740\u770bonwrite\u7684\u5b9e\u73b0\u3002 1. function onwrite(stream, er) { 2. var state = stream._writableState; 3. var sync = state.sync; 4. // \u672c\u6b21\u5199\u5b8c\u65f6\u6267\u884c\u7684\u56de\u8c03 5. var cb = state.writecb; 6. // \u91cd\u7f6e\u5185\u90e8\u5b57\u6bb5\u7684\u503c 7. // \u5199\u5b8c\u4e86\uff0c\u91cd\u7f6e\u56de\u8c03\uff0c\u8fd8\u6709\u591a\u5c11\u5355\u4f4d\u7684\u6570\u636e\u6ca1\u6709\u5199\u5165\uff0c\u6570\u636e\u5199\u5b8c\uff0c\u91cd\u7f6e\u672c\u6b21\u5f85\u5199\u5165\u7684\u6570\u636e\u6570\u4e3a0 8. state.writing = false; 9. state.writecb = null; 10. state.length -= state.writelen; 11. state.writelen = 0; 12. // \u5199\u51fa\u9519 13. if (er) 14. onwriteError(stream, state, sync, er, cb); 15. else { 16. // Check if we're actually ready to finish, but don't emit yet 17. // \u662f\u5426\u5df2\u7ecf\u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u4e5f\u5199\u5b8c\u4e86\uff08\u63d0\u4ea4\u5199\u64cd\u4f5c\u548c\u6700\u540e\u771f\u6b63\u6267\u884c\u4e2d\u95f4\u53ef\u80fd\u6267\u884c\u4e86end\uff09 18. var finished = needFinish(state); 19. // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u963b\u585e\u6807\u8bb0\uff0c\u4e5f\u4e0d\u5728\u5904\u7406buffer\uff0c\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u7f13\u5b58\u6570\u636e\uff0c\u5219\u8fdb\u884c\u5199\u5165 20. if (!finished && 21. !state.corked && 22. !state.bufferProcessing && 23. state.bufferedRequest) { 24. clearBuffer(stream, state); 25. } 26. // \u7528\u6237\u540c\u6b65\u56de\u8c03onwrite\u5219Node.js\u5f02\u6b65\u6267\u884c\u7528\u6237\u56de\u8c03 27. if (sync) { 28. process.nextTick(afterWrite, stream, state, finished, cb); 29. } else { 30. afterWrite(stream, state, finished, cb); 31. } 32. } 33. } onwrite\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u53ef\u5199\u6d41\u7684\u72b6\u6001\u548c\u6570\u636e 2 \u5199\u51fa\u9519\u5219\u89e6\u53d1error\u4e8b\u4ef6\u548c\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5199\u6210\u529f\u5219\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u7ee7\u7eed\u6267\u884c\u5199\u64cd\u4f5c\uff0c\u662f\u7684\u8bdd\u5219\u7ee7\u7eed\u5199\uff0c\u5426\u5219\u6267\u884c\u7528\u6237\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0bclearBuffer\u51fd\u6570\u7684\u903b\u8f91\uff0c\u8be5\u903b\u8f91\u4e3b\u8981\u662f\u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230\u76ee\u7684\u5730\u3002 1. function clearBuffer(stream, state) { 2. // \u6b63\u5728\u5904\u7406buffer 3. state.bufferProcessing = true; 4. // \u6307\u5411\u5934\u7ed3\u70b9 5. var entry = state.bufferedRequest; 6. // \u5b9e\u73b0\u4e86_writev\u5e76\u4e14\u6709\u4e24\u4e2a\u4ee5\u4e0a\u7684\u6570\u636e\u5757\uff0c\u5219\u6279\u91cf\u5199\u5165\uff0c\u5373\u4e00\u6b21\u628a\u6240\u6709\u7f13\u5b58\u7684buffer\u90fd\u5199\u5165 7. if (stream._writev && entry && entry.next) { 8. // Fast case, write everything using _writev() 9. var l = state.bufferedRequestCount; 10. var buffer = new Array(l); 11. var holder = state.corkedRequestsFree; 12. // \u6307\u5411\u5f85\u5199\u5165\u6570\u636e\u7684\u94fe\u8868 13. holder.entry = entry; 14. 15. var count = 0; 16. // \u6570\u636e\u662f\u5426\u5168\u90e8\u90fd\u662fbuffer\u683c\u5f0f 17. var allBuffers = true; 18. // \u628a\u7f13\u5b58\u7684\u8282\u70b9\u653e\u5230buffer\u6570\u7ec4\u4e2d 19. while (entry) { 20. buffer[count] = entry; 21. if (!entry.isBuf) 22. allBuffers = false; 23. entry = entry.next; 24. count += 1; 25. } 26. buffer.allBuffers = allBuffers; 27. 28. doWrite(stream, state, true, state.length, buffer, '', holder.finish); 29. 30. // \u5f85\u6267\u884c\u7684cb\u52a0\u4e00\uff0c\u5373holder.finish 31. state.pendingcb++; 32. // \u6e05\u7a7a\u7f13\u5b58\u961f\u5217 33. state.lastBufferedRequest = null; 34. // \u8fd8\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u66f4\u65b0\u6307\u9488,\u4e0b\u6b21\u4f7f\u7528 35. if (holder.next) { 36. state.corkedRequestsFree = holder.next; 37. holder.next = null; 38. } else { 39. // \u6ca1\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u6062\u590d\u503c\uff0c\u89c1\u521d\u59cb\u5316\u65f6\u7684\u8bbe\u7f6e 40. var corkReq = { next: null, entry: null, finish: undefined }; 41. corkReq.finish = onCorkedFinish.bind(undefined, corkReq, state); 42. state.corkedRequestsFree = corkReq; 43. } 44. state.bufferedRequestCount = 0; 45. } else { 46. // \u6162\u6162\u5199\uff0c\u5373\u4e00\u4e2a\u4e2abuffer\u5199\uff0c\u5199\u5b8c\u540e\u7b49\u9700\u8981\u6267\u884c\u7528\u6237\u7684cb\uff0c\u9a71\u52a8\u4e0b\u4e00\u4e2a\u5199 47. // Slow case, write chunks one-by-one 48. while (entry) { 49. var chunk = entry.chunk; 50. var encoding = entry.encoding; 51. var cb = entry.callback; 52. var len = state.objectMode ? 1 : chunk.length; 53. // \u6267\u884c\u5199\u5165 54. doWrite(stream, state, false, len, chunk, encoding, cb); 55. entry = entry.next; 56. // \u5904\u7406\u5b8c\u4e00\u4e2a\uff0c\u51cf\u4e00 57. state.bufferedRequestCount--; 58. 59. /* 60. \u5728onwrite\u91cc\u6e05\u9664\u8fd9\u4e2a\u6807\u8bb0\uff0conwrite\u4f9d\u8d56\u4e8e\u7528\u6237\u6267\u884c\uff0c\u5982\u679c\u7528\u6237\u6ca1\u8c03\uff0c 61. \u6216\u8005\u4e0d\u662f\u540c\u6b65\u8c03\uff0c\u5219\u9000\u51fa\uff0c\u7b49\u5f85\u6267\u884conwrite\u7684\u65f6\u5019\u518d\u7ee7\u7eed\u5199 62. */ 63. if (state.writing) { 64. break; 65. } 66. } 67. // \u5199\u5b8c\u4e86\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u66f4\u65b0\u6307\u9488 68. if (entry === null) 69. state.lastBufferedRequest = null; 70. } 71. /* 72. \u66f4\u65b0\u7f13\u5b58\u6570\u636e\u94fe\u8868\u7684\u5934\u7ed3\u70b9\u6307\u5411\uff0c 73. 1 \u5982\u679c\u662f\u6279\u91cf\u5199\u5219entry\u4e3anull 74. 2 \u5982\u679c\u5355\u4e2a\u5199\uff0c\u5219\u53ef\u80fd\u8fd8\u6709\u503c\uff08\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u8c03\u7528onwrite\u7684\u8bdd\uff09 75. */ 76. state.bufferedRequest = entry; 77. // \u672c\u8f6e\u5904\u7406\u5b8c\u6bd5\uff08\u5904\u7406\u5b8c\u4e00\u4e2a\u6216\u5168\u90e8\uff09 78. state.bufferProcessing = false; 79. } clearBuffer\u7684\u903b\u8f91\u770b\u8d77\u6765\u975e\u5e38\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u7b97\u5f88\u590d\u6742\u3002\u4e3b\u8981\u5206\u4e3a\u4e24\u4e2a\u5206\u652f\u3002 1 \u7528\u6237\u5b9e\u73b0\u4e86\u6279\u91cf\u5199\u51fd\u6570\uff0c\u5219\u4e00\u6b21\u628a\u7f13\u5b58\u7684\u65f6\u5019\u5199\u5165\u76ee\u7684\u5730\u3002\u9996\u5148\u628a\u7f13\u5b58\u7684\u6570\u636e\uff08\u94fe\u8868\uff09\u5168\u90e8\u6536\u96c6\u8d77\u6765\uff0c\u7136\u540e\u6267\u884c\u6267\u884c\u5199\u5165\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u662ffinish\u51fd\u6570\u3002corkedRequestsFree\u5b57\u6bb5\u6307\u5411\u4e00\u4e2a\u8282\u70b9\u6570\u6700\u5c11\u4e3a\u4e00\uff0c\u6700\u591a\u4e3a\u4e8c\u7684\u94fe\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u6279\u91cf\u5199\u7684\u6570\u636e\u7684\u4e0a\u4e0b\u6587\u3002\u6279\u91cf\u5199\u65f6\u7684\u6570\u636e\u7ed3\u6784\u56fe\u5982\u56fe21-6\u548c21-7\u6240\u793a\uff08\u4e24\u79cd\u573a\u666f\uff09\u3002 \u56fe21-6 \u56fe21-7 corkedRequestsFree\u4fdd\u8bc1\u6700\u5c11\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u7528\u4e8e\u4e00\u6b21\u6279\u91cf\u5199\uff0c\u5f53\u4f7f\u7528\u5b8c\u7684\u65f6\u5019\uff0c\u4f1a\u6700\u591a\u4fdd\u5b58\u4e24\u4e2a\u7a7a\u95f2\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u6210\u529f\u540e\uff0c\u56de\u8c03\u51fd\u6570onCorkedFinish\u7684\u903b\u8f91\u3002 1. function onCorkedFinish(corkReq, state, err) { 2. // corkReq.entry\u6307\u5411\u5f53\u524d\u5904\u7406\u7684buffer\u94fe\u8868\u5934\u7ed3\u70b9 3. var entry = corkReq.entry; 4. corkReq.entry = null; 5. // \u904d\u5386\u6267\u884c\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u56de\u8c03 6. while (entry) { 7. var cb = entry.callback; 8. state.pendingcb--; 9. cb(err); 10. entry = entry.next; 11. } 12. 13. // \u56de\u6536corkReq\uff0cstate.corkedRequestsFree\u8fd9\u65f6\u5019\u5df2\u7ecf\u7b49\u4e8e\u65b0\u7684corkReq\uff0c\u6307\u5411\u521a\u7528\u5b8c\u7684\u8fd9\u4e2acorkReq\uff0c\u5171\u4fdd\u5b58\u4e24\u4e2a 14. state.corkedRequestsFree.next = corkReq; 15. } onCorkedFinish\u9996\u5148\u4ece\u672c\u6b21\u6279\u91cf\u5199\u7684\u6570\u636e\u4e0a\u4e0b\u6587\u53d6\u51fa\u56de\u8c03\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u3002\u6700\u540e\u56de\u6536\u8282\u70b9\u3002corkedRequestsFree\u603b\u662f\u6307\u5411\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6240\u4ee5\u5982\u679c\u8282\u70b9\u8d85\u8fc7\u4e24\u4e2a\u65f6\uff0c\u6bcf\u6b21\u4f1a\u628a\u5c3e\u8282\u70b9\u4e22\u5f03\uff0c\u5982\u56fe21-8\u6240\u793a\u3002 \u56fe21-8 2 \u63a5\u7740\u6211\u4eec\u770b\u5355\u4e2a\u5199\u7684\u573a\u666f \u5355\u4e2a\u5199\u7684\u65f6\u5019\uff0c\u5c31\u662f\u901a\u8fc7doWrite\u628a\u6570\u636e\u9010\u4e2a\u5199\u5230\u76ee\u7684\u5730\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u5730\u65b9\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\uff08\u901a\u8fc7writing\u5b57\u6bb5\uff0c\u56e0\u4e3aonwrite\u4f1a\u7f6ewriting\u4e3atrue\uff0c\u5982\u679c\u6267\u884c\u5b8cdoWrite\uff0cwriting\u4e3afalse\u8bf4\u660e\u662f\u5f02\u6b65\u56de\u8c03\uff09\uff0c\u5219\u5199\u5165\u4e00\u4e2a\u6570\u636e\u540e\u5c31\u4e0d\u518d\u6267\u884cdoWrite\u8fdb\u884c\u5199\uff0c\u800c\u662f\u9700\u8981\u7b49\u5230onwrite\u56de\u8c03\u88ab\u5f02\u6b65\u6267\u884c\u65f6\uff0c\u518d\u6267\u884c\u4e0b\u4e00\u6b21\u5199\uff0c\u56e0\u4e3a\u53ef\u5199\u6d41\u662f\u4e32\u884c\u5730\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u4e0b\u9762\u8bb2\u4e00\u4e0bsync\u5b57\u6bb5\u7684\u4f5c\u7528\u3002sync\u5b57\u6bb5\u662f\u7528\u4e8e\u6807\u8bb0\u6267\u884c\u7528\u6237\u81ea\u5b9a\u4e49\u7684write\u51fd\u6570\u65f6\uff0cwrite\u51fd\u6570\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\u3002\u4e3b\u8981\u7528\u4e8e\u63a7\u5236\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002\u5e76\u4e14\u9700\u8981\u4fdd\u8bc1\u56de\u8c03\u8981\u6309\u7167\u5b9a\u4e49\u7684\u987a\u5e8f\u6267\u884c\u3002\u6709\u4e24\u4e2a\u5730\u65b9\u6d89\u53ca\u4e86\u8fd9\u4e2a\u903b\u8f91\uff0c\u7b2c\u4e00\u4e2a\u662fwirte\u7684\u65f6\u5019\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u7684\u8c03\u7528\u5173\u7cfb\uff0c\u5982\u56fe21-9\u6240\u793a\u3002 \u56fe21-9 \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u6267\u884conwrite\uff0c\u5219\u6570\u636e\u4f1a\u88ab\u5b9e\u65f6\u5730\u6d88\u8d39\uff0c\u4e0d\u5b58\u5728\u7f13\u5b58\u6570\u636e\u7684\u60c5\u51b5\uff0c\u8fd9\u65f6\u5019Node.js\u5f02\u6b65\u5e76\u4e14\u6709\u5e8f\u5730\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u5982\u679c\u7528\u6237\u8fde\u7eed\u4e24\u6b21\u8c03\u7528\u4e86write\u5199\u5165\u6570\u636e\uff0c\u5e76\u4e14\u662f\u4ee5\u5f02\u6b65\u6267\u884c\u56de\u8c03onwrite\uff0c\u5219\u7b2c\u4e00\u6b21\u6267\u884conwrite\u7684\u65f6\u5019\uff0c\u4f1a\u5b58\u5728\u7f13\u5b58\u7684\u6570\u636e\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6765\u5f97\u53ca\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5c31\u4f1a\u5148\u53d1\u751f\u7b2c\u4e8c\u6b21\u5199\u5165\u64cd\u4f5c\uff0c\u540c\u6837\uff0c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\u4e5f\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u6240\u4ee5\u63a5\u4e0b\u6765\u5c31\u4f1a\u540c\u6b65\u6267\u884c\u7684\u7528\u6237\u56de\u8c03\u3002\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u7528\u6237\u56de\u8c03\u7684\u987a\u5e8f\u6267\u884c\u3002\u7b2c\u4e8c\u79cd\u573a\u666f\u662funcork\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u5173\u7cfb\u56fe\uff0c\u5982\u56fe21-10\u6240\u793a\u3002 \u56fe21-10 \u5728uncork\u7684\u6267\u884c\u6d41\u7a0b\u4e2d\uff0c\u5982\u679conwrite\u662f\u88ab\u540c\u6b65\u56de\u8c03\uff0c\u5219\u5728onwrite\u4e2d\u4e0d\u4f1a\u518d\u6b21\u8c03\u7528clearBuffer\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u7684bufferProcessing\u4e3atrue\u3002\u8fd9\u65f6\u5019\u4f1a\u5148\u628a\u7528\u6237\u7684\u56de\u8c03\u5165\u961f\uff0c\u7136\u540e\u518d\u6b21\u6267\u884cdoWrite\u53d1\u8d77\u4e0b\u4e00\u6b21\u5199\u64cd\u4f5c\u3002\u5982\u679conwrite\u662f\u88ab\u5f02\u6b65\u6267\u884c\uff0c\u5728\u6267\u884cclearBuffer\u4e2d\uff0c\u7b2c\u4e00\u6b21\u6267\u884cdoWrite\u5b8c\u6bd5\u540e\uff0cclearBuffer\u5c31\u4f1a\u9000\u51fa\uff0c\u5e76\u4e14\u8fd9\u65f6\u5019bufferProcessing\u4e3afalse\u3002\u7b49\u5230onwrite\u88ab\u56de\u8c03\u7684\u65f6\u5019\uff0c\u518d\u6b21\u6267\u884cclearBuffer\uff0c\u540c\u6837\u6267\u884c\u5b8cdoWrite\u7684\u65f6\u5019\u9000\u51fa\uff0c\u7b49\u5f85\u5f02\u6b65\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u7528\u6237\u56de\u8c03\u88ab\u6267\u884c\u3002 \u6211\u4eec\u7ee7\u7eed\u5206\u6790onwrite\u7684\u4ee3\u7801\uff0conwrite\u6700\u540e\u4f1a\u8c03\u7528afterWrite\u51fd\u6570\u3002 1. function afterWrite(stream, state, finished, cb) { 2. // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u770b\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6 3. if (!finished) 4. onwriteDrain(stream, state); 5. // \u51c6\u5907\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5f85\u6267\u884c\u7684\u56de\u8c03\u51cf\u4e00 6. state.pendingcb--; 7. cb(); 8. finishMaybe(stream, state); 9. } 10. 11. function onwriteDrain(stream, state) { 12. // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u4e86\uff0c\u5e76\u4e14\u6d41\u5728\u963b\u585e\u4e2d\u7b49\u5f85drain\u4e8b\u4ef6 13. if (state.length === 0 && state.needDrain) { 14. // \u89e6\u53d1drain\u4e8b\u4ef6\u7136\u540e\u6e05\u7a7a\u6807\u8bb0 15. state.needDrain = false; 16. stream.emit('drain'); 17. } 18. } 19. afterWrite\u4e3b\u8981\u662f\u5224\u65ad\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u6700\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\uff08\u5728\u5f02\u6b65\u56de\u8c03onwrite\u7684\u60c5\u51b5\u4e0b\uff0c\u7528\u6237\u8c03\u7528\u56de\u8c03\u4e4b\u524d\uff0c\u53ef\u80fd\u6267\u884c\u4e86end\uff09\u3002\u6d41\u7ed3\u675f\u7684\u903b\u8f91\u6211\u4eec\u540e\u9762\u7ae0\u8282\u5355\u72ec\u5206\u6790\u3002","title":"21.3.3 \u6570\u636e\u5199\u5165"},{"location":"chapter21-JS%20Stream/#2134-corkuncork","text":"cork\u548cuncork\u7c7b\u4f3ctcp\u4e2d\u7684negal\u7b97\u6cd5\uff0c\u4e3b\u8981\u7528\u4e8e\u7d2f\u79ef\u6570\u636e\u540e\u4e00\u6b21\u6027\u5199\u5165\u76ee\u7684\u5730\u3002\u800c\u4e0d\u662f\u6709\u4e00\u5757\u5c31\u5b9e\u65f6\u5199\u5165\u3002\u6bd4\u5982\u5728tcp\u4e2d\uff0c\u6bcf\u6b21\u53d1\u9001\u4e00\u4e2a\u5b57\u8282\uff0c\u800c\u534f\u8bae\u5934\u8fdc\u8fdc\u5927\u4e8e\u4e00\u5b57\u8282\uff0c\u6709\u6548\u6570\u636e\u5360\u6bd4\u975e\u5e38\u4f4e\u3002\u4f7f\u7528cork\u7684\u65f6\u5019\u6700\u597d\u540c\u65f6\u63d0\u4f9bwritev\u5b9e\u73b0\uff0c\u5426\u5219\u6700\u540ecork\u5c31\u6ca1\u6709\u610f\u4e49\uff0c\u56e0\u4e3a\u6700\u7ec8\u8fd8\u662f\u9700\u8981\u4e00\u5757\u5757\u7684\u6570\u636e\u8fdb\u884c\u5199\u5165\u3002\u6211\u4eec\u770b\u770bcork\u7684\u4ee3\u7801\u3002 1. Writable.prototype.cork = function() { 2. var state = this._writableState; 3. state.corked++; 4. }; cork\u7684\u4ee3\u7801\u975e\u5e38\u7b80\u5355\uff0c\u8fd9\u91cc\u4f7f\u7528\u4e00\u4e2a\u6574\u6570\u800c\u4e0d\u662f\u6807\u8bb0\u4f4d\uff0c\u6240\u4ee5cork\u548cuncork\u9700\u8981\u914d\u5bf9\u4f7f\u7528\u3002\u6211\u4eec\u770b\u770buncork\u3002 1. Writable.prototype.uncork = function() { 2. var state = this._writableState; 3. 4. if (state.corked) { 5. state.corked--; 6. /* 7. \u6ca1\u6709\u5728\u8fdb\u884c\u5199\u64cd\u4f5c\uff08\u5982\u679c\u8fdb\u884c\u5199\u64cd\u4f5c\u5219\u5728\u5199\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03\u91cc\u4f1a\u6267\u884cclearBuffer\uff09\uff0c 8. corked=0\uff0c 9. \u6ca1\u6709\u5728\u5904\u7406\u7f13\u5b58\u6570\u636e\uff08writing\u4e3afalse\u5df2\u7ecf\u8bf4\u660e\uff09\uff0c 10. \u6709\u7f13\u5b58\u7684\u6570\u636e\u5f85\u5904\u7406 11. */ 12. if (!state.writing && 13. !state.corked && 14. !state.bufferProcessing && 15. state.bufferedRequest) 16. clearBuffer(this, state); 17. } 18. };","title":"21.3.4 cork\u548cuncork"},{"location":"chapter21-JS%20Stream/#2135","text":"\u6d41\u7ed3\u675f\u9996\u5148\u4f1a\u628a\u5f53\u524d\u7f13\u5b58\u7684\u6570\u636e\u5199\u5165\u76ee\u7684\u5730\uff0c\u5e76\u4e14\u5141\u8bb8\u518d\u6267\u884c\u989d\u5916\u7684\u4e00\u6b21\u5199\u64cd\u4f5c\uff0c\u7136\u540e\u628a\u53ef\u5199\u6d41\u7f6e\u4e3a\u4e0d\u53ef\u5199\u548c\u7ed3\u675f\u72b6\u6001\uff0c\u5e76\u4e14\u89e6\u53d1\u4e00\u7cfb\u5217\u4e8b\u4ef6\u3002\u4e0b\u9762\u662f\u7ed3\u675f\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u51fd\u6570\u5173\u7cfb\u56fe\u3002\u5982\u56fe21-11\u6240\u793a\u3002 \u56fe21-11 \u901a\u8fc7end\u51fd\u6570\u53ef\u4ee5\u7ed3\u675f\u53ef\u5199\u6d41\uff0c\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1. Writable.prototype.end = function(chunk, encoding, cb) { 2. var state = this._writableState; 3. 4. if (typeof chunk === 'function') { 5. cb = chunk; 6. chunk = null; 7. encoding = null; 8. } else if (typeof encoding === 'function') { 9. cb = encoding; 10. encoding = null; 11. } 12. // \u6700\u540e\u4e00\u6b21\u5199\u5165\u7684\u673a\u4f1a\uff0c\u53ef\u80fd\u76f4\u63a5\u5199\u5165\uff0c\u4e5f\u53ef\u4ee5\u4f1a\u88ab\u7f13\u5b58\uff08\u6b63\u5728\u5199\u62a4\u7740\u5904\u4e8ecorked\u72b6\u6001\uff09 13. if (chunk !== null && chunk !== undefined) 14. this.write(chunk, encoding); 15. 16. // \u5982\u679c\u5904\u4e8ecorked\u72b6\u6001\uff0c\u5219\u4e0a\u9762\u7684\u5199\u64cd\u4f5c\u4f1a\u88ab\u7f13\u5b58\uff0cuncork\u548cwrite\u4fdd\u5b58\u53ef\u4ee5\u5bf9\u5269\u4f59\u6570\u636e\u6267\u884c\u5199\u64cd\u4f5c 17. if (state.corked) { 18. // \u7f6e1\uff0c\u4e3a\u4e86uncork\u80fd\u6b63\u786e\u6267\u884c,\u53ef\u4ee5\u6709\u673a\u4f1a\u5199\u5165\u7f13\u5b58\u7684\u6570\u636e 19. state.corked = 1; 20. this.uncork(); 21. } 22. 23. if (!state.ending) 24. endWritable(this, state, cb); 25. }; \u6211\u4eec\u63a5\u7740\u770bendWritable\u51fd\u6570 1. function endWritable(stream, state, cb) { 2. // \u6b63\u5728\u6267\u884cend\u51fd\u6570 3. state.ending = true; 4. // \u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u4e86 5. finishMaybe(stream, state); 6. if (cb) { 7. // \u5df2\u7ecf\u89e6\u53d1\u4e86finish\u4e8b\u4ef6\u5219\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884ccb\uff0c\u5426\u5219\u7b49\u5f85finish\u4e8b\u4ef6 8. if (state.finished) 9. process.nextTick(cb); 10. else 11. stream.once('finish', cb); 12. } 13. // \u6d41\u7ed3\u675f\uff0c\u6d41\u4e0d\u53ef\u5199 14. state.ended = true; 15. stream.writable = false; 16. } endWritable\u51fd\u6570\u6807\u8bb0\u6d41\u4e0d\u53ef\u5199\u5e76\u4e14\u5904\u4e8e\u7ed3\u675f\u72b6\u6001\u3002\u4f46\u662f\u53ea\u662f\u4ee3\u8868\u4e0d\u80fd\u518d\u8c03\u7528write\u5199\u6570\u636e\u4e86\uff0c\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e\u9700\u8981\u88ab\u5199\u5b8c\u540e\u624d\u80fd\u771f\u6b63\u5730\u7ed3\u675f\u6d41\u3002\u6211\u4eec\u770bfinishMaybe\u51fd\u6570\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u7528\u4e8e\u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u3002 1. function needFinish(state) { 2. /* 3. \u6267\u884c\u4e86end\u51fd\u6570\u5219\u8bbe\u7f6eending=true\uff0c 4. \u5f53\u524d\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86\uff0c 5. \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c 6. \u8fd8\u6ca1\u6709\u89e6\u53d1finish\u4e8b\u4ef6\uff0c 7. \u6ca1\u6709\u6b63\u5728\u8fdb\u884c\u5199\u5165 8. */ 9. return (state.ending && 10. state.length === 0 && 11. state.bufferedRequest === null && 12. !state.finished && 13. !state.writing); 14. } 15. 16. // \u6bcf\u6b21\u5199\u5b8c\u6210\u7684\u65f6\u5019\u4e5f\u4f1a\u8c03\u7528\u8be5\u51fd\u6570 17. function finishMaybe(stream, state) { 18. // \u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f 19. var need = needFinish(state); 20. // \u662f\u5219\u5148\u5904\u7406prefinish\u4e8b\u4ef6\uff0c\u5426\u5219\u5148\u4e0d\u7ba1\uff0c\u7b49\u5f85\u5199\u5b8c\u6210\u518d\u8c03\u7528\u8be5\u51fd\u6570 21. if (need) { 22. prefinish(stream, state); 23. // \u5982\u679c\u6ca1\u6709\u5f85\u6267\u884c\u7684\u56de\u8c03\uff0c\u5219\u89e6\u53d1finish\u4e8b\u4ef6 24. if (state.pendingcb === 0) { 25. state.finished = true; 26. stream.emit('finish'); 27. } 28. } 29. return need; 30. } \u5f53\u53ef\u5199\u6d41\u4e2d\u6240\u6709\u6570\u636e\u548c\u56de\u8c03\u90fd\u6267\u884c\u4e86\u624d\u80fd\u7ed3\u675f\u6d41\uff0c\u5728\u7ed3\u675f\u6d41\u4e4b\u524d\u4f1a\u5148\u5904\u7406prefinish\u4e8b\u4ef6\u3002 1. function callFinal(stream, state) { 2. // \u6267\u884c\u7528\u6237\u7684final\u51fd\u6570 3. stream._final((err) => { 4. // \u6267\u884c\u4e86callFinal\u51fd\u6570\uff0ccb\u51cf\u4e00 5. state.pendingcb--; 6. if (err) { 7. stream.emit('error', err); 8. } 9. // \u6267\u884cprefinish 10. state.prefinished = true; 11. stream.emit('prefinish'); 12. // \u662f\u5426\u53ef\u4ee5\u89e6\u53d1finish\u4e8b\u4ef6 13. finishMaybe(stream, state); 14. }); 15. } 16. function prefinish(stream, state) { 17. // \u8fd8\u6ca1\u89e6\u53d1prefinish\u5e76\u4e14\u6ca1\u6709\u6267\u884cfinalcall 18. if (!state.prefinished && !state.finalCalled) { 19. // \u7528\u6237\u4f20\u4e86final\u51fd\u6570\u5219\uff0c\u5f85\u6267\u884c\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373callFinal\uff0c\u5426\u5219\u76f4\u63a5\u89e6\u53d1prefinish 20. if (typeof stream._final === 'function') { 21. state.pendingcb++; 22. state.finalCalled = true; 23. process.nextTick(callFinal, stream, state); 24. } else { 25. state.prefinished = true; 26. stream.emit('prefinish'); 27. } 28. } 29. } \u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86_final\u51fd\u6570\uff0c\u5219\u5148\u6267\u884c\u8be5\u51fd\u6570\uff08\u8fd9\u65f6\u5019\u4f1a\u963b\u6b62finish\u4e8b\u4ef6\u7684\u89e6\u53d1\uff09\uff0c\u6267\u884c\u5b8c\u540e\u89e6\u53d1prefinish\uff0c\u518d\u89e6\u53d1finish\u3002\u5982\u679c\u6ca1\u6709\u5b9a\u4e49_final\uff0c\u5219\u76f4\u63a5\u89e6\u53d1prefinish\u4e8b\u4ef6\u3002\u6700\u540e\u89e6\u53d1finish\u4e8b\u4ef6\u3002","title":"21.3.5 \u6d41\u7ed3\u675f"},{"location":"chapter21-JS%20Stream/#214","text":"\u53cc\u5411\u6d41\u662f\u7ee7\u627f\u53ef\u8bfb\u3001\u53ef\u5199\u7684\u6d41\u3002 1. util.inherits(Duplex, Readable); 2. 3. { 4. // \u628a\u53ef\u5199\u6d41\u4e2d\u5b58\u5728\uff0c\u5e76\u4e14\u5728\u53ef\u8bfb\u6d41\u548cDuplex\u91cc\u90fd\u4e0d\u5b58\u5728\u7684\u65b9\u6cd5\u52a0\u5165\u5230Duplex 5. const keys = Object.keys(Writable.prototype); 6. for (var v = 0; v < keys.length; v++) { 7. const method = keys[v]; 8. if (!Duplex.prototype[method]) 9. Duplex.prototype[method] = Writable.prototype[method]; 10. } 11. } 1. function Duplex(options) { 2. if (!(this instanceof Duplex)) 3. return new Duplex(options); 4. 5. Readable.call(this, options); 6. Writable.call(this, options); 7. // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u8bfb 8. if (options && options.readable === false) 9. this.readable = false; 10. // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u5199 11. if (options && options.writable === false) 12. this.writable = false; 13. // \u9ed8\u8ba4\u5141\u8bb8\u534a\u5f00\u5173 14. this.allowHalfOpen = true; 15. if (options && options.allowHalfOpen === false) 16. this.allowHalfOpen = false; 17. 18. this.once('end', onend); 19. } \u53cc\u5411\u6d41\u7ee7\u627f\u4e86\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u80fd\u529b\u3002\u53cc\u5411\u6d41\u5b9e\u73b0\u4e86\u4ee5\u4e0b\u529f\u80fd","title":"21.4 \u53cc\u5411\u6d41"},{"location":"chapter21-JS%20Stream/#2141","text":"\u5982\u679c\u8bfb\u5199\u4e24\u7aef\u90fd\u9500\u6bc1\uff0c\u5219\u53cc\u5411\u6d41\u9500\u6bc1\u3002 1. Object.defineProperty(Duplex.prototype, 'destroyed', { 2. enumerable: false, 3. get() { 4. if (this._readableState === undefined || 5. this._writableState === undefined) { 6. return false; 7. } 8. return this._readableState.destroyed && this._writableState.destroyed; 9. } 10. } \u6211\u4eec\u770b\u5982\u4f55\u9500\u6bc1\u4e00\u4e2a\u53cc\u5411\u6d41\u3002 1. Duplex.prototype._destroy = function(err, cb) { 2. // \u5173\u95ed\u8bfb\u7aef 3. this.push(null); 4. // \u5173\u95ed\u5199\u7aef 5. this.end(); 6. // \u6267\u884c\u56de\u8c03 7. process.nextTick(cb, err); 8. }; \u53cc\u5411\u6d41\u8fd8\u6709\u4e00\u4e2a\u7279\u6027\u662f\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5373\u53ef\u8bfb\u6216\u53ef\u5199\u3002onend\u662f\u8bfb\u7aef\u5173\u95ed\u65f6\u6267\u884c\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1. // \u5173\u95ed\u5199\u6d41 2. function onend() { 3. // \u5141\u8bb8\u534a\u5f00\u5173\u6216\u5199\u6d41\u5df2\u7ecf\u7ed3\u675f\u5219\u8fd4\u56de 4. if (this.allowHalfOpen || this._writableState.ended) 5. return; 6. // \u4e0b\u4e00\u4e2atick\u518d\u5173\u95ed\u5199\u6d41\uff0c\u6267\u884c\u5b8c\u8fd9\u6bb5\u4ee3\u7801\uff0c\u7528\u6237\u8fd8\u53ef\u4ee5\u5199 7. process.nextTick(onEndNT, this); 8. } 9. 10. function onEndNT(self) { 11. // \u8c03\u7528\u5199\u7aef\u7684end\u51fd\u6570 12. self.end(); 13. } \u5f53\u53cc\u5411\u6d41\u5141\u8bb8\u534a\u5f00\u5173\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5173\u95ed\u65f6\uff0c\u53ef\u5199\u6d41\u53ef\u4ee5\u4e0d\u5173\u95ed\u3002","title":"21.4.1 \u9500\u6bc1"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/","text":"events\u6a21\u5757\u662fNode.js\u4e2d\u6bd4\u8f83\u7b80\u5355\u4f46\u662f\u5374\u975e\u5e38\u6838\u5fc3\u7684\u6a21\u5757\uff0cNode.js\u4e2d\uff0c\u5f88\u591a\u6a21\u5757\u90fd\u7ee7\u627f\u4e8eevents\u6a21\u5757\uff0cevents\u6a21\u5757\u662f\u53d1\u5e03\u3001\u8ba2\u9605\u6a21\u5f0f\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e2a\u5982\u679c\u4f7f\u7528events\u6a21\u5757\u3002 1. const { EventEmitter } = require('events'); 2. class Events extends EventEmitter {} 3. const events = new Events(); 4. events.on('demo', () => { 5. console.log('emit demo event'); 6. }); 7. events.emit('demo'); \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bevents\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002 22.1 \u521d\u59cb\u5316 \u00b6 \u5f53new\u4e00\u4e2aEventEmitter\u6216\u8005\u4ed6\u7684\u5b50\u7c7b\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165EventEmitter\u7684\u903b\u8f91\u3002 1. function EventEmitter(opts) { 2. EventEmitter.init.call(this, opts); 3. } 4. 5. EventEmitter.init = function(opts) { 6. // \u5982\u679c\u662f\u672a\u521d\u59cb\u5316\u6216\u8005\u6ca1\u6709\u81ea\u5b9a\u4e49_events\uff0c\u5219\u521d\u59cb\u5316 7. if (this._events === undefined || 8. this._events === ObjectGetPrototypeOf(this)._events) { 9. this._events = ObjectCreate(null); 10. this._eventsCount = 0; 11. } 12. // \u521d\u59cb\u5316\u5904\u7406\u51fd\u6570\u4e2a\u6570\u7684\u9608\u503c 13. this._maxListeners = this._maxListeners || undefined; 14. 15. // \u662f\u5426\u5f00\u542f\u6355\u83b7promise reject,\u9ed8\u8ba4false 16. if (opts && opts.captureRejections) { 17. this[kCapture] = Boolean(opts.captureRejections); 18. } else { 19. this[kCapture] = EventEmitter.prototype[kCapture]; 20. } 21. }; EventEmitter\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u548c\u5c5e\u6027\u3002\u552f\u4e00\u652f\u6301\u7684\u4e00\u4e2a\u53c2\u6570\u5c31\u662fcaptureRejections\uff0ccaptureRejections\u8868\u793a\u5f53\u89e6\u53d1\u4e8b\u4ef6\uff0c\u6267\u884c\u5904\u7406\u51fd\u6570\u65f6\uff0cEventEmitter\u662f\u5426\u6355\u83b7\u5904\u7406\u51fd\u6570\u4e2d\u7684\u5f02\u5e38\u3002\u540e\u9762\u6211\u4eec\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002 22.2 \u8ba2\u9605\u4e8b\u4ef6 \u00b6 \u521d\u59cb\u5316\u5b8cEventEmitter\u4e4b\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u4f7f\u7528\u8ba2\u9605\u3001\u53d1\u5e03\u7684\u529f\u80fd\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7addListener\u3001prependListener\u3001on\u3001once\u8ba2\u9605\u4e8b\u4ef6\u3002addListener\u548con\u662f\u7b49\u4ef7\u7684\uff0cprependListener\u7684\u533a\u522b\u5728\u4e8e\u5904\u7406\u51fd\u6570\u4f1a\u88ab\u63d2\u5165\u5230\u961f\u9996\uff0c\u800c\u9ed8\u8ba4\u662f\u8ffd\u52a0\u5230\u961f\u5c3e\u3002once\u6ce8\u518c\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u591a\u88ab\u6267\u884c\u4e00\u6b21\u3002\u56db\u4e2aAPI\u90fd\u662f\u901a\u8fc7_addListener\u51fd\u6570\u5b9e\u73b0\u7684\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1. function _addListener(target, type, listener, prepend) { 2. let m; 3. let events; 4. let existing; 5. events = target._events; 6. // \u8fd8\u6ca1\u6709\u521d\u59cb\u5316_events\u5219\u521d\u59cb\u5316 7. if (events === undefined) { 8. events = target._events = ObjectCreate(null); 9. target._eventsCount = 0; 10. } else { 11. /* 12. \u662f\u5426\u5b9a\u4e49\u4e86newListener\u4e8b\u4ef6\uff0c\u662f\u7684\u8bdd\u5148\u89e6\u53d1,\u5982\u679c\u76d1\u542c\u4e86newListener\u4e8b\u4ef6\uff0c 13. \u6bcf\u6b21\u6ce8\u518c\u5176\u4ed6\u4e8b\u4ef6\u65f6\u90fd\u4f1a\u89e6\u53d1newListener\uff0c\u76f8\u5f53\u4e8e\u94a9\u5b50 14. */ 15. if (events.newListener !== undefined) { 16. target.emit('newListener', type, 17. listener.listener ? listener.listener : listener); 18. // \u53ef\u80fd\u4f1a\u4fee\u6539_events\uff0c\u8fd9\u91cc\u91cd\u65b0\u8d4b\u503c 19. events = target._events; 20. } 21. // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5904\u7406\u51fd\u6570 22. existing = events[type]; 23. } 24. // \u4e0d\u5b58\u5728\u5219\u4ee5\u51fd\u6570\u7684\u5f62\u5f0f\u5b58\u50a8\uff0c\u5426\u5219\u662f\u6570\u7ec4 25. if (existing === undefined) { 26. events[type] = listener; 27. ++target._eventsCount; 28. } else { 29. if (typeof existing === 'function') { 30. existing = events[type] = 31. prepend ? [listener, existing] : [existing, listener]; 32. } else if (prepend) { 33. existing.unshift(listener); 34. } else { 35. existing.push(listener); 36. } 37. 38. // \u5904\u7406\u544a\u8b66\uff0c\u5904\u7406\u51fd\u6570\u8fc7\u591a\u53ef\u80fd\u662f\u56e0\u4e3a\u4e4b\u524d\u7684\u6ca1\u6709\u5220\u9664\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u6f0f 39. m = _getMaxListeners(target); 40. if (m > 0 && existing.length > m && !existing.warned) { 41. existing.warned = true; 42. const w = new Error('Possible EventEmitter memory leak detected. ' + 43. `${existing.length} ${String(type)} listeners ` + 44. `added to ${inspect(target, { depth: -1 })}. Use ` + 45. 'emitter.setMaxListeners() to increase limit'); 46. w.name = 'MaxListenersExceededWarning'; 47. w.emitter = target; 48. w.type = type; 49. w.count = existing.length; 50. process.emitWarning(w); 51. } 52. } 53. 54. return target; 55. } \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bonce\u7684\u5b9e\u73b0\uff0c\u5bf9\u6bd4\u5176\u4ed6\u51e0\u79cdapi\uff0conce\u7684\u5b9e\u73b0\u76f8\u5bf9\u6bd4\u8f83\u96be\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u63a7\u5236\u5904\u7406\u51fd\u6570\u6700\u591a\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u575a\u6301\u7528\u6237\u5b9a\u4e49\u7684\u51fd\u6570\uff0c\u4fdd\u8bc1\u5728\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7528\u6237\u5b9a\u4e49\u51fd\u6570\u7684\u540c\u65f6\uff0c\u8fd8\u9700\u8981\u5220\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002 1. EventEmitter.prototype.once = function once(type, listener) { 2. this.on(type, _onceWrap(this, type, listener)); 3. return this; 4. }; 5. 6. function onceWrapper() { 7. // \u8fd8\u6ca1\u6709\u89e6\u53d1\u8fc7 8. if (!this.fired) { 9. // \u5220\u9664\u4ed6 10. this.target.removeListener(this.type, this.wrapFn); 11. // \u89e6\u53d1\u4e86 12. this.fired = true; 13. // \u6267\u884c 14. if (arguments.length === 0) 15. return this.listener.call(this.target); 16. return this.listener.apply(this.target, arguments); 17. } 18. } 19. // \u652f\u6301once api 20. function _onceWrap(target, type, listener) { 21. // fired\u662f\u5426\u5df2\u6267\u884c\u5904\u7406\u51fd\u6570\uff0cwrapFn\u5305\u88f9listener\u7684\u51fd\u6570 22. const state = { fired: false, wrapFn: undefined, target, type, listener }; 23. // \u751f\u6210\u4e00\u4e2a\u5305\u88f9listener\u7684\u51fd\u6570 24. const wrapped = onceWrapper.bind(state); 25. // \u628a\u539f\u51fd\u6570listener\u4e5f\u6302\u5230\u5305\u88f9\u51fd\u6570\u4e2d\uff0c\u7528\u4e8e\u4e8b\u4ef6\u6ca1\u6709\u89e6\u53d1\u524d\uff0c\u7528\u6237\u4e3b\u52a8\u5220\u9664\uff0c\u89c1removeListener 26. wrapped.listener = listener; 27. // \u4fdd\u5b58\u5305\u88f9\u51fd\u6570\uff0c\u7528\u4e8e\u6267\u884c\u5b8c\u540e\u5220\u9664\uff0c\u89c1onceWrapper 28. state.wrapFn = wrapped; 29. return wrapped; 30. } 22.3 \u89e6\u53d1\u4e8b\u4ef6 \u00b6 \u5206\u6790\u5b8c\u4e8b\u4ef6\u7684\u8ba2\u9605\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u7684\u89e6\u53d1\u3002 1. EventEmitter.prototype.emit = function emit(type, ...args) { 2. // \u89e6\u53d1\u7684\u4e8b\u4ef6\u662f\u5426\u662ferror\uff0cerror\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406 3. let doError = (type === 'error'); 4. 5. const events = this._events; 6. // \u5b9a\u4e49\u4e86\u5904\u7406\u51fd\u6570\uff08\u4e0d\u4e00\u5b9a\u662ftype\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff09 7. if (events !== undefined) { 8. // \u5982\u679c\u89e6\u53d1\u7684\u4e8b\u4ef6\u662ferror\uff0c\u5e76\u4e14\u76d1\u542c\u4e86kErrorMonitor\u4e8b\u4ef6\u5219\u89e6\u53d1kErrorMonitor\u4e8b\u4ef6 9. if (doError && events[kErrorMonitor] !== undefined) 10. this.emit(kErrorMonitor, ...args); 11. // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570 12. doError = (doError && events.error === undefined); 13. } else if (!doError) // \u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570\u5e76\u4e14\u89e6\u53d1\u7684\u4e0d\u662ferror\u4e8b\u4ef6\u5219\u4e0d\u9700\u8981\u5904\u7406\uff0c 14. return false; 15. 16. // If there is no 'error' event listener then throw. 17. // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\uff0c\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406error\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u5219\u62a5\u9519 18. if (doError) { 19. let er; 20. if (args.length > 0) 21. er = args[0]; 22. // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fError\u7684\u5b9e\u4f8b 23. if (er instanceof Error) { 24. try { 25. const capture = {}; 26. /* 27. \u7ed9capture\u5bf9\u8c61\u6ce8\u5165stack\u5c5e\u6027\uff0cstack\u7684\u503c\u662f\u6267\u884cError.captureStackTrace 28. \u8bed\u53e5\u7684\u5f53\u524d\u6808\u4fe1\u606f\uff0c\u4f46\u662f\u4e0d\u5305\u62ecemit\u7684\u90e8\u5206 29. */ 30. Error.captureStackTrace(capture, EventEmitter.prototype.emit); 31. ObjectDefineProperty(er, kEnhanceStackBeforeInspector, { 32. value: enhanceStackTrace.bind(this, er, capture), 33. configurable: true 34. }); 35. } catch {} 36. throw er; // Unhandled 'error' event 37. } 38. 39. let stringifiedEr; 40. const { inspect } = require('internal/util/inspect'); 41. try { 42. stringifiedEr = inspect(er); 43. } catch { 44. stringifiedEr = er; 45. } 46. const err = new ERR_UNHANDLED_ERROR(stringifiedEr); 47. err.context = er; 48. throw err; // Unhandled 'error' event 49. } 50. // \u83b7\u53d6type\u4e8b\u4ef6\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 51. const handler = events[type]; 52. // \u6ca1\u6709\u5219\u4e0d\u5904\u7406 53. if (handler === undefined) 54. return false; 55. // \u7b49\u4e8e\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a 56. if (typeof handler === 'function') { 57. // \u76f4\u63a5\u6267\u884c 58. const result = ReflectApply(handler, this, args); 59. // \u975e\u7a7a\u5224\u65ad\u662f\u4e0d\u662fpromise\u5e76\u4e14\u662f\u5426\u9700\u8981\u5904\u7406\uff0c\u89c1addCatch 60. if (result !== undefined && result !== null) { 61. addCatch(this, result, type, args); 62. } 63. } else { 64. // \u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u540c\u4e0a 65. const len = handler.length; 66. const listeners = arrayClone(handler, len); 67. for (let i = 0; i < len; ++i) { 68. const result = ReflectApply(listeners[i], this, args); 69. if (result !== undefined && result !== null) { 70. addCatch(this, result, type, args); 71. } 72. } 73. } 74. 75. return true; 76. } \u6211\u4eec\u770b\u5230\u5728Node.js\u4e2d\uff0c\u5bf9\u4e8eerror\u4e8b\u4ef6\u662f\u7279\u6b8a\u5904\u7406\u7684\uff0c\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7a0b\u5e8f\u6302\u6389\uff0c\u53e6\u5916\u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2aaddCatch\u7684\u903b\u8f91\uff0caddCatch\u662f\u4e3a\u4e86\u652f\u6301\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e3a\u5f02\u6b65\u6a21\u5f0f\u7684\u60c5\u51b5\uff0c\u6bd4\u5982async\u51fd\u6570\u6216\u8005\u8fd4\u56dePromise\u7684\u51fd\u6570\u3002 1. function addCatch(that, promise, type, args) { 2. // \u6ca1\u6709\u5f00\u542f\u6355\u83b7\u5219\u4e0d\u9700\u8981\u5904\u7406 3. if (!that[kCapture]) { 4. return; 5. } 6. // that throws on second use. 7. try { 8. const then = promise.then; 9. 10. if (typeof then === 'function') { 11. // \u6ce8\u518creject\u7684\u5904\u7406\u51fd\u6570 12. then.call(promise, undefined, function(err) { 13. process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args); 14. }); 15. } 16. } catch (err) { 17. that.emit('error', err); 18. } 19. } 20. 21. function emitUnhandledRejectionOrErr(ee, err, type, args) { 22. // \u7528\u6237\u5b9e\u73b0\u4e86kRejection\u5219\u6267\u884c 23. if (typeof ee[kRejection] === 'function') { 24. ee[kRejection](err, type, ...args); 25. } else { 26. // \u4fdd\u5b58\u5f53\u524d\u503c 27. const prev = ee[kCapture]; 28. try { 29. /* 30. \u5173\u95ed\u7136\u540e\u89e6\u53d1error\u4e8b\u4ef6\uff0c\u610f\u4e49 31. 1 \u9632\u6b62error\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e5f\u629b\u51faerror\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af 32. 2 \u5982\u679c\u7528\u6237\u5904\u7406\u4e86error\uff0c\u5219\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u6240\u4ee5\u9700\u8981\u6062\u590dkCapture\u7684\u503c 33. \u5982\u679c\u7528\u6237\u6ca1\u6709\u5904\u7406error\uff0c\u5219nodejs\u4f1a\u89e6\u53d1uncaughtException\uff0c\u5982\u679c\u7528\u6237 34. \u5904\u7406\u4e86uncaughtException\u5219\u9700\u8981\u7070\u5ea6kCapture\u7684\u503c 35. */ 36. ee[kCapture] = false; 37. ee.emit('error', err); 38. } finally { 39. ee[kCapture] = prev; 40. } 41. } 42. } 22.4 \u53d6\u6d88\u8ba2\u9605 \u00b6 \u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0b\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u903b\u8f91\u3002 1. function removeAllListeners(type) { 2. const events = this._events; 3. if (events === undefined) 4. return this; 5. 6. // \u6ca1\u6709\u6ce8\u518cremoveListener\u4e8b\u4ef6\uff0c\u5219\u53ea\u9700\u8981\u5220\u9664\u6570\u636e\uff0c\u5426\u5219\u8fd8\u9700\u8981\u89e6\u53d1removeListener\u4e8b\u4ef6 7. if (events.removeListener === undefined) { 8. // \u7b49\u4e8e0\u8bf4\u660e\u662f\u5220\u9664\u5168\u90e8 9. if (arguments.length === 0) { 10. this._events = ObjectCreate(null); 11. this._eventsCount = 0; 12. } else if (events[type] !== undefined) { // \u5426\u5219\u662f\u5220\u9664\u67d0\u4e2a\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c 13. // \u662f\u552f\u4e00\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5219\u91cd\u7f6e_events\uff0c\u5426\u5219\u5220\u9664\u5bf9\u5e94\u7684\u4e8b\u4ef6\u7c7b\u578b 14. if (--this._eventsCount === 0) 15. this._events = ObjectCreate(null); 16. else 17. delete events[type]; 18. } 19. return this; 20. } 21. 22. // \u8bf4\u660e\u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0carguments.length === 0\u8bf4\u660e\u5220\u9664\u6240\u6709\u7c7b\u578b\u7684\u4e8b\u4ef6 23. if (arguments.length === 0) { 24. // \u9010\u4e2a\u5220\u9664\uff0c\u9664\u4e86removeListener\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5220\u9664\u4e86\u975eremoveListener\u4e8b\u4ef6 25. for (const key of ObjectKeys(events)) { 26. if (key === 'removeListener') continue; 27. this.removeAllListeners(key); 28. } 29. // \u8fd9\u91cc\u5220\u9664removeListener\u4e8b\u4ef6\uff0c\u89c1\u4e0b\u9762\u7684\u903b\u8f91 30. this.removeAllListeners('removeListener'); 31. // \u91cd\u7f6e\u6570\u636e\u7ed3\u6784 32. this._events = ObjectCreate(null); 33. this._eventsCount = 0; 34. return this; 35. } 36. // \u5220\u9664\u67d0\u7c7b\u578b\u4e8b\u4ef6 37. const listeners = events[type]; 38. 39. if (typeof listeners === 'function') { 40. this.removeListener(type, listeners); 41. } else if (listeners !== undefined) { 42. // LIFO order 43. for (let i = listeners.length - 1; i >= 0; i--) { 44. this.removeListener(type, listeners[i]); 45. } 46. } 47. 48. return this; 49. } removeAllListeners\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u6709\u4e24\u70b9\uff0c\u7b2c\u4e00\u4e2a\u662fremoveListener\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406\uff0c\u8fd9\u7c7b\u4f3c\u4e00\u4e2a\u94a9\u5b50\uff0c\u6bcf\u6b21\u7528\u6237\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u65f6\u5019\u90fd\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6\u3002\u7b2c\u4e8c\u662fremoveListener\u51fd\u6570\u3002removeListener\u662f\u771f\u6b63\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u5b9e\u73b0\u3002removeAllListeners\u662f\u5c01\u88c5\u4e86removeListener\u7684\u903b\u8f91\u3002 1. function removeListener(type, listener) { 2. let originalListener; 3. const events = this._events; 4. // \u6ca1\u6709\u4e1c\u897f\u53ef\u5220\u9664 5. if (events === undefined) 6. return this; 7. 8. const list = events[type]; 9. // \u540c\u4e0a 10. if (list === undefined) 11. return this; 12. // list\u662f\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5426\u5219\u662f\u6570\u7ec4,\u5982\u679clist.listener === listener\u8bf4\u660e\u662fonce\u6ce8\u518c\u7684 13. if (list === listener || list.listener === listener) { 14. // type\u7c7b\u578b\u7684\u5904\u7406\u51fd\u6570\u5c31\u4e00\u4e2a\uff0c\u5e76\u4e14\u4e5f\u6ca1\u6709\u6ce8\u518c\u5176\u4ed6\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c\u5219\u521d\u59cb\u5316_events 15. if (--this._eventsCount === 0) 16. this._events = ObjectCreate(null); 17. else { 18. // \u5c31\u4e00\u4e2a\u6267\u884c\u5b8c\u5220\u9664type\u5bf9\u5e94\u7684\u5c5e\u6027 19. delete events[type]; 20. // \u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0c\u5219\u5148\u6ce8\u518cremoveListener\u4e8b\u4ef6 21. if (events.removeListener) 22. this.emit('removeListener', type, list.listener || listener); 23. } 24. } else if (typeof list !== 'function') { 25. // \u591a\u4e2a\u5904\u7406\u51fd\u6570 26. let position = -1; 27. // \u627e\u51fa\u9700\u8981\u5220\u9664\u7684\u51fd\u6570 28. for (let i = list.length - 1; i >= 0; i--) { 29. if (list[i] === listener || list[i].listener === listener) { 30. // \u4fdd\u5b58\u539f\u5904\u7406\u51fd\u6570\uff0c\u5982\u679c\u6709\u7684\u8bdd 31. originalListener = list[i].listener; 32. position = i; 33. break; 34. } 35. } 36. 37. if (position < 0) 38. return this; 39. // \u7b2c\u4e00\u4e2a\u5219\u51fa\u961f\uff0c\u5426\u5219\u5220\u9664\u4e00\u4e2a 40. if (position === 0) 41. list.shift(); 42. else { 43. if (spliceOne === undefined) 44. spliceOne = require('internal/util').spliceOne; 45. spliceOne(list, position); 46. } 47. // \u5982\u679c\u53ea\u5269\u4e0b\u4e00\u4e2a\uff0c\u5219\u503c\u6539\u6210\u51fd\u6570\u7c7b\u578b 48. if (list.length === 1) 49. events[type] = list[0]; 50. // \u89e6\u53d1removeListener 51. if (events.removeListener !== undefined) 52. this.emit('removeListener', type, originalListener || listener); 53. } 54. 55. return this; 56. }; \u4ee5\u4e0a\u5c31\u662fevents\u6a21\u5757\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5de5\u5177\u51fd\u6570\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002","title":"21-events\u6a21\u5757"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#221","text":"\u5f53new\u4e00\u4e2aEventEmitter\u6216\u8005\u4ed6\u7684\u5b50\u7c7b\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165EventEmitter\u7684\u903b\u8f91\u3002 1. function EventEmitter(opts) { 2. EventEmitter.init.call(this, opts); 3. } 4. 5. EventEmitter.init = function(opts) { 6. // \u5982\u679c\u662f\u672a\u521d\u59cb\u5316\u6216\u8005\u6ca1\u6709\u81ea\u5b9a\u4e49_events\uff0c\u5219\u521d\u59cb\u5316 7. if (this._events === undefined || 8. this._events === ObjectGetPrototypeOf(this)._events) { 9. this._events = ObjectCreate(null); 10. this._eventsCount = 0; 11. } 12. // \u521d\u59cb\u5316\u5904\u7406\u51fd\u6570\u4e2a\u6570\u7684\u9608\u503c 13. this._maxListeners = this._maxListeners || undefined; 14. 15. // \u662f\u5426\u5f00\u542f\u6355\u83b7promise reject,\u9ed8\u8ba4false 16. if (opts && opts.captureRejections) { 17. this[kCapture] = Boolean(opts.captureRejections); 18. } else { 19. this[kCapture] = EventEmitter.prototype[kCapture]; 20. } 21. }; EventEmitter\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u548c\u5c5e\u6027\u3002\u552f\u4e00\u652f\u6301\u7684\u4e00\u4e2a\u53c2\u6570\u5c31\u662fcaptureRejections\uff0ccaptureRejections\u8868\u793a\u5f53\u89e6\u53d1\u4e8b\u4ef6\uff0c\u6267\u884c\u5904\u7406\u51fd\u6570\u65f6\uff0cEventEmitter\u662f\u5426\u6355\u83b7\u5904\u7406\u51fd\u6570\u4e2d\u7684\u5f02\u5e38\u3002\u540e\u9762\u6211\u4eec\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002","title":"22.1 \u521d\u59cb\u5316"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#222","text":"\u521d\u59cb\u5316\u5b8cEventEmitter\u4e4b\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u4f7f\u7528\u8ba2\u9605\u3001\u53d1\u5e03\u7684\u529f\u80fd\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7addListener\u3001prependListener\u3001on\u3001once\u8ba2\u9605\u4e8b\u4ef6\u3002addListener\u548con\u662f\u7b49\u4ef7\u7684\uff0cprependListener\u7684\u533a\u522b\u5728\u4e8e\u5904\u7406\u51fd\u6570\u4f1a\u88ab\u63d2\u5165\u5230\u961f\u9996\uff0c\u800c\u9ed8\u8ba4\u662f\u8ffd\u52a0\u5230\u961f\u5c3e\u3002once\u6ce8\u518c\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u591a\u88ab\u6267\u884c\u4e00\u6b21\u3002\u56db\u4e2aAPI\u90fd\u662f\u901a\u8fc7_addListener\u51fd\u6570\u5b9e\u73b0\u7684\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1. function _addListener(target, type, listener, prepend) { 2. let m; 3. let events; 4. let existing; 5. events = target._events; 6. // \u8fd8\u6ca1\u6709\u521d\u59cb\u5316_events\u5219\u521d\u59cb\u5316 7. if (events === undefined) { 8. events = target._events = ObjectCreate(null); 9. target._eventsCount = 0; 10. } else { 11. /* 12. \u662f\u5426\u5b9a\u4e49\u4e86newListener\u4e8b\u4ef6\uff0c\u662f\u7684\u8bdd\u5148\u89e6\u53d1,\u5982\u679c\u76d1\u542c\u4e86newListener\u4e8b\u4ef6\uff0c 13. \u6bcf\u6b21\u6ce8\u518c\u5176\u4ed6\u4e8b\u4ef6\u65f6\u90fd\u4f1a\u89e6\u53d1newListener\uff0c\u76f8\u5f53\u4e8e\u94a9\u5b50 14. */ 15. if (events.newListener !== undefined) { 16. target.emit('newListener', type, 17. listener.listener ? listener.listener : listener); 18. // \u53ef\u80fd\u4f1a\u4fee\u6539_events\uff0c\u8fd9\u91cc\u91cd\u65b0\u8d4b\u503c 19. events = target._events; 20. } 21. // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5904\u7406\u51fd\u6570 22. existing = events[type]; 23. } 24. // \u4e0d\u5b58\u5728\u5219\u4ee5\u51fd\u6570\u7684\u5f62\u5f0f\u5b58\u50a8\uff0c\u5426\u5219\u662f\u6570\u7ec4 25. if (existing === undefined) { 26. events[type] = listener; 27. ++target._eventsCount; 28. } else { 29. if (typeof existing === 'function') { 30. existing = events[type] = 31. prepend ? [listener, existing] : [existing, listener]; 32. } else if (prepend) { 33. existing.unshift(listener); 34. } else { 35. existing.push(listener); 36. } 37. 38. // \u5904\u7406\u544a\u8b66\uff0c\u5904\u7406\u51fd\u6570\u8fc7\u591a\u53ef\u80fd\u662f\u56e0\u4e3a\u4e4b\u524d\u7684\u6ca1\u6709\u5220\u9664\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u6f0f 39. m = _getMaxListeners(target); 40. if (m > 0 && existing.length > m && !existing.warned) { 41. existing.warned = true; 42. const w = new Error('Possible EventEmitter memory leak detected. ' + 43. `${existing.length} ${String(type)} listeners ` + 44. `added to ${inspect(target, { depth: -1 })}. Use ` + 45. 'emitter.setMaxListeners() to increase limit'); 46. w.name = 'MaxListenersExceededWarning'; 47. w.emitter = target; 48. w.type = type; 49. w.count = existing.length; 50. process.emitWarning(w); 51. } 52. } 53. 54. return target; 55. } \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bonce\u7684\u5b9e\u73b0\uff0c\u5bf9\u6bd4\u5176\u4ed6\u51e0\u79cdapi\uff0conce\u7684\u5b9e\u73b0\u76f8\u5bf9\u6bd4\u8f83\u96be\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u63a7\u5236\u5904\u7406\u51fd\u6570\u6700\u591a\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u575a\u6301\u7528\u6237\u5b9a\u4e49\u7684\u51fd\u6570\uff0c\u4fdd\u8bc1\u5728\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7528\u6237\u5b9a\u4e49\u51fd\u6570\u7684\u540c\u65f6\uff0c\u8fd8\u9700\u8981\u5220\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002 1. EventEmitter.prototype.once = function once(type, listener) { 2. this.on(type, _onceWrap(this, type, listener)); 3. return this; 4. }; 5. 6. function onceWrapper() { 7. // \u8fd8\u6ca1\u6709\u89e6\u53d1\u8fc7 8. if (!this.fired) { 9. // \u5220\u9664\u4ed6 10. this.target.removeListener(this.type, this.wrapFn); 11. // \u89e6\u53d1\u4e86 12. this.fired = true; 13. // \u6267\u884c 14. if (arguments.length === 0) 15. return this.listener.call(this.target); 16. return this.listener.apply(this.target, arguments); 17. } 18. } 19. // \u652f\u6301once api 20. function _onceWrap(target, type, listener) { 21. // fired\u662f\u5426\u5df2\u6267\u884c\u5904\u7406\u51fd\u6570\uff0cwrapFn\u5305\u88f9listener\u7684\u51fd\u6570 22. const state = { fired: false, wrapFn: undefined, target, type, listener }; 23. // \u751f\u6210\u4e00\u4e2a\u5305\u88f9listener\u7684\u51fd\u6570 24. const wrapped = onceWrapper.bind(state); 25. // \u628a\u539f\u51fd\u6570listener\u4e5f\u6302\u5230\u5305\u88f9\u51fd\u6570\u4e2d\uff0c\u7528\u4e8e\u4e8b\u4ef6\u6ca1\u6709\u89e6\u53d1\u524d\uff0c\u7528\u6237\u4e3b\u52a8\u5220\u9664\uff0c\u89c1removeListener 26. wrapped.listener = listener; 27. // \u4fdd\u5b58\u5305\u88f9\u51fd\u6570\uff0c\u7528\u4e8e\u6267\u884c\u5b8c\u540e\u5220\u9664\uff0c\u89c1onceWrapper 28. state.wrapFn = wrapped; 29. return wrapped; 30. }","title":"22.2 \u8ba2\u9605\u4e8b\u4ef6"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#223","text":"\u5206\u6790\u5b8c\u4e8b\u4ef6\u7684\u8ba2\u9605\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u7684\u89e6\u53d1\u3002 1. EventEmitter.prototype.emit = function emit(type, ...args) { 2. // \u89e6\u53d1\u7684\u4e8b\u4ef6\u662f\u5426\u662ferror\uff0cerror\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406 3. let doError = (type === 'error'); 4. 5. const events = this._events; 6. // \u5b9a\u4e49\u4e86\u5904\u7406\u51fd\u6570\uff08\u4e0d\u4e00\u5b9a\u662ftype\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff09 7. if (events !== undefined) { 8. // \u5982\u679c\u89e6\u53d1\u7684\u4e8b\u4ef6\u662ferror\uff0c\u5e76\u4e14\u76d1\u542c\u4e86kErrorMonitor\u4e8b\u4ef6\u5219\u89e6\u53d1kErrorMonitor\u4e8b\u4ef6 9. if (doError && events[kErrorMonitor] !== undefined) 10. this.emit(kErrorMonitor, ...args); 11. // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570 12. doError = (doError && events.error === undefined); 13. } else if (!doError) // \u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570\u5e76\u4e14\u89e6\u53d1\u7684\u4e0d\u662ferror\u4e8b\u4ef6\u5219\u4e0d\u9700\u8981\u5904\u7406\uff0c 14. return false; 15. 16. // If there is no 'error' event listener then throw. 17. // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\uff0c\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406error\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u5219\u62a5\u9519 18. if (doError) { 19. let er; 20. if (args.length > 0) 21. er = args[0]; 22. // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fError\u7684\u5b9e\u4f8b 23. if (er instanceof Error) { 24. try { 25. const capture = {}; 26. /* 27. \u7ed9capture\u5bf9\u8c61\u6ce8\u5165stack\u5c5e\u6027\uff0cstack\u7684\u503c\u662f\u6267\u884cError.captureStackTrace 28. \u8bed\u53e5\u7684\u5f53\u524d\u6808\u4fe1\u606f\uff0c\u4f46\u662f\u4e0d\u5305\u62ecemit\u7684\u90e8\u5206 29. */ 30. Error.captureStackTrace(capture, EventEmitter.prototype.emit); 31. ObjectDefineProperty(er, kEnhanceStackBeforeInspector, { 32. value: enhanceStackTrace.bind(this, er, capture), 33. configurable: true 34. }); 35. } catch {} 36. throw er; // Unhandled 'error' event 37. } 38. 39. let stringifiedEr; 40. const { inspect } = require('internal/util/inspect'); 41. try { 42. stringifiedEr = inspect(er); 43. } catch { 44. stringifiedEr = er; 45. } 46. const err = new ERR_UNHANDLED_ERROR(stringifiedEr); 47. err.context = er; 48. throw err; // Unhandled 'error' event 49. } 50. // \u83b7\u53d6type\u4e8b\u4ef6\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 51. const handler = events[type]; 52. // \u6ca1\u6709\u5219\u4e0d\u5904\u7406 53. if (handler === undefined) 54. return false; 55. // \u7b49\u4e8e\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a 56. if (typeof handler === 'function') { 57. // \u76f4\u63a5\u6267\u884c 58. const result = ReflectApply(handler, this, args); 59. // \u975e\u7a7a\u5224\u65ad\u662f\u4e0d\u662fpromise\u5e76\u4e14\u662f\u5426\u9700\u8981\u5904\u7406\uff0c\u89c1addCatch 60. if (result !== undefined && result !== null) { 61. addCatch(this, result, type, args); 62. } 63. } else { 64. // \u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u540c\u4e0a 65. const len = handler.length; 66. const listeners = arrayClone(handler, len); 67. for (let i = 0; i < len; ++i) { 68. const result = ReflectApply(listeners[i], this, args); 69. if (result !== undefined && result !== null) { 70. addCatch(this, result, type, args); 71. } 72. } 73. } 74. 75. return true; 76. } \u6211\u4eec\u770b\u5230\u5728Node.js\u4e2d\uff0c\u5bf9\u4e8eerror\u4e8b\u4ef6\u662f\u7279\u6b8a\u5904\u7406\u7684\uff0c\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7a0b\u5e8f\u6302\u6389\uff0c\u53e6\u5916\u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2aaddCatch\u7684\u903b\u8f91\uff0caddCatch\u662f\u4e3a\u4e86\u652f\u6301\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e3a\u5f02\u6b65\u6a21\u5f0f\u7684\u60c5\u51b5\uff0c\u6bd4\u5982async\u51fd\u6570\u6216\u8005\u8fd4\u56dePromise\u7684\u51fd\u6570\u3002 1. function addCatch(that, promise, type, args) { 2. // \u6ca1\u6709\u5f00\u542f\u6355\u83b7\u5219\u4e0d\u9700\u8981\u5904\u7406 3. if (!that[kCapture]) { 4. return; 5. } 6. // that throws on second use. 7. try { 8. const then = promise.then; 9. 10. if (typeof then === 'function') { 11. // \u6ce8\u518creject\u7684\u5904\u7406\u51fd\u6570 12. then.call(promise, undefined, function(err) { 13. process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args); 14. }); 15. } 16. } catch (err) { 17. that.emit('error', err); 18. } 19. } 20. 21. function emitUnhandledRejectionOrErr(ee, err, type, args) { 22. // \u7528\u6237\u5b9e\u73b0\u4e86kRejection\u5219\u6267\u884c 23. if (typeof ee[kRejection] === 'function') { 24. ee[kRejection](err, type, ...args); 25. } else { 26. // \u4fdd\u5b58\u5f53\u524d\u503c 27. const prev = ee[kCapture]; 28. try { 29. /* 30. \u5173\u95ed\u7136\u540e\u89e6\u53d1error\u4e8b\u4ef6\uff0c\u610f\u4e49 31. 1 \u9632\u6b62error\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e5f\u629b\u51faerror\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af 32. 2 \u5982\u679c\u7528\u6237\u5904\u7406\u4e86error\uff0c\u5219\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u6240\u4ee5\u9700\u8981\u6062\u590dkCapture\u7684\u503c 33. \u5982\u679c\u7528\u6237\u6ca1\u6709\u5904\u7406error\uff0c\u5219nodejs\u4f1a\u89e6\u53d1uncaughtException\uff0c\u5982\u679c\u7528\u6237 34. \u5904\u7406\u4e86uncaughtException\u5219\u9700\u8981\u7070\u5ea6kCapture\u7684\u503c 35. */ 36. ee[kCapture] = false; 37. ee.emit('error', err); 38. } finally { 39. ee[kCapture] = prev; 40. } 41. } 42. }","title":"22.3 \u89e6\u53d1\u4e8b\u4ef6"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#224","text":"\u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0b\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u903b\u8f91\u3002 1. function removeAllListeners(type) { 2. const events = this._events; 3. if (events === undefined) 4. return this; 5. 6. // \u6ca1\u6709\u6ce8\u518cremoveListener\u4e8b\u4ef6\uff0c\u5219\u53ea\u9700\u8981\u5220\u9664\u6570\u636e\uff0c\u5426\u5219\u8fd8\u9700\u8981\u89e6\u53d1removeListener\u4e8b\u4ef6 7. if (events.removeListener === undefined) { 8. // \u7b49\u4e8e0\u8bf4\u660e\u662f\u5220\u9664\u5168\u90e8 9. if (arguments.length === 0) { 10. this._events = ObjectCreate(null); 11. this._eventsCount = 0; 12. } else if (events[type] !== undefined) { // \u5426\u5219\u662f\u5220\u9664\u67d0\u4e2a\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c 13. // \u662f\u552f\u4e00\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5219\u91cd\u7f6e_events\uff0c\u5426\u5219\u5220\u9664\u5bf9\u5e94\u7684\u4e8b\u4ef6\u7c7b\u578b 14. if (--this._eventsCount === 0) 15. this._events = ObjectCreate(null); 16. else 17. delete events[type]; 18. } 19. return this; 20. } 21. 22. // \u8bf4\u660e\u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0carguments.length === 0\u8bf4\u660e\u5220\u9664\u6240\u6709\u7c7b\u578b\u7684\u4e8b\u4ef6 23. if (arguments.length === 0) { 24. // \u9010\u4e2a\u5220\u9664\uff0c\u9664\u4e86removeListener\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5220\u9664\u4e86\u975eremoveListener\u4e8b\u4ef6 25. for (const key of ObjectKeys(events)) { 26. if (key === 'removeListener') continue; 27. this.removeAllListeners(key); 28. } 29. // \u8fd9\u91cc\u5220\u9664removeListener\u4e8b\u4ef6\uff0c\u89c1\u4e0b\u9762\u7684\u903b\u8f91 30. this.removeAllListeners('removeListener'); 31. // \u91cd\u7f6e\u6570\u636e\u7ed3\u6784 32. this._events = ObjectCreate(null); 33. this._eventsCount = 0; 34. return this; 35. } 36. // \u5220\u9664\u67d0\u7c7b\u578b\u4e8b\u4ef6 37. const listeners = events[type]; 38. 39. if (typeof listeners === 'function') { 40. this.removeListener(type, listeners); 41. } else if (listeners !== undefined) { 42. // LIFO order 43. for (let i = listeners.length - 1; i >= 0; i--) { 44. this.removeListener(type, listeners[i]); 45. } 46. } 47. 48. return this; 49. } removeAllListeners\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u6709\u4e24\u70b9\uff0c\u7b2c\u4e00\u4e2a\u662fremoveListener\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406\uff0c\u8fd9\u7c7b\u4f3c\u4e00\u4e2a\u94a9\u5b50\uff0c\u6bcf\u6b21\u7528\u6237\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u65f6\u5019\u90fd\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6\u3002\u7b2c\u4e8c\u662fremoveListener\u51fd\u6570\u3002removeListener\u662f\u771f\u6b63\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u5b9e\u73b0\u3002removeAllListeners\u662f\u5c01\u88c5\u4e86removeListener\u7684\u903b\u8f91\u3002 1. function removeListener(type, listener) { 2. let originalListener; 3. const events = this._events; 4. // \u6ca1\u6709\u4e1c\u897f\u53ef\u5220\u9664 5. if (events === undefined) 6. return this; 7. 8. const list = events[type]; 9. // \u540c\u4e0a 10. if (list === undefined) 11. return this; 12. // list\u662f\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5426\u5219\u662f\u6570\u7ec4,\u5982\u679clist.listener === listener\u8bf4\u660e\u662fonce\u6ce8\u518c\u7684 13. if (list === listener || list.listener === listener) { 14. // type\u7c7b\u578b\u7684\u5904\u7406\u51fd\u6570\u5c31\u4e00\u4e2a\uff0c\u5e76\u4e14\u4e5f\u6ca1\u6709\u6ce8\u518c\u5176\u4ed6\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c\u5219\u521d\u59cb\u5316_events 15. if (--this._eventsCount === 0) 16. this._events = ObjectCreate(null); 17. else { 18. // \u5c31\u4e00\u4e2a\u6267\u884c\u5b8c\u5220\u9664type\u5bf9\u5e94\u7684\u5c5e\u6027 19. delete events[type]; 20. // \u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0c\u5219\u5148\u6ce8\u518cremoveListener\u4e8b\u4ef6 21. if (events.removeListener) 22. this.emit('removeListener', type, list.listener || listener); 23. } 24. } else if (typeof list !== 'function') { 25. // \u591a\u4e2a\u5904\u7406\u51fd\u6570 26. let position = -1; 27. // \u627e\u51fa\u9700\u8981\u5220\u9664\u7684\u51fd\u6570 28. for (let i = list.length - 1; i >= 0; i--) { 29. if (list[i] === listener || list[i].listener === listener) { 30. // \u4fdd\u5b58\u539f\u5904\u7406\u51fd\u6570\uff0c\u5982\u679c\u6709\u7684\u8bdd 31. originalListener = list[i].listener; 32. position = i; 33. break; 34. } 35. } 36. 37. if (position < 0) 38. return this; 39. // \u7b2c\u4e00\u4e2a\u5219\u51fa\u961f\uff0c\u5426\u5219\u5220\u9664\u4e00\u4e2a 40. if (position === 0) 41. list.shift(); 42. else { 43. if (spliceOne === undefined) 44. spliceOne = require('internal/util').spliceOne; 45. spliceOne(list, position); 46. } 47. // \u5982\u679c\u53ea\u5269\u4e0b\u4e00\u4e2a\uff0c\u5219\u503c\u6539\u6210\u51fd\u6570\u7c7b\u578b 48. if (list.length === 1) 49. events[type] = list[0]; 50. // \u89e6\u53d1removeListener 51. if (events.removeListener !== undefined) 52. this.emit('removeListener', type, originalListener || listener); 53. } 54. 55. return this; 56. }; \u4ee5\u4e0a\u5c31\u662fevents\u6a21\u5757\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5de5\u5177\u51fd\u6570\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002","title":"22.4 \u53d6\u6d88\u8ba2\u9605"},{"location":"chapter23-Async%20hooks/","text":"\u524d\u8a00\uff1a\u867d\u7136Async hooks\u81f3\u6b64\u8fd8\u662f\u5b9e\u9a8c\u6027API\uff0c\u4f46\u662f\u4ed6\u7684\u786e\u53ef\u4ee5\u89e3\u51b3\u5e94\u7528\u4e2d\u7684\u4e00\u4e9b\u95ee\u9898\uff0c\u6bd4\u5982\u65e5\u5fd7\u548c\u8c03\u7528\u6808\u8ddf\u8e2a\u3002\u672c\u6587\u4ece\u5e94\u7528\u548c\u539f\u7406\u65b9\u4fbf\u4ecb\u7ecd\u4e00\u4e0bNode.js\u7684Async hooks\u3002 1 env\u4e2d\u7684AsyncHooks \u00b6 \u5728Node.js\u7684env\u5bf9\u8c61\u4e2d\u6709\u4e00\u4e2aAsyncHooks\u5bf9\u8c61\uff0c\u8d1f\u8d23Node.js\u8fdb\u7a0b\u4e2dasync_hooks\u7684\u7ba1\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b9a\u4e49\u3002 1.1 \u7c7b\u5b9a\u4e49 \u00b6 class AsyncHooks : public MemoryRetainer { public : enum Fields { // \u4e94\u79cd\u94a9\u5b50 kInit , kBefore , kAfter , kDestroy , kPromiseResolve , // \u94a9\u5b50\u603b\u6570 kTotals , // async_hooks\u5f00\u542f\u7684\u4e2a\u6570 kCheck , // \u8bb0\u5f55\u6808\u7684top\u6307\u9488 kStackLength , // \u6570\u7ec4\u5927\u5c0f kFieldsCount , }; enum UidFields { kExecutionAsyncId , kTriggerAsyncId , // \u5f53\u524dasync id\u7684\u503c kAsyncIdCounter , kDefaultTriggerAsyncId , kUidFieldsCount , }; private : inline AsyncHooks (); // \u5f02\u6b65\u8d44\u6e90\u7684\u7c7b\u578b std :: array < v8 :: Eternal < v8 :: String > , AsyncWrap :: PROVIDERS_LENGTH > providers_ ; // \u6808 AliasedFloat64Array async_ids_stack_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cFields\u5bf9\u5e94 AliasedUint32Array fields_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cUidFields\u5bf9\u5e94 AliasedFloat64Array async_id_fields_ ; }; \u7ed3\u6784\u56fe\u5982\u4e0b \u63a5\u4e0b\u6765\u770b\u4e00\u4e0benv\u7684AsyncHooks\u5bf9\u8c61\u63d0\u4f9b\u4e86\u54ea\u4e9bAPI\uff0c\u8fd9\u4e9bAPI\u662f\u4e0a\u5c42\u7684\u57fa\u7840\u3002 1.2 \u8bfbAPI \u00b6 \u6211\u4eec\u770b\u4e00\u4e0benv\u5bf9\u8c61\u4e2d\u83b7\u53d6AsyncHooks\u5bf9\u8c61\u5bf9\u5e94\u5b57\u6bb5\u7684API\u3002 // \u83b7\u53d6\u5bf9\u5e94\u7684\u5b57\u6bb5 inline AliasedUint32Array & AsyncHooks::fields () { return fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_id_fields () { return async_id_fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_ids_stack () { return async_ids_stack_ ; } // \u83b7\u53d6\u8d44\u6e90\u7c7b\u578b inline v8 :: Local < v8 :: String > AsyncHooks :: provider_string ( int idx ) { return providers_ [ idx ]. Get ( env () -> isolate ()); } // \u65b0\u5efa\u8d44\u6e90\u7684\u65f6\u5019\uff0c\u83b7\u53d6\u65b0\u7684async id inline double Environment :: new_async_id () { async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ] += 1 ; return async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ]; } // \u83b7\u53d6\u5f53\u524dasync id inline double Environment :: execution_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524dtrigger async id inline double Environment :: trigger_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kTriggerAsyncId ]; } // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\uff0c\u5219\u83b7\u53d6\u5f53\u524d\u7684async id inline double Environment :: get_default_trigger_async_id () { double default_trigger_async_id = async_hooks () -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; // If defaultTriggerAsyncId isn't set, use the executionAsyncId if ( default_trigger_async_id < 0 ) default_trigger_async_id = execution_async_id (); return default_trigger_async_id ; } 1.3 \u5199API \u00b6 inline void AsyncHooks::push_async_ids ( double async_id , double trigger_async_id ) { // \u83b7\u53d6\u5f53\u524d\u6808\u9876\u6307\u9488 uint32_t offset = fields_ [ kStackLength ]; // \u4e0d\u591f\u5219\u6269\u5bb9 if ( offset * 2 >= async_ids_stack_ . Length ()) grow_async_ids_stack (); // \u628a\u65e7\u7684\u4e0a\u4e0b\u6587\u538b\u6808 async_ids_stack_ [ 2 * offset ] = async_id_fields_ [ kExecutionAsyncId ]; async_ids_stack_ [ 2 * offset + 1 ] = async_id_fields_ [ kTriggerAsyncId ]; // \u6808\u6307\u9488\u52a0\u4e00 fields_ [ kStackLength ] += 1 ; // \u8bb0\u5f55\u5f53\u524d\u4e0a\u4e0b\u6587 async_id_fields_ [ kExecutionAsyncId ] = async_id ; async_id_fields_ [ kTriggerAsyncId ] = trigger_async_id ; } // \u548c\u4e0a\u9762\u7684\u903b\u8f91\u76f8\u53cd inline bool AsyncHooks::pop_async_id ( double async_id ) { if ( fields_ [ kStackLength ] == 0 ) return false ; uint32_t offset = fields_ [ kStackLength ] - 1 ; async_id_fields_ [ kExecutionAsyncId ] = async_ids_stack_ [ 2 * offset ]; async_id_fields_ [ kTriggerAsyncId ] = async_ids_stack_ [ 2 * offset + 1 ]; fields_ [ kStackLength ] = offset ; return fields_ [ kStackLength ] > 0 ; } 2 \u5e95\u5c42\u8d44\u6e90\u5c01\u88c5\u7c7b - AsyncWrap \u00b6 \u63a5\u7740\u770b\u4e00\u4e0b\u5f02\u6b65\u8d44\u6e90\u7684\u57fa\u7c7bAsyncWrap\u3002\u6240\u6709\u4f9d\u8d56\u4e8eC\u3001C++\u5c42\u5b9e\u73b0\u7684\u8d44\u6e90\uff08\u6bd4\u5982TCP\u3001UDP\uff09\u90fd\u4f1a\u7ee7\u627fAsyncWrap\u3002\u770b\u770b\u8be5\u7c7b\u7684\u5b9a\u4e49\u3002 class AsyncWrap : public BaseObject { private : ProviderType provider_type_ = PROVIDER_NONE ; double async_id_ = kInvalidAsyncId ; double trigger_async_id_ ; }; \u6211\u4eec\u770b\u5230\u6bcf\u4e2aAsyncWrap\u5bf9\u8c61\u90fd\u6709async_id_\u3001trigger_async_id_\u548cprovider_type_\u5c5e\u6027\uff0c\u8fd9\u6b63\u662f\u5728init\u56de\u8c03\u91cc\u62ff\u5230\u7684\u6570\u636e\u3002\u6211\u4eec\u770b\u770bAsyncWrap\u7684\u6784\u9020\u51fd\u6570\u3002\u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff08AsyncWrap\uff09\u65f6\u7684\u903b\u8f91\u3002 2.1 \u8d44\u6e90\u521d\u59cb\u5316 \u00b6 AsyncWrap :: AsyncWrap ( Environment * env , Local < Object > object , ProviderType provider , double execution_async_id , bool silent ) : AsyncWrap ( env , object ) { // \u8d44\u6e90\u7c7b\u578b provider_type_ = provider ; AsyncReset ( execution_async_id , silent ); } void AsyncWrap :: AsyncReset ( Local < Object > resource , double execution_async_id , bool silent ) { // \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684async id\uff0cexecution_async_id\u9ed8\u8ba4\u662fkInvalidAsyncId async_id_ = execution_async_id == kInvalidAsyncId ? env () -> new_async_id () : execution_async_id ; // \u83b7\u53d6trigger async id trigger_async_id_ = env () -> get_default_trigger_async_id (); // \u6267\u884cinit\u94a9\u5b50 EmitAsyncInit ( env (), resource , env () -> async_hooks () -> provider_string ( provider_type ()), async_id_ , trigger_async_id_ ); } \u63a5\u7740\u770bEmitAsyncInit void AsyncWrap::EmitAsyncInit ( Environment * env , Local < Object > object , Local < String > type , double async_id , double trigger_async_id ) { AsyncHooks * async_hooks = env -> async_hooks (); HandleScope scope ( env -> isolate ()); Local < Function > init_fn = env -> async_hooks_init_function (); Local < Value > argv [] = { Number :: New ( env -> isolate (), async_id ), type , Number :: New ( env -> isolate (), trigger_async_id ), object , }; TryCatchScope try_catch ( env , TryCatchScope :: CatchMode :: kFatal ); // \u6267\u884cinit\u56de\u8c03 USE ( init_fn -> Call ( env -> context (), object , arraysize ( argv ), argv )); } \u90a3\u4e48env->async_hooks_init_function()\u7684\u503c\u662f\u4ec0\u4e48\u5462\uff1f\u8fd9\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u3002 const { nativeHooks } = require ( ' internal / async_hooks ' ); internalBinding ( ' async_wrap ' ). setupHooks ( nativeHooks ); SetupHooks\u7684\u5b9e\u73b0\u5982\u4e0b static void SetupHooks ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Object > fn_obj = args [ 0 ]. As < Object > (); #define SET_HOOK_FN(name) \\ do { \\ Local<Value> v = \\ fn_obj->Get(env->context(), \\ FIXED_ONE_BYTE_STRING(env->isolate(), #name)) \\ .ToLocalChecked(); \\ CHECK(v->IsFunction()); \\ env->set_async_hooks_##name##_function(v.As<Function>()); \\ } while (0) // \u4fdd\u5b58\u5230env\u4e2d SET_HOOK_FN ( init ); SET_HOOK_FN ( before ); SET_HOOK_FN ( after ); SET_HOOK_FN ( destroy ); SET_HOOK_FN ( promise_resolve ); #undef SET_HOOK_FN } nativeHooks\u7684\u5b9e\u73b0\u5982\u4e0b nativeHooks : { init : emitInitNative , before : emitBeforeNative , after : emitAfterNative , destroy : emitDestroyNative , promise_resolve : emitPromiseResolveNative } \u8fd9\u4e9bHooks\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u6bd4\u5982emitInitNative function emitInitNative ( asyncId , type , triggerAsyncId , resource ) { for ( var i = 0 ; i < active_hooks . array . length ; i ++ ) { if ( typeof active_hooks . array [ i ][ init_symbol ] === ' function ' ) { active_hooks . array [ i ][ init_symbol ]( asyncId , type , triggerAsyncId , resource ); } } } active_hooks.array\u7684\u503c\u5c31\u662f\u6211\u4eec\u5728\u4e1a\u52a1\u4ee3\u7801\u91cc\u8bbe\u7f6e\u7684\u94a9\u5b50\uff0c\u6bcf\u6b21\u8c03\u7814createHooks\u7684\u65f6\u5019\u5c31\u5bf9\u5e94\u6570\u7ec4\u7684\u4e00\u4e2a\u5143\u7d20\u3002 2.2 \u6267\u884c\u8d44\u6e90\u56de\u8c03 \u00b6 \u5f53\u4e1a\u52a1\u4ee3\u7801\u5f02\u6b65\u8bf7\u6c42\u5e95\u5c42API\uff0c\u5e76\u4e14\u5e95\u5c42\u6ee1\u8db3\u6761\u4ef6\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u7684\u56de\u8c03\uff0c\u6bd4\u5982\u76d1\u542c\u4e00\u4e2asocket\u65f6\uff0c\u6709\u8fde\u63a5\u5230\u6765\u3002Node.js\u5c31\u4f1a\u8c03\u7528MakeCallback\u51fd\u6570\u6267\u884c\u56de\u8c03\u3002 MaybeLocal < Value > AsyncWrap :: MakeCallback ( const Local < Function > cb , int argc , Local < Value >* argv ) { // \u5f53\u524dAsyncWrap\u5bf9\u8c61\u5bf9\u5e94\u7684\u6267\u884c\u4e0a\u4e0b\u6587 ProviderType provider = provider_type (); async_context context { get_async_id (), get_trigger_async_id () }; MaybeLocal < Value > ret = InternalMakeCallback ( env (), object (), cb , argc , argv , context ); return ret ; } MakeCallback\u4e2d\u4f1a\u8c03\u7528InternalMakeCallback\u3002 MaybeLocal < Value > InternalMakeCallback ( Environment * env , Local < Object > recv , const Local < Function > callback , int argc , Local < Value > argv [], async_context asyncContext ) { // \u65b0\u5efa\u4e00\u4e2ascope InternalCallbackScope scope ( env , recv , asyncContext ); // \u6267\u884c\u56de\u8c03 callback -> Call ( env -> context (), recv , argc , argv ); // \u5173\u95edscope scope . Close (); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u548c\u5173\u95edscope\u90fd\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 InternalCallbackScope :: InternalCallbackScope ( Environment * env , Local < Object > object , const async_context & asyncContext , int flags ) : env_ ( env ), async_context_ ( asyncContext ), object_ ( object ), skip_hooks_ ( flags & kSkipAsyncHooks ), skip_task_queues_ ( flags & kSkipTaskQueues ) { // v14\u7248\u672c\u4e2d\uff0c\u662f\u5148\u89e6\u53d1before\u518dpush\u4e0a\u4e0b\u6587\uff0c\u987a\u5e8f\u662f\u4e0d\u5bf9\u7684\uff0cv16\u5df2\u7ecf\u6539\u8fc7\u6765\u3002 // \u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5165\u6808 env -> async_hooks () -> push_async_ids ( async_context_ . async_id , async_context_ . trigger_async_id ); // \u89e6\u53d1before\u94a9\u5b50 if ( asyncContext . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitBefore ( env , asyncContext . async_id ); } pushed_ids_ = true ; } \u5728scope\u91cc\u4f1a\u628a\u5f53\u524dAsyncWrap\u5bf9\u8c61\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u5e76\u4e14\u89e6\u53d1before\u94a9\u5b50\uff0c\u7136\u540e\u6267\u884c\u4e1a\u52a1\u56de\u8c03\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u56de\u8c03\u91cc\u83b7\u53d6\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u65f6\u5c31\u62ff\u5230\u4e86AsyncWrap\u5bf9\u5e94\u7684\u503c\uff08 \u8c03\u7528executionAsyncId\uff09\uff0c\u63a5\u7740\u770bClose void InternalCallbackScope::Close () { // \u6267\u884c if ( pushed_ids_ ) env_ -> async_hooks () -> pop_async_id ( async_context_ . async_id ); if ( async_context_ . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitAfter ( env_ , async_context_ . async_id ); } } Close\u5728\u6267\u884c\u56de\u8c03\u540e\u88ab\u8c03\u7528\uff0c\u4e3b\u8981\u662f\u6062\u590d\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5e76\u4e14\u89e6\u53d1after\u94a9\u5b50\u3002 3 \u4e0a\u5c42\u8d44\u6e90\u7684\u5c01\u88c5 - Timeout\u3001TickObjecd\u7b49 \u00b6 \u5e76\u4e0d\u662f\u6240\u6709\u7684\u5f02\u6b65\u8d44\u6e90\u90fd\u662f\u5e95\u5c42\u5b9e\u73b0\u7684\uff0c\u6bd4\u5982\u5b9a\u65f6\u5668\uff0ctick\u4e5f\u88ab\u5b9a\u4e49\u4e3a\u5f02\u6b65\u8d44\u6e90\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u662f\u548c\u56de\u8c03\u76f8\u5173\u3002\u8fd9\u79cd\u5f02\u6b65\u8d44\u6e90\u662f\u5728JS\u5c42\u5b9e\u73b0\u7684\uff0c\u8fd9\u91cc\u53ea\u5206\u6790Timeout\u3002 3.1 \u521b\u5efa\u8d44\u6e90 \u00b6 \u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884csetTimeout\u65f6\u7684\u6838\u5fc3\u903b\u8f91\u3002 function setTimeout ( callback , after , arg1 , arg2 , arg3 ) { const timeout = new Timeout ( callback , after , args , false , true ); return timeout ; } function Timeout ( callback , after , args , isRepeat , isRefed ) { initAsyncResource ( this , ' Timeout ' ); } function initAsyncResource ( resource , type ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = resource [ async_id_symbol ] = newAsyncId (); const triggerAsyncId = resource [ trigger_async_id_symbol ] = getDefaultTriggerAsyncId (); // \u662f\u5426\u8bbe\u7f6e\u4e86init\u94a9\u5b50\uff0c\u662f\u5219\u89e6\u53d1\u56de\u8c03 if ( initHooksExist ()) emitInit ( asyncId , type , triggerAsyncId , resource ); } \u6267\u884csetTimeout\u65f6\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8bbe\u7f6easync_hooks\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u5e76\u8bb0\u5f55\u5230Timeout\u5bf9\u8c61\u4e2d\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\u3002 function emitInitScript ( asyncId , type , triggerAsyncId , resource ) { emitInitNative ( asyncId , type , triggerAsyncId , resource ); } \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u6267\u884c\u6bcf\u4e2aasync_hooks\u5bf9\u8c61\u7684init\u56de\u8c03(\u901a\u5e38\u6211\u4eec\u53ea\u6709\u4e00\u4e2aasync_hooks\u5bf9\u8c61)\u3002 3.1 \u6267\u884c\u56de\u8c03 \u00b6 \u5f53\u5b9a\u65f6\u5668\u5230\u671f\u65f6\uff0c\u4f1a\u6267\u884c\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u76f8\u5173\u7684\u903b\u8f91\u3002 // \u89e6\u53d1before\u94a9\u5b50 emitBefore ( asyncId , timer [ trigger_async_id_symbol ]); // \u6267\u884c\u56de\u8c03 timer . _onTimeout (); // \u89e6\u53d1after\u56de\u8c03 emitAfter ( asyncId ); \u6211\u4eec\u770b\u5230\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u524d\u540e\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002 function emitBeforeScript ( asyncId , triggerAsyncId ) { // \u548c\u5e95\u5c42\u7684push_async_ids\u903b\u8f91\u4e00\u6837 pushAsyncIds ( asyncId , triggerAsyncId ); // \u5982\u679c\u6709\u56de\u8c03\u5219\u6267\u884c if ( async_hook_fields [ kBefore ] > 0 ) emitBeforeNative ( asyncId ); } function emitAfterScript ( asyncId ) { // \u8bbe\u7f6e\u4e86after\u56de\u8c03\u5219emit if ( async_hook_fields [ kAfter ] > 0 ) emitAfterNative ( asyncId ); // \u548c\u5e95\u5c42\u7684pop_async_ids\u903b\u8f91\u4e00\u6837 popAsyncIds ( asyncId ); } JS\u5c42\u7684\u5b9e\u73b0\u548c\u5e95\u5c42\u662f\u4fdd\u6301\u4e00\u81f4\u7684\u3002\u5982\u679c\u6211\u4eec\u5728setTimeout\u56de\u8c03\u91cc\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff0c\u6bd4\u5982\u518d\u6b21\u6267\u884csetTimeout\uff0c\u8fd9\u65f6\u5019trigger async id\u5c31\u662f\u7b2c\u4e00\u4e2asetTimeout\u5bf9\u5e94\u7684async id\uff0c\u6240\u4ee5\u5c31\u8fde\u8d77\u6765\u4e86\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u4f8b\u5b50\u3002 4 DefaultTriggerAsyncIdScope \u00b6 Node.js\u4e3a\u4e86\u907f\u514d\u8fc7\u591a\u901a\u8fc7\u53c2\u6570\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u9012async id\uff0c\u5c31\u8bbe\u8ba1\u4e86DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7684\u4f5c\u7528\u7c7b\u4f3c\u5728\u591a\u4e2a\u51fd\u6570\u5916\u7ef4\u62a4\u4e00\u4e2a\u53d8\u91cf\uff0c\u591a\u4e2a\u51fd\u6570\u90fd\u53ef\u4ee5\u901a\u8fc7DefaultTriggerAsyncIdScope\u83b7\u5f97trigger async id\uff0c\u800c\u4e0d\u9700\u8981\u901a\u8fc7\u5c42\u5c42\u4f20\u9012\u7684\u65b9\u5f0f\uff0c\u4ed6\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\u3002 class DefaultTriggerAsyncIdScope { private : AsyncHooks * async_hooks_ ; double old_default_trigger_async_id_ ; }; inline AsyncHooks :: DefaultTriggerAsyncIdScope :: DefaultTriggerAsyncIdScope ( Environment * env , double default_trigger_async_id ) : async_hooks_ ( env -> async_hooks ()) { // \u8bb0\u5f55\u65e7\u7684id\uff0c\u8bbe\u7f6e\u65b0\u7684id old_default_trigger_async_id_ = async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = default_trigger_async_id ; } // \u6062\u590d inline AsyncHooks :: DefaultTriggerAsyncIdScope ::~ DefaultTriggerAsyncIdScope () { async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = old_default_trigger_async_id_ ; } DefaultTriggerAsyncIdScope\u4e3b\u8981\u662f\u8bb0\u5f55\u65e7\u7684id\uff0c\u7136\u540e\u628a\u65b0\u7684id\u8bbe\u7f6e\u5230env\u4e2d\uff0c\u5f53\u5176\u4ed6\u51fd\u6570\u8c03\u7528get_default_trigger_async_id\u65f6\u5c31\u53ef\u4ee5\u83b7\u53d6\u8bbe\u7f6e\u7684async id\u3002\u540c\u6837JS\u5c42\u4e5f\u5b9e\u73b0\u4e86\u7c7b\u4f3c\u7684API\u3002 function defaultTriggerAsyncIdScope ( triggerAsyncId , block , ... args ) { const oldDefaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; async_id_fields [ kDefaultTriggerAsyncId ] = triggerAsyncId ; try { return block (... args ); } finally { async_id_fields [ kDefaultTriggerAsyncId ] = oldDefaultTriggerAsyncId ; } } \u5728\u6267\u884cblock\u51fd\u6570\u65f6\uff0c\u53ef\u4ee5\u83b7\u53d6\u5230\u8bbe\u7f6e\u7684\u503c\uff0c\u800c\u4e0d\u9700\u8981\u4f20\u9012\uff0c\u6267\u884c\u5b8cblock\u540e\u6062\u590d\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u4f7f\u7528\u3002\u4e0b\u9762\u6458\u81eanet\u6a21\u5757\u7684\u4ee3\u7801\u3002 // \u83b7\u53d6handle\u91cc\u7684async id this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u91cc\u5177\u4f53\u7684\u60c5\u51b5\u3002\u5728defaultTriggerAsyncIdScope\u4e2d\u4f1a\u4ee5emitListeningNT\u4e3a\u5165\u53c2\u6267\u884cprocess.nextTick\u3002\u6211\u4eec\u770b\u770bnextTick\u7684\u5b9e\u73b0\u3002 function nextTick ( callback ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = newAsyncId (); // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5373\u521a\u624d\u8bbe\u7f6e\u7684 const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; if ( initHooksExist ()) // \u521b\u5efa\u4e86\u65b0\u7684\u8d44\u6e90\uff0c\u89e6\u53d1init\u94a9\u5b50 emitInit ( asyncId , ' TickObject ' , triggerAsyncId , tickObject ); queue . push ( tickObject ); } \u6211\u4eec\u770b\u5230\u5728nextTick\u4e2d\u901a\u8fc7getDefaultTriggerAsyncId\u62ff\u5230\u4e86trigger async id\u3002 function getDefaultTriggerAsyncId () { const defaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; if ( defaultTriggerAsyncId < 0 ) return async_id_fields [ kExecutionAsyncId ]; return defaultTriggerAsyncId ; } getDefaultTriggerAsyncId\u8fd4\u56de\u7684\u5c31\u662f\u521a\u624d\u901a\u8fc7defaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684async id\u3002\u6240\u4ee5\u5728\u89e6\u53d1TickObject\u7684init\u94a9\u5b50\u65f6\u7528\u6237\u5c31\u53ef\u4ee5\u62ff\u5230\u5bf9\u5e94\u7684id\u3002\u4e0d\u8fc7\u66f4\u91cd\u8981\u7684\u65f6\uff0c\u5728\u5f02\u6b65\u6267\u884cnextTick\u7684\u4efb\u52a1\u65f6\uff0c\u8fd8\u53ef\u4ee5\u62ff\u5230\u539f\u59cb\u7684trigger async id\u3002\u56e0\u4e3a\u8be5id\u8bb0\u5f55\u5728tickObject\u4e2d\u3002\u6211\u4eec\u770b\u770b\u6267\u884ctick\u4efb\u52a1\u65f6\u7684\u903b\u8f91\u3002 function processTicksAndRejections () { let tock ; do { while ( tock = queue . shift ()) { // \u62ff\u5230\u5bf9\u5e94\u7684async \u4e0a\u4e0b\u6587 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { const callback = tock . callback ; callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); } } while ( ! queue . isEmpty () || processPromiseRejections ()); } 5 \u8d44\u6e90\u9500\u6bc1 \u00b6 \u8d44\u6e90\u9500\u6bc1\u7684\u65f6\u5019\u4e5f\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u4e0d\u8fc7\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u94a9\u5b50\u662f\u5f02\u6b65\u89e6\u53d1\u7684\u3002\u65e0\u8bba\u662fJS\u8fd8\u662f\u597dC++\u5c42\u89e6\u53d1\u9500\u6bc1\u94a9\u5b50\u7684\u65f6\u5019\uff0c\u903b\u8f91\u90fd\u662f\u4e00\u81f4\u7684\u3002 void AsyncWrap::EmitDestroy ( Environment * env , double async_id ) { // \b\u4e4b\u524d\u4e3a\u7a7a\u5219\u8bbe\u7f6e\u56de\u8c03 if ( env -> destroy_async_id_list () -> empty ()) { env -> SetUnrefImmediate ( & DestroyAsyncIdsCallback ); } // async id\u5165\u961f env -> destroy_async_id_list () -> push_back ( async_id ); } template < typename Fn > void Environment :: SetUnrefImmediate ( Fn && cb ) { CreateImmediate ( std :: move ( cb ), false ); } template < typename Fn > void Environment :: CreateImmediate ( Fn && cb , bool ref ) { auto callback = std :: make_unique < NativeImmediateCallbackImpl < Fn >> ( std :: move ( cb ), ref ); // \u52a0\u5165\u4efb\u52a1\u961f\u5217 native_immediates_ . Push ( std :: move ( callback )); } \u5728\u4e8b\u4ef6\u5faa\u73af\u7684check\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u91cc\u9762\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u6267\u884c\u56de\u8c03DestroyAsyncIdsCallback\u3002 void AsyncWrap::DestroyAsyncIdsCallback ( Environment * env ) { Local < Function > fn = env -> async_hooks_destroy_function (); do { std :: vector < double > destroy_async_id_list ; destroy_async_id_list . swap ( * env -> destroy_async_id_list ()); // \u904d\u5386\u9500\u6bc1\u7684async id for ( auto async_id : destroy_async_id_list ) { HandleScope scope ( env -> isolate ()); Local < Value > async_id_value = Number :: New ( env -> isolate (), async_id ); // \u6267\u884cJS\u5c42\u56de\u8c03 MaybeLocal < Value > ret = fn -> Call ( env -> context (), Undefined ( env -> isolate ()), 1 , & async_id_value ); } } while ( ! env -> destroy_async_id_list () -> empty ()); } 6 Async hooks\u7684\u4f7f\u7528 \u00b6 \u6211\u4eec\u901a\u5e38\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528Async hooks const async_hooks = require ( ' async_hooks ' ); async_hooks . createHook ({ init ( asyncId , type , triggerAsyncId ) {}, before ( asyncId ) {}, after ( asyncId ) {}, destroy ( asyncId ) {}, promiseResolve ( asyncId ), }) . enable (); async_hooks\u662f\u5bf9\u8d44\u6e90\u751f\u547d\u5468\u671f\u7684\u62bd\u8c61\uff0c\u8d44\u6e90\u5c31\u662f\u64cd\u4f5c\u5bf9\u8c61\u548c\u56de\u8c03\u7684\u62bd\u8c61\u3002async_hooks\u5b9a\u4e49\u4e86\u4e94\u4e2a\u751f\u547d\u5468\u671f\u94a9\u5b50\uff0c\u5f53\u8d44\u6e90\u7684\u72b6\u6001\u5230\u8fbe\u67d0\u4e2a\u5468\u671f\u8282\u70b9\u65f6\uff0casync_hooks\u5c31\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateHook\u3002 function createHook ( fns ) { return new AsyncHook ( fns ); } createHook\u662f\u5bf9AsyncHook\u7684\u5c01\u88c5 class AsyncHook { constructor ({ init , before , after , destroy , promiseResolve }) { // \u8bb0\u5f55\u56de\u8c03 this [ init_symbol ] = init ; this [ before_symbol ] = before ; this [ after_symbol ] = after ; this [ destroy_symbol ] = destroy ; this [ promise_resolve_symbol ] = promiseResolve ; } } AsyncHook\u7684\u521d\u59cb\u5316\u5f88\u7b80\u5355\uff0c\u521b\u5efa\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u8bb0\u5f55\u56de\u8c03\u51fd\u6570\u3002\u521b\u5efa\u4e86AsyncHook\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528AsyncHook\u7684enable\u51fd\u6570\u624b\u52a8\u5f00\u542f\u3002 class AsyncHook { enable () { // \u83b7\u53d6\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4 const [ hooks_array , hook_fields ] = getHookArrays (); // \u6267\u884c\u8fc7enable\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6267\u884c if ( hooks_array . includes ( this )) return this ; // \u505a\u4e9b\u7edf\u8ba1 const prev_kTotals = hook_fields [ kTotals ]; hook_fields [ kTotals ] = hook_fields [ kInit ] += +!! this [ init_symbol ]; hook_fields [ kTotals ] += hook_fields [ kBefore ] += +!! this [ before_symbol ]; hook_fields [ kTotals ] += hook_fields [ kAfter ] += +!! this [ after_symbol ]; hook_fields [ kTotals ] += hook_fields [ kDestroy ] += +!! this [ destroy_symbol ]; hook_fields [ kTotals ] += hook_fields [ kPromiseResolve ] += +!! this [ promise_resolve_symbol ]; // \u5f53\u524d\u5bf9\u8c61\u63d2\u5165\u6570\u7ec4\u4e2d hooks_array . push ( this ); // \u5982\u679c\u4e4b\u524d\u7684\u6570\u91cf\u662f0\uff0c\u672c\u6b21\u64cd\u4f5c\u540e\u5927\u4e8e0\u5219\u5f00\u542f\u5e95\u5c42\u7684\u903b\u8f91 if ( prev_kTotals === 0 && hook_fields [ kTotals ] > 0 ) { enableHooks (); } return this ; } } 1 hooks_array\uff1a\u662f\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\uff0c\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u7528\u6237\u521b\u5efa\u4e86\u54ea\u4e9bAsyncHook\u5bf9\u8c61\uff0c\u7136\u540e\u54ea\u4e9bAsyncHook\u5bf9\u8c61\u91cc\u90fd\u8bbe\u7f6e\u4e86\u54ea\u4e9b\u94a9\u5b50\uff0c\u5728\u56de\u8c03\u7684\u65f6\u5019\u5c31\u4f1a\u904d\u5386\u8fd9\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03\u3002 2 hook_fields\uff1a\u5bf9\u5e94\u5e95\u5c42\u7684async_hook_fields\u3002 3 enableHooks\uff1a function enableHooks () { // \u8bb0\u5f55async_hooks\u7684\u5f00\u542f\u4e2a\u6570 async_hook_fields [ kCheck ] += 1 ; } \u81f3\u6b64\uff0casync_hooks\u7684\u521d\u59cb\u5316\u5c31\u5b8c\u6210\u4e86\uff0c\u6211\u4eec\u53d1\u73b0\u903b\u8f91\u975e\u5e38\u7b80\u5355\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u4e0b\u9762\u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 const { createHook , executionAsyncId } = require ( ' async_hooks ' ); const fs = require ( ' fs ' ); const net = require ( ' net ' ); createHook ({ init ( asyncId , type , triggerAsyncId ) { fs . writeSync ( 1 , ` $ { type }( $ { asyncId }) : trigger : $ { triggerAsyncId } execution : $ { executionAsyncId ()} \\ n ` ); } }). enable (); net . createServer (( conn ) => {}). listen ( 8080 ); \u4ee5\u4e0a\u4ee3\u7801\u8f93\u51fa init : type : TCPSERVERWRAP asyncId : 2 trigger id : 1 executionAsyncId () : 1 triggerAsyncId () : 0 init : type : TickObject asyncId : 3 trigger id : 2 executionAsyncId () : 1 triggerAsyncId () : 0 before : asyncId : 3 executionAsyncId () : 3 triggerAsyncId () : 2 after : asyncId : 3 executionAsyncId () : 3 triggerAsyncId () : 2 \u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u77e5\u9053\u521b\u5efa\u8d44\u6e90\u7684\u65f6\u5019\u4f1a\u6267\u884cinit\u56de\u8c03\uff0c\u5177\u4f53\u903b\u8f91\u5728listen\u51fd\u6570\u4e2d\uff0c\u5728listen\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u4f1a\u6267\u884cnew TCP\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8868\u793a\u670d\u52a1\u5668\u3002TCP\u662fC++\u5c42\u5bfc\u51fa\u7684\u7c7b\uff0c\u521a\u624d\u6211\u4eec\u8bf4\u8fc7\uff0cTCP\u4f1a\u7ee7\u627fAsyncWrap\uff0c\u65b0\u5efaAsyncWrap\u5bf9\u8c61\u7684\u65f6\u5019\u4f1a\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa init : type : TCPSERVERWRAP asyncId : 2 trigger id : 1 executionAsyncId () : 1 triggerAsyncId () : 0 \u90a3TickObject\u662f\u600e\u4e48\u6765\u7684\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770blisten\u91cc\u7684\u53e6\u4e00\u6bb5\u903b\u8f91\u3002 this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u4e0a\u9762\u7684\u4ee3\u7801\u6211\u4eec\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5728\u6267\u884cprocess.nextTick\u7684\u65f6\u5019\u4f1a\u521b\u5efa\u4e00\u4e2aTickObject\u5bf9\u8c61\u5c01\u88c5\u6267\u884c\u4e0a\u4e0b\u6587\u548c\u56de\u8c03\u3002 const asyncId = newAsyncId (); const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; emitInit ( asyncId , ' TickObject ' , triggerAsyncId , tickObject ); \u8fd9\u6b21\u518d\u6b21\u89e6\u53d1\u4e86init\u94a9\u5b50\uff0c\u7ed3\u6784\u5982\u4e0b\uff08nextTick\u901a\u8fc7getDefaultTriggerAsyncId\u83b7\u53d6\u7684id\u662fdefaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684id\uff09\u3002 \u5bf9\u5e94\u8f93\u51fa init : type : TickObject asyncId : 3 trigger id : 2 executionAsyncId () : 1 triggerAsyncId () : 0 \u63a5\u7740\u6267\u884ctick\u4efb\u52a1\u3002 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { tock . callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); emitBefore\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa before: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 after: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 \u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0c\u6240\u6709\u5165\u6808\u7684\u4e0a\u4e0b\u6587\u90fd\u4f1a\u88ab\u6e05\u7a7a\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8fde\u63a5\u5efa\u7acb\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f\u5f53\u6709\u8fde\u63a5\u5efa\u7acb\u65f6\uff0c\u4f1a\u6267\u884cC++\u5c42\u7684OnConnection\u3002 OnConnection\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684TCP\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61\u3002 MaybeLocal < Object > TCPWrap :: Instantiate ( Environment * env , AsyncWrap * parent , TCPWrap :: SocketType type ) { EscapableHandleScope handle_scope ( env -> isolate ()); AsyncHooks :: DefaultTriggerAsyncIdScope trigger_scope ( parent ); return handle_scope . EscapeMaybe ( constructor -> NewInstance ( env -> context (), 1 , & type_value )); } \u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2aAsyncHooks::DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7528\u4e8e\u8bbe\u7f6e\u9ed8\u8ba4default_trigger_async_id\u4e3aparent\u7684async id\uff08\u503c\u662f2\uff09\uff0c\u6267\u884cInstantiate\u65f6\u4f1a\u6267\u884c\u6790\u6784\u51fd\u6570\u6062\u590d\u539f\u6765\u72b6\u6001\u3002\u63a5\u7740NewInstance\u7684\u65f6\u5019\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\uff0c\u4ece\u800c\u521b\u5efa\u4e00\u4e2aAsyncWrap\u5bf9\u8c61\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa init : type : TCPWRAP asyncId : 4 trigger id : 2 executionAsyncId () : 0 triggerAsyncId () : 0 \u521b\u5efa\u5b8c\u5bf9\u8c61\u540e\uff0c\u901a\u8fc7AsyncWrap::MakeCallback\u56de\u8c03JS\u5c42\uff0c\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7AsyncWrap::MakeCallback\u4f1a\u89e6\u53d1before\u548cafter\u94a9\u5b50\uff0c\u89e6\u53d1before\u94a9\u5b50\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa before: asyncId: 2 executionAsyncId(): 2 triggerAsyncId(): 1 \u540c\u6837\uff0c\u5728\u56de\u8c03\u51fd\u6570\u91cc\u6267\u884cexecutionAsyncId\u548ctriggerAsyncId\u62ff\u5230\u7684\u5185\u5bb9\u662f\u4e00\u6837\u7684\u3002\u89e6\u53d1after\u540e\u518d\u6062\u590d\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u8f93\u51fa\u4e5f\u662f\u4e00\u6837\u7684\u3002 after : asyncId : 2 executionAsyncId () : 2 triggerAsyncId () : 1 7 AsyncResource \u00b6 \u5f02\u6b65\u8d44\u6e90\u5e76\u4e0d\u662fNode.js\u5185\u7f6e\u7684\uff0cNode.js\u53ea\u662f\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4e1a\u52a1\u5c42\u4e5f\u53ef\u4ee5\u4f7f\u7528\u3002Node.js\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7c7b\u7ed9\u4e1a\u52a1\u4f7f\u7528\uff0c\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b\u3002 class AsyncResource { constructor ( type , opts = {}) { let triggerAsyncId = opts ; let requireManualDestroy = false ; if ( typeof opts !== ' number ' ) { triggerAsyncId = opts . triggerAsyncId === undefined ? getDefaultTriggerAsyncId () : opts . triggerAsyncId ; requireManualDestroy = !! opts . requireManualDestroy ; } const asyncId = newAsyncId (); this [ async_id_symbol ] = asyncId ; this [ trigger_async_id_symbol ] = triggerAsyncId ; if ( initHooksExist ()) { emitInit ( asyncId , type , triggerAsyncId , this ); } } runInAsyncScope ( fn , thisArg , ... args ) { const asyncId = this [ async_id_symbol ]; emitBefore ( asyncId , this [ trigger_async_id_symbol ]); const ret = thisArg === undefined ? fn (... args ) : ReflectApply ( fn , thisArg , args ); emitAfter ( asyncId ); return ret ; } emitDestroy () { if ( this [ destroyedSymbol ] !== undefined ) { this [ destroyedSymbol ]. destroyed = true ; } emitDestroy ( this [ async_id_symbol ]); return this ; } asyncId () { return this [ async_id_symbol ]; } triggerAsyncId () { return this [ trigger_async_id_symbol ]; } } \u4f7f\u7528\u65b9\u5f0f\u5982\u4e0b\u3002 const { AsyncResource , executionAsyncId , triggerAsyncId } = require ( ' async_hooks ' ); const asyncResource = new AsyncResource ( ' Demo ' ); asyncResource . runInAsyncScope (() => { console . log ( executionAsyncId (), triggerAsyncId ()) }); runInAsyncScope\u4e2d\u4f1a\u628aasyncResource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0casync id\u662f2\uff0ctrigger async id\u662f1\uff0c\u6240\u4ee5\u5728\u56de\u8c03\u91cc\u6267\u884cexecutionAsyncId\u8f93\u51fa\u7684\u662f2\uff0ctriggerAsyncId\u8f93\u51fa\u7684\u662f1\u3002 8 AsyncLocalStorage \u00b6 AsyncLocalStorage\u662f\u57fa\u4e8eAsyncResource\u5b9e\u73b0\u7684\u4e00\u4e2a\u7ef4\u62a4\u5f02\u6b65\u903b\u8f91\u4e2d\u516c\u5171\u4e0a\u4e0b\u6587\u7684\u7c7b\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u4ed6\u7406\u89e3\u4e3aRedis\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u600e\u4e48\u4f7f\u7528\u3002 8.1 \u4f7f\u7528 \u00b6 const { AsyncLocalStorage } = require ( ' async_hooks ' ); const asyncLocalStorage = new AsyncLocalStorage (); function logWithId ( msg ) { const id = asyncLocalStorage . getStore (); console . log ( ` $ { id !== undefined ? id : '-' } : ` , msg ); } asyncLocalStorage . run ( 1 , () => { logWithId ( ' start ' ); setImmediate (() => { logWithId ( ' finish ' ); }); }); \u6267\u884c\u4e0a\u9762\u4ee3\u7801\u4f1a\u8f93\u51fa 1 : start 1 : finish run\u7684\u65f6\u5019\u521d\u59cb\u5316\u516c\u5171\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u5728run\u91cc\u6267\u884c\u7684\u5f02\u6b65\u4ee3\u7801\u4e5f\u53ef\u4ee5\u62ff\u5f97\u5230\u8fd9\u4e2a\u516c\u5171\u4e0a\u4e0b\u6587\uff0c\u8fd9\u4e2a\u5728\u8bb0\u5f55\u65e5\u5fd7traceId\u65f6\u5c31\u4f1a\u5f88\u6709\u7528\uff0c\u5426\u5219\u6211\u4eec\u5c31\u9700\u8981\u628atraceId\u4f20\u904d\u4ee3\u7801\u6bcf\u4e2a\u9700\u8981\u7684\u5730\u65b9\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 8.2 \u5b9e\u73b0 \u00b6 \u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521b\u5efaAsyncLocalStorage\u7684\u903b\u8f91 class AsyncLocalStorage { constructor () { this . kResourceStore = Symbol ( ' kResourceStore ' ); this . enabled = false ; } } \u521b\u5efaAsyncLocalStorage\u7684\u65f6\u5019\u5f88\u7b80\u5355\uff0c\u4e3b\u8981\u662f\u7f6e\u72b6\u6001\u4e3afalse\uff0c\u5e76\u4e14\u8bbe\u7f6ekResourceStore\u7684\u503c\u4e3aSymbol('kResourceStore')\u3002\u8bbe\u7f6e\u4e3aSymbol('kResourceStore')\u800c\u4e0d\u662f\u2018kResourceStore\u2018\u5f88\u91cd\u8981\uff0c\u6211\u4eec\u540e\u9762\u4f1a\u770b\u5230\u3002\u7ee7\u7eed\u770b\u4e00\u4e0b\u6267\u884cAsyncLocalStorage.run\u7684\u903b\u8f91\u3002 run ( store , callback , ... args ) { // \u65b0\u5efa\u4e00\u4e2aAsyncResource const resource = new AsyncResource ( ' AsyncLocalStorage ' , defaultAlsResourceOpts ); // \u901a\u8fc7runInAsyncScope\u628aresource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u5b8c\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587 return resource . emitDestroy (). runInAsyncScope (() => { this . enterWith ( store ); return ReflectApply ( callback , null , args ); }); } \u8bbe\u7f6e\u5b8c\u4e0a\u4e0b\u6587\u4e4b\u540e\u6267\u884crunInAsyncScope\u7684\u56de\u8c03\uff0c\u56de\u8c03\u91cc\u9996\u5148\u6267\u884c\u91ccenterWith\u3002 enterWith ( store ) { // \u4fee\u6539AsyncLocalStorage\u72b6\u6001 this . _enable (); // \u83b7\u5f97\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u4e8e\u591a\u8d44\u6e90\uff0c\u4e5f\u5c31\u662frun\u91cc\u521b\u5efa\u7684resource const resource = executionAsyncResource (); // \u628a\u516c\u5171\u4e0a\u4e0b\u6587\u6302\u8f7d\u5230\u5bf9\u8c61\u4e0a resource [ this . kResourceStore ] = store ; } _enable () { if ( ! this . enabled ) { this . enabled = true ; ArrayPrototypePush ( storageList , this ); storageHook . enable (); } } \u6302\u8f7d\u5b8c\u516c\u5171\u4e0a\u4e0b\u6587\u540e\uff0c\u5c31\u6267\u884c\u4e1a\u52a1\u56de\u8c03\u3002\u56de\u8c03\u91cc\u53ef\u4ee5\u901a\u8fc7asyncLocalStorage.getStore()\u83b7\u5f97\u8bbe\u7f6e\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002 getStore () { if ( this . enabled ) { const resource = executionAsyncResource (); return resource [ this . kResourceStore ]; } } getStore\u7684\u539f\u7406\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u9996\u5148\u62ff\u5230\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\uff0c\u7136\u540e\u6839\u636eAsyncLocalStorage\u7684kResourceStore\u7684\u503c\u4eceresource\u4e2d\u62ff\u5230\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u662f\u540c\u6b65\u6267\u884cgetStore\uff0c\u90a3\u4e48executionAsyncResource\u8fd4\u56de\u7684\u5c31\u662f\u6211\u4eec\u5728run\u7684\u65f6\u5019\u521b\u5efa\u7684AsyncResource\uff0c\u4f46\u662f\u5982\u679c\u662f\u5f02\u6b65getStore\u90a3\u4e48\u600e\u4e48\u529e\u5462\uff1f\u56e0\u4e3a\u8fd9\u65f6\u5019executionAsyncResource\u8fd4\u56de\u7684\u4e0d\u518d\u662f\u6211\u4eec\u521b\u5efa\u7684AsyncResource\uff0c\u4e5f\u5c31\u62ff\u4e0d\u5230\u4ed6\u6302\u8f7d\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cNode.js\u5bf9\u516c\u5171\u4e0a\u4e0b\u6587\u8fdb\u884c\u4e86\u4f20\u9012\u3002 const storageList = []; // AsyncLocalStorage\u5bf9\u8c61\u6570\u7ec4 const storageHook = createHook ({ init ( asyncId , type , triggerAsyncId , resource ) { const currentResource = executionAsyncResource (); for ( let i = 0 ; i < storageList . length ; ++ i ) { storageList [ i ]. _propagate ( resource , currentResource ); } } }); _propagate ( resource , triggerResource ) { const store = triggerResource [ this . kResourceStore ]; if ( this . enabled ) { resource [ this . kResourceStore ] = store ; } } \u6211\u4eec\u770b\u5230Node.js\u5185\u90e8\u521b\u5efa\u4e86\u4e00\u4e2aHooks\uff0c\u5728\u6bcf\u6b21\u8d44\u6e90\u521b\u5efa\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u628a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\u4e2d\u7684\u4e00\u4e2a\u6216\u591a\u4e2akey\uff08\u6839\u636estorageList\u91cc\u5bf9\u8c61\u7684this.kResourceStore\u5b57\u6bb5\uff09\u5bf9\u5e94\u7684\u503c\u6302\u8f7d\u5230\u65b0\u521b\u5efa\u7684\u8d44\u6e90\u4e2d\u3002\u6240\u4ee5\u5728asyncLocalStorage.getStore()\u65f6\u5373\u4f7f\u4e0d\u662f\u6211\u4eec\u5728\u6267\u884crun\u65f6\u521b\u5efa\u7684\u8d44\u6e90\u5bf9\u8c61\uff0c\u4e5f\u53ef\u4ee5\u83b7\u5f97\u5177\u4f53asyncLocalStorage\u5bf9\u8c61\u6240\u8bbe\u7f6e\u7684\u8d44\u6e90\uff0c\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002 const { AsyncLocalStorage } = require ( ' async_hooks ' ); const asyncLocalStorage = new AsyncLocalStorage (); const asyncLocalStorage2 = new AsyncLocalStorage (); function logWithId ( msg ) { console . log ( asyncLocalStorage2 . getStore ()); const id = asyncLocalStorage . getStore (); console . log ( ` $ { id !== undefined ? id : '-' } : ` , msg ); } asyncLocalStorage . run ( 0 , () => { asyncLocalStorage2 . enterWith ({ hello : \"world\" }); logWithId ( ' start ' ); setImmediate (() => { logWithId ( ' finish ' ); }); }); \u9664\u4e86\u901a\u8fc7asyncLocalStorage.run\u8bbe\u7f6e\u4e0a\u4e0b\u6587\uff0c\u6211\u4eec\u901a\u8fc7asyncLocalStorage2.enterWith\u4e5f\u7ed9\u5bf9\u8c61\u4e0a\u4e0b\u6587\u7684\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e2a\u65b0\u5c5e\u6027\uff0ckey\u662fSymbol('kResourceStore')\uff0c\u503c\u662f{hello: \"world\"}\uff0c\u7136\u540e\u5728logWithId\u4e2d\u8f93\u51faasyncLocalStorage2.getStore()\u3002\u4ece\u8f93\u51fa\u4e2d\u53ef\u4ee5\u770b\u5230\u6210\u529f\u4ece\u8d44\u6e90\u4e2d\u83b7\u5f97\u6302\u8f7d\u7684\u6240\u6709\u4e0a\u4e0b\u6587\u3002 { hello : ' world ' } 0 : start { hello : ' world ' } 0 : finish \u6211\u4eec\u4e5f\u53ef\u4ee5\u4fee\u6539\u6e90\u7801\u9a8c\u8bc1 Immediate { _idleNext : null , _idlePrev : null , _onImmediate : [ Function ( anonymous )], _argv : undefined , _destroyed : true , [ Symbol ( refed )] : null , [ Symbol ( asyncId )] : 6 , [ Symbol ( triggerId )] : 2 , [ Symbol ( kResourceStore )] : 0 , [ Symbol ( kResourceStore )] : { hello : ' world ' } } \u53ef\u4ee5\u770b\u5230\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u91cc\u4e24\u4e2akey\u4e3aSymbol(kResourceStore)\u7684\u5c5e\u6027\u3002 9 \u521d\u59cb\u5316\u65f6\u7684Async hooks \u00b6 const async_hooks = require ( ' async_hooks ' ); const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); \u4ee5\u4e0a\u4ee3\u7801\u4e2d,\u8f93\u51fa1\u548c0\u3002\u5bf9\u5e94\u7684API\u5b9e\u73b0\u5982\u4e0b\u3002 // \u83b7\u53d6\u5f53\u524d\u7684async id function executionAsyncId () { return async_id_fields [ kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524d\u7684trigger async id\uff0c\u5373\u89e6\u53d1\u5f53\u524d\u4ee3\u7801\u7684async id function triggerAsyncId () { return async_id_fields [ kTriggerAsyncId ]; } \u90a3\u4e48async_id_fields\u7684\u521d\u59cb\u5316\u662f\u4ec0\u4e48\u5462\uff1f\u4eceenv.h\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230async_id_fields_\uff08async_id_fields\u662f\u4e0a\u5c42\u4f7f\u7528\u7684\u540d\u79f0\uff0c\u5bf9\u5e94\u5e95\u5c42\u7684async_id_fields_\uff09\u662fAliasedFloat64Array\u7c7b\u578b\u3002 AliasedFloat64Array async_id_fields_ ; AliasedFloat64Array\u662f\u4e2a\u7c7b\u578b\u522b\u540d\u3002 typedef AliasedBufferBase < double , v8 :: Float64Array > AliasedFloat64Array ; AliasedBufferBase\u7684\u6784\u9020\u51fd\u6570\u5982\u4e0b AliasedBufferBase ( v8 :: Isolate * isolate , const size_t count ) : isolate_ ( isolate ), count_ ( count ), byte_offset_ ( 0 ) { const v8 :: HandleScope handle_scope ( isolate_ ); const size_t size_in_bytes = MultiplyWithOverflowCheck ( sizeof ( NativeT ), count ); v8 :: Local < v8 :: ArrayBuffer > ab = v8 :: ArrayBuffer :: New ( isolate_ , size_in_bytes ); // ... } \u5e95\u5c42\u662f\u4e00\u4e2aArrayBuffer\u3002 Local < ArrayBuffer > v8 :: ArrayBuffer :: New ( Isolate * isolate , size_t byte_length ) { i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate *> ( isolate ); LOG_API ( i_isolate , ArrayBuffer , New ); ENTER_V8_NO_SCRIPT_NO_EXCEPTION ( i_isolate ); i :: MaybeHandle < i :: JSArrayBuffer > result = i_isolate -> factory () -> NewJSArrayBufferAndBackingStore ( byte_length , i :: InitializedFlag :: kZeroInitialized ); // ... } ArrayBuffer::New\u5728\u7533\u8bf7\u5185\u5b58\u65f6\u4f20\u5165\u4e86i::InitializedFlag::kZeroInitialized\u3002\u4eceV8\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230\u4f1a\u521d\u59cb\u5316\u5185\u5b58\u7684\u5185\u5bb9\u4e3a0\u3002 // Whether the backing store memory is initialied to zero or not. enum class InitializedFlag : uint8_t { kUninitialized , kZeroInitialized }; \u56de\u5230\u4f8b\u5b50\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u8f93\u51fa\u4f1a\u662f1\u548c0\u800c\u4e0d\u662f0\u548c0\u5462\uff1f\u7b54\u6848\u5728Node.js\u542f\u52a8\u65f6\u7684\u8fd9\u6bb5\u4ee3\u7801\u3002 { InternalCallbackScope callback_scope ( env . get (), Local < Object > (), // async id\u548ctrigger async id { 1 , 0 }, InternalCallbackScope :: kAllowEmptyResource | InternalCallbackScope :: kSkipAsyncHooks ); // \u6267\u884c\u6211\u4eec\u7684js LoadEnvironment ( env . get ()); } InternalCallbackScope\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4ed6\u4f1a\u628a1\u548c0\u8bbe\u7f6e\u4e3a\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u3002\u7136\u540e\u5728LoadEnvironment\u91cc\u6267\u884c\u6211\u7684JS\u4ee3\u7801\u65f6\u83b7\u53d6\u5230\u7684\u503c\u5c31\u662f1\u548c0\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u6539\u6210\u4ee5\u4e0b\u4ee3\u7801\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f const async_hooks = require ( ' async_hooks ' ); Promise . resolve (). then (() => { const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); }) \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u8f93\u51fa0\u548c\u3002\u56e0\u4e3a\u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0cInternalCallbackScope\u5c31\u88ab\u6790\u6784\u4e86\uff0c\u4ece\u800c\u6062\u590d\u4e3a0\u548c0\u3002","title":"22-Async hooks"},{"location":"chapter23-Async%20hooks/#1-envasynchooks","text":"\u5728Node.js\u7684env\u5bf9\u8c61\u4e2d\u6709\u4e00\u4e2aAsyncHooks\u5bf9\u8c61\uff0c\u8d1f\u8d23Node.js\u8fdb\u7a0b\u4e2dasync_hooks\u7684\u7ba1\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b9a\u4e49\u3002","title":"1 env\u4e2d\u7684AsyncHooks"},{"location":"chapter23-Async%20hooks/#11","text":"class AsyncHooks : public MemoryRetainer { public : enum Fields { // \u4e94\u79cd\u94a9\u5b50 kInit , kBefore , kAfter , kDestroy , kPromiseResolve , // \u94a9\u5b50\u603b\u6570 kTotals , // async_hooks\u5f00\u542f\u7684\u4e2a\u6570 kCheck , // \u8bb0\u5f55\u6808\u7684top\u6307\u9488 kStackLength , // \u6570\u7ec4\u5927\u5c0f kFieldsCount , }; enum UidFields { kExecutionAsyncId , kTriggerAsyncId , // \u5f53\u524dasync id\u7684\u503c kAsyncIdCounter , kDefaultTriggerAsyncId , kUidFieldsCount , }; private : inline AsyncHooks (); // \u5f02\u6b65\u8d44\u6e90\u7684\u7c7b\u578b std :: array < v8 :: Eternal < v8 :: String > , AsyncWrap :: PROVIDERS_LENGTH > providers_ ; // \u6808 AliasedFloat64Array async_ids_stack_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cFields\u5bf9\u5e94 AliasedUint32Array fields_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cUidFields\u5bf9\u5e94 AliasedFloat64Array async_id_fields_ ; }; \u7ed3\u6784\u56fe\u5982\u4e0b \u63a5\u4e0b\u6765\u770b\u4e00\u4e0benv\u7684AsyncHooks\u5bf9\u8c61\u63d0\u4f9b\u4e86\u54ea\u4e9bAPI\uff0c\u8fd9\u4e9bAPI\u662f\u4e0a\u5c42\u7684\u57fa\u7840\u3002","title":"1.1 \u7c7b\u5b9a\u4e49"},{"location":"chapter23-Async%20hooks/#12-api","text":"\u6211\u4eec\u770b\u4e00\u4e0benv\u5bf9\u8c61\u4e2d\u83b7\u53d6AsyncHooks\u5bf9\u8c61\u5bf9\u5e94\u5b57\u6bb5\u7684API\u3002 // \u83b7\u53d6\u5bf9\u5e94\u7684\u5b57\u6bb5 inline AliasedUint32Array & AsyncHooks::fields () { return fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_id_fields () { return async_id_fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_ids_stack () { return async_ids_stack_ ; } // \u83b7\u53d6\u8d44\u6e90\u7c7b\u578b inline v8 :: Local < v8 :: String > AsyncHooks :: provider_string ( int idx ) { return providers_ [ idx ]. Get ( env () -> isolate ()); } // \u65b0\u5efa\u8d44\u6e90\u7684\u65f6\u5019\uff0c\u83b7\u53d6\u65b0\u7684async id inline double Environment :: new_async_id () { async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ] += 1 ; return async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ]; } // \u83b7\u53d6\u5f53\u524dasync id inline double Environment :: execution_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524dtrigger async id inline double Environment :: trigger_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kTriggerAsyncId ]; } // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\uff0c\u5219\u83b7\u53d6\u5f53\u524d\u7684async id inline double Environment :: get_default_trigger_async_id () { double default_trigger_async_id = async_hooks () -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; // If defaultTriggerAsyncId isn't set, use the executionAsyncId if ( default_trigger_async_id < 0 ) default_trigger_async_id = execution_async_id (); return default_trigger_async_id ; }","title":"1.2 \u8bfbAPI"},{"location":"chapter23-Async%20hooks/#13-api","text":"inline void AsyncHooks::push_async_ids ( double async_id , double trigger_async_id ) { // \u83b7\u53d6\u5f53\u524d\u6808\u9876\u6307\u9488 uint32_t offset = fields_ [ kStackLength ]; // \u4e0d\u591f\u5219\u6269\u5bb9 if ( offset * 2 >= async_ids_stack_ . Length ()) grow_async_ids_stack (); // \u628a\u65e7\u7684\u4e0a\u4e0b\u6587\u538b\u6808 async_ids_stack_ [ 2 * offset ] = async_id_fields_ [ kExecutionAsyncId ]; async_ids_stack_ [ 2 * offset + 1 ] = async_id_fields_ [ kTriggerAsyncId ]; // \u6808\u6307\u9488\u52a0\u4e00 fields_ [ kStackLength ] += 1 ; // \u8bb0\u5f55\u5f53\u524d\u4e0a\u4e0b\u6587 async_id_fields_ [ kExecutionAsyncId ] = async_id ; async_id_fields_ [ kTriggerAsyncId ] = trigger_async_id ; } // \u548c\u4e0a\u9762\u7684\u903b\u8f91\u76f8\u53cd inline bool AsyncHooks::pop_async_id ( double async_id ) { if ( fields_ [ kStackLength ] == 0 ) return false ; uint32_t offset = fields_ [ kStackLength ] - 1 ; async_id_fields_ [ kExecutionAsyncId ] = async_ids_stack_ [ 2 * offset ]; async_id_fields_ [ kTriggerAsyncId ] = async_ids_stack_ [ 2 * offset + 1 ]; fields_ [ kStackLength ] = offset ; return fields_ [ kStackLength ] > 0 ; }","title":"1.3 \u5199API"},{"location":"chapter23-Async%20hooks/#2-asyncwrap","text":"\u63a5\u7740\u770b\u4e00\u4e0b\u5f02\u6b65\u8d44\u6e90\u7684\u57fa\u7c7bAsyncWrap\u3002\u6240\u6709\u4f9d\u8d56\u4e8eC\u3001C++\u5c42\u5b9e\u73b0\u7684\u8d44\u6e90\uff08\u6bd4\u5982TCP\u3001UDP\uff09\u90fd\u4f1a\u7ee7\u627fAsyncWrap\u3002\u770b\u770b\u8be5\u7c7b\u7684\u5b9a\u4e49\u3002 class AsyncWrap : public BaseObject { private : ProviderType provider_type_ = PROVIDER_NONE ; double async_id_ = kInvalidAsyncId ; double trigger_async_id_ ; }; \u6211\u4eec\u770b\u5230\u6bcf\u4e2aAsyncWrap\u5bf9\u8c61\u90fd\u6709async_id_\u3001trigger_async_id_\u548cprovider_type_\u5c5e\u6027\uff0c\u8fd9\u6b63\u662f\u5728init\u56de\u8c03\u91cc\u62ff\u5230\u7684\u6570\u636e\u3002\u6211\u4eec\u770b\u770bAsyncWrap\u7684\u6784\u9020\u51fd\u6570\u3002\u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff08AsyncWrap\uff09\u65f6\u7684\u903b\u8f91\u3002","title":"2 \u5e95\u5c42\u8d44\u6e90\u5c01\u88c5\u7c7b - AsyncWrap"},{"location":"chapter23-Async%20hooks/#21","text":"AsyncWrap :: AsyncWrap ( Environment * env , Local < Object > object , ProviderType provider , double execution_async_id , bool silent ) : AsyncWrap ( env , object ) { // \u8d44\u6e90\u7c7b\u578b provider_type_ = provider ; AsyncReset ( execution_async_id , silent ); } void AsyncWrap :: AsyncReset ( Local < Object > resource , double execution_async_id , bool silent ) { // \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684async id\uff0cexecution_async_id\u9ed8\u8ba4\u662fkInvalidAsyncId async_id_ = execution_async_id == kInvalidAsyncId ? env () -> new_async_id () : execution_async_id ; // \u83b7\u53d6trigger async id trigger_async_id_ = env () -> get_default_trigger_async_id (); // \u6267\u884cinit\u94a9\u5b50 EmitAsyncInit ( env (), resource , env () -> async_hooks () -> provider_string ( provider_type ()), async_id_ , trigger_async_id_ ); } \u63a5\u7740\u770bEmitAsyncInit void AsyncWrap::EmitAsyncInit ( Environment * env , Local < Object > object , Local < String > type , double async_id , double trigger_async_id ) { AsyncHooks * async_hooks = env -> async_hooks (); HandleScope scope ( env -> isolate ()); Local < Function > init_fn = env -> async_hooks_init_function (); Local < Value > argv [] = { Number :: New ( env -> isolate (), async_id ), type , Number :: New ( env -> isolate (), trigger_async_id ), object , }; TryCatchScope try_catch ( env , TryCatchScope :: CatchMode :: kFatal ); // \u6267\u884cinit\u56de\u8c03 USE ( init_fn -> Call ( env -> context (), object , arraysize ( argv ), argv )); } \u90a3\u4e48env->async_hooks_init_function()\u7684\u503c\u662f\u4ec0\u4e48\u5462\uff1f\u8fd9\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u3002 const { nativeHooks } = require ( ' internal / async_hooks ' ); internalBinding ( ' async_wrap ' ). setupHooks ( nativeHooks ); SetupHooks\u7684\u5b9e\u73b0\u5982\u4e0b static void SetupHooks ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Object > fn_obj = args [ 0 ]. As < Object > (); #define SET_HOOK_FN(name) \\ do { \\ Local<Value> v = \\ fn_obj->Get(env->context(), \\ FIXED_ONE_BYTE_STRING(env->isolate(), #name)) \\ .ToLocalChecked(); \\ CHECK(v->IsFunction()); \\ env->set_async_hooks_##name##_function(v.As<Function>()); \\ } while (0) // \u4fdd\u5b58\u5230env\u4e2d SET_HOOK_FN ( init ); SET_HOOK_FN ( before ); SET_HOOK_FN ( after ); SET_HOOK_FN ( destroy ); SET_HOOK_FN ( promise_resolve ); #undef SET_HOOK_FN } nativeHooks\u7684\u5b9e\u73b0\u5982\u4e0b nativeHooks : { init : emitInitNative , before : emitBeforeNative , after : emitAfterNative , destroy : emitDestroyNative , promise_resolve : emitPromiseResolveNative } \u8fd9\u4e9bHooks\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u6bd4\u5982emitInitNative function emitInitNative ( asyncId , type , triggerAsyncId , resource ) { for ( var i = 0 ; i < active_hooks . array . length ; i ++ ) { if ( typeof active_hooks . array [ i ][ init_symbol ] === ' function ' ) { active_hooks . array [ i ][ init_symbol ]( asyncId , type , triggerAsyncId , resource ); } } } active_hooks.array\u7684\u503c\u5c31\u662f\u6211\u4eec\u5728\u4e1a\u52a1\u4ee3\u7801\u91cc\u8bbe\u7f6e\u7684\u94a9\u5b50\uff0c\u6bcf\u6b21\u8c03\u7814createHooks\u7684\u65f6\u5019\u5c31\u5bf9\u5e94\u6570\u7ec4\u7684\u4e00\u4e2a\u5143\u7d20\u3002","title":"2.1 \u8d44\u6e90\u521d\u59cb\u5316"},{"location":"chapter23-Async%20hooks/#22","text":"\u5f53\u4e1a\u52a1\u4ee3\u7801\u5f02\u6b65\u8bf7\u6c42\u5e95\u5c42API\uff0c\u5e76\u4e14\u5e95\u5c42\u6ee1\u8db3\u6761\u4ef6\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u7684\u56de\u8c03\uff0c\u6bd4\u5982\u76d1\u542c\u4e00\u4e2asocket\u65f6\uff0c\u6709\u8fde\u63a5\u5230\u6765\u3002Node.js\u5c31\u4f1a\u8c03\u7528MakeCallback\u51fd\u6570\u6267\u884c\u56de\u8c03\u3002 MaybeLocal < Value > AsyncWrap :: MakeCallback ( const Local < Function > cb , int argc , Local < Value >* argv ) { // \u5f53\u524dAsyncWrap\u5bf9\u8c61\u5bf9\u5e94\u7684\u6267\u884c\u4e0a\u4e0b\u6587 ProviderType provider = provider_type (); async_context context { get_async_id (), get_trigger_async_id () }; MaybeLocal < Value > ret = InternalMakeCallback ( env (), object (), cb , argc , argv , context ); return ret ; } MakeCallback\u4e2d\u4f1a\u8c03\u7528InternalMakeCallback\u3002 MaybeLocal < Value > InternalMakeCallback ( Environment * env , Local < Object > recv , const Local < Function > callback , int argc , Local < Value > argv [], async_context asyncContext ) { // \u65b0\u5efa\u4e00\u4e2ascope InternalCallbackScope scope ( env , recv , asyncContext ); // \u6267\u884c\u56de\u8c03 callback -> Call ( env -> context (), recv , argc , argv ); // \u5173\u95edscope scope . Close (); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u548c\u5173\u95edscope\u90fd\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 InternalCallbackScope :: InternalCallbackScope ( Environment * env , Local < Object > object , const async_context & asyncContext , int flags ) : env_ ( env ), async_context_ ( asyncContext ), object_ ( object ), skip_hooks_ ( flags & kSkipAsyncHooks ), skip_task_queues_ ( flags & kSkipTaskQueues ) { // v14\u7248\u672c\u4e2d\uff0c\u662f\u5148\u89e6\u53d1before\u518dpush\u4e0a\u4e0b\u6587\uff0c\u987a\u5e8f\u662f\u4e0d\u5bf9\u7684\uff0cv16\u5df2\u7ecf\u6539\u8fc7\u6765\u3002 // \u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5165\u6808 env -> async_hooks () -> push_async_ids ( async_context_ . async_id , async_context_ . trigger_async_id ); // \u89e6\u53d1before\u94a9\u5b50 if ( asyncContext . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitBefore ( env , asyncContext . async_id ); } pushed_ids_ = true ; } \u5728scope\u91cc\u4f1a\u628a\u5f53\u524dAsyncWrap\u5bf9\u8c61\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u5e76\u4e14\u89e6\u53d1before\u94a9\u5b50\uff0c\u7136\u540e\u6267\u884c\u4e1a\u52a1\u56de\u8c03\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u56de\u8c03\u91cc\u83b7\u53d6\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u65f6\u5c31\u62ff\u5230\u4e86AsyncWrap\u5bf9\u5e94\u7684\u503c\uff08 \u8c03\u7528executionAsyncId\uff09\uff0c\u63a5\u7740\u770bClose void InternalCallbackScope::Close () { // \u6267\u884c if ( pushed_ids_ ) env_ -> async_hooks () -> pop_async_id ( async_context_ . async_id ); if ( async_context_ . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitAfter ( env_ , async_context_ . async_id ); } } Close\u5728\u6267\u884c\u56de\u8c03\u540e\u88ab\u8c03\u7528\uff0c\u4e3b\u8981\u662f\u6062\u590d\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5e76\u4e14\u89e6\u53d1after\u94a9\u5b50\u3002","title":"2.2 \u6267\u884c\u8d44\u6e90\u56de\u8c03"},{"location":"chapter23-Async%20hooks/#3-timeouttickobjecd","text":"\u5e76\u4e0d\u662f\u6240\u6709\u7684\u5f02\u6b65\u8d44\u6e90\u90fd\u662f\u5e95\u5c42\u5b9e\u73b0\u7684\uff0c\u6bd4\u5982\u5b9a\u65f6\u5668\uff0ctick\u4e5f\u88ab\u5b9a\u4e49\u4e3a\u5f02\u6b65\u8d44\u6e90\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u662f\u548c\u56de\u8c03\u76f8\u5173\u3002\u8fd9\u79cd\u5f02\u6b65\u8d44\u6e90\u662f\u5728JS\u5c42\u5b9e\u73b0\u7684\uff0c\u8fd9\u91cc\u53ea\u5206\u6790Timeout\u3002","title":"3 \u4e0a\u5c42\u8d44\u6e90\u7684\u5c01\u88c5 - Timeout\u3001TickObjecd\u7b49"},{"location":"chapter23-Async%20hooks/#31","text":"\u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884csetTimeout\u65f6\u7684\u6838\u5fc3\u903b\u8f91\u3002 function setTimeout ( callback , after , arg1 , arg2 , arg3 ) { const timeout = new Timeout ( callback , after , args , false , true ); return timeout ; } function Timeout ( callback , after , args , isRepeat , isRefed ) { initAsyncResource ( this , ' Timeout ' ); } function initAsyncResource ( resource , type ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = resource [ async_id_symbol ] = newAsyncId (); const triggerAsyncId = resource [ trigger_async_id_symbol ] = getDefaultTriggerAsyncId (); // \u662f\u5426\u8bbe\u7f6e\u4e86init\u94a9\u5b50\uff0c\u662f\u5219\u89e6\u53d1\u56de\u8c03 if ( initHooksExist ()) emitInit ( asyncId , type , triggerAsyncId , resource ); } \u6267\u884csetTimeout\u65f6\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8bbe\u7f6easync_hooks\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u5e76\u8bb0\u5f55\u5230Timeout\u5bf9\u8c61\u4e2d\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\u3002 function emitInitScript ( asyncId , type , triggerAsyncId , resource ) { emitInitNative ( asyncId , type , triggerAsyncId , resource ); } \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u6267\u884c\u6bcf\u4e2aasync_hooks\u5bf9\u8c61\u7684init\u56de\u8c03(\u901a\u5e38\u6211\u4eec\u53ea\u6709\u4e00\u4e2aasync_hooks\u5bf9\u8c61)\u3002","title":"3.1 \u521b\u5efa\u8d44\u6e90"},{"location":"chapter23-Async%20hooks/#31_1","text":"\u5f53\u5b9a\u65f6\u5668\u5230\u671f\u65f6\uff0c\u4f1a\u6267\u884c\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u76f8\u5173\u7684\u903b\u8f91\u3002 // \u89e6\u53d1before\u94a9\u5b50 emitBefore ( asyncId , timer [ trigger_async_id_symbol ]); // \u6267\u884c\u56de\u8c03 timer . _onTimeout (); // \u89e6\u53d1after\u56de\u8c03 emitAfter ( asyncId ); \u6211\u4eec\u770b\u5230\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u524d\u540e\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002 function emitBeforeScript ( asyncId , triggerAsyncId ) { // \u548c\u5e95\u5c42\u7684push_async_ids\u903b\u8f91\u4e00\u6837 pushAsyncIds ( asyncId , triggerAsyncId ); // \u5982\u679c\u6709\u56de\u8c03\u5219\u6267\u884c if ( async_hook_fields [ kBefore ] > 0 ) emitBeforeNative ( asyncId ); } function emitAfterScript ( asyncId ) { // \u8bbe\u7f6e\u4e86after\u56de\u8c03\u5219emit if ( async_hook_fields [ kAfter ] > 0 ) emitAfterNative ( asyncId ); // \u548c\u5e95\u5c42\u7684pop_async_ids\u903b\u8f91\u4e00\u6837 popAsyncIds ( asyncId ); } JS\u5c42\u7684\u5b9e\u73b0\u548c\u5e95\u5c42\u662f\u4fdd\u6301\u4e00\u81f4\u7684\u3002\u5982\u679c\u6211\u4eec\u5728setTimeout\u56de\u8c03\u91cc\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff0c\u6bd4\u5982\u518d\u6b21\u6267\u884csetTimeout\uff0c\u8fd9\u65f6\u5019trigger async id\u5c31\u662f\u7b2c\u4e00\u4e2asetTimeout\u5bf9\u5e94\u7684async id\uff0c\u6240\u4ee5\u5c31\u8fde\u8d77\u6765\u4e86\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u4f8b\u5b50\u3002","title":"3.1 \u6267\u884c\u56de\u8c03"},{"location":"chapter23-Async%20hooks/#4-defaulttriggerasyncidscope","text":"Node.js\u4e3a\u4e86\u907f\u514d\u8fc7\u591a\u901a\u8fc7\u53c2\u6570\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u9012async id\uff0c\u5c31\u8bbe\u8ba1\u4e86DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7684\u4f5c\u7528\u7c7b\u4f3c\u5728\u591a\u4e2a\u51fd\u6570\u5916\u7ef4\u62a4\u4e00\u4e2a\u53d8\u91cf\uff0c\u591a\u4e2a\u51fd\u6570\u90fd\u53ef\u4ee5\u901a\u8fc7DefaultTriggerAsyncIdScope\u83b7\u5f97trigger async id\uff0c\u800c\u4e0d\u9700\u8981\u901a\u8fc7\u5c42\u5c42\u4f20\u9012\u7684\u65b9\u5f0f\uff0c\u4ed6\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\u3002 class DefaultTriggerAsyncIdScope { private : AsyncHooks * async_hooks_ ; double old_default_trigger_async_id_ ; }; inline AsyncHooks :: DefaultTriggerAsyncIdScope :: DefaultTriggerAsyncIdScope ( Environment * env , double default_trigger_async_id ) : async_hooks_ ( env -> async_hooks ()) { // \u8bb0\u5f55\u65e7\u7684id\uff0c\u8bbe\u7f6e\u65b0\u7684id old_default_trigger_async_id_ = async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = default_trigger_async_id ; } // \u6062\u590d inline AsyncHooks :: DefaultTriggerAsyncIdScope ::~ DefaultTriggerAsyncIdScope () { async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = old_default_trigger_async_id_ ; } DefaultTriggerAsyncIdScope\u4e3b\u8981\u662f\u8bb0\u5f55\u65e7\u7684id\uff0c\u7136\u540e\u628a\u65b0\u7684id\u8bbe\u7f6e\u5230env\u4e2d\uff0c\u5f53\u5176\u4ed6\u51fd\u6570\u8c03\u7528get_default_trigger_async_id\u65f6\u5c31\u53ef\u4ee5\u83b7\u53d6\u8bbe\u7f6e\u7684async id\u3002\u540c\u6837JS\u5c42\u4e5f\u5b9e\u73b0\u4e86\u7c7b\u4f3c\u7684API\u3002 function defaultTriggerAsyncIdScope ( triggerAsyncId , block , ... args ) { const oldDefaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; async_id_fields [ kDefaultTriggerAsyncId ] = triggerAsyncId ; try { return block (... args ); } finally { async_id_fields [ kDefaultTriggerAsyncId ] = oldDefaultTriggerAsyncId ; } } \u5728\u6267\u884cblock\u51fd\u6570\u65f6\uff0c\u53ef\u4ee5\u83b7\u53d6\u5230\u8bbe\u7f6e\u7684\u503c\uff0c\u800c\u4e0d\u9700\u8981\u4f20\u9012\uff0c\u6267\u884c\u5b8cblock\u540e\u6062\u590d\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u4f7f\u7528\u3002\u4e0b\u9762\u6458\u81eanet\u6a21\u5757\u7684\u4ee3\u7801\u3002 // \u83b7\u53d6handle\u91cc\u7684async id this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u91cc\u5177\u4f53\u7684\u60c5\u51b5\u3002\u5728defaultTriggerAsyncIdScope\u4e2d\u4f1a\u4ee5emitListeningNT\u4e3a\u5165\u53c2\u6267\u884cprocess.nextTick\u3002\u6211\u4eec\u770b\u770bnextTick\u7684\u5b9e\u73b0\u3002 function nextTick ( callback ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = newAsyncId (); // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5373\u521a\u624d\u8bbe\u7f6e\u7684 const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; if ( initHooksExist ()) // \u521b\u5efa\u4e86\u65b0\u7684\u8d44\u6e90\uff0c\u89e6\u53d1init\u94a9\u5b50 emitInit ( asyncId , ' TickObject ' , triggerAsyncId , tickObject ); queue . push ( tickObject ); } \u6211\u4eec\u770b\u5230\u5728nextTick\u4e2d\u901a\u8fc7getDefaultTriggerAsyncId\u62ff\u5230\u4e86trigger async id\u3002 function getDefaultTriggerAsyncId () { const defaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; if ( defaultTriggerAsyncId < 0 ) return async_id_fields [ kExecutionAsyncId ]; return defaultTriggerAsyncId ; } getDefaultTriggerAsyncId\u8fd4\u56de\u7684\u5c31\u662f\u521a\u624d\u901a\u8fc7defaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684async id\u3002\u6240\u4ee5\u5728\u89e6\u53d1TickObject\u7684init\u94a9\u5b50\u65f6\u7528\u6237\u5c31\u53ef\u4ee5\u62ff\u5230\u5bf9\u5e94\u7684id\u3002\u4e0d\u8fc7\u66f4\u91cd\u8981\u7684\u65f6\uff0c\u5728\u5f02\u6b65\u6267\u884cnextTick\u7684\u4efb\u52a1\u65f6\uff0c\u8fd8\u53ef\u4ee5\u62ff\u5230\u539f\u59cb\u7684trigger async id\u3002\u56e0\u4e3a\u8be5id\u8bb0\u5f55\u5728tickObject\u4e2d\u3002\u6211\u4eec\u770b\u770b\u6267\u884ctick\u4efb\u52a1\u65f6\u7684\u903b\u8f91\u3002 function processTicksAndRejections () { let tock ; do { while ( tock = queue . shift ()) { // \u62ff\u5230\u5bf9\u5e94\u7684async \u4e0a\u4e0b\u6587 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { const callback = tock . callback ; callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); } } while ( ! queue . isEmpty () || processPromiseRejections ()); }","title":"4 DefaultTriggerAsyncIdScope"},{"location":"chapter23-Async%20hooks/#5","text":"\u8d44\u6e90\u9500\u6bc1\u7684\u65f6\u5019\u4e5f\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u4e0d\u8fc7\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u94a9\u5b50\u662f\u5f02\u6b65\u89e6\u53d1\u7684\u3002\u65e0\u8bba\u662fJS\u8fd8\u662f\u597dC++\u5c42\u89e6\u53d1\u9500\u6bc1\u94a9\u5b50\u7684\u65f6\u5019\uff0c\u903b\u8f91\u90fd\u662f\u4e00\u81f4\u7684\u3002 void AsyncWrap::EmitDestroy ( Environment * env , double async_id ) { // \b\u4e4b\u524d\u4e3a\u7a7a\u5219\u8bbe\u7f6e\u56de\u8c03 if ( env -> destroy_async_id_list () -> empty ()) { env -> SetUnrefImmediate ( & DestroyAsyncIdsCallback ); } // async id\u5165\u961f env -> destroy_async_id_list () -> push_back ( async_id ); } template < typename Fn > void Environment :: SetUnrefImmediate ( Fn && cb ) { CreateImmediate ( std :: move ( cb ), false ); } template < typename Fn > void Environment :: CreateImmediate ( Fn && cb , bool ref ) { auto callback = std :: make_unique < NativeImmediateCallbackImpl < Fn >> ( std :: move ( cb ), ref ); // \u52a0\u5165\u4efb\u52a1\u961f\u5217 native_immediates_ . Push ( std :: move ( callback )); } \u5728\u4e8b\u4ef6\u5faa\u73af\u7684check\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u91cc\u9762\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u6267\u884c\u56de\u8c03DestroyAsyncIdsCallback\u3002 void AsyncWrap::DestroyAsyncIdsCallback ( Environment * env ) { Local < Function > fn = env -> async_hooks_destroy_function (); do { std :: vector < double > destroy_async_id_list ; destroy_async_id_list . swap ( * env -> destroy_async_id_list ()); // \u904d\u5386\u9500\u6bc1\u7684async id for ( auto async_id : destroy_async_id_list ) { HandleScope scope ( env -> isolate ()); Local < Value > async_id_value = Number :: New ( env -> isolate (), async_id ); // \u6267\u884cJS\u5c42\u56de\u8c03 MaybeLocal < Value > ret = fn -> Call ( env -> context (), Undefined ( env -> isolate ()), 1 , & async_id_value ); } } while ( ! env -> destroy_async_id_list () -> empty ()); }","title":"5 \u8d44\u6e90\u9500\u6bc1"},{"location":"chapter23-Async%20hooks/#6-async-hooks","text":"\u6211\u4eec\u901a\u5e38\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528Async hooks const async_hooks = require ( ' async_hooks ' ); async_hooks . createHook ({ init ( asyncId , type , triggerAsyncId ) {}, before ( asyncId ) {}, after ( asyncId ) {}, destroy ( asyncId ) {}, promiseResolve ( asyncId ), }) . enable (); async_hooks\u662f\u5bf9\u8d44\u6e90\u751f\u547d\u5468\u671f\u7684\u62bd\u8c61\uff0c\u8d44\u6e90\u5c31\u662f\u64cd\u4f5c\u5bf9\u8c61\u548c\u56de\u8c03\u7684\u62bd\u8c61\u3002async_hooks\u5b9a\u4e49\u4e86\u4e94\u4e2a\u751f\u547d\u5468\u671f\u94a9\u5b50\uff0c\u5f53\u8d44\u6e90\u7684\u72b6\u6001\u5230\u8fbe\u67d0\u4e2a\u5468\u671f\u8282\u70b9\u65f6\uff0casync_hooks\u5c31\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateHook\u3002 function createHook ( fns ) { return new AsyncHook ( fns ); } createHook\u662f\u5bf9AsyncHook\u7684\u5c01\u88c5 class AsyncHook { constructor ({ init , before , after , destroy , promiseResolve }) { // \u8bb0\u5f55\u56de\u8c03 this [ init_symbol ] = init ; this [ before_symbol ] = before ; this [ after_symbol ] = after ; this [ destroy_symbol ] = destroy ; this [ promise_resolve_symbol ] = promiseResolve ; } } AsyncHook\u7684\u521d\u59cb\u5316\u5f88\u7b80\u5355\uff0c\u521b\u5efa\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u8bb0\u5f55\u56de\u8c03\u51fd\u6570\u3002\u521b\u5efa\u4e86AsyncHook\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528AsyncHook\u7684enable\u51fd\u6570\u624b\u52a8\u5f00\u542f\u3002 class AsyncHook { enable () { // \u83b7\u53d6\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4 const [ hooks_array , hook_fields ] = getHookArrays (); // \u6267\u884c\u8fc7enable\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6267\u884c if ( hooks_array . includes ( this )) return this ; // \u505a\u4e9b\u7edf\u8ba1 const prev_kTotals = hook_fields [ kTotals ]; hook_fields [ kTotals ] = hook_fields [ kInit ] += +!! this [ init_symbol ]; hook_fields [ kTotals ] += hook_fields [ kBefore ] += +!! this [ before_symbol ]; hook_fields [ kTotals ] += hook_fields [ kAfter ] += +!! this [ after_symbol ]; hook_fields [ kTotals ] += hook_fields [ kDestroy ] += +!! this [ destroy_symbol ]; hook_fields [ kTotals ] += hook_fields [ kPromiseResolve ] += +!! this [ promise_resolve_symbol ]; // \u5f53\u524d\u5bf9\u8c61\u63d2\u5165\u6570\u7ec4\u4e2d hooks_array . push ( this ); // \u5982\u679c\u4e4b\u524d\u7684\u6570\u91cf\u662f0\uff0c\u672c\u6b21\u64cd\u4f5c\u540e\u5927\u4e8e0\u5219\u5f00\u542f\u5e95\u5c42\u7684\u903b\u8f91 if ( prev_kTotals === 0 && hook_fields [ kTotals ] > 0 ) { enableHooks (); } return this ; } } 1 hooks_array\uff1a\u662f\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\uff0c\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u7528\u6237\u521b\u5efa\u4e86\u54ea\u4e9bAsyncHook\u5bf9\u8c61\uff0c\u7136\u540e\u54ea\u4e9bAsyncHook\u5bf9\u8c61\u91cc\u90fd\u8bbe\u7f6e\u4e86\u54ea\u4e9b\u94a9\u5b50\uff0c\u5728\u56de\u8c03\u7684\u65f6\u5019\u5c31\u4f1a\u904d\u5386\u8fd9\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03\u3002 2 hook_fields\uff1a\u5bf9\u5e94\u5e95\u5c42\u7684async_hook_fields\u3002 3 enableHooks\uff1a function enableHooks () { // \u8bb0\u5f55async_hooks\u7684\u5f00\u542f\u4e2a\u6570 async_hook_fields [ kCheck ] += 1 ; } \u81f3\u6b64\uff0casync_hooks\u7684\u521d\u59cb\u5316\u5c31\u5b8c\u6210\u4e86\uff0c\u6211\u4eec\u53d1\u73b0\u903b\u8f91\u975e\u5e38\u7b80\u5355\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u4e0b\u9762\u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 const { createHook , executionAsyncId } = require ( ' async_hooks ' ); const fs = require ( ' fs ' ); const net = require ( ' net ' ); createHook ({ init ( asyncId , type , triggerAsyncId ) { fs . writeSync ( 1 , ` $ { type }( $ { asyncId }) : trigger : $ { triggerAsyncId } execution : $ { executionAsyncId ()} \\ n ` ); } }). enable (); net . createServer (( conn ) => {}). listen ( 8080 ); \u4ee5\u4e0a\u4ee3\u7801\u8f93\u51fa init : type : TCPSERVERWRAP asyncId : 2 trigger id : 1 executionAsyncId () : 1 triggerAsyncId () : 0 init : type : TickObject asyncId : 3 trigger id : 2 executionAsyncId () : 1 triggerAsyncId () : 0 before : asyncId : 3 executionAsyncId () : 3 triggerAsyncId () : 2 after : asyncId : 3 executionAsyncId () : 3 triggerAsyncId () : 2 \u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u77e5\u9053\u521b\u5efa\u8d44\u6e90\u7684\u65f6\u5019\u4f1a\u6267\u884cinit\u56de\u8c03\uff0c\u5177\u4f53\u903b\u8f91\u5728listen\u51fd\u6570\u4e2d\uff0c\u5728listen\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u4f1a\u6267\u884cnew TCP\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8868\u793a\u670d\u52a1\u5668\u3002TCP\u662fC++\u5c42\u5bfc\u51fa\u7684\u7c7b\uff0c\u521a\u624d\u6211\u4eec\u8bf4\u8fc7\uff0cTCP\u4f1a\u7ee7\u627fAsyncWrap\uff0c\u65b0\u5efaAsyncWrap\u5bf9\u8c61\u7684\u65f6\u5019\u4f1a\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa init : type : TCPSERVERWRAP asyncId : 2 trigger id : 1 executionAsyncId () : 1 triggerAsyncId () : 0 \u90a3TickObject\u662f\u600e\u4e48\u6765\u7684\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770blisten\u91cc\u7684\u53e6\u4e00\u6bb5\u903b\u8f91\u3002 this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u4e0a\u9762\u7684\u4ee3\u7801\u6211\u4eec\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5728\u6267\u884cprocess.nextTick\u7684\u65f6\u5019\u4f1a\u521b\u5efa\u4e00\u4e2aTickObject\u5bf9\u8c61\u5c01\u88c5\u6267\u884c\u4e0a\u4e0b\u6587\u548c\u56de\u8c03\u3002 const asyncId = newAsyncId (); const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; emitInit ( asyncId , ' TickObject ' , triggerAsyncId , tickObject ); \u8fd9\u6b21\u518d\u6b21\u89e6\u53d1\u4e86init\u94a9\u5b50\uff0c\u7ed3\u6784\u5982\u4e0b\uff08nextTick\u901a\u8fc7getDefaultTriggerAsyncId\u83b7\u53d6\u7684id\u662fdefaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684id\uff09\u3002 \u5bf9\u5e94\u8f93\u51fa init : type : TickObject asyncId : 3 trigger id : 2 executionAsyncId () : 1 triggerAsyncId () : 0 \u63a5\u7740\u6267\u884ctick\u4efb\u52a1\u3002 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { tock . callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); emitBefore\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa before: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 after: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 \u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0c\u6240\u6709\u5165\u6808\u7684\u4e0a\u4e0b\u6587\u90fd\u4f1a\u88ab\u6e05\u7a7a\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8fde\u63a5\u5efa\u7acb\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f\u5f53\u6709\u8fde\u63a5\u5efa\u7acb\u65f6\uff0c\u4f1a\u6267\u884cC++\u5c42\u7684OnConnection\u3002 OnConnection\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684TCP\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61\u3002 MaybeLocal < Object > TCPWrap :: Instantiate ( Environment * env , AsyncWrap * parent , TCPWrap :: SocketType type ) { EscapableHandleScope handle_scope ( env -> isolate ()); AsyncHooks :: DefaultTriggerAsyncIdScope trigger_scope ( parent ); return handle_scope . EscapeMaybe ( constructor -> NewInstance ( env -> context (), 1 , & type_value )); } \u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2aAsyncHooks::DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7528\u4e8e\u8bbe\u7f6e\u9ed8\u8ba4default_trigger_async_id\u4e3aparent\u7684async id\uff08\u503c\u662f2\uff09\uff0c\u6267\u884cInstantiate\u65f6\u4f1a\u6267\u884c\u6790\u6784\u51fd\u6570\u6062\u590d\u539f\u6765\u72b6\u6001\u3002\u63a5\u7740NewInstance\u7684\u65f6\u5019\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\uff0c\u4ece\u800c\u521b\u5efa\u4e00\u4e2aAsyncWrap\u5bf9\u8c61\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa init : type : TCPWRAP asyncId : 4 trigger id : 2 executionAsyncId () : 0 triggerAsyncId () : 0 \u521b\u5efa\u5b8c\u5bf9\u8c61\u540e\uff0c\u901a\u8fc7AsyncWrap::MakeCallback\u56de\u8c03JS\u5c42\uff0c\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7AsyncWrap::MakeCallback\u4f1a\u89e6\u53d1before\u548cafter\u94a9\u5b50\uff0c\u89e6\u53d1before\u94a9\u5b50\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa before: asyncId: 2 executionAsyncId(): 2 triggerAsyncId(): 1 \u540c\u6837\uff0c\u5728\u56de\u8c03\u51fd\u6570\u91cc\u6267\u884cexecutionAsyncId\u548ctriggerAsyncId\u62ff\u5230\u7684\u5185\u5bb9\u662f\u4e00\u6837\u7684\u3002\u89e6\u53d1after\u540e\u518d\u6062\u590d\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u8f93\u51fa\u4e5f\u662f\u4e00\u6837\u7684\u3002 after : asyncId : 2 executionAsyncId () : 2 triggerAsyncId () : 1","title":"6 Async hooks\u7684\u4f7f\u7528"},{"location":"chapter23-Async%20hooks/#7-asyncresource","text":"\u5f02\u6b65\u8d44\u6e90\u5e76\u4e0d\u662fNode.js\u5185\u7f6e\u7684\uff0cNode.js\u53ea\u662f\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4e1a\u52a1\u5c42\u4e5f\u53ef\u4ee5\u4f7f\u7528\u3002Node.js\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7c7b\u7ed9\u4e1a\u52a1\u4f7f\u7528\uff0c\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b\u3002 class AsyncResource { constructor ( type , opts = {}) { let triggerAsyncId = opts ; let requireManualDestroy = false ; if ( typeof opts !== ' number ' ) { triggerAsyncId = opts . triggerAsyncId === undefined ? getDefaultTriggerAsyncId () : opts . triggerAsyncId ; requireManualDestroy = !! opts . requireManualDestroy ; } const asyncId = newAsyncId (); this [ async_id_symbol ] = asyncId ; this [ trigger_async_id_symbol ] = triggerAsyncId ; if ( initHooksExist ()) { emitInit ( asyncId , type , triggerAsyncId , this ); } } runInAsyncScope ( fn , thisArg , ... args ) { const asyncId = this [ async_id_symbol ]; emitBefore ( asyncId , this [ trigger_async_id_symbol ]); const ret = thisArg === undefined ? fn (... args ) : ReflectApply ( fn , thisArg , args ); emitAfter ( asyncId ); return ret ; } emitDestroy () { if ( this [ destroyedSymbol ] !== undefined ) { this [ destroyedSymbol ]. destroyed = true ; } emitDestroy ( this [ async_id_symbol ]); return this ; } asyncId () { return this [ async_id_symbol ]; } triggerAsyncId () { return this [ trigger_async_id_symbol ]; } } \u4f7f\u7528\u65b9\u5f0f\u5982\u4e0b\u3002 const { AsyncResource , executionAsyncId , triggerAsyncId } = require ( ' async_hooks ' ); const asyncResource = new AsyncResource ( ' Demo ' ); asyncResource . runInAsyncScope (() => { console . log ( executionAsyncId (), triggerAsyncId ()) }); runInAsyncScope\u4e2d\u4f1a\u628aasyncResource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0casync id\u662f2\uff0ctrigger async id\u662f1\uff0c\u6240\u4ee5\u5728\u56de\u8c03\u91cc\u6267\u884cexecutionAsyncId\u8f93\u51fa\u7684\u662f2\uff0ctriggerAsyncId\u8f93\u51fa\u7684\u662f1\u3002","title":"7 AsyncResource"},{"location":"chapter23-Async%20hooks/#8-asynclocalstorage","text":"AsyncLocalStorage\u662f\u57fa\u4e8eAsyncResource\u5b9e\u73b0\u7684\u4e00\u4e2a\u7ef4\u62a4\u5f02\u6b65\u903b\u8f91\u4e2d\u516c\u5171\u4e0a\u4e0b\u6587\u7684\u7c7b\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u4ed6\u7406\u89e3\u4e3aRedis\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u600e\u4e48\u4f7f\u7528\u3002","title":"8 AsyncLocalStorage"},{"location":"chapter23-Async%20hooks/#81","text":"const { AsyncLocalStorage } = require ( ' async_hooks ' ); const asyncLocalStorage = new AsyncLocalStorage (); function logWithId ( msg ) { const id = asyncLocalStorage . getStore (); console . log ( ` $ { id !== undefined ? id : '-' } : ` , msg ); } asyncLocalStorage . run ( 1 , () => { logWithId ( ' start ' ); setImmediate (() => { logWithId ( ' finish ' ); }); }); \u6267\u884c\u4e0a\u9762\u4ee3\u7801\u4f1a\u8f93\u51fa 1 : start 1 : finish run\u7684\u65f6\u5019\u521d\u59cb\u5316\u516c\u5171\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u5728run\u91cc\u6267\u884c\u7684\u5f02\u6b65\u4ee3\u7801\u4e5f\u53ef\u4ee5\u62ff\u5f97\u5230\u8fd9\u4e2a\u516c\u5171\u4e0a\u4e0b\u6587\uff0c\u8fd9\u4e2a\u5728\u8bb0\u5f55\u65e5\u5fd7traceId\u65f6\u5c31\u4f1a\u5f88\u6709\u7528\uff0c\u5426\u5219\u6211\u4eec\u5c31\u9700\u8981\u628atraceId\u4f20\u904d\u4ee3\u7801\u6bcf\u4e2a\u9700\u8981\u7684\u5730\u65b9\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002","title":"8.1 \u4f7f\u7528"},{"location":"chapter23-Async%20hooks/#82","text":"\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521b\u5efaAsyncLocalStorage\u7684\u903b\u8f91 class AsyncLocalStorage { constructor () { this . kResourceStore = Symbol ( ' kResourceStore ' ); this . enabled = false ; } } \u521b\u5efaAsyncLocalStorage\u7684\u65f6\u5019\u5f88\u7b80\u5355\uff0c\u4e3b\u8981\u662f\u7f6e\u72b6\u6001\u4e3afalse\uff0c\u5e76\u4e14\u8bbe\u7f6ekResourceStore\u7684\u503c\u4e3aSymbol('kResourceStore')\u3002\u8bbe\u7f6e\u4e3aSymbol('kResourceStore')\u800c\u4e0d\u662f\u2018kResourceStore\u2018\u5f88\u91cd\u8981\uff0c\u6211\u4eec\u540e\u9762\u4f1a\u770b\u5230\u3002\u7ee7\u7eed\u770b\u4e00\u4e0b\u6267\u884cAsyncLocalStorage.run\u7684\u903b\u8f91\u3002 run ( store , callback , ... args ) { // \u65b0\u5efa\u4e00\u4e2aAsyncResource const resource = new AsyncResource ( ' AsyncLocalStorage ' , defaultAlsResourceOpts ); // \u901a\u8fc7runInAsyncScope\u628aresource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u5b8c\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587 return resource . emitDestroy (). runInAsyncScope (() => { this . enterWith ( store ); return ReflectApply ( callback , null , args ); }); } \u8bbe\u7f6e\u5b8c\u4e0a\u4e0b\u6587\u4e4b\u540e\u6267\u884crunInAsyncScope\u7684\u56de\u8c03\uff0c\u56de\u8c03\u91cc\u9996\u5148\u6267\u884c\u91ccenterWith\u3002 enterWith ( store ) { // \u4fee\u6539AsyncLocalStorage\u72b6\u6001 this . _enable (); // \u83b7\u5f97\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u4e8e\u591a\u8d44\u6e90\uff0c\u4e5f\u5c31\u662frun\u91cc\u521b\u5efa\u7684resource const resource = executionAsyncResource (); // \u628a\u516c\u5171\u4e0a\u4e0b\u6587\u6302\u8f7d\u5230\u5bf9\u8c61\u4e0a resource [ this . kResourceStore ] = store ; } _enable () { if ( ! this . enabled ) { this . enabled = true ; ArrayPrototypePush ( storageList , this ); storageHook . enable (); } } \u6302\u8f7d\u5b8c\u516c\u5171\u4e0a\u4e0b\u6587\u540e\uff0c\u5c31\u6267\u884c\u4e1a\u52a1\u56de\u8c03\u3002\u56de\u8c03\u91cc\u53ef\u4ee5\u901a\u8fc7asyncLocalStorage.getStore()\u83b7\u5f97\u8bbe\u7f6e\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002 getStore () { if ( this . enabled ) { const resource = executionAsyncResource (); return resource [ this . kResourceStore ]; } } getStore\u7684\u539f\u7406\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u9996\u5148\u62ff\u5230\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\uff0c\u7136\u540e\u6839\u636eAsyncLocalStorage\u7684kResourceStore\u7684\u503c\u4eceresource\u4e2d\u62ff\u5230\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u662f\u540c\u6b65\u6267\u884cgetStore\uff0c\u90a3\u4e48executionAsyncResource\u8fd4\u56de\u7684\u5c31\u662f\u6211\u4eec\u5728run\u7684\u65f6\u5019\u521b\u5efa\u7684AsyncResource\uff0c\u4f46\u662f\u5982\u679c\u662f\u5f02\u6b65getStore\u90a3\u4e48\u600e\u4e48\u529e\u5462\uff1f\u56e0\u4e3a\u8fd9\u65f6\u5019executionAsyncResource\u8fd4\u56de\u7684\u4e0d\u518d\u662f\u6211\u4eec\u521b\u5efa\u7684AsyncResource\uff0c\u4e5f\u5c31\u62ff\u4e0d\u5230\u4ed6\u6302\u8f7d\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cNode.js\u5bf9\u516c\u5171\u4e0a\u4e0b\u6587\u8fdb\u884c\u4e86\u4f20\u9012\u3002 const storageList = []; // AsyncLocalStorage\u5bf9\u8c61\u6570\u7ec4 const storageHook = createHook ({ init ( asyncId , type , triggerAsyncId , resource ) { const currentResource = executionAsyncResource (); for ( let i = 0 ; i < storageList . length ; ++ i ) { storageList [ i ]. _propagate ( resource , currentResource ); } } }); _propagate ( resource , triggerResource ) { const store = triggerResource [ this . kResourceStore ]; if ( this . enabled ) { resource [ this . kResourceStore ] = store ; } } \u6211\u4eec\u770b\u5230Node.js\u5185\u90e8\u521b\u5efa\u4e86\u4e00\u4e2aHooks\uff0c\u5728\u6bcf\u6b21\u8d44\u6e90\u521b\u5efa\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u628a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\u4e2d\u7684\u4e00\u4e2a\u6216\u591a\u4e2akey\uff08\u6839\u636estorageList\u91cc\u5bf9\u8c61\u7684this.kResourceStore\u5b57\u6bb5\uff09\u5bf9\u5e94\u7684\u503c\u6302\u8f7d\u5230\u65b0\u521b\u5efa\u7684\u8d44\u6e90\u4e2d\u3002\u6240\u4ee5\u5728asyncLocalStorage.getStore()\u65f6\u5373\u4f7f\u4e0d\u662f\u6211\u4eec\u5728\u6267\u884crun\u65f6\u521b\u5efa\u7684\u8d44\u6e90\u5bf9\u8c61\uff0c\u4e5f\u53ef\u4ee5\u83b7\u5f97\u5177\u4f53asyncLocalStorage\u5bf9\u8c61\u6240\u8bbe\u7f6e\u7684\u8d44\u6e90\uff0c\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002 const { AsyncLocalStorage } = require ( ' async_hooks ' ); const asyncLocalStorage = new AsyncLocalStorage (); const asyncLocalStorage2 = new AsyncLocalStorage (); function logWithId ( msg ) { console . log ( asyncLocalStorage2 . getStore ()); const id = asyncLocalStorage . getStore (); console . log ( ` $ { id !== undefined ? id : '-' } : ` , msg ); } asyncLocalStorage . run ( 0 , () => { asyncLocalStorage2 . enterWith ({ hello : \"world\" }); logWithId ( ' start ' ); setImmediate (() => { logWithId ( ' finish ' ); }); }); \u9664\u4e86\u901a\u8fc7asyncLocalStorage.run\u8bbe\u7f6e\u4e0a\u4e0b\u6587\uff0c\u6211\u4eec\u901a\u8fc7asyncLocalStorage2.enterWith\u4e5f\u7ed9\u5bf9\u8c61\u4e0a\u4e0b\u6587\u7684\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e2a\u65b0\u5c5e\u6027\uff0ckey\u662fSymbol('kResourceStore')\uff0c\u503c\u662f{hello: \"world\"}\uff0c\u7136\u540e\u5728logWithId\u4e2d\u8f93\u51faasyncLocalStorage2.getStore()\u3002\u4ece\u8f93\u51fa\u4e2d\u53ef\u4ee5\u770b\u5230\u6210\u529f\u4ece\u8d44\u6e90\u4e2d\u83b7\u5f97\u6302\u8f7d\u7684\u6240\u6709\u4e0a\u4e0b\u6587\u3002 { hello : ' world ' } 0 : start { hello : ' world ' } 0 : finish \u6211\u4eec\u4e5f\u53ef\u4ee5\u4fee\u6539\u6e90\u7801\u9a8c\u8bc1 Immediate { _idleNext : null , _idlePrev : null , _onImmediate : [ Function ( anonymous )], _argv : undefined , _destroyed : true , [ Symbol ( refed )] : null , [ Symbol ( asyncId )] : 6 , [ Symbol ( triggerId )] : 2 , [ Symbol ( kResourceStore )] : 0 , [ Symbol ( kResourceStore )] : { hello : ' world ' } } \u53ef\u4ee5\u770b\u5230\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u91cc\u4e24\u4e2akey\u4e3aSymbol(kResourceStore)\u7684\u5c5e\u6027\u3002","title":"8.2 \u5b9e\u73b0"},{"location":"chapter23-Async%20hooks/#9-async-hooks","text":"const async_hooks = require ( ' async_hooks ' ); const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); \u4ee5\u4e0a\u4ee3\u7801\u4e2d,\u8f93\u51fa1\u548c0\u3002\u5bf9\u5e94\u7684API\u5b9e\u73b0\u5982\u4e0b\u3002 // \u83b7\u53d6\u5f53\u524d\u7684async id function executionAsyncId () { return async_id_fields [ kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524d\u7684trigger async id\uff0c\u5373\u89e6\u53d1\u5f53\u524d\u4ee3\u7801\u7684async id function triggerAsyncId () { return async_id_fields [ kTriggerAsyncId ]; } \u90a3\u4e48async_id_fields\u7684\u521d\u59cb\u5316\u662f\u4ec0\u4e48\u5462\uff1f\u4eceenv.h\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230async_id_fields_\uff08async_id_fields\u662f\u4e0a\u5c42\u4f7f\u7528\u7684\u540d\u79f0\uff0c\u5bf9\u5e94\u5e95\u5c42\u7684async_id_fields_\uff09\u662fAliasedFloat64Array\u7c7b\u578b\u3002 AliasedFloat64Array async_id_fields_ ; AliasedFloat64Array\u662f\u4e2a\u7c7b\u578b\u522b\u540d\u3002 typedef AliasedBufferBase < double , v8 :: Float64Array > AliasedFloat64Array ; AliasedBufferBase\u7684\u6784\u9020\u51fd\u6570\u5982\u4e0b AliasedBufferBase ( v8 :: Isolate * isolate , const size_t count ) : isolate_ ( isolate ), count_ ( count ), byte_offset_ ( 0 ) { const v8 :: HandleScope handle_scope ( isolate_ ); const size_t size_in_bytes = MultiplyWithOverflowCheck ( sizeof ( NativeT ), count ); v8 :: Local < v8 :: ArrayBuffer > ab = v8 :: ArrayBuffer :: New ( isolate_ , size_in_bytes ); // ... } \u5e95\u5c42\u662f\u4e00\u4e2aArrayBuffer\u3002 Local < ArrayBuffer > v8 :: ArrayBuffer :: New ( Isolate * isolate , size_t byte_length ) { i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate *> ( isolate ); LOG_API ( i_isolate , ArrayBuffer , New ); ENTER_V8_NO_SCRIPT_NO_EXCEPTION ( i_isolate ); i :: MaybeHandle < i :: JSArrayBuffer > result = i_isolate -> factory () -> NewJSArrayBufferAndBackingStore ( byte_length , i :: InitializedFlag :: kZeroInitialized ); // ... } ArrayBuffer::New\u5728\u7533\u8bf7\u5185\u5b58\u65f6\u4f20\u5165\u4e86i::InitializedFlag::kZeroInitialized\u3002\u4eceV8\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230\u4f1a\u521d\u59cb\u5316\u5185\u5b58\u7684\u5185\u5bb9\u4e3a0\u3002 // Whether the backing store memory is initialied to zero or not. enum class InitializedFlag : uint8_t { kUninitialized , kZeroInitialized }; \u56de\u5230\u4f8b\u5b50\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u8f93\u51fa\u4f1a\u662f1\u548c0\u800c\u4e0d\u662f0\u548c0\u5462\uff1f\u7b54\u6848\u5728Node.js\u542f\u52a8\u65f6\u7684\u8fd9\u6bb5\u4ee3\u7801\u3002 { InternalCallbackScope callback_scope ( env . get (), Local < Object > (), // async id\u548ctrigger async id { 1 , 0 }, InternalCallbackScope :: kAllowEmptyResource | InternalCallbackScope :: kSkipAsyncHooks ); // \u6267\u884c\u6211\u4eec\u7684js LoadEnvironment ( env . get ()); } InternalCallbackScope\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4ed6\u4f1a\u628a1\u548c0\u8bbe\u7f6e\u4e3a\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u3002\u7136\u540e\u5728LoadEnvironment\u91cc\u6267\u884c\u6211\u7684JS\u4ee3\u7801\u65f6\u83b7\u53d6\u5230\u7684\u503c\u5c31\u662f1\u548c0\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u6539\u6210\u4ee5\u4e0b\u4ee3\u7801\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f const async_hooks = require ( ' async_hooks ' ); Promise . resolve (). then (() => { const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); }) \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u8f93\u51fa0\u548c\u3002\u56e0\u4e3a\u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0cInternalCallbackScope\u5c31\u88ab\u6790\u6784\u4e86\uff0c\u4ece\u800c\u6062\u590d\u4e3a0\u548c0\u3002","title":"9 \u521d\u59cb\u5316\u65f6\u7684Async hooks"},{"location":"chapter24-Inspector/","text":"\u524d\u8a00\uff1aNode.js\u63d0\u4f9b\u7684Inspector\u4e0d\u4ec5\u53ef\u4ee5\u7528\u6765\u8c03\u8bd5Node.js\u4ee3\u7801\uff0c\u8fd8\u53ef\u4ee5\u5b9e\u65f6\u6536\u96c6Node.js\u8fdb\u7a0b\u7684\u5185\u5b58\uff0cCPU\u7b49\u6570\u636e\uff0c\u540c\u65f6\u652f\u6301\u9759\u6001\u3001\u52a8\u6001\u5f00\u542f\uff0c\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u672c\u6587\u4ece\u4f7f\u7528\u548c\u539f\u7406\u8be6\u7ec6\u8bb2\u89e3Inspector Node.js\u7684\u6587\u6863\u4e2d\u5bf9inspector\u7684\u63cf\u8ff0\u5f88\u5c11\uff0c\u4f46\u662f\u5982\u679c\u6df1\u5165\u63a2\u7d22\uff0c\u5176\u5b9e\u91cc\u9762\u7684\u5185\u5bb9\u8fd8\u662f\u633a\u591a\u7684\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bInspector\u7684\u4f7f\u7528\u3002 1 Inspector\u7684\u4f7f\u7528 \u00b6 1.1 \u672c\u5730\u8c03\u8bd5 \u00b6 \u6211\u4eec\u5148\u4ece\u4e00\u4e2a\u4f8b\u5b50\u5f00\u59cb\u3002\u4e0b\u9762\u662f\u4e00\u4e2ahttp\u670d\u52a1\u5668\u3002 const http = require ( ' http ' ); http . createServer (( req , res ) => { res . end ( ' ok ' ); }). listen ( 80 ); \u7136\u540e\u6211\u4eec\u4ee5node --inspect httpServer.js\u7684\u65b9\u5f0f\u542f\u52a8\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u8f93\u51fa\u3002 Debugger listening on ws : //127.0.0.1:9229/fbbd9d8f-e088-48cc-b1e0-e16bfe58db44 For help , see : https : //nodejs.org/en/docs/inspector 9229\u7aef\u53e3\u662fNode.js\u9ed8\u8ba4\u9009\u62e9\u7684\u7aef\u53e3\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5b9a\u4e49\uff0c\u5177\u4f53\u53ef\u53c2\u8003\u6587\u6863\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53bb\u6d4f\u89c8\u5668\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u83dc\u5355\u680f\u591a\u4e86\u4e00\u4e2a\u8c03\u8bd5Node.js\u7684\u6309\u94ae\u3002 \u70b9\u51fb\u8fd9\u4e2a\u6309\u94ae\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u754c\u9762\u3002 \u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u67d0\u4e00\u884c\u4ee3\u7801\u6253\u65ad\u70b9\uff0c\u6bd4\u5982\u6211\u5728\u7b2c\u4e09\u884c\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8bbf\u95ee80\u7aef\u53e3\uff0c\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u505c\u7559\u5728\u65ad\u70b9\u5904\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e9b\u6267\u884c\u4e0a\u4e0b\u6587\u3002 1.2 \u8fdc\u7a0b\u8c03\u8bd5 \u00b6 \u4f46\u5f88\u591a\u65f6\u5019\u6211\u4eec\u53ef\u80fd\u9700\u8981\u8fdc\u7a0b\u8c03\u8bd5\u3002\u6bd4\u5982\u6211\u5728\u4e00\u53f0\u4e91\u670d\u52a1\u5668\u4e0a\u90e8\u7f72\u4ee5\u4e0a\u670d\u52a1\u5668\u4ee3\u7801\u3002\u7136\u540e\u6267\u884c node -- inspect = 0.0.0.0 : 8888 httpServer . js \u4e0d\u8fc7\u8fd9\u65f6\u5019\u6211\u4eec\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u53d1\u73b0\u6309\u94ae\u7f6e\u7070\u6216\u8005\u627e\u4e0d\u5230\u6211\u4eec\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u4fe1\u606f\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u7528\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002\u901a\u8fc7\u5728\u6d4f\u89c8\u5668url\u8f93\u5165\u6846\u8f93\u5165devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws={host}:{port}/{path}\u7684\u65b9\u5f0f\uff08\u66ff\u6362{}\u91cc\u9762\u7684\u5185\u5bb9\u4e3a\u4f60\u6267\u884cNode.js\u65f6\u8f93\u51fa\u7684\u4fe1\u606f\uff09\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53bb\u8fde\u63a5\u4f60\u8f93\u5165\u7684\u5730\u5740\uff0c\u6bd4\u59821.1.1.1:9229/abc\u3002\u8fd9\u79cd\u6bd4\u8f83\u9002\u5408\u4e8e\u5bf9\u4e8e\u901a\u7528\u7684\u573a\u666f\u3002 1.3 \u81ea\u52a8\u63a2\u6d4b \u00b6 \u5982\u679c\u662f\u6211\u4eec\u81ea\u5df1\u8c03\u8bd5\u7684\u8bdd\uff0c\u8fd9\u79cd\u65b9\u5f0f\u770b\u8d77\u6765\u5c31\u6709\u70b9\u9ebb\u70e6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6d4f\u89c8\u5668\u63d0\u4f9b\u7684\u81ea\u52a8\u63a2\u6d4b\u529f\u80fd\u3002 1 url\u8f93\u5165\u6846\u8f93\u5165chrome://inspect/#devices\u6211\u4eec\u4f1a\u770b\u5230\u4ee5\u4e0b\u754c\u9762 2 \u70b9\u51fbconfigure\u6309\u94ae\uff0c\u5728\u5f39\u51fa\u7684\u5f39\u6846\u91cc\u8f93\u5165\u4f60\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u5730\u5740 3 \u914d\u7f6e\u5b8c\u6bd5\u540e\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u754c\u9762\u53d8\u6210\u8fd9\u6837\u4e86\uff0c\u6216\u8005\u6253\u5f00\u65b0\u7684tab\uff0c\u6211\u4eec\u770b\u5230\u5f00\u53d1\u8005\u5de5\u5177\u7684\u8c03\u8bd5\u6309\u94ae\u4e5f\u53d8\u4eae\u4e86\u3002 4 \u8fd9\u65f6\u5019\u6211\u4eec\u70b9\u51fbinspect\u6309\u94ae\u3001Open dedicated DevTools for Node\u6309\u94ae\u6216\u8005\u6253\u5f00\u65b0tab\u7684\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u5c31\u53ef\u4ee5\u5f00\u59cb\u8c03\u8bd5\u3002\u800c\u4e14\u8fd8\u53ef\u4ee5\u8c03\u8bd5Node.js\u7684\u539f\u751fjs\u6a21\u5757\u3002 2 Inspector\u8c03\u8bd5\u7684\u539f\u7406 \u00b6 \u4e0b\u9762\u4ee5\u901a\u8fc7url\u7684\u65b9\u5f0f\u8c03\u8bd5\uff08\u53ef\u4ee5\u770b\u5230network\uff09\uff0c\u6765\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u90fd\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u6d4f\u89c8\u5668\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\u540e\uff0c\u662f\u901a\u8fc7websocket\u534f\u8bae\u901a\u4fe1\u7684\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u547d\u4ee4\u662f\u4ec0\u4e48\u610f\u601d\uff0c\u9996\u5148\u770bDebugger.scriptParsed\u3002 Debugger.scriptParsed # Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. \u4ece\u8bf4\u660e\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u5f53V8\u89e3\u6790\u811a\u672c\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u8fd9\u4e2a\u4e8b\u4ef6\uff0c\u90a3\u5c31\u4f1a\u544a\u8bc9\u6d4f\u89c8\u5668\u8fd9\u4e2a\u4fe1\u606f\u3002 \u6211\u4eec\u53d1\u73b0\u8fd4\u56de\u7684\u90fd\u662f\u4e00\u4e9b\u5143\u6570\u636e\uff0c\u6ca1\u6709\u811a\u672c\u7684\u5177\u4f53\u4ee3\u7801\u5185\u5bb9\uff0c\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4f1a\u518d\u6b21\u53d1\u8d77\u8bf7\u6c42\uff0c \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u811a\u672c\u7684scriptId\u662f103\u3002\u6240\u4ee5\u8bf7\u6c42\u91cc\u5e26\u4e86\u8fd9\u4e2ascriptId\u3002\u5bf9\u5e94\u7684\u8bf7\u6c42id\u662f11\u3002\u63a5\u7740\u770b\u4e00\u4e0b\u54cd\u5e94\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u4e86\u89e3\u4e86\u83b7\u53d6\u811a\u672c\u5185\u5bb9\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u6211\u4eec\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u662f\u600e\u6837\u7684\u8fc7\u7a0b\u3002\u5f53\u6211\u4eec\u5728\u6d4f\u89c8\u5668\u4e0a\u70b9\u51fb\u67d0\u4e00\u884c\u8bbe\u7f6e\u65ad\u70b9\u7684\u65f6\u5019\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u3002 \u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u4e49\u987e\u540d\u601d\u4e49\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9a\u4e49\u3002 Debugger.setBreakpointByUrl # Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in locations property. Further matching script parsing will result in subsequent breakpointResolved events issued. This logical breakpoint will survive page reloads. \u63a5\u7740\u670d\u52a1\u8fd4\u56de\u54cd\u5e94\u3002 \u8fd9\u65f6\u5019\u6211\u4eec\u4ece\u53e6\u5916\u4e00\u4e2atab\u8bbf\u95ee80\u7aef\u53e3\u3002\u670d\u52a1\u5668\u5c31\u4f1a\u5728\u6211\u4eec\u8bbe\u7f6e\u7684\u65ad\u70b9\u5904\u505c\u7559\uff0c\u5e76\u4e14\u901a\u77e5\u6d4f\u89c8\u5668\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u601d\u3002 \u8fd9\u4e2a\u547d\u4ee4\u5c31\u662f\u5f53\u670d\u52a1\u5668\u6267\u884c\u5230\u65ad\u70b9\u65f6\u901a\u77e5\u6d4f\u89c8\u5668\uff0c\u5e76\u4e14\u8fd4\u56de\u6267\u884c\u7684\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u662f\u54ea\u4e2a\u6267\u884c\u5230\u54ea\u4e2a\u65ad\u70b9\u505c\u7559\u4e86\u3002\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4fa7\u4e5f\u4f1a\u505c\u7559\u5728\u5bf9\u5e94\u7684\u5730\u65b9\uff0c\u5f53\u6211\u4eechover\u67d0\u4e2a\u53d8\u91cf\u65f6\uff0c\u5c31\u4f1a\u770b\u5230\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\u3002\u8fd9\u4e9b\u90fd\u662f\u901a\u8fc7\u5177\u4f53\u7684\u547d\u4ee4\u83b7\u53d6\u7684\u6570\u636e\u3002\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u4e86\uff0c\u53ef\u4ee5\u53c2\u8003\u5177\u4f53\u6587\u6863\u3002 3 Inspector\u7684\u5b9e\u73b0 \u00b6 \u5927\u81f4\u4e86\u89e3\u4e86\u6d4f\u89c8\u5668\u548c\u670d\u52a1\u5668\u7684\u4ea4\u4e92\u8fc7\u7a0b\u548c\u534f\u8bae\u540e\uff0c\u6211\u4eec\u518d\u6765\u6df1\u5165\u4e86\u89e3\u4e00\u4e0b\u5173\u4e8einspector\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002\u5f53\u7136\u8fd9\u91cc\u4e0d\u662f\u5206\u6790V8\u4e2dInspector\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u5206\u6790\u5982\u4f55\u4f7f\u7528V8\u7684Inspector\u4ee5\u53caNode.js\u4e2d\u5173\u4e8eInspector\u7684\u5b9e\u73b0\u90e8\u5206\u3002 3.1 \u5f00\u6e90\u5b9e\u73b0 \u00b6 \u56e0\u4e3aNode.js\u7684\u5b9e\u73b0\u6bd4\u8f83\u590d\u6742\uff0c\u8fd9\u91cc\u5148\u4ee5\u4e00\u4e2a\u7b80\u5355\u7248\u7684\u8c03\u8bd5\u5de5\u5177\u6e90\u7801\u6765\u5206\u6790inspector\u7684\u539f\u7406\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u4ee3\u7801\u3002 inspector = std :: unique_ptr < Inspector > ( new Inspector ( v8Platform , context , port )); inspector -> startAgent (); \u9996\u5148\u65b0\u5efa\u4e00\u4e2aInspector\u3002\u7136\u540e\u542f\u52a8\u5b83\u3002\u63a5\u4e0b\u6765\u770b\u770bInspector\u91cc\u7684\u903b\u8f91\u3002 Inspector :: Inspector ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const int webSocketPort ) { context_ = context ; // \u65b0\u5efa\u4e00\u4e2awebsocket server\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1 websocket_server_ = std :: unique_ptr < WebSocketServer > ( new WebSocketServer ( webSocketPort , // \u6536\u5230\u5ba2\u6237\u7684\u7684\u6d88\u606f\u540e\u6267\u884conMessage\u56de\u8c03 std :: bind ( & Inspector :: onMessage , this , std :: placeholders :: _1 ) ) ); // \u65b0\u5efa\u4e00\u4e2ainspector client\u548cV8\u901a\u4fe1 inspector_client_ = std :: unique_ptr < V8InspectorClientImpl > ( new V8InspectorClientImpl ( platform , context_ , // \u6536\u5230V8\u7684\u6d88\u606f\u540e\u8c03\u7528sendMessage\u56de\u590d\u7ed9\u5ba2\u6237\u7684 std :: bind ( & Inspector :: sendMessage , this , std :: placeholders :: _1 ), std :: bind ( & Inspector :: waitForFrontendMessage , this ) ) ); } \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u590d\u6742\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u6df1\u7a76\u3002\u4e3b\u8981\u662f\u4e24\u4e2a\u90e8\u5206\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2awebsocket\u670d\u52a1\u5668\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2ainspector\u5ba2\u6237\u7aef\uff08\u7528\u4e8e\u548cV8 Inspector\u901a\u4fe1\uff09\uff0c\u6574\u4f53\u67b6\u6784\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u5206\u522b\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002\u9996\u5148\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u7684\u6784\u9020\u51fd\u6570\u3002 WebSocketServer :: WebSocketServer ( int port , std :: function < void ( std :: string ) > onMessage ) { port_ = port ; onMessage_ = std :: move ( onMessage ); } WebSocketServer\u6784\u9020\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\u3002\u63a5\u7740\u770binspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002 V8InspectorClientImpl :: V8InspectorClientImpl ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const std :: function < void ( std :: string ) > & onResponse , const std :: function < int ( void ) > & onWaitFrontendMessageOnPause ) { platform_ = platform . get (); context_ = context ; onWaitFrontendMessageOnPause_ = onWaitFrontendMessageOnPause ; isolate_ = context_ -> GetIsolate (); // \u521b\u5efa\u4e00\u4e2achannel\u548cinspector\u901a\u4fe1\uff0c\u6536\u5230V8\u6d88\u606f\u65f6\u4f1a\u6267\u884conResponse channel_ . reset ( new V8InspectorChannelImp ( isolate_ , onResponse )); // \u65b0\u5efa\u4e00\u4e2aV8\u63d0\u4f9b\u7684inspector inspector_ = v8_inspector :: V8Inspector :: create ( isolate_ , this ); // \u521b\u5efa\u4e00\u4e2a\u548cinspector\u901a\u4fe1\u7684session\u3002 session_ = inspector_ -> connect ( kContextGroupId , channel_ . get (), v8_inspector :: StringView ()); context_ -> SetAlignedPointerInEmbedderData ( 1 , this ); v8_inspector :: StringView contextName = convertToStringView ( \"inspector\" ); inspector_ -> contextCreated ( v8_inspector :: V8ContextInfo ( context , kContextGroupId , contextName )); terminated_ = true ; run_nested_loop_ = false ; } \u4e0a\u9762\u4ee3\u7801\u5f88\u591a\uff0c\u4e3b\u8981\u662f\u6839\u636eV8\u63d0\u4f9b\u7684API\u6765\u5c31\u884c\u3002\u8fd9\u91cc\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 V8Inspector\u662fV8\u63d0\u4f9b\u7684\u7c7b\u3002 2 session\u8868\u793a\u548cV8 inspector\u901a\u4fe1\u7684\u4f1a\u8bdd\u3002 3 channel\u7528\u4e8e\u548cV8 inspector\u901a\u4fe1\uff0c\u4eceAPI\u6765\u770b\uff0cchannel\u53ea\u80fd\u4eceV8\u83b7\u53d6\u6570\u636e\uff0c\u5199\u5165\u6570\u636e\u662f\u53e6\u5916\u7684API\u3002 \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u5982\u4e0b \u81f3\u6b64\uff0cwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u5c31\u5206\u6790\u5b8c\u6bd5\u4e86\uff0c\u56de\u5230\u6700\u5f00\u59cb\u7684\u4ee3\u7801\uff0c\u521d\u59cb\u5316\u5b8c\u6bd5\u540e\u4f1a\u6267\u884cstartAgent\u3002 void Inspector::startAgent () { websocket_server_ -> run (); } // \u542f\u52a8websocket\u670d\u52a1\u5668 void WebSocketServer::run () { auto const address = net :: ip :: make_address ( \"127.0.0.1\" ); net :: io_context ioc { 1 }; tcp :: acceptor acceptor { ioc , { address , static_cast < unsigned short > ( port_ )}}; tcp :: socket socket { ioc }; acceptor . accept ( socket ); ws_ = std :: unique_ptr < websocket :: stream < tcp :: socket >> ( new websocket :: stream < tcp :: socket > ( std :: move ( socket ))); startListening (); } // \u7b49\u5f85\u8fde\u63a5 void WebSocketServer::startListening () { ws_ -> accept (); while ( true ) { waitFrontendMessage (); } } // \u8bfb\u53d6\u8fde\u63a5\u4e2d\u7684\u6d88\u606f void WebSocketServer::waitFrontendMessage () { beast :: flat_buffer buffer ; ws_ -> read ( buffer ); std :: string message = boost :: beast :: buffers_to_string ( buffer . data ()); onMessage_ ( std :: move ( message )); } startAgent\u7684\u903b\u8f91\u5c31\u662f\u542f\u52a8websocket\u670d\u52a1\u5668\u3002\u542f\u52a8\u5b8c\u6bd5\u540e\u5c31\u7b49\u5f85\u5ba2\u6237\u7684\u8fde\u63a5\u3002\u8fde\u63a5\u6210\u529f\u540e\u6267\u884conMessage_\u3002\u6211\u4eec\u770b\u4e00\u4e0bonMessage\u7684\u5b9e\u73b0\u3002 void Inspector::onMessage ( const std :: string & message ) { std :: cout << \"CDT message: \" << message << std :: endl ; // StringView\u662fV8\u8981\u6c42\u7684\u683c\u5f0f v8_inspector :: StringView protocolMessage = convertToStringView ( message ); // \u901a\u77e5V8 Inspector inspector_client_ -> dispatchProtocolMessage ( protocolMessage ); } onMessage\u901a\u8fc7Inspector\u5ba2\u6237\u7aef\u628a\u6d88\u606f\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u901a\u8fc7channel\u901a\u77e5Inspector\u5ba2\u6237\u7aef\uff0c\u5bf9\u5e94\u7684\u51fd\u6570\u662fsendResponse\u3002V8InspectorChannelImp\u662f\u7ee7\u627fV8\u63d0\u4f9b\u7684Channel\uff0csendResponse\u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff0c\u7531V8InspectorChannelImp\u5b9e\u73b0\u3002 void V8InspectorChannelImp::sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) { const std :: string response = convertToString ( isolate_ , message -> string ()); onResponse_ ( response ); } onResponse_\u662f\u5728Chnnel\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\uff0c\u5bf9\u5e94\u51fd\u6570\u662finspector\u5ba2\u6237\u7aef\u7684sendMessage\u3002 void Inspector::sendMessage ( const std :: string & message ) { websocket_server_ -> sendMessage ( message ); } sendMessage\u901a\u8fc7websocket\u670d\u52a1\u5668\u628aV8 Inspector\u8fd4\u56de\u7684\u6d88\u606f\u8fd4\u56de\u7ed9\u5ba2\u6237\u7684\u3002\u81f3\u6b64\uff0c\u6574\u4e2a\u901a\u4fe1\u6d41\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002 3.2 Node.js\u7684\u5b9e\u73b0(v14) \u00b6 Node.js\u7684\u5b9e\u73b0\u975e\u5e38\u590d\u6742\u5e76\u4e14\u5f88\u7ed5\uff0c\u4e5f\u65e0\u6cd5\u901a\u4fd7\u6613\u61c2\u5730\u4ecb\u7ecd\u548c\u5206\u6790\uff0c\u53ea\u80fd\u6309\u7167\u6211\u81ea\u5df1\u7684\u601d\u8def\u5927\u81f4\u8bb2\u89e3\u4e00\u4e0b\u6d41\u7a0b\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u6e90\u7801\u3002\u5f53\u6211\u4eec\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u6267\u884c\u6211\u4eec\u7684\u5e94\u7528\u65f6 node -- inspect app . js 3.2.1 \u521d\u59cb\u5316 \u00b6 Node.js\u5728\u542f\u52a8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u4f1a\u521d\u59cb\u5316Inspector\u76f8\u5173\u7684\u903b\u8f91\u3002 inspector_agent_ = std :: make_unique < inspector :: Agent > ( this ); Agent\u662f\u8d1f\u8d23\u548cV8 Inspector\u901a\u4fe1\u7684\u5bf9\u8c61\u3002\u521b\u5efa\u5b8c\u540e\u63a5\u7740\u6267\u884cenv->InitializeInspector({})\u542f\u52a8Agent\u3002 inspector_agent_ -> Start (...); Start\u7ee7\u7eed\u6267\u884cAgent::StartIoThread\u3002 bool Agent::StartIoThread () { io_ = InspectorIo :: Start ( client_ -> getThreadHandle (), ...); return true ; } StartIoThread\u4e2d\u7684client_->getThreadHandle()\u662f\u91cd\u8981\u7684\u903b\u8f91\uff0c\u6211\u4eec\u5148\u6765\u5206\u6790\u8be5\u51fd\u6570\u3002 std :: shared_ptr < MainThreadHandle > getThreadHandle () { if ( ! interface_ ) { interface_ = std :: make_shared < MainThreadInterface > ( env_ -> inspector_agent (), ...); } return interface_ -> GetHandle (); } getThreadHandle\u9996\u5148\u521b\u5efa\u6765\u4e00\u4e2aMainThreadInterface\u5bf9\u8c61\uff0c\u63a5\u7740\u53c8\u8c03\u7528\u4e86\u4ed6\u7684GetHandle\u65b9\u6cd5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u65b9\u6cd5\u7684\u903b\u8f91\u3002 std :: shared_ptr < MainThreadHandle > MainThreadInterface :: GetHandle () { if ( handle_ == nullptr ) handle_ = std :: make_shared < MainThreadHandle > ( this ); return handle_ ; } GetHandlei\u4e86\u521b\u5efa\u4e86\u4e00\u4e2aMainThreadHandle\u5bf9\u8c61\uff0c\u6700\u7ec8\u7ed3\u6784\u5982\u4e0b\u6240\u793a\u3002 \u5206\u6790\u5b8c\u540e\u6211\u4eec\u7ee7\u7eed\u770bAgent::StartIoThread\u4e2dInspectorIo::Start\u7684\u903b\u8f91\u3002 std :: unique_ptr < InspectorIo > InspectorIo :: Start ( std :: shared_ptr < MainThreadHandle > main_thread , ...) { auto io = std :: unique_ptr < InspectorIo > ( new InspectorIo ( main_thread , ...)); return io ; } InspectorIo::Star\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2aInspectorIo\u5bf9\u8c61\uff0c\u6211\u4eec\u770b\u770bInspectorIo\u6784\u9020\u51fd\u6570\u7684\u903b\u8f91\u3002 InspectorIo :: InspectorIo ( std :: shared_ptr < MainThreadHandle > main_thread , ...) : // \u521d\u59cb\u5316main_thread_ main_thread_ ( main_thread )) { // \u65b0\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cInspectorIo::ThreadMain uv_thread_create ( & thread_ , InspectorIo :: ThreadMain , this ); } \u8fd9\u65f6\u5019\u7ed3\u6784\u5982\u4e0b\u3002 Inspector\u5728\u5b50\u7ebf\u7a0b\u91cc\u542f\u52a8\u7684\u539f\u56e0\u4e3b\u8981\u6709\u4e24\u4e2a\u3002 1 \u5982\u679c\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8fd0\u884c\uff0c\u90a3\u4e48\u5f53\u6211\u4eec\u65ad\u70b9\u8c03\u8bd5\u7684\u65f6\u5019\uff0cNode.js\u4e3b\u7ebf\u7a0b\u5c31\u4f1a\u88ab\u505c\u4f4f\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5904\u7406\u5ba2\u6237\u7aef\u53d1\u8fc7\u6765\u7684\u8c03\u8bd5\u6307\u4ee4\u3002 2 \u5982\u679c\u4e3b\u7ebf\u7a0b\u9677\u5165\u6b7b\u5faa\u73af\uff0c\u6211\u4eec\u5c31\u65e0\u6cd5\u5b9e\u65f6\u6293\u53d6\u8fdb\u7a0b\u7684profile\u6570\u636e\u6765\u5206\u6790\u539f\u56e0\u3002 \u63a5\u7740\u7ee7\u7eed\u770b\u4e00\u4e0b\u5b50\u7ebf\u7a0b\u91cc\u6267\u884cInspectorIo::ThreadMain\u7684\u903b\u8f91\u3002 void InspectorIo::ThreadMain ( void * io ) { static_cast < InspectorIo *> ( io ) -> ThreadMain (); } void InspectorIo::ThreadMain () { uv_loop_t loop ; loop . data = nullptr ; // \u5728\u5b50\u7ebf\u7a0b\u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af int err = uv_loop_init ( & loop ); std :: shared_ptr < RequestQueueData > queue ( new RequestQueueData ( & loop ), ...); // \u65b0\u5efa\u4e00\u4e2adelegate\uff0c\u7528\u4e8e\u5904\u7406\u8bf7\u6c42 std :: unique_ptr < InspectorIoDelegate > delegate ( new InspectorIoDelegate ( queue , main_thread_ , ...) ); InspectorSocketServer server ( std :: move ( delegate ), ...); server . Start () uv_run ( & loop , UV_RUN_DEFAULT ); } ThreadMain\u91cc\u4e3b\u8981\u4e09\u4e2a\u903b\u8f91 1 \u521b\u5efa\u4e00\u4e2adelegate\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u6838\u5fc3\u7684\u5bf9\u8c61\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u6709\u4ec0\u4e48\u4f5c\u7528\u3002 2 \u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\u5e76\u542f\u52a8\u3002 3 \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u7684\u903b\u8f91\uff0c\u9996\u5148\u770b\u4e00\u4e0b\u521b\u5efa\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 InspectorSocketServer :: InspectorSocketServer ( std :: unique_ptr < SocketServerDelegate > delegate , ...) : // \u4fdd\u5b58delegate delegate_ ( std :: move ( delegate )), // \u521d\u59cb\u5316sessionId next_session_id_ ( 0 ) { // \u8bbe\u7f6edelegate\u7684server\u4e3a\u5f53\u524d\u670d\u52a1\u5668 delegate_ -> AssignServer ( this ); } \u6267\u884c\u5b8c\u540e\u5f62\u6210\u4ee5\u4e0b\u7ed3\u6784\u3002 \u63a5\u7740\u6211\u4eec\u770b\u542f\u52a8\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 bool InspectorSocketServer::Start () { // DNS\u89e3\u6790,\u6bd4\u5982\u8f93\u5165\u7684\u662flocalhost struct addrinfo hints ; memset ( & hints , 0 , sizeof ( hints )); hints . ai_flags = AI_NUMERICSERV ; hints . ai_socktype = SOCK_STREAM ; uv_getaddrinfo_t req ; const std :: string port_string = std :: to_string ( port_ ); uv_getaddrinfo ( loop_ , & req , nullptr , host_ . c_str (), port_string . c_str (), & hints ); // \u76d1\u542c\u89e3\u6790\u5230\u7684ip\u5217\u8868 for ( addrinfo * address = req . addrinfo ; address != nullptr ; address = address -> ai_next ) { auto server_socket = ServerSocketPtr ( new ServerSocket ( this )); err = server_socket -> Listen ( address -> ai_addr , loop_ ); if ( err == 0 ) server_sockets_ . push_back ( std :: move ( server_socket )); } return true ; } \u9996\u5148\u6839\u636e\u53c2\u6570\u505a\u4e00\u4e2aDNS\u89e3\u6790\uff0c\u7136\u540e\u6839\u636e\u62ff\u5230\u7684ip\u5217\u8868\uff08\u901a\u5e38\u662f\u4e00\u4e2a\uff09\uff0c\u521b\u5efa\u5bf9\u5e94\u4e2a\u6570\u7684ServerSocket\u5bf9\u8c61\uff0c\u5e76\u6267\u884c\u4ed6\u7684Listen\u65b9\u6cd5\u3002ServerSocket\u8868\u793a\u4e00\u4e2a\u76d1\u542csocket\u3002\u770b\u4e00\u4e0bServerSocket\u7684\u6784\u9020\u51fd\u6570\u3002 ServerSocket ( InspectorSocketServer * server ) : tcp_socket_ ( uv_tcp_t ()), server_ ( server ) {} \u6267\u884c\u5b8c\u540e\u7ed3\u6784\u5982\u4e0b\u3002 \u63a5\u7740\u770b\u4e00\u4e0bServerSocket\u7684Listen\u65b9\u6cd5\u3002 int ServerSocket::Listen ( sockaddr * addr , uv_loop_t * loop ) { uv_tcp_t * server = & tcp_socket_ ; uv_tcp_init ( loop , server ) uv_tcp_bind ( server , addr , 0 ); uv_listen ( reinterpret_cast < uv_stream_t *> ( server ), 511 , ServerSocket :: SocketConnectedCallback ); } Listen\u8c03\u7528Libuv\u7684\u63a5\u53e3\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\u3002\u81f3\u6b64\uff0cInspector\u63d0\u4f9b\u7684Weboscket\u670d\u52a1\u5668\u542f\u52a8\u4e86\u3002 3.2.2 \u5904\u7406\u8fde\u63a5 \u00b6 \u4ece\u521a\u624d\u5206\u6790\u4e2d\u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u56de\u8c03ServerSocket::SocketConnectedCallback\u3002 void ServerSocket::SocketConnectedCallback ( uv_stream_t * tcp_socket , int status ) { if ( status == 0 ) { // \u6839\u636eLibuv handle\u627e\u5230\u5bf9\u5e94\u7684ServerSocket\u5bf9\u8c61 ServerSocket * server_socket = ServerSocket :: FromTcpSocket ( tcp_socket ); // Socket\u5bf9\u8c61\u7684server_\u5b57\u6bb5\u4fdd\u5b58\u4e86\u6240\u5728\u7684InspectorSocketServer server_socket -> server_ -> Accept ( server_socket -> port_ , tcp_socket ); } } \u63a5\u7740\u770bInspectorSocketServer\u7684Accept\u662f\u5982\u4f55\u5904\u7406\u8fde\u63a5\u7684\u3002 void InspectorSocketServer::Accept ( int server_port , uv_stream_t * server_socket ) { std :: unique_ptr < SocketSession > session ( new SocketSession ( this , next_session_id_ ++ , server_port ) ); InspectorSocket :: DelegatePointer delegate = InspectorSocket :: DelegatePointer ( new SocketSession :: Delegate ( this , session -> id ()) ); InspectorSocket :: Pointer inspector = InspectorSocket :: Accept ( server_socket , std :: move ( delegate )); if ( inspector ) { session -> Own ( std :: move ( inspector )); connected_sessions_ [ session -> id ()]. second = std :: move ( session ); } } Accept\u7684\u9996\u5148\u521b\u5efa\u91cc\u4e00\u4e2aSocketSession\u548cSocketSession::Delegate\u5bf9\u8c61\u3002\u7136\u540e\u8c03\u7528InspectorSocket::Accept\uff0c\u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230InspectorSocket::Accept\u4f1a\u8fd4\u56de\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002InspectorSocket\u662f\u5bf9\u901a\u4fe1socket\u7684\u5c01\u88c5\uff08\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684socket\uff0c\u533a\u522b\u4e8e\u670d\u52a1\u5668\u7684\u76d1\u542csocket\uff09\u3002\u7136\u540e\u8bb0\u5f55session\u5bf9\u8c61\u5bf9\u5e94\u7684InspectorSocket\u5bf9\u8c61\uff0c\u540c\u65f6\u8bb0\u5f55sessionId\u548csession\u7684\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u63a5\u7740\u770b\u4e00\u4e0bInspectorSocket::Accept\u8fd4\u56deInspectorSocket\u7684\u903b\u8f91\u3002 InspectorSocket :: Pointer InspectorSocket::Accept ( uv_stream_t * server , DelegatePointer delegate ) { auto tcp = TcpHolder :: Accept ( server , std :: move ( delegate )); InspectorSocket * inspector = new InspectorSocket (); inspector -> SwitchProtocol ( new HttpHandler ( inspector , std :: move ( tcp ))); return InspectorSocket :: Pointer ( inspector ); } InspectorSocket::Accept\u7684\u4ee3\u7801\u4e0d\u591a\uff0c\u4f46\u662f\u903b\u8f91\u8fd8\u662f\u633a\u591a\u7684\u3002 1 InspectorSocket::Accept\u518d\u6b21\u8c03\u7528TcpHolder::Accept\u83b7\u5f97\u4e00\u4e2aTcpHolder\u5bf9\u8c61\u3002 TcpHolder :: Pointer TcpHolder::Accept ( uv_stream_t * server , InspectorSocket :: DelegatePointer delegate ) { // \u65b0\u5efa\u4e00\u4e2aTcpHolder\u5bf9\u8c61\uff0cTcpHolder\u662f\u5bf9uv_tcp_t\u548cdelegate\u7684\u5c01\u88c5 TcpHolder * result = new TcpHolder ( std :: move ( delegate )); // \u62ff\u5230TcpHolder\u5bf9\u8c61\u7684uv_tcp_t\u7ed3\u6784\u4f53 uv_stream_t * tcp = reinterpret_cast < uv_stream_t *> ( & result -> tcp_ ); // \u521d\u59cb\u5316 int err = uv_tcp_init ( server -> loop , & result -> tcp_ ); // \u6458\u53d6\u4e00\u4e2aTCP\u8fde\u63a5\u5bf9\u5e94\u7684fd\u4fdd\u5b58\u5230TcpHolder\u7684uv_tcp_t\u7ed3\u6784\u4f53\u4e2d\uff08\u5373\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684tcp\u5b57\u6bb5\uff09 uv_accept ( server , tcp ); // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u65f6\u6267\u884cOnDataReceivedCb\u56de\u8c03 uv_read_start ( tcp , allocate_buffer , OnDataReceivedCb ); return TcpHolder :: Pointer ( result ); } 2 \u65b0\u5efa\u4e00\u4e2aHttpHandler\u5bf9\u8c61\u3002 explicit HttpHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : ProtocolHandler ( inspector , std :: move ( tcp )){ llhttp_init ( & parser_ , HTTP_REQUEST , & parser_settings ); llhttp_settings_init ( & parser_settings ); parser_settings . on_header_field = OnHeaderField ; parser_settings . on_header_value = OnHeaderValue ; parser_settings . on_message_complete = OnMessageComplete ; parser_settings . on_url = OnPath ; } ProtocolHandler :: ProtocolHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : inspector_ ( inspector ), tcp_ ( std :: move ( tcp )) { // \u8bbe\u7f6eTCP\u6570\u636e\u7684handler\uff0cTCP\u662f\u53ea\u8d1f\u8d23\u4f20\u8f93\uff0c\u6570\u636e\u7684\u89e3\u6790\u4ea4\u7ed9handler\u5904\u7406 tcp_ -> SetHandler ( this ); } HttpHandler\u662f\u5bf9uv_tcp_t\u7684\u5c01\u88c5\uff0c\u4e3b\u8981\u901a\u8fc7HTTP\u89e3\u6790\u5668llhttp\u5bf9HTTP\u534f\u8bae\u8fdb\u884c\u89e3\u6790\u3002 3 \u8c03\u7528inspector->SwitchProtocol()\u5207\u6362\u5f53\u524d\u534f\u8bae\u4e3aHTTP\uff0c\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0c\u9996\u5148\u8981\u7ecf\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u4eceHTTP\u534f\u8bae\u5347\u7ea7\u5230WebSocket\u534f\u8bae\uff0c\u5347\u7ea7\u6210\u529f\u540e\u5c31\u4f7f\u7528Websocket\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u7ed3\u6784\u56fe\u3002 \u81f3\u6b64\uff0c\u5c31\u5b8c\u6210\u4e86\u8fde\u63a5\u5904\u7406\u7684\u5206\u6790\u3002 3.2.3 \u534f\u8bae\u5347\u7ea7 \u00b6 \u5b8c\u6210\u4e86TCP\u8fde\u63a5\u7684\u5904\u7406\u540e\uff0c\u63a5\u4e0b\u6765\u8981\u5b8c\u6210\u534f\u8bae\u5347\u7ea7\uff0c\u56e0\u4e3aInspector\u662f\u901a\u8fc7WebSocket\u534f\u8bae\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\uff0c\u6240\u4ee5\u9700\u8981\u901a\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u6765\u5b8c\u6210HTTP\u5230WebSocekt\u534f\u8bae\u7684\u5347\u7ea7\u3002\u4ece\u521a\u624d\u7684\u5206\u6790\u4e2d\u770b\u5f53\u6709\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cOnDataReceivedCb\u56de\u8c03\u3002 void TcpHolder::OnDataReceivedCb ( uv_stream_t * tcp , ssize_t nread , const uv_buf_t * buf ) { TcpHolder * holder = From ( tcp ); holder -> ReclaimUvBuf ( buf , nread ); // \u8c03\u7528handler\u7684onData\uff0c\u76ee\u524dhandler\u662fHTTP\u534f\u8bae holder -> handler_ -> OnData ( & holder -> buffer ); } TCP\u5c42\u6536\u5230\u6570\u636e\u540e\u4ea4\u7ed9\u5e94\u7528\u5c42\u89e3\u6790\uff0c\u76f4\u63a5\u8c03\u7528\u4e0a\u5c42\u7684OnData\u56de\u8c03\u3002 void OnData ( std :: vector < char >* data ) override { // \u89e3\u6790HTTP\u534f\u8bae llhttp_execute ( & parser_ , data -> data (), data -> size ()); // \u89e3\u6790\u5b8c\u5e76\u4e14\u662f\u5347\u7ea7\u534f\u8bae\u7684\u8bf7\u6c42\u5219\u8c03\u7528delegate\u7684\u56de\u8c03OnSocketUpgrade delegate () -> OnSocketUpgrade ( event . host , event . path , event . ws_key ); } OnData\u53ef\u80fd\u4f1a\u88ab\u591a\u6b21\u56de\u8c03\uff0c\u5e76\u901a\u8fc7llhttp_execute\u89e3\u6790\u6536\u5230\u7684HTTP\u62a5\u6587\uff0c\u5f53\u53d1\u73b0\u662f\u4e00\u4e2a\u534f\u8bae\u5347\u7ea7\u7684\u8bf7\u6c42\u540e\uff0c\u5c31\u8c03\u7528OnSocketUpgrade\u56de\u8c03\u3002delegate\u662fTCP\u5c42\u4fdd\u5b58\u7684SocketSession::Delegate\u5bf9\u8c61\u3002\u6765\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684OnSocketUpgrade\u65b9\u6cd5\u3002 void SocketSession::Delegate::OnSocketUpgrade ( const std :: string & host , const std :: string & path , const std :: string & ws_key ) { std :: string id = path . empty () ? path : path . substr ( 1 ); server_ -> SessionStarted ( session_id_ , id , ws_key ); } OnSocketUpgrade\u53c8\u8c03\u7528\u6765server_\uff08InspectorSocketServer\u5bf9\u8c61\uff09\u7684SessionStarted\u3002 void InspectorSocketServer::SessionStarted ( int session_id , const std :: string & id , const std :: string & ws_key ) { // \u627e\u5230\u5bf9\u5e94\u7684session\u5bf9\u8c61 SocketSession * session = Session ( session_id ); connected_sessions_ [ session_id ]. first = id ; session -> Accept ( ws_key ); delegate_ -> StartSession ( session_id , id ); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u5206\u914d\u7684SocketSession\u5bf9\u8c61\u3002 1 \u6267\u884csession->Accept(ws_key);\u56de\u590d\u5ba2\u6237\u7aef\u540c\u610f\u534f\u8bae\u5347\u7ea7\u3002 void Accept ( const std :: string & ws_key ) { ws_socket_ -> AcceptUpgrade ( ws_key ); } \u4ece\u7ed3\u6784\u56fe\u6211\u4eec\u53ef\u4ee5\u770b\u5230ws_socket_\u662f\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002 void AcceptUpgrade ( const std :: string & accept_key ) override { char accept_string [ ACCEPT_KEY_LENGTH ]; generate_accept_string ( accept_key , & accept_string ); const char accept_ws_prefix [] = \"HTTP/1.1 101 Switching Protocols \\r\\n \" \"Upgrade: websocket \\r\\n \" \"Connection: Upgrade \\r\\n \" \"Sec-WebSocket-Accept: \" ; const char accept_ws_suffix [] = \" \\r\\n\\r\\n \" ; std :: vector < char > reply ( accept_ws_prefix , accept_ws_prefix + sizeof ( accept_ws_prefix ) - 1 ); reply . insert ( reply . end (), accept_string , accept_string + sizeof ( accept_string )); reply . insert ( reply . end (), accept_ws_suffix , accept_ws_suffix + sizeof ( accept_ws_suffix ) - 1 ); // \u56de\u590d101\u7ed9\u5ba2\u6237\u7aef WriteRaw ( reply , WriteRequest :: Cleanup ); // \u5207\u6362handler\u4e3aWebSocket handler inspector_ -> SwitchProtocol ( new WsHandler ( inspector_ , std :: move ( tcp_ ))); } AcceptUpgradeh\u9996\u5148\u56de\u590d\u5ba2\u6237\u7aef101\u8868\u793a\u540c\u610f\u5347\u7ea7\u9053WebSocket\u534f\u8bae\uff0c\u7136\u540e\u5207\u6362\u6570\u636e\u5904\u7406\u5668\u4e3aWsHandler\uff0c\u5373\u540e\u7eed\u7684\u6570\u636e\u6309\u7167WebSocket\u534f\u8bae\u5904\u7406\u3002 2 \u6267\u884cdelegate_->StartSession(session_id, id)\u5efa\u7acb\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 void InspectorIoDelegate::StartSession ( int session_id , const std :: string & target_id ) { auto session = main_thread_ -> Connect ( std :: unique_ptr < InspectorSessionDelegate > ( new IoSessionDelegate ( request_queue_ -> handle (), session_id ) ), true ); if ( session ) { sessions_ [ session_id ] = std :: move ( session ); fprintf ( stderr , \"Debugger attached. \\n \" ); } } \u9996\u5148\u901a\u8fc7main_thread_->Connect\u62ff\u5230\u4e00\u4e2asession\uff0c\u5e76\u5728InspectorIoDelegate\u4e2d\u8bb0\u5f55\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0bmain_thread_->Connect\u7684\u903b\u8f91\uff08main_thread_\u662fMainThreadHandle\u5bf9\u8c61\uff09\u3002 std :: unique_ptr < InspectorSession > MainThreadHandle :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { return std :: unique_ptr < InspectorSession > ( new CrossThreadInspectorSession ( ++ next_session_id_ , shared_from_this (), std :: move ( delegate ), prevent_shutdown )); } Connect\u51fd\u6570\u65b0\u5efa\u4e86\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002 CrossThreadInspectorSession ( int id , std :: shared_ptr < MainThreadHandle > thread , std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) // \u521b\u5efa\u4e00\u4e2aMainThreadSessionState\u5bf9\u8c61 : state_ ( thread , std :: bind ( MainThreadSessionState :: Create , std :: placeholders :: _1 , prevent_shutdown )) { // \u6267\u884cMainThreadSessionState::Connect state_ . Call ( & MainThreadSessionState :: Connect , std :: move ( delegate )); } \u7ee7\u7eed\u770bMainThreadSessionState::Connect\u3002 void Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate ) { Agent * agent = thread_ -> inspector_agent (); session_ = agent -> Connect ( std :: move ( delegate ), prevent_shutdown_ ); } \u7ee7\u7eed\u8c03agent->Connect\u3002 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ )); } \u7ee7\u7eed\u8c03connectFrontend int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u521b\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5e76\u4e14\u5728channels_\u4e2d\u4fdd\u5b58\u4e86\u6620\u5c04\u5173\u7cfb\u3002\u770b\u770bChannelImpl\u7684\u6784\u9020\u51fd\u6570\u3002 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: unique_ptr < InspectorSessionDelegate > delegate , ...) : delegate_ ( std :: move ( delegate )) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); } ChannelImpl\u8c03\u7528inspector->connect\u5efa\u7acb\u4e86\u4e00\u4e2a\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002\u7ed3\u6784\u56fe\u5927\u81f4\u5982\u4e0b\u3002 3.2.4 \u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u6570\u636e\u5904\u7406 \u00b6 TCP\u8fde\u63a5\u5efa\u7acb\u4e86\uff0c\u534f\u8bae\u5347\u7ea7\u4e5f\u5b8c\u6210\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u5f00\u59cb\u5904\u7406\u4e1a\u52a1\u6570\u636e\u3002\u4ece\u524d\u9762\u7684\u5206\u6790\u4e2d\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cTcpHoldler\u7684handler_->OnData\u56de\u8c03\u3002\u56e0\u4e3a\u5df2\u7ecf\u5b8c\u6210\u4e86\u534f\u8bae\u5347\u7ea7\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u7684handler\u53d8\u6210\u4e86WeSocket handler\u3002 void OnData ( std :: vector < char >* data ) override { // 1. Parse. int processed = 0 ; do { processed = ParseWsFrames ( * data ); // 2. Fix the data size & length if ( processed > 0 ) { remove_from_beginning ( data , processed ); } } while ( processed > 0 && ! data -> empty ()); } OnData\u901a\u8fc7ParseWsFrames\u89e3\u6790WebSocket\u534f\u8bae\u3002 int ParseWsFrames ( const std :: vector < char >& buffer ) { int bytes_consumed = 0 ; std :: vector < char > output ; bool compressed = false ; // \u89e3\u6790WebSocket\u534f\u8bae ws_decode_result r = decode_frame_hybi17 ( buffer , true /* client_frame */ , & bytes_consumed , & output , & compressed ); // \u6267\u884cdelegate\u7684\u56de\u8c03 delegate () -> OnWsFrame ( output ); return bytes_consumed ; } \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7delegate\u662fTcpHoldler\u7684delegate\uff0c\u5373SocketSession::Delegate\u5bf9\u8c61\u3002 void SocketSession::Delegate::OnWsFrame ( const std :: vector < char >& data ) { server_ -> MessageReceived ( session_id_ , std :: string ( data . data (), data . size ())); } \u7ee7\u7eed\u56de\u8c03server_->MessageReceived\u3002\u4ece\u7ed3\u6784\u56fe\u53ef\u4ee5\u770b\u5230server_\u662fInspectorSocketServer\u5bf9\u8c61\u3002 void MessageReceived ( int session_id , const std :: string & message ) { delegate_ -> MessageReceived ( session_id , message ); } \u7ee7\u7eed\u56de\u8c03delegate_->MessageReceived\u3002InspectorSocketServer\u7684delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 void InspectorIoDelegate::MessageReceived ( int session_id , const std :: string & message ) { auto session = sessions_ . find ( session_id ); if ( session != sessions_ . end ()) session -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684session\u3002session\u662f\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002\u770b\u770b\u4ed6\u7684Dispatch\u65b9\u6cd5\u3002 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u6267\u884cMainThreadSessionState::Dispatch\u3002 void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); if ( client ) client -> dispatchMessageFromFrontend ( session_id_ , message ); } \u7ee7\u7eed\u8c03client->dispatchMessageFromFrontend\u3002 void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684ChannelImpl\uff0c\u7ee7\u7eed\u8c03ChannelImpl\u7684dispatchProtocolMessage\u3002 voiddispatchProtocolMessage ( const StringView & message ) { session_ -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u548cV8 Inspector\u7684\u4f1a\u8bdd\u5bf9\u8c61\u628a\u6570\u636e\u53d1\u9001\u7ed9V8\u3002\u81f3\u6b64\u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u901a\u4fe1\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002 3.2.5 V8 Inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u5904\u7406 \u00b6 \u63a5\u7740\u770b\u4eceV8 inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u4f20\u9012\u903b\u8f91\u3002V8 inspector\u662f\u901a\u8fc7channel\u7684sendResponse\u51fd\u6570\u4f20\u9012\u7ed9\u5ba2\u6237\u7aef\u7684\u3002 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fIoSessionDelegate\u5bf9\u8c61\u3002 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { request_queue_ -> Post ( id_ , TransportAction :: kSendMessage , StringBuffer :: create ( message )); } request_queue_\u662fRequestQueueData\u5bf9\u8c61\u3002 void Post ( int session_id , TransportAction action , std :: unique_ptr < StringBuffer > message ) { Mutex :: ScopedLock scoped_lock ( state_lock_ ); bool notify = messages_ . empty (); messages_ . emplace_back ( action , session_id , std :: move ( message )); if ( notify ) { CHECK_EQ ( 0 , uv_async_send ( & async_ )); incoming_message_cond_ . Broadcast ( scoped_lock ); } } Post\u9996\u5148\u628a\u6d88\u606f\u5165\u961f\uff0c\u7136\u540e\u901a\u8fc7\u5f02\u6b65\u7684\u65b9\u5f0f\u901a\u77e5async_\u63a5\u7740\u770basync_\u7684\u5904\u7406\u51fd\u6570\uff08\u5728\u5b50\u7ebf\u7a0b\u7684\u4e8b\u4ef6\u5faa\u73af\u91cc\u6267\u884c\uff09\u3002 uv_async_init ( loop , & async_ , []( uv_async_t * async ) { // \u62ff\u5230async\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587 RequestQueueData * wrapper = node :: ContainerOf ( & RequestQueueData :: async_ , async ); // \u6267\u884cRequestQueueData\u7684DoDispatch wrapper -> DoDispatch (); }); void DoDispatch () { for ( const auto & request : GetMessages ()) { request . Dispatch ( server_ ); } } request\u662fRequestToServer\u5bf9\u8c61\u3002 void Dispatch ( InspectorSocketServer * server ) const { switch ( action_ ) { case TransportAction :: kSendMessage : server -> Send ( session_id_ , protocol :: StringUtil :: StringViewToUtf8 ( message_ -> string ())); break ; } } \u63a5\u7740\u770bInspectorSocketServer\u7684Send\u3002 void InspectorSocketServer::Send ( int session_id , const std :: string & message ) { SocketSession * session = Session ( session_id ); if ( session != nullptr ) { session -> Send ( message ); } } session\u4ee3\u8868\u53ef\u5ba2\u6237\u7aef\u7684\u4e00\u4e2a\u8fde\u63a5\u3002 void SocketSession::Send ( const std :: string & message ) { ws_socket_ -> Write ( message . data (), message . length ()); } \u63a5\u7740\u8c03\u7528WebSocket handler\u7684Write\u3002 void Write ( const std :: vector < char > data ) override { std :: vector < char > output = encode_frame_hybi17 ( data ); WriteRaw ( output , WriteRequest :: Cleanup ); } WriteRaw\u662f\u57fa\u7c7bProtocolHandler\u5b9e\u73b0\u7684\u3002 int ProtocolHandler::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { return tcp_ -> WriteRaw ( buffer , write_cb ); } \u6700\u7ec8\u662f\u901a\u8fc7TCP\u8fde\u63a5\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\u3002 int TcpHolder::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { // Freed in write_request_cleanup WriteRequest * wr = new WriteRequest ( handler_ , buffer ); uv_stream_t * stream = reinterpret_cast < uv_stream_t *> ( & tcp_ ); int err = uv_write ( & wr -> req , stream , & wr -> buf , 1 , write_cb ); if ( err < 0 ) delete wr ; return err < 0 ; } \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0csocket\u53ef\u5199\u7684\u65f6\u5019\u53d1\u9001\u6570\u636e\u7ed9\u5ba2\u6237\u7aef\u3002 4 \u52a8\u6001\u5f00\u542fInspector \u00b6 \u9ed8\u8ba4\u6253\u5f00Inspector\u80fd\u529b\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u8fd9\u610f\u5473\u7740\u80fd\u8fde\u4e0awebsocket\u670d\u52a1\u5668\u7684\u5ba2\u6237\u7aef\u90fd\u80fd\u901a\u8fc7\u534f\u8bae\u63a7\u5236Node.js\u8fdb\u7a0b\uff0c\u901a\u5e38\u6211\u4eec\u662f\u5728Node.js\u8fdb\u7a0b\u51fa\u73b0\u95ee\u9898\u7684\u65f6\u5019\uff0c\u52a8\u6001\u5f00\u542fInspector\u3002 const http = require ( ' http ' ); const inspector = require ( ' inspector ' ); const fs = require ( ' fs ' ); http . createServer (( req , res ) => { if ( req . url == ' debug ' ) { const session = new inspector . Session (); session . connect (); session . post ( ' Profiler . enable ' , () => { session . post ( ' Profiler . start ' , () => { session . post ( ' Profiler . stop ' , ( err , { profile }) => { if ( ! err ) { fs . writeFileSync ( ' . / profile . cpuprofile ' , JSON . stringify ( profile )); } session . disconnect (); res . end ( ' ok ' ); }); }); }); } else { res . end ( ' ok ' ); } }). listen ( 80 ); \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7url\u53c2\u6570\u63a7\u5236Inspector\u7684\u80fd\u529b\uff0c\u672c\u5730\u8c03\u8bd5\u65f6\u53ef\u4ee5\u5728vscode\u91cc\u53ef\u4ee5\u76f4\u63a5\u770b\u5230\u6570\u636e\u3002 5 \u6536\u96c6\u6570\u636e \u00b6 V8 inspector\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u8c03\u8bd5\u53ea\u662f\u5b83\u5176\u4e2d\u4e00\u4e2a\u80fd\u529b\uff0c\u4ed6\u8fd8\u53ef\u4ee5\u83b7\u53d6\u5185\u5b58\u3001CPU\u7b49\u6570\u636e\uff0c\u5177\u4f53\u80fd\u529b\u8bf7\u53c2\u8003\u6587\u6863\u3002 \u540e\u8bb0\uff1aNode.js\u7684inspector\u662f\u5728Node.js\u989d\u5916\u7ebf\u7a0b\u91cc\u5f00\u542f\u7684\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u901a\u8fc7Node.js\u4f5c\u4e3a\u4e2d\u95f4\u4eba\uff0c\u5b8c\u6210\u5ba2\u6237\u7aef\u548cV8 inspector\u7684\u901a\u4fe1\uff08\u8c03\u8bd5\u3001\u6536\u96c6\u6570\u636e\uff09\uff0c\u662f\u6211\u4eec\u8c03\u8bd5\u548c\u8bca\u65adNode.js\u8fdb\u7a0b\u975e\u5e38\u597d\u7684\u65b9\u5f0f\u3002 \u53c2\u8003\u5185\u5bb9\uff1a 1 Debugging Guide 2 inspector 3 \u5f00\u6e90\u7684inspector agent\u5b9e\u73b0 4 inpector\u534f\u8bae\u6587\u6863 5 Debugging Node.js with Chrome DevTools","title":"23-Inspector"},{"location":"chapter24-Inspector/#1-inspector","text":"","title":"1 Inspector\u7684\u4f7f\u7528"},{"location":"chapter24-Inspector/#11","text":"\u6211\u4eec\u5148\u4ece\u4e00\u4e2a\u4f8b\u5b50\u5f00\u59cb\u3002\u4e0b\u9762\u662f\u4e00\u4e2ahttp\u670d\u52a1\u5668\u3002 const http = require ( ' http ' ); http . createServer (( req , res ) => { res . end ( ' ok ' ); }). listen ( 80 ); \u7136\u540e\u6211\u4eec\u4ee5node --inspect httpServer.js\u7684\u65b9\u5f0f\u542f\u52a8\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u8f93\u51fa\u3002 Debugger listening on ws : //127.0.0.1:9229/fbbd9d8f-e088-48cc-b1e0-e16bfe58db44 For help , see : https : //nodejs.org/en/docs/inspector 9229\u7aef\u53e3\u662fNode.js\u9ed8\u8ba4\u9009\u62e9\u7684\u7aef\u53e3\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5b9a\u4e49\uff0c\u5177\u4f53\u53ef\u53c2\u8003\u6587\u6863\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53bb\u6d4f\u89c8\u5668\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u83dc\u5355\u680f\u591a\u4e86\u4e00\u4e2a\u8c03\u8bd5Node.js\u7684\u6309\u94ae\u3002 \u70b9\u51fb\u8fd9\u4e2a\u6309\u94ae\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u754c\u9762\u3002 \u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u67d0\u4e00\u884c\u4ee3\u7801\u6253\u65ad\u70b9\uff0c\u6bd4\u5982\u6211\u5728\u7b2c\u4e09\u884c\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8bbf\u95ee80\u7aef\u53e3\uff0c\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u505c\u7559\u5728\u65ad\u70b9\u5904\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e9b\u6267\u884c\u4e0a\u4e0b\u6587\u3002","title":"1.1 \u672c\u5730\u8c03\u8bd5"},{"location":"chapter24-Inspector/#12","text":"\u4f46\u5f88\u591a\u65f6\u5019\u6211\u4eec\u53ef\u80fd\u9700\u8981\u8fdc\u7a0b\u8c03\u8bd5\u3002\u6bd4\u5982\u6211\u5728\u4e00\u53f0\u4e91\u670d\u52a1\u5668\u4e0a\u90e8\u7f72\u4ee5\u4e0a\u670d\u52a1\u5668\u4ee3\u7801\u3002\u7136\u540e\u6267\u884c node -- inspect = 0.0.0.0 : 8888 httpServer . js \u4e0d\u8fc7\u8fd9\u65f6\u5019\u6211\u4eec\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u53d1\u73b0\u6309\u94ae\u7f6e\u7070\u6216\u8005\u627e\u4e0d\u5230\u6211\u4eec\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u4fe1\u606f\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u7528\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002\u901a\u8fc7\u5728\u6d4f\u89c8\u5668url\u8f93\u5165\u6846\u8f93\u5165devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws={host}:{port}/{path}\u7684\u65b9\u5f0f\uff08\u66ff\u6362{}\u91cc\u9762\u7684\u5185\u5bb9\u4e3a\u4f60\u6267\u884cNode.js\u65f6\u8f93\u51fa\u7684\u4fe1\u606f\uff09\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53bb\u8fde\u63a5\u4f60\u8f93\u5165\u7684\u5730\u5740\uff0c\u6bd4\u59821.1.1.1:9229/abc\u3002\u8fd9\u79cd\u6bd4\u8f83\u9002\u5408\u4e8e\u5bf9\u4e8e\u901a\u7528\u7684\u573a\u666f\u3002","title":"1.2 \u8fdc\u7a0b\u8c03\u8bd5"},{"location":"chapter24-Inspector/#13","text":"\u5982\u679c\u662f\u6211\u4eec\u81ea\u5df1\u8c03\u8bd5\u7684\u8bdd\uff0c\u8fd9\u79cd\u65b9\u5f0f\u770b\u8d77\u6765\u5c31\u6709\u70b9\u9ebb\u70e6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6d4f\u89c8\u5668\u63d0\u4f9b\u7684\u81ea\u52a8\u63a2\u6d4b\u529f\u80fd\u3002 1 url\u8f93\u5165\u6846\u8f93\u5165chrome://inspect/#devices\u6211\u4eec\u4f1a\u770b\u5230\u4ee5\u4e0b\u754c\u9762 2 \u70b9\u51fbconfigure\u6309\u94ae\uff0c\u5728\u5f39\u51fa\u7684\u5f39\u6846\u91cc\u8f93\u5165\u4f60\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u5730\u5740 3 \u914d\u7f6e\u5b8c\u6bd5\u540e\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u754c\u9762\u53d8\u6210\u8fd9\u6837\u4e86\uff0c\u6216\u8005\u6253\u5f00\u65b0\u7684tab\uff0c\u6211\u4eec\u770b\u5230\u5f00\u53d1\u8005\u5de5\u5177\u7684\u8c03\u8bd5\u6309\u94ae\u4e5f\u53d8\u4eae\u4e86\u3002 4 \u8fd9\u65f6\u5019\u6211\u4eec\u70b9\u51fbinspect\u6309\u94ae\u3001Open dedicated DevTools for Node\u6309\u94ae\u6216\u8005\u6253\u5f00\u65b0tab\u7684\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u5c31\u53ef\u4ee5\u5f00\u59cb\u8c03\u8bd5\u3002\u800c\u4e14\u8fd8\u53ef\u4ee5\u8c03\u8bd5Node.js\u7684\u539f\u751fjs\u6a21\u5757\u3002","title":"1.3 \u81ea\u52a8\u63a2\u6d4b"},{"location":"chapter24-Inspector/#2-inspector","text":"\u4e0b\u9762\u4ee5\u901a\u8fc7url\u7684\u65b9\u5f0f\u8c03\u8bd5\uff08\u53ef\u4ee5\u770b\u5230network\uff09\uff0c\u6765\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u90fd\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u6d4f\u89c8\u5668\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\u540e\uff0c\u662f\u901a\u8fc7websocket\u534f\u8bae\u901a\u4fe1\u7684\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u547d\u4ee4\u662f\u4ec0\u4e48\u610f\u601d\uff0c\u9996\u5148\u770bDebugger.scriptParsed\u3002 Debugger.scriptParsed # Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. \u4ece\u8bf4\u660e\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u5f53V8\u89e3\u6790\u811a\u672c\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u8fd9\u4e2a\u4e8b\u4ef6\uff0c\u90a3\u5c31\u4f1a\u544a\u8bc9\u6d4f\u89c8\u5668\u8fd9\u4e2a\u4fe1\u606f\u3002 \u6211\u4eec\u53d1\u73b0\u8fd4\u56de\u7684\u90fd\u662f\u4e00\u4e9b\u5143\u6570\u636e\uff0c\u6ca1\u6709\u811a\u672c\u7684\u5177\u4f53\u4ee3\u7801\u5185\u5bb9\uff0c\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4f1a\u518d\u6b21\u53d1\u8d77\u8bf7\u6c42\uff0c \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u811a\u672c\u7684scriptId\u662f103\u3002\u6240\u4ee5\u8bf7\u6c42\u91cc\u5e26\u4e86\u8fd9\u4e2ascriptId\u3002\u5bf9\u5e94\u7684\u8bf7\u6c42id\u662f11\u3002\u63a5\u7740\u770b\u4e00\u4e0b\u54cd\u5e94\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u4e86\u89e3\u4e86\u83b7\u53d6\u811a\u672c\u5185\u5bb9\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u6211\u4eec\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u662f\u600e\u6837\u7684\u8fc7\u7a0b\u3002\u5f53\u6211\u4eec\u5728\u6d4f\u89c8\u5668\u4e0a\u70b9\u51fb\u67d0\u4e00\u884c\u8bbe\u7f6e\u65ad\u70b9\u7684\u65f6\u5019\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u3002 \u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u4e49\u987e\u540d\u601d\u4e49\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9a\u4e49\u3002 Debugger.setBreakpointByUrl # Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in locations property. Further matching script parsing will result in subsequent breakpointResolved events issued. This logical breakpoint will survive page reloads. \u63a5\u7740\u670d\u52a1\u8fd4\u56de\u54cd\u5e94\u3002 \u8fd9\u65f6\u5019\u6211\u4eec\u4ece\u53e6\u5916\u4e00\u4e2atab\u8bbf\u95ee80\u7aef\u53e3\u3002\u670d\u52a1\u5668\u5c31\u4f1a\u5728\u6211\u4eec\u8bbe\u7f6e\u7684\u65ad\u70b9\u5904\u505c\u7559\uff0c\u5e76\u4e14\u901a\u77e5\u6d4f\u89c8\u5668\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u601d\u3002 \u8fd9\u4e2a\u547d\u4ee4\u5c31\u662f\u5f53\u670d\u52a1\u5668\u6267\u884c\u5230\u65ad\u70b9\u65f6\u901a\u77e5\u6d4f\u89c8\u5668\uff0c\u5e76\u4e14\u8fd4\u56de\u6267\u884c\u7684\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u662f\u54ea\u4e2a\u6267\u884c\u5230\u54ea\u4e2a\u65ad\u70b9\u505c\u7559\u4e86\u3002\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4fa7\u4e5f\u4f1a\u505c\u7559\u5728\u5bf9\u5e94\u7684\u5730\u65b9\uff0c\u5f53\u6211\u4eechover\u67d0\u4e2a\u53d8\u91cf\u65f6\uff0c\u5c31\u4f1a\u770b\u5230\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\u3002\u8fd9\u4e9b\u90fd\u662f\u901a\u8fc7\u5177\u4f53\u7684\u547d\u4ee4\u83b7\u53d6\u7684\u6570\u636e\u3002\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u4e86\uff0c\u53ef\u4ee5\u53c2\u8003\u5177\u4f53\u6587\u6863\u3002","title":"2 Inspector\u8c03\u8bd5\u7684\u539f\u7406"},{"location":"chapter24-Inspector/#3-inspector","text":"\u5927\u81f4\u4e86\u89e3\u4e86\u6d4f\u89c8\u5668\u548c\u670d\u52a1\u5668\u7684\u4ea4\u4e92\u8fc7\u7a0b\u548c\u534f\u8bae\u540e\uff0c\u6211\u4eec\u518d\u6765\u6df1\u5165\u4e86\u89e3\u4e00\u4e0b\u5173\u4e8einspector\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002\u5f53\u7136\u8fd9\u91cc\u4e0d\u662f\u5206\u6790V8\u4e2dInspector\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u5206\u6790\u5982\u4f55\u4f7f\u7528V8\u7684Inspector\u4ee5\u53caNode.js\u4e2d\u5173\u4e8eInspector\u7684\u5b9e\u73b0\u90e8\u5206\u3002","title":"3 Inspector\u7684\u5b9e\u73b0"},{"location":"chapter24-Inspector/#31","text":"\u56e0\u4e3aNode.js\u7684\u5b9e\u73b0\u6bd4\u8f83\u590d\u6742\uff0c\u8fd9\u91cc\u5148\u4ee5\u4e00\u4e2a\u7b80\u5355\u7248\u7684\u8c03\u8bd5\u5de5\u5177\u6e90\u7801\u6765\u5206\u6790inspector\u7684\u539f\u7406\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u4ee3\u7801\u3002 inspector = std :: unique_ptr < Inspector > ( new Inspector ( v8Platform , context , port )); inspector -> startAgent (); \u9996\u5148\u65b0\u5efa\u4e00\u4e2aInspector\u3002\u7136\u540e\u542f\u52a8\u5b83\u3002\u63a5\u4e0b\u6765\u770b\u770bInspector\u91cc\u7684\u903b\u8f91\u3002 Inspector :: Inspector ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const int webSocketPort ) { context_ = context ; // \u65b0\u5efa\u4e00\u4e2awebsocket server\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1 websocket_server_ = std :: unique_ptr < WebSocketServer > ( new WebSocketServer ( webSocketPort , // \u6536\u5230\u5ba2\u6237\u7684\u7684\u6d88\u606f\u540e\u6267\u884conMessage\u56de\u8c03 std :: bind ( & Inspector :: onMessage , this , std :: placeholders :: _1 ) ) ); // \u65b0\u5efa\u4e00\u4e2ainspector client\u548cV8\u901a\u4fe1 inspector_client_ = std :: unique_ptr < V8InspectorClientImpl > ( new V8InspectorClientImpl ( platform , context_ , // \u6536\u5230V8\u7684\u6d88\u606f\u540e\u8c03\u7528sendMessage\u56de\u590d\u7ed9\u5ba2\u6237\u7684 std :: bind ( & Inspector :: sendMessage , this , std :: placeholders :: _1 ), std :: bind ( & Inspector :: waitForFrontendMessage , this ) ) ); } \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u590d\u6742\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u6df1\u7a76\u3002\u4e3b\u8981\u662f\u4e24\u4e2a\u90e8\u5206\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2awebsocket\u670d\u52a1\u5668\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2ainspector\u5ba2\u6237\u7aef\uff08\u7528\u4e8e\u548cV8 Inspector\u901a\u4fe1\uff09\uff0c\u6574\u4f53\u67b6\u6784\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u5206\u522b\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002\u9996\u5148\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u7684\u6784\u9020\u51fd\u6570\u3002 WebSocketServer :: WebSocketServer ( int port , std :: function < void ( std :: string ) > onMessage ) { port_ = port ; onMessage_ = std :: move ( onMessage ); } WebSocketServer\u6784\u9020\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\u3002\u63a5\u7740\u770binspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002 V8InspectorClientImpl :: V8InspectorClientImpl ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const std :: function < void ( std :: string ) > & onResponse , const std :: function < int ( void ) > & onWaitFrontendMessageOnPause ) { platform_ = platform . get (); context_ = context ; onWaitFrontendMessageOnPause_ = onWaitFrontendMessageOnPause ; isolate_ = context_ -> GetIsolate (); // \u521b\u5efa\u4e00\u4e2achannel\u548cinspector\u901a\u4fe1\uff0c\u6536\u5230V8\u6d88\u606f\u65f6\u4f1a\u6267\u884conResponse channel_ . reset ( new V8InspectorChannelImp ( isolate_ , onResponse )); // \u65b0\u5efa\u4e00\u4e2aV8\u63d0\u4f9b\u7684inspector inspector_ = v8_inspector :: V8Inspector :: create ( isolate_ , this ); // \u521b\u5efa\u4e00\u4e2a\u548cinspector\u901a\u4fe1\u7684session\u3002 session_ = inspector_ -> connect ( kContextGroupId , channel_ . get (), v8_inspector :: StringView ()); context_ -> SetAlignedPointerInEmbedderData ( 1 , this ); v8_inspector :: StringView contextName = convertToStringView ( \"inspector\" ); inspector_ -> contextCreated ( v8_inspector :: V8ContextInfo ( context , kContextGroupId , contextName )); terminated_ = true ; run_nested_loop_ = false ; } \u4e0a\u9762\u4ee3\u7801\u5f88\u591a\uff0c\u4e3b\u8981\u662f\u6839\u636eV8\u63d0\u4f9b\u7684API\u6765\u5c31\u884c\u3002\u8fd9\u91cc\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 V8Inspector\u662fV8\u63d0\u4f9b\u7684\u7c7b\u3002 2 session\u8868\u793a\u548cV8 inspector\u901a\u4fe1\u7684\u4f1a\u8bdd\u3002 3 channel\u7528\u4e8e\u548cV8 inspector\u901a\u4fe1\uff0c\u4eceAPI\u6765\u770b\uff0cchannel\u53ea\u80fd\u4eceV8\u83b7\u53d6\u6570\u636e\uff0c\u5199\u5165\u6570\u636e\u662f\u53e6\u5916\u7684API\u3002 \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u5982\u4e0b \u81f3\u6b64\uff0cwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u5c31\u5206\u6790\u5b8c\u6bd5\u4e86\uff0c\u56de\u5230\u6700\u5f00\u59cb\u7684\u4ee3\u7801\uff0c\u521d\u59cb\u5316\u5b8c\u6bd5\u540e\u4f1a\u6267\u884cstartAgent\u3002 void Inspector::startAgent () { websocket_server_ -> run (); } // \u542f\u52a8websocket\u670d\u52a1\u5668 void WebSocketServer::run () { auto const address = net :: ip :: make_address ( \"127.0.0.1\" ); net :: io_context ioc { 1 }; tcp :: acceptor acceptor { ioc , { address , static_cast < unsigned short > ( port_ )}}; tcp :: socket socket { ioc }; acceptor . accept ( socket ); ws_ = std :: unique_ptr < websocket :: stream < tcp :: socket >> ( new websocket :: stream < tcp :: socket > ( std :: move ( socket ))); startListening (); } // \u7b49\u5f85\u8fde\u63a5 void WebSocketServer::startListening () { ws_ -> accept (); while ( true ) { waitFrontendMessage (); } } // \u8bfb\u53d6\u8fde\u63a5\u4e2d\u7684\u6d88\u606f void WebSocketServer::waitFrontendMessage () { beast :: flat_buffer buffer ; ws_ -> read ( buffer ); std :: string message = boost :: beast :: buffers_to_string ( buffer . data ()); onMessage_ ( std :: move ( message )); } startAgent\u7684\u903b\u8f91\u5c31\u662f\u542f\u52a8websocket\u670d\u52a1\u5668\u3002\u542f\u52a8\u5b8c\u6bd5\u540e\u5c31\u7b49\u5f85\u5ba2\u6237\u7684\u8fde\u63a5\u3002\u8fde\u63a5\u6210\u529f\u540e\u6267\u884conMessage_\u3002\u6211\u4eec\u770b\u4e00\u4e0bonMessage\u7684\u5b9e\u73b0\u3002 void Inspector::onMessage ( const std :: string & message ) { std :: cout << \"CDT message: \" << message << std :: endl ; // StringView\u662fV8\u8981\u6c42\u7684\u683c\u5f0f v8_inspector :: StringView protocolMessage = convertToStringView ( message ); // \u901a\u77e5V8 Inspector inspector_client_ -> dispatchProtocolMessage ( protocolMessage ); } onMessage\u901a\u8fc7Inspector\u5ba2\u6237\u7aef\u628a\u6d88\u606f\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u901a\u8fc7channel\u901a\u77e5Inspector\u5ba2\u6237\u7aef\uff0c\u5bf9\u5e94\u7684\u51fd\u6570\u662fsendResponse\u3002V8InspectorChannelImp\u662f\u7ee7\u627fV8\u63d0\u4f9b\u7684Channel\uff0csendResponse\u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff0c\u7531V8InspectorChannelImp\u5b9e\u73b0\u3002 void V8InspectorChannelImp::sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) { const std :: string response = convertToString ( isolate_ , message -> string ()); onResponse_ ( response ); } onResponse_\u662f\u5728Chnnel\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\uff0c\u5bf9\u5e94\u51fd\u6570\u662finspector\u5ba2\u6237\u7aef\u7684sendMessage\u3002 void Inspector::sendMessage ( const std :: string & message ) { websocket_server_ -> sendMessage ( message ); } sendMessage\u901a\u8fc7websocket\u670d\u52a1\u5668\u628aV8 Inspector\u8fd4\u56de\u7684\u6d88\u606f\u8fd4\u56de\u7ed9\u5ba2\u6237\u7684\u3002\u81f3\u6b64\uff0c\u6574\u4e2a\u901a\u4fe1\u6d41\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002","title":"3.1 \u5f00\u6e90\u5b9e\u73b0"},{"location":"chapter24-Inspector/#32-nodejsv14","text":"Node.js\u7684\u5b9e\u73b0\u975e\u5e38\u590d\u6742\u5e76\u4e14\u5f88\u7ed5\uff0c\u4e5f\u65e0\u6cd5\u901a\u4fd7\u6613\u61c2\u5730\u4ecb\u7ecd\u548c\u5206\u6790\uff0c\u53ea\u80fd\u6309\u7167\u6211\u81ea\u5df1\u7684\u601d\u8def\u5927\u81f4\u8bb2\u89e3\u4e00\u4e0b\u6d41\u7a0b\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u6e90\u7801\u3002\u5f53\u6211\u4eec\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u6267\u884c\u6211\u4eec\u7684\u5e94\u7528\u65f6 node -- inspect app . js","title":"3.2 Node.js\u7684\u5b9e\u73b0(v14)"},{"location":"chapter24-Inspector/#321","text":"Node.js\u5728\u542f\u52a8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u4f1a\u521d\u59cb\u5316Inspector\u76f8\u5173\u7684\u903b\u8f91\u3002 inspector_agent_ = std :: make_unique < inspector :: Agent > ( this ); Agent\u662f\u8d1f\u8d23\u548cV8 Inspector\u901a\u4fe1\u7684\u5bf9\u8c61\u3002\u521b\u5efa\u5b8c\u540e\u63a5\u7740\u6267\u884cenv->InitializeInspector({})\u542f\u52a8Agent\u3002 inspector_agent_ -> Start (...); Start\u7ee7\u7eed\u6267\u884cAgent::StartIoThread\u3002 bool Agent::StartIoThread () { io_ = InspectorIo :: Start ( client_ -> getThreadHandle (), ...); return true ; } StartIoThread\u4e2d\u7684client_->getThreadHandle()\u662f\u91cd\u8981\u7684\u903b\u8f91\uff0c\u6211\u4eec\u5148\u6765\u5206\u6790\u8be5\u51fd\u6570\u3002 std :: shared_ptr < MainThreadHandle > getThreadHandle () { if ( ! interface_ ) { interface_ = std :: make_shared < MainThreadInterface > ( env_ -> inspector_agent (), ...); } return interface_ -> GetHandle (); } getThreadHandle\u9996\u5148\u521b\u5efa\u6765\u4e00\u4e2aMainThreadInterface\u5bf9\u8c61\uff0c\u63a5\u7740\u53c8\u8c03\u7528\u4e86\u4ed6\u7684GetHandle\u65b9\u6cd5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u65b9\u6cd5\u7684\u903b\u8f91\u3002 std :: shared_ptr < MainThreadHandle > MainThreadInterface :: GetHandle () { if ( handle_ == nullptr ) handle_ = std :: make_shared < MainThreadHandle > ( this ); return handle_ ; } GetHandlei\u4e86\u521b\u5efa\u4e86\u4e00\u4e2aMainThreadHandle\u5bf9\u8c61\uff0c\u6700\u7ec8\u7ed3\u6784\u5982\u4e0b\u6240\u793a\u3002 \u5206\u6790\u5b8c\u540e\u6211\u4eec\u7ee7\u7eed\u770bAgent::StartIoThread\u4e2dInspectorIo::Start\u7684\u903b\u8f91\u3002 std :: unique_ptr < InspectorIo > InspectorIo :: Start ( std :: shared_ptr < MainThreadHandle > main_thread , ...) { auto io = std :: unique_ptr < InspectorIo > ( new InspectorIo ( main_thread , ...)); return io ; } InspectorIo::Star\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2aInspectorIo\u5bf9\u8c61\uff0c\u6211\u4eec\u770b\u770bInspectorIo\u6784\u9020\u51fd\u6570\u7684\u903b\u8f91\u3002 InspectorIo :: InspectorIo ( std :: shared_ptr < MainThreadHandle > main_thread , ...) : // \u521d\u59cb\u5316main_thread_ main_thread_ ( main_thread )) { // \u65b0\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cInspectorIo::ThreadMain uv_thread_create ( & thread_ , InspectorIo :: ThreadMain , this ); } \u8fd9\u65f6\u5019\u7ed3\u6784\u5982\u4e0b\u3002 Inspector\u5728\u5b50\u7ebf\u7a0b\u91cc\u542f\u52a8\u7684\u539f\u56e0\u4e3b\u8981\u6709\u4e24\u4e2a\u3002 1 \u5982\u679c\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8fd0\u884c\uff0c\u90a3\u4e48\u5f53\u6211\u4eec\u65ad\u70b9\u8c03\u8bd5\u7684\u65f6\u5019\uff0cNode.js\u4e3b\u7ebf\u7a0b\u5c31\u4f1a\u88ab\u505c\u4f4f\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5904\u7406\u5ba2\u6237\u7aef\u53d1\u8fc7\u6765\u7684\u8c03\u8bd5\u6307\u4ee4\u3002 2 \u5982\u679c\u4e3b\u7ebf\u7a0b\u9677\u5165\u6b7b\u5faa\u73af\uff0c\u6211\u4eec\u5c31\u65e0\u6cd5\u5b9e\u65f6\u6293\u53d6\u8fdb\u7a0b\u7684profile\u6570\u636e\u6765\u5206\u6790\u539f\u56e0\u3002 \u63a5\u7740\u7ee7\u7eed\u770b\u4e00\u4e0b\u5b50\u7ebf\u7a0b\u91cc\u6267\u884cInspectorIo::ThreadMain\u7684\u903b\u8f91\u3002 void InspectorIo::ThreadMain ( void * io ) { static_cast < InspectorIo *> ( io ) -> ThreadMain (); } void InspectorIo::ThreadMain () { uv_loop_t loop ; loop . data = nullptr ; // \u5728\u5b50\u7ebf\u7a0b\u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af int err = uv_loop_init ( & loop ); std :: shared_ptr < RequestQueueData > queue ( new RequestQueueData ( & loop ), ...); // \u65b0\u5efa\u4e00\u4e2adelegate\uff0c\u7528\u4e8e\u5904\u7406\u8bf7\u6c42 std :: unique_ptr < InspectorIoDelegate > delegate ( new InspectorIoDelegate ( queue , main_thread_ , ...) ); InspectorSocketServer server ( std :: move ( delegate ), ...); server . Start () uv_run ( & loop , UV_RUN_DEFAULT ); } ThreadMain\u91cc\u4e3b\u8981\u4e09\u4e2a\u903b\u8f91 1 \u521b\u5efa\u4e00\u4e2adelegate\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u6838\u5fc3\u7684\u5bf9\u8c61\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u6709\u4ec0\u4e48\u4f5c\u7528\u3002 2 \u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\u5e76\u542f\u52a8\u3002 3 \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u7684\u903b\u8f91\uff0c\u9996\u5148\u770b\u4e00\u4e0b\u521b\u5efa\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 InspectorSocketServer :: InspectorSocketServer ( std :: unique_ptr < SocketServerDelegate > delegate , ...) : // \u4fdd\u5b58delegate delegate_ ( std :: move ( delegate )), // \u521d\u59cb\u5316sessionId next_session_id_ ( 0 ) { // \u8bbe\u7f6edelegate\u7684server\u4e3a\u5f53\u524d\u670d\u52a1\u5668 delegate_ -> AssignServer ( this ); } \u6267\u884c\u5b8c\u540e\u5f62\u6210\u4ee5\u4e0b\u7ed3\u6784\u3002 \u63a5\u7740\u6211\u4eec\u770b\u542f\u52a8\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 bool InspectorSocketServer::Start () { // DNS\u89e3\u6790,\u6bd4\u5982\u8f93\u5165\u7684\u662flocalhost struct addrinfo hints ; memset ( & hints , 0 , sizeof ( hints )); hints . ai_flags = AI_NUMERICSERV ; hints . ai_socktype = SOCK_STREAM ; uv_getaddrinfo_t req ; const std :: string port_string = std :: to_string ( port_ ); uv_getaddrinfo ( loop_ , & req , nullptr , host_ . c_str (), port_string . c_str (), & hints ); // \u76d1\u542c\u89e3\u6790\u5230\u7684ip\u5217\u8868 for ( addrinfo * address = req . addrinfo ; address != nullptr ; address = address -> ai_next ) { auto server_socket = ServerSocketPtr ( new ServerSocket ( this )); err = server_socket -> Listen ( address -> ai_addr , loop_ ); if ( err == 0 ) server_sockets_ . push_back ( std :: move ( server_socket )); } return true ; } \u9996\u5148\u6839\u636e\u53c2\u6570\u505a\u4e00\u4e2aDNS\u89e3\u6790\uff0c\u7136\u540e\u6839\u636e\u62ff\u5230\u7684ip\u5217\u8868\uff08\u901a\u5e38\u662f\u4e00\u4e2a\uff09\uff0c\u521b\u5efa\u5bf9\u5e94\u4e2a\u6570\u7684ServerSocket\u5bf9\u8c61\uff0c\u5e76\u6267\u884c\u4ed6\u7684Listen\u65b9\u6cd5\u3002ServerSocket\u8868\u793a\u4e00\u4e2a\u76d1\u542csocket\u3002\u770b\u4e00\u4e0bServerSocket\u7684\u6784\u9020\u51fd\u6570\u3002 ServerSocket ( InspectorSocketServer * server ) : tcp_socket_ ( uv_tcp_t ()), server_ ( server ) {} \u6267\u884c\u5b8c\u540e\u7ed3\u6784\u5982\u4e0b\u3002 \u63a5\u7740\u770b\u4e00\u4e0bServerSocket\u7684Listen\u65b9\u6cd5\u3002 int ServerSocket::Listen ( sockaddr * addr , uv_loop_t * loop ) { uv_tcp_t * server = & tcp_socket_ ; uv_tcp_init ( loop , server ) uv_tcp_bind ( server , addr , 0 ); uv_listen ( reinterpret_cast < uv_stream_t *> ( server ), 511 , ServerSocket :: SocketConnectedCallback ); } Listen\u8c03\u7528Libuv\u7684\u63a5\u53e3\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\u3002\u81f3\u6b64\uff0cInspector\u63d0\u4f9b\u7684Weboscket\u670d\u52a1\u5668\u542f\u52a8\u4e86\u3002","title":"3.2.1 \u521d\u59cb\u5316"},{"location":"chapter24-Inspector/#322","text":"\u4ece\u521a\u624d\u5206\u6790\u4e2d\u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u56de\u8c03ServerSocket::SocketConnectedCallback\u3002 void ServerSocket::SocketConnectedCallback ( uv_stream_t * tcp_socket , int status ) { if ( status == 0 ) { // \u6839\u636eLibuv handle\u627e\u5230\u5bf9\u5e94\u7684ServerSocket\u5bf9\u8c61 ServerSocket * server_socket = ServerSocket :: FromTcpSocket ( tcp_socket ); // Socket\u5bf9\u8c61\u7684server_\u5b57\u6bb5\u4fdd\u5b58\u4e86\u6240\u5728\u7684InspectorSocketServer server_socket -> server_ -> Accept ( server_socket -> port_ , tcp_socket ); } } \u63a5\u7740\u770bInspectorSocketServer\u7684Accept\u662f\u5982\u4f55\u5904\u7406\u8fde\u63a5\u7684\u3002 void InspectorSocketServer::Accept ( int server_port , uv_stream_t * server_socket ) { std :: unique_ptr < SocketSession > session ( new SocketSession ( this , next_session_id_ ++ , server_port ) ); InspectorSocket :: DelegatePointer delegate = InspectorSocket :: DelegatePointer ( new SocketSession :: Delegate ( this , session -> id ()) ); InspectorSocket :: Pointer inspector = InspectorSocket :: Accept ( server_socket , std :: move ( delegate )); if ( inspector ) { session -> Own ( std :: move ( inspector )); connected_sessions_ [ session -> id ()]. second = std :: move ( session ); } } Accept\u7684\u9996\u5148\u521b\u5efa\u91cc\u4e00\u4e2aSocketSession\u548cSocketSession::Delegate\u5bf9\u8c61\u3002\u7136\u540e\u8c03\u7528InspectorSocket::Accept\uff0c\u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230InspectorSocket::Accept\u4f1a\u8fd4\u56de\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002InspectorSocket\u662f\u5bf9\u901a\u4fe1socket\u7684\u5c01\u88c5\uff08\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684socket\uff0c\u533a\u522b\u4e8e\u670d\u52a1\u5668\u7684\u76d1\u542csocket\uff09\u3002\u7136\u540e\u8bb0\u5f55session\u5bf9\u8c61\u5bf9\u5e94\u7684InspectorSocket\u5bf9\u8c61\uff0c\u540c\u65f6\u8bb0\u5f55sessionId\u548csession\u7684\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u63a5\u7740\u770b\u4e00\u4e0bInspectorSocket::Accept\u8fd4\u56deInspectorSocket\u7684\u903b\u8f91\u3002 InspectorSocket :: Pointer InspectorSocket::Accept ( uv_stream_t * server , DelegatePointer delegate ) { auto tcp = TcpHolder :: Accept ( server , std :: move ( delegate )); InspectorSocket * inspector = new InspectorSocket (); inspector -> SwitchProtocol ( new HttpHandler ( inspector , std :: move ( tcp ))); return InspectorSocket :: Pointer ( inspector ); } InspectorSocket::Accept\u7684\u4ee3\u7801\u4e0d\u591a\uff0c\u4f46\u662f\u903b\u8f91\u8fd8\u662f\u633a\u591a\u7684\u3002 1 InspectorSocket::Accept\u518d\u6b21\u8c03\u7528TcpHolder::Accept\u83b7\u5f97\u4e00\u4e2aTcpHolder\u5bf9\u8c61\u3002 TcpHolder :: Pointer TcpHolder::Accept ( uv_stream_t * server , InspectorSocket :: DelegatePointer delegate ) { // \u65b0\u5efa\u4e00\u4e2aTcpHolder\u5bf9\u8c61\uff0cTcpHolder\u662f\u5bf9uv_tcp_t\u548cdelegate\u7684\u5c01\u88c5 TcpHolder * result = new TcpHolder ( std :: move ( delegate )); // \u62ff\u5230TcpHolder\u5bf9\u8c61\u7684uv_tcp_t\u7ed3\u6784\u4f53 uv_stream_t * tcp = reinterpret_cast < uv_stream_t *> ( & result -> tcp_ ); // \u521d\u59cb\u5316 int err = uv_tcp_init ( server -> loop , & result -> tcp_ ); // \u6458\u53d6\u4e00\u4e2aTCP\u8fde\u63a5\u5bf9\u5e94\u7684fd\u4fdd\u5b58\u5230TcpHolder\u7684uv_tcp_t\u7ed3\u6784\u4f53\u4e2d\uff08\u5373\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684tcp\u5b57\u6bb5\uff09 uv_accept ( server , tcp ); // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u65f6\u6267\u884cOnDataReceivedCb\u56de\u8c03 uv_read_start ( tcp , allocate_buffer , OnDataReceivedCb ); return TcpHolder :: Pointer ( result ); } 2 \u65b0\u5efa\u4e00\u4e2aHttpHandler\u5bf9\u8c61\u3002 explicit HttpHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : ProtocolHandler ( inspector , std :: move ( tcp )){ llhttp_init ( & parser_ , HTTP_REQUEST , & parser_settings ); llhttp_settings_init ( & parser_settings ); parser_settings . on_header_field = OnHeaderField ; parser_settings . on_header_value = OnHeaderValue ; parser_settings . on_message_complete = OnMessageComplete ; parser_settings . on_url = OnPath ; } ProtocolHandler :: ProtocolHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : inspector_ ( inspector ), tcp_ ( std :: move ( tcp )) { // \u8bbe\u7f6eTCP\u6570\u636e\u7684handler\uff0cTCP\u662f\u53ea\u8d1f\u8d23\u4f20\u8f93\uff0c\u6570\u636e\u7684\u89e3\u6790\u4ea4\u7ed9handler\u5904\u7406 tcp_ -> SetHandler ( this ); } HttpHandler\u662f\u5bf9uv_tcp_t\u7684\u5c01\u88c5\uff0c\u4e3b\u8981\u901a\u8fc7HTTP\u89e3\u6790\u5668llhttp\u5bf9HTTP\u534f\u8bae\u8fdb\u884c\u89e3\u6790\u3002 3 \u8c03\u7528inspector->SwitchProtocol()\u5207\u6362\u5f53\u524d\u534f\u8bae\u4e3aHTTP\uff0c\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0c\u9996\u5148\u8981\u7ecf\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u4eceHTTP\u534f\u8bae\u5347\u7ea7\u5230WebSocket\u534f\u8bae\uff0c\u5347\u7ea7\u6210\u529f\u540e\u5c31\u4f7f\u7528Websocket\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u7ed3\u6784\u56fe\u3002 \u81f3\u6b64\uff0c\u5c31\u5b8c\u6210\u4e86\u8fde\u63a5\u5904\u7406\u7684\u5206\u6790\u3002","title":"3.2.2 \u5904\u7406\u8fde\u63a5"},{"location":"chapter24-Inspector/#323","text":"\u5b8c\u6210\u4e86TCP\u8fde\u63a5\u7684\u5904\u7406\u540e\uff0c\u63a5\u4e0b\u6765\u8981\u5b8c\u6210\u534f\u8bae\u5347\u7ea7\uff0c\u56e0\u4e3aInspector\u662f\u901a\u8fc7WebSocket\u534f\u8bae\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\uff0c\u6240\u4ee5\u9700\u8981\u901a\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u6765\u5b8c\u6210HTTP\u5230WebSocekt\u534f\u8bae\u7684\u5347\u7ea7\u3002\u4ece\u521a\u624d\u7684\u5206\u6790\u4e2d\u770b\u5f53\u6709\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cOnDataReceivedCb\u56de\u8c03\u3002 void TcpHolder::OnDataReceivedCb ( uv_stream_t * tcp , ssize_t nread , const uv_buf_t * buf ) { TcpHolder * holder = From ( tcp ); holder -> ReclaimUvBuf ( buf , nread ); // \u8c03\u7528handler\u7684onData\uff0c\u76ee\u524dhandler\u662fHTTP\u534f\u8bae holder -> handler_ -> OnData ( & holder -> buffer ); } TCP\u5c42\u6536\u5230\u6570\u636e\u540e\u4ea4\u7ed9\u5e94\u7528\u5c42\u89e3\u6790\uff0c\u76f4\u63a5\u8c03\u7528\u4e0a\u5c42\u7684OnData\u56de\u8c03\u3002 void OnData ( std :: vector < char >* data ) override { // \u89e3\u6790HTTP\u534f\u8bae llhttp_execute ( & parser_ , data -> data (), data -> size ()); // \u89e3\u6790\u5b8c\u5e76\u4e14\u662f\u5347\u7ea7\u534f\u8bae\u7684\u8bf7\u6c42\u5219\u8c03\u7528delegate\u7684\u56de\u8c03OnSocketUpgrade delegate () -> OnSocketUpgrade ( event . host , event . path , event . ws_key ); } OnData\u53ef\u80fd\u4f1a\u88ab\u591a\u6b21\u56de\u8c03\uff0c\u5e76\u901a\u8fc7llhttp_execute\u89e3\u6790\u6536\u5230\u7684HTTP\u62a5\u6587\uff0c\u5f53\u53d1\u73b0\u662f\u4e00\u4e2a\u534f\u8bae\u5347\u7ea7\u7684\u8bf7\u6c42\u540e\uff0c\u5c31\u8c03\u7528OnSocketUpgrade\u56de\u8c03\u3002delegate\u662fTCP\u5c42\u4fdd\u5b58\u7684SocketSession::Delegate\u5bf9\u8c61\u3002\u6765\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684OnSocketUpgrade\u65b9\u6cd5\u3002 void SocketSession::Delegate::OnSocketUpgrade ( const std :: string & host , const std :: string & path , const std :: string & ws_key ) { std :: string id = path . empty () ? path : path . substr ( 1 ); server_ -> SessionStarted ( session_id_ , id , ws_key ); } OnSocketUpgrade\u53c8\u8c03\u7528\u6765server_\uff08InspectorSocketServer\u5bf9\u8c61\uff09\u7684SessionStarted\u3002 void InspectorSocketServer::SessionStarted ( int session_id , const std :: string & id , const std :: string & ws_key ) { // \u627e\u5230\u5bf9\u5e94\u7684session\u5bf9\u8c61 SocketSession * session = Session ( session_id ); connected_sessions_ [ session_id ]. first = id ; session -> Accept ( ws_key ); delegate_ -> StartSession ( session_id , id ); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u5206\u914d\u7684SocketSession\u5bf9\u8c61\u3002 1 \u6267\u884csession->Accept(ws_key);\u56de\u590d\u5ba2\u6237\u7aef\u540c\u610f\u534f\u8bae\u5347\u7ea7\u3002 void Accept ( const std :: string & ws_key ) { ws_socket_ -> AcceptUpgrade ( ws_key ); } \u4ece\u7ed3\u6784\u56fe\u6211\u4eec\u53ef\u4ee5\u770b\u5230ws_socket_\u662f\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002 void AcceptUpgrade ( const std :: string & accept_key ) override { char accept_string [ ACCEPT_KEY_LENGTH ]; generate_accept_string ( accept_key , & accept_string ); const char accept_ws_prefix [] = \"HTTP/1.1 101 Switching Protocols \\r\\n \" \"Upgrade: websocket \\r\\n \" \"Connection: Upgrade \\r\\n \" \"Sec-WebSocket-Accept: \" ; const char accept_ws_suffix [] = \" \\r\\n\\r\\n \" ; std :: vector < char > reply ( accept_ws_prefix , accept_ws_prefix + sizeof ( accept_ws_prefix ) - 1 ); reply . insert ( reply . end (), accept_string , accept_string + sizeof ( accept_string )); reply . insert ( reply . end (), accept_ws_suffix , accept_ws_suffix + sizeof ( accept_ws_suffix ) - 1 ); // \u56de\u590d101\u7ed9\u5ba2\u6237\u7aef WriteRaw ( reply , WriteRequest :: Cleanup ); // \u5207\u6362handler\u4e3aWebSocket handler inspector_ -> SwitchProtocol ( new WsHandler ( inspector_ , std :: move ( tcp_ ))); } AcceptUpgradeh\u9996\u5148\u56de\u590d\u5ba2\u6237\u7aef101\u8868\u793a\u540c\u610f\u5347\u7ea7\u9053WebSocket\u534f\u8bae\uff0c\u7136\u540e\u5207\u6362\u6570\u636e\u5904\u7406\u5668\u4e3aWsHandler\uff0c\u5373\u540e\u7eed\u7684\u6570\u636e\u6309\u7167WebSocket\u534f\u8bae\u5904\u7406\u3002 2 \u6267\u884cdelegate_->StartSession(session_id, id)\u5efa\u7acb\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 void InspectorIoDelegate::StartSession ( int session_id , const std :: string & target_id ) { auto session = main_thread_ -> Connect ( std :: unique_ptr < InspectorSessionDelegate > ( new IoSessionDelegate ( request_queue_ -> handle (), session_id ) ), true ); if ( session ) { sessions_ [ session_id ] = std :: move ( session ); fprintf ( stderr , \"Debugger attached. \\n \" ); } } \u9996\u5148\u901a\u8fc7main_thread_->Connect\u62ff\u5230\u4e00\u4e2asession\uff0c\u5e76\u5728InspectorIoDelegate\u4e2d\u8bb0\u5f55\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0bmain_thread_->Connect\u7684\u903b\u8f91\uff08main_thread_\u662fMainThreadHandle\u5bf9\u8c61\uff09\u3002 std :: unique_ptr < InspectorSession > MainThreadHandle :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { return std :: unique_ptr < InspectorSession > ( new CrossThreadInspectorSession ( ++ next_session_id_ , shared_from_this (), std :: move ( delegate ), prevent_shutdown )); } Connect\u51fd\u6570\u65b0\u5efa\u4e86\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002 CrossThreadInspectorSession ( int id , std :: shared_ptr < MainThreadHandle > thread , std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) // \u521b\u5efa\u4e00\u4e2aMainThreadSessionState\u5bf9\u8c61 : state_ ( thread , std :: bind ( MainThreadSessionState :: Create , std :: placeholders :: _1 , prevent_shutdown )) { // \u6267\u884cMainThreadSessionState::Connect state_ . Call ( & MainThreadSessionState :: Connect , std :: move ( delegate )); } \u7ee7\u7eed\u770bMainThreadSessionState::Connect\u3002 void Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate ) { Agent * agent = thread_ -> inspector_agent (); session_ = agent -> Connect ( std :: move ( delegate ), prevent_shutdown_ ); } \u7ee7\u7eed\u8c03agent->Connect\u3002 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ )); } \u7ee7\u7eed\u8c03connectFrontend int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u521b\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5e76\u4e14\u5728channels_\u4e2d\u4fdd\u5b58\u4e86\u6620\u5c04\u5173\u7cfb\u3002\u770b\u770bChannelImpl\u7684\u6784\u9020\u51fd\u6570\u3002 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: unique_ptr < InspectorSessionDelegate > delegate , ...) : delegate_ ( std :: move ( delegate )) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); } ChannelImpl\u8c03\u7528inspector->connect\u5efa\u7acb\u4e86\u4e00\u4e2a\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002\u7ed3\u6784\u56fe\u5927\u81f4\u5982\u4e0b\u3002","title":"3.2.3 \u534f\u8bae\u5347\u7ea7"},{"location":"chapter24-Inspector/#324-v8-inspector","text":"TCP\u8fde\u63a5\u5efa\u7acb\u4e86\uff0c\u534f\u8bae\u5347\u7ea7\u4e5f\u5b8c\u6210\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u5f00\u59cb\u5904\u7406\u4e1a\u52a1\u6570\u636e\u3002\u4ece\u524d\u9762\u7684\u5206\u6790\u4e2d\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cTcpHoldler\u7684handler_->OnData\u56de\u8c03\u3002\u56e0\u4e3a\u5df2\u7ecf\u5b8c\u6210\u4e86\u534f\u8bae\u5347\u7ea7\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u7684handler\u53d8\u6210\u4e86WeSocket handler\u3002 void OnData ( std :: vector < char >* data ) override { // 1. Parse. int processed = 0 ; do { processed = ParseWsFrames ( * data ); // 2. Fix the data size & length if ( processed > 0 ) { remove_from_beginning ( data , processed ); } } while ( processed > 0 && ! data -> empty ()); } OnData\u901a\u8fc7ParseWsFrames\u89e3\u6790WebSocket\u534f\u8bae\u3002 int ParseWsFrames ( const std :: vector < char >& buffer ) { int bytes_consumed = 0 ; std :: vector < char > output ; bool compressed = false ; // \u89e3\u6790WebSocket\u534f\u8bae ws_decode_result r = decode_frame_hybi17 ( buffer , true /* client_frame */ , & bytes_consumed , & output , & compressed ); // \u6267\u884cdelegate\u7684\u56de\u8c03 delegate () -> OnWsFrame ( output ); return bytes_consumed ; } \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7delegate\u662fTcpHoldler\u7684delegate\uff0c\u5373SocketSession::Delegate\u5bf9\u8c61\u3002 void SocketSession::Delegate::OnWsFrame ( const std :: vector < char >& data ) { server_ -> MessageReceived ( session_id_ , std :: string ( data . data (), data . size ())); } \u7ee7\u7eed\u56de\u8c03server_->MessageReceived\u3002\u4ece\u7ed3\u6784\u56fe\u53ef\u4ee5\u770b\u5230server_\u662fInspectorSocketServer\u5bf9\u8c61\u3002 void MessageReceived ( int session_id , const std :: string & message ) { delegate_ -> MessageReceived ( session_id , message ); } \u7ee7\u7eed\u56de\u8c03delegate_->MessageReceived\u3002InspectorSocketServer\u7684delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 void InspectorIoDelegate::MessageReceived ( int session_id , const std :: string & message ) { auto session = sessions_ . find ( session_id ); if ( session != sessions_ . end ()) session -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684session\u3002session\u662f\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002\u770b\u770b\u4ed6\u7684Dispatch\u65b9\u6cd5\u3002 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u6267\u884cMainThreadSessionState::Dispatch\u3002 void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); if ( client ) client -> dispatchMessageFromFrontend ( session_id_ , message ); } \u7ee7\u7eed\u8c03client->dispatchMessageFromFrontend\u3002 void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684ChannelImpl\uff0c\u7ee7\u7eed\u8c03ChannelImpl\u7684dispatchProtocolMessage\u3002 voiddispatchProtocolMessage ( const StringView & message ) { session_ -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u548cV8 Inspector\u7684\u4f1a\u8bdd\u5bf9\u8c61\u628a\u6570\u636e\u53d1\u9001\u7ed9V8\u3002\u81f3\u6b64\u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u901a\u4fe1\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002","title":"3.2.4 \u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u6570\u636e\u5904\u7406"},{"location":"chapter24-Inspector/#325-v8-inspector","text":"\u63a5\u7740\u770b\u4eceV8 inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u4f20\u9012\u903b\u8f91\u3002V8 inspector\u662f\u901a\u8fc7channel\u7684sendResponse\u51fd\u6570\u4f20\u9012\u7ed9\u5ba2\u6237\u7aef\u7684\u3002 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fIoSessionDelegate\u5bf9\u8c61\u3002 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { request_queue_ -> Post ( id_ , TransportAction :: kSendMessage , StringBuffer :: create ( message )); } request_queue_\u662fRequestQueueData\u5bf9\u8c61\u3002 void Post ( int session_id , TransportAction action , std :: unique_ptr < StringBuffer > message ) { Mutex :: ScopedLock scoped_lock ( state_lock_ ); bool notify = messages_ . empty (); messages_ . emplace_back ( action , session_id , std :: move ( message )); if ( notify ) { CHECK_EQ ( 0 , uv_async_send ( & async_ )); incoming_message_cond_ . Broadcast ( scoped_lock ); } } Post\u9996\u5148\u628a\u6d88\u606f\u5165\u961f\uff0c\u7136\u540e\u901a\u8fc7\u5f02\u6b65\u7684\u65b9\u5f0f\u901a\u77e5async_\u63a5\u7740\u770basync_\u7684\u5904\u7406\u51fd\u6570\uff08\u5728\u5b50\u7ebf\u7a0b\u7684\u4e8b\u4ef6\u5faa\u73af\u91cc\u6267\u884c\uff09\u3002 uv_async_init ( loop , & async_ , []( uv_async_t * async ) { // \u62ff\u5230async\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587 RequestQueueData * wrapper = node :: ContainerOf ( & RequestQueueData :: async_ , async ); // \u6267\u884cRequestQueueData\u7684DoDispatch wrapper -> DoDispatch (); }); void DoDispatch () { for ( const auto & request : GetMessages ()) { request . Dispatch ( server_ ); } } request\u662fRequestToServer\u5bf9\u8c61\u3002 void Dispatch ( InspectorSocketServer * server ) const { switch ( action_ ) { case TransportAction :: kSendMessage : server -> Send ( session_id_ , protocol :: StringUtil :: StringViewToUtf8 ( message_ -> string ())); break ; } } \u63a5\u7740\u770bInspectorSocketServer\u7684Send\u3002 void InspectorSocketServer::Send ( int session_id , const std :: string & message ) { SocketSession * session = Session ( session_id ); if ( session != nullptr ) { session -> Send ( message ); } } session\u4ee3\u8868\u53ef\u5ba2\u6237\u7aef\u7684\u4e00\u4e2a\u8fde\u63a5\u3002 void SocketSession::Send ( const std :: string & message ) { ws_socket_ -> Write ( message . data (), message . length ()); } \u63a5\u7740\u8c03\u7528WebSocket handler\u7684Write\u3002 void Write ( const std :: vector < char > data ) override { std :: vector < char > output = encode_frame_hybi17 ( data ); WriteRaw ( output , WriteRequest :: Cleanup ); } WriteRaw\u662f\u57fa\u7c7bProtocolHandler\u5b9e\u73b0\u7684\u3002 int ProtocolHandler::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { return tcp_ -> WriteRaw ( buffer , write_cb ); } \u6700\u7ec8\u662f\u901a\u8fc7TCP\u8fde\u63a5\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\u3002 int TcpHolder::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { // Freed in write_request_cleanup WriteRequest * wr = new WriteRequest ( handler_ , buffer ); uv_stream_t * stream = reinterpret_cast < uv_stream_t *> ( & tcp_ ); int err = uv_write ( & wr -> req , stream , & wr -> buf , 1 , write_cb ); if ( err < 0 ) delete wr ; return err < 0 ; } \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0csocket\u53ef\u5199\u7684\u65f6\u5019\u53d1\u9001\u6570\u636e\u7ed9\u5ba2\u6237\u7aef\u3002","title":"3.2.5 V8 Inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u5904\u7406"},{"location":"chapter24-Inspector/#4-inspector","text":"\u9ed8\u8ba4\u6253\u5f00Inspector\u80fd\u529b\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u8fd9\u610f\u5473\u7740\u80fd\u8fde\u4e0awebsocket\u670d\u52a1\u5668\u7684\u5ba2\u6237\u7aef\u90fd\u80fd\u901a\u8fc7\u534f\u8bae\u63a7\u5236Node.js\u8fdb\u7a0b\uff0c\u901a\u5e38\u6211\u4eec\u662f\u5728Node.js\u8fdb\u7a0b\u51fa\u73b0\u95ee\u9898\u7684\u65f6\u5019\uff0c\u52a8\u6001\u5f00\u542fInspector\u3002 const http = require ( ' http ' ); const inspector = require ( ' inspector ' ); const fs = require ( ' fs ' ); http . createServer (( req , res ) => { if ( req . url == ' debug ' ) { const session = new inspector . Session (); session . connect (); session . post ( ' Profiler . enable ' , () => { session . post ( ' Profiler . start ' , () => { session . post ( ' Profiler . stop ' , ( err , { profile }) => { if ( ! err ) { fs . writeFileSync ( ' . / profile . cpuprofile ' , JSON . stringify ( profile )); } session . disconnect (); res . end ( ' ok ' ); }); }); }); } else { res . end ( ' ok ' ); } }). listen ( 80 ); \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7url\u53c2\u6570\u63a7\u5236Inspector\u7684\u80fd\u529b\uff0c\u672c\u5730\u8c03\u8bd5\u65f6\u53ef\u4ee5\u5728vscode\u91cc\u53ef\u4ee5\u76f4\u63a5\u770b\u5230\u6570\u636e\u3002","title":"4 \u52a8\u6001\u5f00\u542fInspector"},{"location":"chapter24-Inspector/#5","text":"V8 inspector\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u8c03\u8bd5\u53ea\u662f\u5b83\u5176\u4e2d\u4e00\u4e2a\u80fd\u529b\uff0c\u4ed6\u8fd8\u53ef\u4ee5\u83b7\u53d6\u5185\u5b58\u3001CPU\u7b49\u6570\u636e\uff0c\u5177\u4f53\u80fd\u529b\u8bf7\u53c2\u8003\u6587\u6863\u3002 \u540e\u8bb0\uff1aNode.js\u7684inspector\u662f\u5728Node.js\u989d\u5916\u7ebf\u7a0b\u91cc\u5f00\u542f\u7684\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u901a\u8fc7Node.js\u4f5c\u4e3a\u4e2d\u95f4\u4eba\uff0c\u5b8c\u6210\u5ba2\u6237\u7aef\u548cV8 inspector\u7684\u901a\u4fe1\uff08\u8c03\u8bd5\u3001\u6536\u96c6\u6570\u636e\uff09\uff0c\u662f\u6211\u4eec\u8c03\u8bd5\u548c\u8bca\u65adNode.js\u8fdb\u7a0b\u975e\u5e38\u597d\u7684\u65b9\u5f0f\u3002 \u53c2\u8003\u5185\u5bb9\uff1a 1 Debugging Guide 2 inspector 3 \u5f00\u6e90\u7684inspector agent\u5b9e\u73b0 4 inpector\u534f\u8bae\u6587\u6863 5 Debugging Node.js with Chrome DevTools","title":"5 \u6536\u96c6\u6570\u636e"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/","text":"\u8c03\u8bd5\u3001\u8bca\u65ad\u5b50\u7ebf\u7a0b\u6700\u76f4\u63a5\u7684\u65b9\u5f0f\u5c31\u662f\u50cf\u8c03\u8bd5\u3001\u8bca\u65ad\u4e3b\u7ebf\u7a0b\u4e00\u6837\uff0c\u4f46\u662f\u65e0\u8bba\u662f\u52a8\u6001\u5f00\u542f\u8fd8\u662f\u9759\u6001\u5f00\u542f\uff0c\u5b50\u7ebf\u7a0b\u90fd\u4e0d\u53ef\u907f\u514d\u5730\u9700\u8981\u5185\u7f6e\u4e00\u4e9b\u76f8\u5173\u7684\u975e\u4e1a\u52a1\u4ee3\u7801\uff0c\u672c\u6587\u4ecb\u7ecd\u53e6\u5916\u4e00\u79cd\u5bf9\u5b50\u7ebf\u7a0b\u4ee3\u7801\u65e0\u4fb5\u5165\u7684\u8c03\u8bd5\u65b9\u5f0f\uff0c\u53e6\u5916\u4e5f\u4ecb\u7ecd\u4e00\u4e0b\u901a\u8fc7\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u7684\u65b9\u5f0f\u3002 1 \u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u7684Inspector \u00b6 \u5728Node.js\u542f\u52a8\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u521d\u59cb\u5316Inspector\u3002 env_ -> InitializeInspector ( std :: move ( inspector_parent_handle_ )); \u5728\u5206\u6790InitializeInspector\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0binspector_parent_handle_\u3002 std :: unique_ptr < inspector :: ParentInspectorHandle > inspector_parent_handle_ ; inspector_parent_handle_\u662f\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u6865\u6881\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u7684\u521d\u59cb\u5316\u903b\u8f91\uff08\u5728\u4e3b\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 inspector_parent_handle_ = env -> inspector_agent () -> GetParentHandle ( thread_id_ , url ); \u8c03\u7528agent\u7684GetParentHandle\u83b7\u53d6\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\u3002 std :: unique_ptr < ParentInspectorHandle > Agent :: GetParentHandle ( int thread_id , const std :: string & url ) { return client_ -> getWorkerManager () -> NewParentHandle ( thread_id , url ); } \u5185\u90e8\u5176\u5b9e\u662f\u901a\u8fc7client_->getWorkerManager()\u5bf9\u8c61\u7684NewParentHandle\u65b9\u6cd5\u83b7\u53d6ParentInspectorHandle\u5bf9\u8c61\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bWorkerManager\u7684NewParentHandle\u3002 std :: unique_ptr < ParentInspectorHandle > WorkerManager :: NewParentHandle ( int thread_id , const std :: string & url ) { bool wait = ! delegates_waiting_on_start_ . empty (); return std :: make_unique < ParentInspectorHandle > ( thread_id , url , thread_ , wait ); } ParentInspectorHandle :: ParentInspectorHandle ( int id , const std :: string & url , std :: shared_ptr < MainThreadHandle > parent_thread , bool wait_for_connect ) : id_ ( id ), url_ ( url ), parent_thread_ ( parent_thread ), wait_ ( wait_for_connect ) {} \u6700\u7ec8\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u5165\u6240\u793a\u3002 \u5206\u6790\u5b8cParentInspectorHandle\u540e\u7ee7\u7eed\u770b\u4e00\u4e0benv_->InitializeInspector(std::move(inspector_parent_handle_))\u7684\u903b\u8f91\uff08\u5728\u5b50\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 int Environment::InitializeInspector ( std :: unique_ptr < inspector :: ParentInspectorHandle > parent_handle ) { std :: string inspector_path ; inspector_path = parent_handle -> url (); inspector_agent_ -> SetParentHandle ( std :: move ( parent_handle )); inspector_agent_ -> Start ( inspector_path , options_ -> debug_options (), inspector_host_port (), is_main_thread ()); } \u9996\u5148\u628aParentInspectorHandle\u5bf9\u8c61\u4fdd\u5b58\u5230agent\u4e2d\uff0c\u7136\u540e\u8c03\u7528agent\u7684Start\u65b9\u6cd5\u3002 bool Agent::Start (...) { // \u65b0\u5efaclient\u5bf9\u8c61 client_ = std :: make_shared < NodeInspectorClient > ( parent_env_ , is_main ); // \u8c03\u7528agent\u4e2d\u4fdd\u5b58\u7684ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted parent_handle_ -> WorkerStarted ( client_ -> getThreadHandle (), ...); } Agent::Start\u521b\u5efa\u4e86\u4e00\u4e2aclient\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted\u65b9\u6cd5\uff08\u521a\u624dSetParentHandle\u7684\u65f6\u5019\u4fdd\u5b58\u7684\uff09\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770bparent_handle_->WorkerStarted\u3002 void ParentInspectorHandle::WorkerStarted ( std :: shared_ptr < MainThreadHandle > worker_thread , bool waiting ) { std :: unique_ptr < Request > request ( new WorkerStartedRequest ( id_ , url_ , worker_thread , waiting )); parent_thread_ -> Post ( std :: move ( request )); } WorkerStarted\u521b\u5efa\u4e86\u4e00\u4e2aWorkerStartedRequest\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7parent_thread_->Post\u63d0\u4ea4\uff0cparent_thread_\u662fMainThreadInterface\u5bf9\u8c61\u3002 void MainThreadInterface::Post ( std :: unique_ptr < Request > request ) { Mutex :: ScopedLock scoped_lock ( requests_lock_ ); // \u4e4b\u524d\u662f\u7a7a\u5219\u9700\u8981\u5524\u9192\u6d88\u8d39\u8005 bool needs_notify = requests_ . empty (); // \u6d88\u606f\u5165\u961f requests_ . push_back ( std :: move ( request )); if ( needs_notify ) { // \u83b7\u53d6\u5f53\u524d\u5bf9\u8c61\u7684\u4e00\u4e2a\u5f31\u5f15\u7528 std :: weak_ptr < MainThreadInterface >* interface_ptr = new std :: weak_ptr < MainThreadInterface > ( shared_from_this ()); // \u8bf7\u6c42V8\u6267\u884cRequestInterrupt\u5165\u53c2\u5bf9\u5e94\u7684\u56de\u8c03 isolate_ -> RequestInterrupt ([]( v8 :: Isolate * isolate , void * opaque ) { // \u628a\u6267\u884c\u65f6\u4f20\u5165\u7684\u53c2\u6570\u8f6c\u6210MainThreadInterface std :: unique_ptr < std :: weak_ptr < MainThreadInterface >> interface_ptr { static_cast < std :: weak_ptr < MainThreadInterface >*> ( opaque ) }; // \u5224\u65ad\u5bf9\u8c61\u662f\u5426\u8fd8\u6709\u6548\uff0c\u662f\u5219\u8c03\u7528DispatchMessages if ( auto iface = interface_ptr -> lock ()) iface -> DispatchMessages (); }, static_cast < void *> ( interface_ptr )); } // \u5524\u9192\u6d88\u8d39\u8005 incoming_message_cond_ . Broadcast ( scoped_lock ); } \u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770b\u56de\u8c03\u91cc\u6267\u884cMainThreadInterface\u5bf9\u8c61DispatchMessages\u65b9\u6cd5\u7684\u903b\u8f91\u3002 void MainThreadInterface::DispatchMessages () { // \u904d\u5386\u8bf7\u6c42\u961f\u5217 requests_ . swap ( dispatching_message_queue_ ); while ( ! dispatching_message_queue_ . empty ()) { MessageQueue :: value_type task ; std :: swap ( dispatching_message_queue_ . front (), task ); dispatching_message_queue_ . pop_front (); // \u6267\u884c\u4efb\u52a1\u51fd\u6570 task -> Call ( this ); } } task\u662fWorkerStartedRequest\u5bf9\u8c61\uff0c\u770b\u4e00\u4e0bCall\u65b9\u6cd5\u7684\u4ee3\u7801\u3002 void Call ( MainThreadInterface * thread ) override { auto manager = thread -> inspector_agent () -> GetWorkerManager (); manager -> WorkerStarted ( id_ , info_ , waiting_ ); } \u63a5\u7740\u8c03\u7528agent\u7684WorkerManager\u7684WorkerStarted\u3002 void WorkerManager::WorkerStarted ( int session_id , const WorkerInfo & info , bool waiting ) { children_ . emplace ( session_id , info ); for ( const auto & delegate : delegates_ ) { Report ( delegate . second , info , waiting ); } } WorkerStarted\u8bb0\u5f55\u4e86\u4e00\u4e2aid\u548c\u4e0a\u4e0b\u6587\uff0c\u56e0\u4e3adelegates_\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f\u7a7a\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u6267\u884c\u3002\u81f3\u6b64\uff0c\u5b50\u7ebf\u7a0bInspector\u521d\u59cb\u5316\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u548c\u4e3b\u7ebf\u7a0b\u4e0d\u4e00\u6837\uff0c\u4e3b\u7ebf\u7a0b\u4f1a\u542f\u52a8\u4e00\u4e2aWebSocket\u670d\u52a1\u5668\u63a5\u6536\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\uff0c\u800c\u5b50\u7ebf\u7a0b\u53ea\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u7ebf\u7a0b\u662f\u5982\u4f55\u52a8\u6001\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u3002 2 \u4e3b\u7ebf\u7a0b\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b \u00b6 \u6211\u4eec\u53ef\u4ee5\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u5f00\u542f\u5bf9\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002 const { Worker , workerData } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); // \u65b0\u5efa\u4e00\u4e2a\u65b0\u7684\u901a\u4fe1\u901a\u9053 const session = new Session (); session . connect (); // \u521b\u5efa\u5b50\u7ebf\u7a0b const worker = new Worker ( ' . / httpServer . js ' , { workerData : { port : 80 }}); // \u5b50\u7ebf\u7a0b\u542f\u52a8\u6210\u529f\u540e\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b worker . on ( ' online ' , () => { session . post ( \"NodeWorker.enable\" , { waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err ); }); }); // \u9632\u6b62\u4e3b\u7ebf\u7a0b\u9000\u51fa setInterval (() => {}, 100000 ); \u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0bconnect\u51fd\u6570\u7684\u903b\u8f91\u3002 connect () { this [ connectionSymbol ] = new Connection (( message ) => this [ onMessageSymbol ]( message )); } \u65b0\u5efa\u4e86\u4e00\u4e2aConnection\u5bf9\u8c61\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u5728\u6536\u5230\u6d88\u606f\u65f6\u88ab\u56de\u8c03\u3002Connection\u662fC++\u5c42\u5bfc\u51fa\u7684\u5bf9\u8c61\uff0c\u7531\u6a21\u7248\u7c7bJSBindingsConnection\u5b9e\u73b0\u3002 template < typename ConnectionType > class JSBindingsConnection {} \u6211\u4eec\u770b\u770b\u5bfc\u51fa\u7684\u8def\u903b\u8f91\u3002 JSBindingsConnection < Connection >:: Bind ( env , target ); \u63a5\u7740\u770bBind\u3002 static void Bind ( Environment * env , Local < Object > target ) { // class_name\u662fConnection Local < String > class_name = ConnectionType :: GetClassName ( env ); Local < FunctionTemplate > tmpl = env -> NewFunctionTemplate ( JSBindingsConnection :: New ); tmpl -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); tmpl -> SetClassName ( class_name ); tmpl -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); env -> SetProtoMethod ( tmpl , \"dispatch\" , JSBindingsConnection :: Dispatch ); env -> SetProtoMethod ( tmpl , \"disconnect\" , JSBindingsConnection :: Disconnect ); target -> Set ( env -> context (), class_name , tmpl -> GetFunction ( env -> context ()). ToLocalChecked ()) . ToChecked (); } \u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew Connection\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cJSBindingsConnection::New\u3002 static void New ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); Local < Function > callback = info [ 0 ]. As < Function > (); new JSBindingsConnection ( env , info . This (), callback ); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aJSBindingsConnection\u5bf9\u8c61\u65f6\u7684\u903b\u8f91\u3002 JSBindingsConnection ( Environment * env , Local < Object > wrap , Local < Function > callback ) : AsyncWrap ( env , wrap , PROVIDER_INSPECTORJSBINDING ), callback_ ( env -> isolate (), callback ) { Agent * inspector = env -> inspector_agent (); session_ = LocalConnection :: Connect ( inspector , std :: make_unique < JSBindingsSessionDelegate > ( env , this ) ); } static std :: unique_ptr < InspectorSession > Connect ( Agent * inspector , std :: unique_ptr < InspectorSessionDelegate > delegate ) { return inspector -> Connect ( std :: move ( delegate ), false ); } \u6700\u7ec8\u662f\u4f20\u5165\u4e86\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u8c03\u7528Agent\u7684Connect\u65b9\u6cd5\u3002 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); // JSBindingsConnection\u5bf9\u8c61\u7684session_\u5b57\u6bb5\u6307\u5411\u7684\u5bf9\u8c61 return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ ) ); } Agent\u7684Connect\u65b9\u6cd5\u7ee7\u7eed\u8c03\u7528client_->connectFrontend\u3002 int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u65b0\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5bf9\u8c61\uff0c\u5728\u65b0\u5efaChannelImpl\u65f6\uff0c\u4f1a\u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u5904\u7406\u7684\u903b\u8f91\u3002 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: shared_ptr < WorkerManager > worker_manager , std :: unique_ptr < InspectorSessionDelegate > delegate , std :: shared_ptr < MainThreadHandle > main_thread_ , bool prevent_shutdown ) : delegate_ ( std :: move ( delegate )), prevent_shutdown_ ( prevent_shutdown ), retaining_context_ ( false ) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); // Node.js\u62d3\u5c55\u547d\u4ee4\u7684\u5904\u7406\u5206\u53d1\u5668 node_dispatcher_ = std :: make_unique < protocol :: UberDispatcher > ( this ); // trace\u76f8\u5173 tracing_agent_ = std :: make_unique < protocol :: TracingAgent > ( env , main_thread_ ); tracing_agent_ -> Wire ( node_dispatcher_ . get ()); // \u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173 if ( worker_manager ) { worker_agent_ = std :: make_unique < protocol :: WorkerAgent > ( worker_manager ); worker_agent_ -> Wire ( node_dispatcher_ . get ()); } // \u5904\u7406runtime runtime_agent_ = std :: make_unique < protocol :: RuntimeAgent > (); runtime_agent_ -> Wire ( node_dispatcher_ . get ()); } \u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173\u7684\u903b\u8f91\u3002\u770b\u4e00\u4e0b worker_agent_->Wire\u3002 void WorkerAgent::Wire ( UberDispatcher * dispatcher ) { frontend_ . reset ( new NodeWorker :: Frontend ( dispatcher -> channel ())); NodeWorker :: Dispatcher :: wire ( dispatcher , this ); auto manager = manager_ . lock (); workers_ = std :: make_shared < NodeWorkers > ( frontend_ , manager -> MainThread ()); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b \u63a5\u7740\u770b\u4e00\u4e0bNodeWorker::Dispatcher::wire(dispatcher, this)\u7684\u903b\u8f91\u3002 void Dispatcher::wire ( UberDispatcher * uber , Backend * backend ) { std :: unique_ptr < DispatcherImpl > dispatcher ( new DispatcherImpl ( uber -> channel (), backend )); uber -> setupRedirects ( dispatcher -> redirects ()); uber -> registerBackend ( \"NodeWorker\" , std :: move ( dispatcher )); } \u9996\u5148\u65b0\u5efa\u4e86\u4e00\u4e2aDispatcherImpl\u5bf9\u8c61\u3002 DispatcherImpl ( FrontendChannel * frontendChannel , Backend * backend ) : DispatcherBase ( frontendChannel ) , m_backend ( backend ) { m_dispatchMap [ \"NodeWorker.sendMessageToWorker\" ] = & DispatcherImpl :: sendMessageToWorker ; m_dispatchMap [ \"NodeWorker.enable\" ] = & DispatcherImpl :: enable ; m_dispatchMap [ \"NodeWorker.disable\" ] = & DispatcherImpl :: disable ; m_dispatchMap [ \"NodeWorker.detach\" ] = & DispatcherImpl :: detach ; } \u9664\u4e86\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\uff0c\u53e6\u5916\u4e86\u4e00\u4e2akv\u6570\u636e\u7ed3\u6784\uff0c\u8fd9\u4e2a\u662f\u4e00\u4e2a\u8def\u7531\u914d\u7f6e\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u65b0\u5efa\u5b8cDispatcherImpl\u540e\u53c8\u8c03\u7528\u4e86uber->registerBackend(\"NodeWorker\", std::move(dispatcher))\u6ce8\u518c\u8be5\u5bf9\u8c61\u3002 void UberDispatcher::registerBackend ( const String & name , std :: unique_ptr < protocol :: DispatcherBase > dispatcher ) { m_dispatchers [ name ] = std :: move ( dispatcher ); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u5176\u5b9e\u662f\u5efa\u7acb\u4e86\u4e00\u4e2a\u8def\u7531\u4f53\u7cfb\uff0c\u540e\u9762\u6536\u5230\u547d\u4ee4\u65f6\u5c31\u4f1a\u6839\u636e\u8fd9\u4e9b\u8def\u7531\u914d\u7f6e\u8fdb\u884c\u8f6c\u53d1\uff0c\u7c7b\u4f3cNode.js Express\u6846\u67b6\u8def\u7531\u673a\u5236\u3002\u8fd9\u65f6\u5019\u53ef\u4ee5\u901a\u8fc7session\u7684post\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001NodeWorker.enable\u547d\u4ee4\u6765\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002\u6211\u4eec\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 post ( method , params , callback ) { // \u5ffd\u7565\u53c2\u6570\u5904\u7406 // \u4fdd\u5b58\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 if ( callback ) { this [ messageCallbacksSymbol ]. set ( id , callback ); } // \u8c03\u7528C++\u7684dispatch this [ connectionSymbol ]. dispatch ( JSONStringify ( message )); } this[connectionSymbol]\u5bf9\u5e94\u7684\u662fJSBindingsConnection\u5bf9\u8c61\u3002 static void Dispatch ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); JSBindingsConnection * session ; ASSIGN_OR_RETURN_UNWRAP ( & session , info . Holder ()); if ( session -> session_ ) { session -> session_ -> Dispatch ( ToProtocolString ( env -> isolate (), info [ 0 ]) -> string ()); } } session_\u662f\u4e00\u4e2aSameThreadInspectorSession\u5bf9\u8c61\u3002 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u4e86ChannelImpl\u7684dispatchProtocolMessage\u3002 void dispatchProtocolMessage ( const StringView & message ) { std :: string raw_message = protocol :: StringUtil :: StringViewToUtf8 ( message ); std :: unique_ptr < protocol :: DictionaryValue > value = protocol :: DictionaryValue :: cast ( protocol :: StringUtil :: parseMessage ( raw_message , false )); int call_id ; std :: string method ; // \u89e3\u6790\u547d\u4ee4 node_dispatcher_ -> parseCommand ( value . get (), & call_id , & method ); // \u5224\u65ad\u547d\u4ee4\u662fV8\u5185\u7f6e\u547d\u4ee4\u8fd8\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4 if ( v8_inspector :: V8InspectorSession :: canDispatchMethod ( Utf8ToStringView ( method ) -> string ())) { session_ -> dispatchProtocolMessage ( message ); } else { node_dispatcher_ -> dispatch ( call_id , method , std :: move ( value ), raw_message ); } } \u56e0\u4e3aNodeWorker.enable\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u8d70\u5230else\u91cc\u9762\u7684\u903b\u8f91\u3002\u6839\u636e\u8def\u7531\u914d\u7f6e\u627e\u5230\u8be5\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u903b\u8f91\uff08NodeWorker.enable\u4ee5.\u5207\u5206\uff0c\u5bf9\u5e94\u4e24\u7ea7\u8def\u7531\uff09\u3002 void UberDispatcher::dispatch ( int callId , const String & in_method , std :: unique_ptr < Value > parsedMessage , const ProtocolMessage & rawMessage ) { // \u627e\u5230\u4e00\u7ea7\u8def\u7531\u914d\u7f6e protocol :: DispatcherBase * dispatcher = findDispatcher ( method ); std :: unique_ptr < protocol :: DictionaryValue > messageObject = DictionaryValue :: cast ( std :: move ( parsedMessage )); // \u4ea4\u7ed9\u4e00\u7ea7\u8def\u7531\u5904\u7406\u5668\u5904\u7406 dispatcher -> dispatch ( callId , method , rawMessage , std :: move ( messageObject )); } NodeWorker.enable\u5bf9\u5e94\u7684\u8def\u7531\u5904\u7406\u5668\u4ee3\u7801\u5982\u4e0b void DispatcherImpl::dispatch ( int callId , const String & method , const ProtocolMessage & message , std :: unique_ptr < protocol :: DictionaryValue > messageObject ) { // \u67e5\u627e\u4e8c\u7ea7\u8def\u7531 std :: unordered_map < String , CallHandler >:: iterator it = m_dispatchMap . find ( method ); protocol :: ErrorSupport errors ; // \u627e\u5230\u5904\u7406\u51fd\u6570 ( this ->* ( it -> second ))( callId , method , message , std :: move ( messageObject ), & errors ); } dispatch\u7ee7\u7eed\u5bfb\u627e\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u7ec8\u627e\u5230NodeWorker.enable\u547d\u4ee4\u7684\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::enable\u3002 void DispatcherImpl::enable (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> enable (...); // \u8fd4\u56de\u54cd\u5e94\u7ed9\u547d\u4ee4\uff08\u7c7b\u4f3c\u8bf7\u6c42/\u54cd\u5e94\u6a21\u5f0f\uff09 weak -> get () -> sendResponse ( callId , response ); } \u6839\u636e\u67b6\u6784\u56fe\u53ef\u4ee5\u77e5\u9053m_backend\u662fWorkerAgent\u5bf9\u8c61\u3002 DispatchResponse WorkerAgent::enable ( bool waitForDebuggerOnStart ) { auto manager = manager_ . lock (); std :: unique_ptr < AgentWorkerInspectorDelegate > delegate ( new AgentWorkerInspectorDelegate ( workers_ )); event_handle_ = manager -> SetAutoAttach ( std :: move ( delegate )); return DispatchResponse :: OK (); } \u7ee7\u7eed\u8c03\u7528WorkerManager\u7684SetAutoAttach\u65b9\u6cd5\u3002 std :: unique_ptr < WorkerManagerEventHandle > WorkerManager :: SetAutoAttach ( std :: unique_ptr < WorkerDelegate > attach_delegate ) { int id = ++ next_delegate_id_ ; // \u4fdd\u5b58delegate delegates_ [ id ] = std :: move ( attach_delegate ); const auto & delegate = delegates_ [ id ]; // \u901a\u77e5\u5b50\u7ebf\u7a0b for ( const auto & worker : children_ ) { Report ( delegate , worker . second , false ); } ... } SetAutoAttach\u904d\u5386\u5b50\u7ebf\u7a0b\u3002 void Report ( const std :: unique_ptr < WorkerDelegate >& delegate , const WorkerInfo & info , bool waiting ) { if ( info . worker_thread ) delegate -> WorkerCreated ( info . title , info . url , waiting , info . worker_thread ); } info\u662f\u4e00\u4e2aWorkerInfo\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u521d\u59cb\u5316\u548c\u4e3b\u7ebf\u7a0b\u5efa\u7acb\u5173\u7cfb\u7684\u6570\u636e\u7ed3\u6784\u3002delegate\u662fAgentWorkerInspectorDelegate\u5bf9\u8c61\u3002 void WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) override { workers_ -> WorkerCreated ( title , url , waiting , target ); } workers_\u662f\u4e00\u4e2aNodeWorkers\u5bf9\u8c61\u3002 void NodeWorkers::WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) { auto frontend = frontend_ . lock (); std :: string id = std :: to_string ( ++ next_target_id_ ); // \u5904\u7406\u6570\u636e\u901a\u4fe1\u7684delegate auto delegate = thread_ -> MakeDelegateThreadSafe ( std :: unique_ptr < InspectorSessionDelegate > ( new ParentInspectorSessionDelegate ( id , shared_from_this ()) ) ); // \u5efa\u7acb\u548c\u5b50\u7ebf\u7a0bV8 Inspector\u7684\u901a\u4fe1\u901a\u9053 sessions_ [ id ] = target -> Connect ( std :: move ( delegate ), true ); frontend -> attachedToWorker ( id , WorkerInfo ( id , title , url ), waiting ); } WorkerCreated\u5efa\u7acb\u4e86\u4e00\u6761\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684\u901a\u9053\uff0c\u7136\u540e\u901a\u77e5\u547d\u4ee4\u7684\u53d1\u9001\u65b9\u901a\u9053\u5efa\u7acb\u6210\u529f\u3002\u8fd9\u65f6\u5019\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u7740\u770battachedToWorker\u3002 void Frontend::attachedToWorker ( const String & sessionId , std :: unique_ptr < protocol :: NodeWorker :: WorkerInfo > workerInfo , bool waitingForDebugger ) { std :: unique_ptr < AttachedToWorkerNotification > messageData = AttachedToWorkerNotification :: create () . setSessionId ( sessionId ) . setWorkerInfo ( std :: move ( workerInfo )) . setWaitingForDebugger ( waitingForDebugger ) . build (); // \u89e6\u53d1NodeWorker.attachedToWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.attachedToWorker\" , std :: move ( messageData ))); } \u7ee7\u7eed\u770bsendProtocolNotification void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662f\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u3002 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { Isolate * isolate = env_ -> isolate (); HandleScope handle_scope ( isolate ); Context :: Scope context_scope ( env_ -> context ()); MaybeLocal < String > v8string = String :: NewFromTwoByte ( isolate , message . characters16 (), NewStringType :: kNormal , message . length () ); Local < Value > argument = v8string . ToLocalChecked (). As < Value > (); // \u6536\u5230\u6d88\u606f\u6267\u884c\u56de\u8c03 connection_ -> OnMessage ( argument ); } // \u6267\u884cJS\u5c42\u56de\u8c03 void OnMessage ( Local < Value > value ) { MakeCallback ( callback_ . Get ( env () -> isolate ()), 1 , & value ); } JS\u5c42\u56de\u8c03\u903b\u8f91\u5982\u4e0b\u3002 [ onMessageSymbol ]( message ) { const parsed = JSONParse ( message ); // \u6536\u5230\u7684\u6d88\u606f\u5982\u679c\u662f\u67d0\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u6709\u4e2aid\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684id\uff0c\u5426\u5219\u5219\u89e6\u53d1\u4e8b\u4ef6 if ( parsed . id ) { const callback = this [ messageCallbacksSymbol ]. get ( parsed . id ); this [ messageCallbacksSymbol ]. delete ( parsed . id ); if ( callback ) { callback ( null , parsed . result ); } } else { this . emit ( parsed . method , parsed ); this . emit ( ' inspectorNotification ' , parsed ); } } \u4e3b\u7ebf\u7a0b\u62ff\u5230Worker Session\u5bf9\u4e00\u4e2a\u7684id\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4NodeWorker.sendMessageToWorker\u52a0\u4e0a\u8be5id\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002\u5927\u81f4\u539f\u7406\u5982\u4e0b\uff0c\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u81ea\u5df1\u7684channel\u548c\u5b50\u7ebf\u7a0b\u7684channel\u8fdb\u884c\u901a\u4fe1\uff0c\u4ece\u800c\u8fbe\u5230\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u76ee\u7684\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0bNodeWorker.sendMessageToWorker\u547d\u4ee4\u7684\u903b\u8f91\uff0c\u5bf9\u5e94\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::sendMessageToWorker\u3002 void DispatcherImpl::sendMessageToWorker (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> sendMessageToWorker ( in_message , in_sessionId ); // \u54cd\u5e94 weak -> get () -> sendResponse ( callId , response ); return ; } \u7ee7\u7eed\u5206\u6790m_backend->sendMessageToWorker\u3002 DispatchResponse WorkerAgent::sendMessageToWorker ( const String & message , const String & sessionId ) { workers_ -> Receive ( sessionId , message ); return DispatchResponse :: OK (); } void NodeWorkers::Receive ( const std :: string & id , const std :: string & message ) { auto it = sessions_ . find ( id ); it -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } sessions_\u5bf9\u5e94\u7684\u662f\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784CrossThreadInspectorSession\u3002\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684Dispatch\u65b9\u6cd5\u3002 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u518d\u6b21\u8c03\u4e86MainThreadSessionState::Dispatch void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002\u7ee7\u7eed\u770b\u5b83\u7684Dispatch\u65b9\u6cd5\u3002 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\uff0c\u6700\u7ec8\u62ff\u5230\u4e86\u4e00\u4e2a\u5408\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684channel\uff0cdispatchProtocolMessage\u65b9\u6cd5\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u8be5\u65b9\u6cd5\u4f1a\u6839\u636e\u547d\u4ee4\u505a\u4e0d\u540c\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd9\u91cc\u53d1\u9001\u7684\u662fV8\u5185\u7f6e\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002\u5f53V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u4f1a\u901a\u8fc7ChannelImpl\u7684sendResponse\u8fd4\u56de\u7ed3\u679c\u3002 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662fParentInspectorSessionDelegate\u5bf9\u8c61\u3002 void SendMessageToFrontend ( const v8_inspector :: StringView & msg ) override { std :: string message = protocol :: StringUtil :: StringViewToUtf8 ( msg ); workers_ -> Send ( id_ , message ); } void NodeWorkers::Send ( const std :: string & id , const std :: string & message ) { auto frontend = frontend_ . lock (); if ( frontend ) frontend -> receivedMessageFromWorker ( id , message ); } void Frontend::receivedMessageFromWorker ( const String & sessionId , const String & message ) { std :: unique_ptr < ReceivedMessageFromWorkerNotification > messageData = ReceivedMessageFromWorkerNotification :: create () . setSessionId ( sessionId ) . setMessage ( message ) . build (); // \u89e6\u53d1NodeWorker.receivedMessageFromWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.receivedMessageFromWorker\" , std :: move ( messageData ))); } m_frontendChannel\u662f\u4e3b\u7ebf\u7a0b\u7684ChannelImpl\u5bf9\u8c61\u3002 void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fC++\u5c42\u4f20\u5165\u7684JSBindingsSessionDelegate\u5bf9\u8c61\u3002\u6700\u7ec8\u901a\u8fc7JSBindingsSessionDelegate\u5bf9\u8c61\u56de\u8c03JS\u5c42\uff0c\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\u5c31\u4e0d\u518d\u8d58\u8ff0\u3002\u81f3\u6b64\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u5177\u5907\u4e86\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b\uff0c\u4f46\u662f\u63a7\u5236\u65b9\u5f0f\u6709\u5f88\u591a\u79cd\u3002 2.1 \u4f7f\u7528\u901a\u7528\u7684V8\u547d\u4ee4 \u00b6 \u901a\u8fc7\u4e0b\u9762\u4ee3\u7801\u6536\u96c6\u5b50\u7ebf\u7a0b\u7684CPU Profile\u4fe1\u606f\u3002 const { Worker , workerData } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); const session = new Session (); session . connect (); let id = 1 ; function post ( sessionId , method , params , callback ) { session . post ( ' NodeWorker . sendMessageToWorker ' , { sessionId , message : JSON . stringify ({ id : id ++ , method , params }) }, callback ); } session . on ( ' NodeWorker . attachedToWorker ' , ( data ) => { post ( data . params . sessionId , ' Profiler . enable ' ); post ( data . params . sessionId , ' Profiler . start ' ); // \u6536\u96c6\u4e00\u6bb5\u65f6\u95f4\u540e\u63d0\u4ea4\u505c\u6b62\u6536\u96c6\u547d\u4ee4 setTimeout (() => { post ( data . params . sessionId , ' Profiler . stop ' ); }, 10000 ) }); session . on ( ' NodeWorker . receivedMessageFromWorker ' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); const worker = new Worker ( ' . / httpServer . js ' , { workerData : { port : 80 }}); worker . on ( ' online ' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { console . log ( err , \"NodeWorker.enable\" );}); }); setInterval (() => {}, 100000 ); \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u548c\u6570\u636e\u6536\u96c6\u3002 2.2 \u5728\u5b50\u7ebf\u7a0b\u4e2d\u52a8\u6001\u6267\u884c\u811a\u672c \u00b6 \u53ef\u4ee5\u901a\u8fc7\u6267\u884c\u811a\u672c\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684WebSocket\u670d\u52a1\uff0c\u50cf\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u4e00\u6837\u3002 const { Worker , workerData } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); const session = new Session (); session . connect (); let workerSessionId ; let id = 1 ; function post ( method , params ) { session . post ( ' NodeWorker . sendMessageToWorker ' , { sessionId : workerSessionId , message : JSON . stringify ({ id : id ++ , method , params }) }); } session . on ( ' NodeWorker . receivedMessageFromWorker ' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); session . on ( ' NodeWorker . attachedToWorker ' , ( data ) => { workerSessionId = data . params . sessionId ; post ( \"Runtime.evaluate\" , { includeCommandLineAPI : true , expression : ` const inspector = process . binding ( ' inspector ' ); inspector . open (); inspector . url (); ` } ); }); const worker = new Worker ( ' . / httpServer . js ' , { workerData : { port : 80 }}); worker . on ( ' online ' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err );}); }); setInterval (() => {}, 100000 ); \u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u62ff\u5230\u4ee5\u4e0b\u8f93\u51fa { id : 1 , result : { result : { type : ' string ' , value : ' ws : //127.0.0.1:9229/c0ca16c8-55aa-4651-9776-fca1b27fc718' } } } \u901a\u8fc7\u8be5\u5730\u5740\uff0c\u5ba2\u6237\u7aef\u5c31\u53ef\u4ee5\u5bf9\u5b50\u7ebf\u7a0b\u8fdb\u884c\u8c03\u8bd5\u4e86\u3002\u4e0a\u9762\u4ee3\u7801\u91cc\u4f7f\u7528process.binding\u800c\u4e0d\u662frequire\u52a0\u8f7dinspector\uff0c\u56e0\u4e3a\u521a\u624d\u901a\u8fc7NodeWorker.enable\u547d\u4ee4\u4e3a\u5b50\u7ebf\u7a0b\u521b\u5efa\u4e86\u4e00\u4e2a\u5230\u5b50\u7ebf\u7a0bInspector\u7684channel\uff0c\u800cJS\u6a21\u5757\u91cc\u5224\u65ad\u5982\u679cchannel\u975e\u7a7a\u5219\u62a5\u9519Inspector\u5df2\u7ecf\u6253\u5f00\u3002\u6240\u4ee5\u8fd9\u91cc\u9700\u8981\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\uff0c\u76f4\u63a5\u52a0\u8f7dC++\u6a21\u5757\u5f00\u542fWebSocket\u670d\u52a1\u5668\u3002 3 \u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b \u00b6 \u4e0d\u4ec5\u53ef\u4ee5\u901a\u8fc7\u4e3b\u7ebf\u7a0b\u8c03\u8bd5\u5b50\u7ebf\u7a0b\uff0c\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u3002Node.js\u5728\u5b50\u7ebf\u7a0b\u66b4\u9732\u4e86connectToMainThread\u65b9\u6cd5\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684Inspector\uff08\u53ea\u80fd\u5728work_threads\u4e2d\u4f7f\u7528\uff09\uff0c\u5b9e\u73b0\u7684\u539f\u7406\u548c\u4e4b\u524d\u5206\u6790\u7684\u7c7b\u4f3c\uff0c\u4e3b\u8981\u662f\u5b50\u7ebf\u7a0b\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684V8 Inspector\uff0c\u901a\u8fc7\u548c\u8be5Inspector\u5b8c\u6210\u5bf9\u4e3b\u7ebf\u7a0b\u7684\u63a7\u5236\u3002\u770b\u4e0b\u9762\u4e00\u4e2a\u4f8b\u5b50\u3002 \u4e3b\u7ebf\u7a0b\u4ee3\u7801 const { Worker , workerData } = require ( ' worker_threads ' ); const http = require ( ' http ' ); const worker = new Worker ( ' . / worker . js ' , { workerData : { port : 80 }}); http . createServer (( _ , res ) => { res . end ( ' main ' ); }). listen ( 8000 ); worker.js\u4ee3\u7801\u5982\u4e0b const fs = require ( ' fs ' ); const { workerData : { port } } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); const session = new Session (); session . connectToMainThread (); session . post ( ' Profiler . enable ' ); session . post ( ' Profiler . start ' ); setTimeout (() => { session . post ( ' Profiler . stop ' , ( err , data ) => { if ( data . profile ) { fs . writeFileSync ( ' . / profile . cpuprofile ' , JSON . stringify ( data . profile )); } }); }, 5000 )","title":"chapter25 Node.js\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u548c\u8bca\u65ad\u6307\u5357"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#1-inspector","text":"\u5728Node.js\u542f\u52a8\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u521d\u59cb\u5316Inspector\u3002 env_ -> InitializeInspector ( std :: move ( inspector_parent_handle_ )); \u5728\u5206\u6790InitializeInspector\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0binspector_parent_handle_\u3002 std :: unique_ptr < inspector :: ParentInspectorHandle > inspector_parent_handle_ ; inspector_parent_handle_\u662f\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u6865\u6881\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u7684\u521d\u59cb\u5316\u903b\u8f91\uff08\u5728\u4e3b\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 inspector_parent_handle_ = env -> inspector_agent () -> GetParentHandle ( thread_id_ , url ); \u8c03\u7528agent\u7684GetParentHandle\u83b7\u53d6\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\u3002 std :: unique_ptr < ParentInspectorHandle > Agent :: GetParentHandle ( int thread_id , const std :: string & url ) { return client_ -> getWorkerManager () -> NewParentHandle ( thread_id , url ); } \u5185\u90e8\u5176\u5b9e\u662f\u901a\u8fc7client_->getWorkerManager()\u5bf9\u8c61\u7684NewParentHandle\u65b9\u6cd5\u83b7\u53d6ParentInspectorHandle\u5bf9\u8c61\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bWorkerManager\u7684NewParentHandle\u3002 std :: unique_ptr < ParentInspectorHandle > WorkerManager :: NewParentHandle ( int thread_id , const std :: string & url ) { bool wait = ! delegates_waiting_on_start_ . empty (); return std :: make_unique < ParentInspectorHandle > ( thread_id , url , thread_ , wait ); } ParentInspectorHandle :: ParentInspectorHandle ( int id , const std :: string & url , std :: shared_ptr < MainThreadHandle > parent_thread , bool wait_for_connect ) : id_ ( id ), url_ ( url ), parent_thread_ ( parent_thread ), wait_ ( wait_for_connect ) {} \u6700\u7ec8\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u5165\u6240\u793a\u3002 \u5206\u6790\u5b8cParentInspectorHandle\u540e\u7ee7\u7eed\u770b\u4e00\u4e0benv_->InitializeInspector(std::move(inspector_parent_handle_))\u7684\u903b\u8f91\uff08\u5728\u5b50\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 int Environment::InitializeInspector ( std :: unique_ptr < inspector :: ParentInspectorHandle > parent_handle ) { std :: string inspector_path ; inspector_path = parent_handle -> url (); inspector_agent_ -> SetParentHandle ( std :: move ( parent_handle )); inspector_agent_ -> Start ( inspector_path , options_ -> debug_options (), inspector_host_port (), is_main_thread ()); } \u9996\u5148\u628aParentInspectorHandle\u5bf9\u8c61\u4fdd\u5b58\u5230agent\u4e2d\uff0c\u7136\u540e\u8c03\u7528agent\u7684Start\u65b9\u6cd5\u3002 bool Agent::Start (...) { // \u65b0\u5efaclient\u5bf9\u8c61 client_ = std :: make_shared < NodeInspectorClient > ( parent_env_ , is_main ); // \u8c03\u7528agent\u4e2d\u4fdd\u5b58\u7684ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted parent_handle_ -> WorkerStarted ( client_ -> getThreadHandle (), ...); } Agent::Start\u521b\u5efa\u4e86\u4e00\u4e2aclient\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted\u65b9\u6cd5\uff08\u521a\u624dSetParentHandle\u7684\u65f6\u5019\u4fdd\u5b58\u7684\uff09\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770bparent_handle_->WorkerStarted\u3002 void ParentInspectorHandle::WorkerStarted ( std :: shared_ptr < MainThreadHandle > worker_thread , bool waiting ) { std :: unique_ptr < Request > request ( new WorkerStartedRequest ( id_ , url_ , worker_thread , waiting )); parent_thread_ -> Post ( std :: move ( request )); } WorkerStarted\u521b\u5efa\u4e86\u4e00\u4e2aWorkerStartedRequest\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7parent_thread_->Post\u63d0\u4ea4\uff0cparent_thread_\u662fMainThreadInterface\u5bf9\u8c61\u3002 void MainThreadInterface::Post ( std :: unique_ptr < Request > request ) { Mutex :: ScopedLock scoped_lock ( requests_lock_ ); // \u4e4b\u524d\u662f\u7a7a\u5219\u9700\u8981\u5524\u9192\u6d88\u8d39\u8005 bool needs_notify = requests_ . empty (); // \u6d88\u606f\u5165\u961f requests_ . push_back ( std :: move ( request )); if ( needs_notify ) { // \u83b7\u53d6\u5f53\u524d\u5bf9\u8c61\u7684\u4e00\u4e2a\u5f31\u5f15\u7528 std :: weak_ptr < MainThreadInterface >* interface_ptr = new std :: weak_ptr < MainThreadInterface > ( shared_from_this ()); // \u8bf7\u6c42V8\u6267\u884cRequestInterrupt\u5165\u53c2\u5bf9\u5e94\u7684\u56de\u8c03 isolate_ -> RequestInterrupt ([]( v8 :: Isolate * isolate , void * opaque ) { // \u628a\u6267\u884c\u65f6\u4f20\u5165\u7684\u53c2\u6570\u8f6c\u6210MainThreadInterface std :: unique_ptr < std :: weak_ptr < MainThreadInterface >> interface_ptr { static_cast < std :: weak_ptr < MainThreadInterface >*> ( opaque ) }; // \u5224\u65ad\u5bf9\u8c61\u662f\u5426\u8fd8\u6709\u6548\uff0c\u662f\u5219\u8c03\u7528DispatchMessages if ( auto iface = interface_ptr -> lock ()) iface -> DispatchMessages (); }, static_cast < void *> ( interface_ptr )); } // \u5524\u9192\u6d88\u8d39\u8005 incoming_message_cond_ . Broadcast ( scoped_lock ); } \u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770b\u56de\u8c03\u91cc\u6267\u884cMainThreadInterface\u5bf9\u8c61DispatchMessages\u65b9\u6cd5\u7684\u903b\u8f91\u3002 void MainThreadInterface::DispatchMessages () { // \u904d\u5386\u8bf7\u6c42\u961f\u5217 requests_ . swap ( dispatching_message_queue_ ); while ( ! dispatching_message_queue_ . empty ()) { MessageQueue :: value_type task ; std :: swap ( dispatching_message_queue_ . front (), task ); dispatching_message_queue_ . pop_front (); // \u6267\u884c\u4efb\u52a1\u51fd\u6570 task -> Call ( this ); } } task\u662fWorkerStartedRequest\u5bf9\u8c61\uff0c\u770b\u4e00\u4e0bCall\u65b9\u6cd5\u7684\u4ee3\u7801\u3002 void Call ( MainThreadInterface * thread ) override { auto manager = thread -> inspector_agent () -> GetWorkerManager (); manager -> WorkerStarted ( id_ , info_ , waiting_ ); } \u63a5\u7740\u8c03\u7528agent\u7684WorkerManager\u7684WorkerStarted\u3002 void WorkerManager::WorkerStarted ( int session_id , const WorkerInfo & info , bool waiting ) { children_ . emplace ( session_id , info ); for ( const auto & delegate : delegates_ ) { Report ( delegate . second , info , waiting ); } } WorkerStarted\u8bb0\u5f55\u4e86\u4e00\u4e2aid\u548c\u4e0a\u4e0b\u6587\uff0c\u56e0\u4e3adelegates_\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f\u7a7a\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u6267\u884c\u3002\u81f3\u6b64\uff0c\u5b50\u7ebf\u7a0bInspector\u521d\u59cb\u5316\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u548c\u4e3b\u7ebf\u7a0b\u4e0d\u4e00\u6837\uff0c\u4e3b\u7ebf\u7a0b\u4f1a\u542f\u52a8\u4e00\u4e2aWebSocket\u670d\u52a1\u5668\u63a5\u6536\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\uff0c\u800c\u5b50\u7ebf\u7a0b\u53ea\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u7ebf\u7a0b\u662f\u5982\u4f55\u52a8\u6001\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u3002","title":"1 \u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u7684Inspector"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#2","text":"\u6211\u4eec\u53ef\u4ee5\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u5f00\u542f\u5bf9\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002 const { Worker , workerData } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); // \u65b0\u5efa\u4e00\u4e2a\u65b0\u7684\u901a\u4fe1\u901a\u9053 const session = new Session (); session . connect (); // \u521b\u5efa\u5b50\u7ebf\u7a0b const worker = new Worker ( ' . / httpServer . js ' , { workerData : { port : 80 }}); // \u5b50\u7ebf\u7a0b\u542f\u52a8\u6210\u529f\u540e\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b worker . on ( ' online ' , () => { session . post ( \"NodeWorker.enable\" , { waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err ); }); }); // \u9632\u6b62\u4e3b\u7ebf\u7a0b\u9000\u51fa setInterval (() => {}, 100000 ); \u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0bconnect\u51fd\u6570\u7684\u903b\u8f91\u3002 connect () { this [ connectionSymbol ] = new Connection (( message ) => this [ onMessageSymbol ]( message )); } \u65b0\u5efa\u4e86\u4e00\u4e2aConnection\u5bf9\u8c61\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u5728\u6536\u5230\u6d88\u606f\u65f6\u88ab\u56de\u8c03\u3002Connection\u662fC++\u5c42\u5bfc\u51fa\u7684\u5bf9\u8c61\uff0c\u7531\u6a21\u7248\u7c7bJSBindingsConnection\u5b9e\u73b0\u3002 template < typename ConnectionType > class JSBindingsConnection {} \u6211\u4eec\u770b\u770b\u5bfc\u51fa\u7684\u8def\u903b\u8f91\u3002 JSBindingsConnection < Connection >:: Bind ( env , target ); \u63a5\u7740\u770bBind\u3002 static void Bind ( Environment * env , Local < Object > target ) { // class_name\u662fConnection Local < String > class_name = ConnectionType :: GetClassName ( env ); Local < FunctionTemplate > tmpl = env -> NewFunctionTemplate ( JSBindingsConnection :: New ); tmpl -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); tmpl -> SetClassName ( class_name ); tmpl -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); env -> SetProtoMethod ( tmpl , \"dispatch\" , JSBindingsConnection :: Dispatch ); env -> SetProtoMethod ( tmpl , \"disconnect\" , JSBindingsConnection :: Disconnect ); target -> Set ( env -> context (), class_name , tmpl -> GetFunction ( env -> context ()). ToLocalChecked ()) . ToChecked (); } \u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew Connection\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cJSBindingsConnection::New\u3002 static void New ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); Local < Function > callback = info [ 0 ]. As < Function > (); new JSBindingsConnection ( env , info . This (), callback ); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aJSBindingsConnection\u5bf9\u8c61\u65f6\u7684\u903b\u8f91\u3002 JSBindingsConnection ( Environment * env , Local < Object > wrap , Local < Function > callback ) : AsyncWrap ( env , wrap , PROVIDER_INSPECTORJSBINDING ), callback_ ( env -> isolate (), callback ) { Agent * inspector = env -> inspector_agent (); session_ = LocalConnection :: Connect ( inspector , std :: make_unique < JSBindingsSessionDelegate > ( env , this ) ); } static std :: unique_ptr < InspectorSession > Connect ( Agent * inspector , std :: unique_ptr < InspectorSessionDelegate > delegate ) { return inspector -> Connect ( std :: move ( delegate ), false ); } \u6700\u7ec8\u662f\u4f20\u5165\u4e86\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u8c03\u7528Agent\u7684Connect\u65b9\u6cd5\u3002 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); // JSBindingsConnection\u5bf9\u8c61\u7684session_\u5b57\u6bb5\u6307\u5411\u7684\u5bf9\u8c61 return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ ) ); } Agent\u7684Connect\u65b9\u6cd5\u7ee7\u7eed\u8c03\u7528client_->connectFrontend\u3002 int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u65b0\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5bf9\u8c61\uff0c\u5728\u65b0\u5efaChannelImpl\u65f6\uff0c\u4f1a\u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u5904\u7406\u7684\u903b\u8f91\u3002 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: shared_ptr < WorkerManager > worker_manager , std :: unique_ptr < InspectorSessionDelegate > delegate , std :: shared_ptr < MainThreadHandle > main_thread_ , bool prevent_shutdown ) : delegate_ ( std :: move ( delegate )), prevent_shutdown_ ( prevent_shutdown ), retaining_context_ ( false ) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); // Node.js\u62d3\u5c55\u547d\u4ee4\u7684\u5904\u7406\u5206\u53d1\u5668 node_dispatcher_ = std :: make_unique < protocol :: UberDispatcher > ( this ); // trace\u76f8\u5173 tracing_agent_ = std :: make_unique < protocol :: TracingAgent > ( env , main_thread_ ); tracing_agent_ -> Wire ( node_dispatcher_ . get ()); // \u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173 if ( worker_manager ) { worker_agent_ = std :: make_unique < protocol :: WorkerAgent > ( worker_manager ); worker_agent_ -> Wire ( node_dispatcher_ . get ()); } // \u5904\u7406runtime runtime_agent_ = std :: make_unique < protocol :: RuntimeAgent > (); runtime_agent_ -> Wire ( node_dispatcher_ . get ()); } \u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173\u7684\u903b\u8f91\u3002\u770b\u4e00\u4e0b worker_agent_->Wire\u3002 void WorkerAgent::Wire ( UberDispatcher * dispatcher ) { frontend_ . reset ( new NodeWorker :: Frontend ( dispatcher -> channel ())); NodeWorker :: Dispatcher :: wire ( dispatcher , this ); auto manager = manager_ . lock (); workers_ = std :: make_shared < NodeWorkers > ( frontend_ , manager -> MainThread ()); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b \u63a5\u7740\u770b\u4e00\u4e0bNodeWorker::Dispatcher::wire(dispatcher, this)\u7684\u903b\u8f91\u3002 void Dispatcher::wire ( UberDispatcher * uber , Backend * backend ) { std :: unique_ptr < DispatcherImpl > dispatcher ( new DispatcherImpl ( uber -> channel (), backend )); uber -> setupRedirects ( dispatcher -> redirects ()); uber -> registerBackend ( \"NodeWorker\" , std :: move ( dispatcher )); } \u9996\u5148\u65b0\u5efa\u4e86\u4e00\u4e2aDispatcherImpl\u5bf9\u8c61\u3002 DispatcherImpl ( FrontendChannel * frontendChannel , Backend * backend ) : DispatcherBase ( frontendChannel ) , m_backend ( backend ) { m_dispatchMap [ \"NodeWorker.sendMessageToWorker\" ] = & DispatcherImpl :: sendMessageToWorker ; m_dispatchMap [ \"NodeWorker.enable\" ] = & DispatcherImpl :: enable ; m_dispatchMap [ \"NodeWorker.disable\" ] = & DispatcherImpl :: disable ; m_dispatchMap [ \"NodeWorker.detach\" ] = & DispatcherImpl :: detach ; } \u9664\u4e86\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\uff0c\u53e6\u5916\u4e86\u4e00\u4e2akv\u6570\u636e\u7ed3\u6784\uff0c\u8fd9\u4e2a\u662f\u4e00\u4e2a\u8def\u7531\u914d\u7f6e\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u65b0\u5efa\u5b8cDispatcherImpl\u540e\u53c8\u8c03\u7528\u4e86uber->registerBackend(\"NodeWorker\", std::move(dispatcher))\u6ce8\u518c\u8be5\u5bf9\u8c61\u3002 void UberDispatcher::registerBackend ( const String & name , std :: unique_ptr < protocol :: DispatcherBase > dispatcher ) { m_dispatchers [ name ] = std :: move ( dispatcher ); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u5176\u5b9e\u662f\u5efa\u7acb\u4e86\u4e00\u4e2a\u8def\u7531\u4f53\u7cfb\uff0c\u540e\u9762\u6536\u5230\u547d\u4ee4\u65f6\u5c31\u4f1a\u6839\u636e\u8fd9\u4e9b\u8def\u7531\u914d\u7f6e\u8fdb\u884c\u8f6c\u53d1\uff0c\u7c7b\u4f3cNode.js Express\u6846\u67b6\u8def\u7531\u673a\u5236\u3002\u8fd9\u65f6\u5019\u53ef\u4ee5\u901a\u8fc7session\u7684post\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001NodeWorker.enable\u547d\u4ee4\u6765\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002\u6211\u4eec\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 post ( method , params , callback ) { // \u5ffd\u7565\u53c2\u6570\u5904\u7406 // \u4fdd\u5b58\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 if ( callback ) { this [ messageCallbacksSymbol ]. set ( id , callback ); } // \u8c03\u7528C++\u7684dispatch this [ connectionSymbol ]. dispatch ( JSONStringify ( message )); } this[connectionSymbol]\u5bf9\u5e94\u7684\u662fJSBindingsConnection\u5bf9\u8c61\u3002 static void Dispatch ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); JSBindingsConnection * session ; ASSIGN_OR_RETURN_UNWRAP ( & session , info . Holder ()); if ( session -> session_ ) { session -> session_ -> Dispatch ( ToProtocolString ( env -> isolate (), info [ 0 ]) -> string ()); } } session_\u662f\u4e00\u4e2aSameThreadInspectorSession\u5bf9\u8c61\u3002 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u4e86ChannelImpl\u7684dispatchProtocolMessage\u3002 void dispatchProtocolMessage ( const StringView & message ) { std :: string raw_message = protocol :: StringUtil :: StringViewToUtf8 ( message ); std :: unique_ptr < protocol :: DictionaryValue > value = protocol :: DictionaryValue :: cast ( protocol :: StringUtil :: parseMessage ( raw_message , false )); int call_id ; std :: string method ; // \u89e3\u6790\u547d\u4ee4 node_dispatcher_ -> parseCommand ( value . get (), & call_id , & method ); // \u5224\u65ad\u547d\u4ee4\u662fV8\u5185\u7f6e\u547d\u4ee4\u8fd8\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4 if ( v8_inspector :: V8InspectorSession :: canDispatchMethod ( Utf8ToStringView ( method ) -> string ())) { session_ -> dispatchProtocolMessage ( message ); } else { node_dispatcher_ -> dispatch ( call_id , method , std :: move ( value ), raw_message ); } } \u56e0\u4e3aNodeWorker.enable\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u8d70\u5230else\u91cc\u9762\u7684\u903b\u8f91\u3002\u6839\u636e\u8def\u7531\u914d\u7f6e\u627e\u5230\u8be5\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u903b\u8f91\uff08NodeWorker.enable\u4ee5.\u5207\u5206\uff0c\u5bf9\u5e94\u4e24\u7ea7\u8def\u7531\uff09\u3002 void UberDispatcher::dispatch ( int callId , const String & in_method , std :: unique_ptr < Value > parsedMessage , const ProtocolMessage & rawMessage ) { // \u627e\u5230\u4e00\u7ea7\u8def\u7531\u914d\u7f6e protocol :: DispatcherBase * dispatcher = findDispatcher ( method ); std :: unique_ptr < protocol :: DictionaryValue > messageObject = DictionaryValue :: cast ( std :: move ( parsedMessage )); // \u4ea4\u7ed9\u4e00\u7ea7\u8def\u7531\u5904\u7406\u5668\u5904\u7406 dispatcher -> dispatch ( callId , method , rawMessage , std :: move ( messageObject )); } NodeWorker.enable\u5bf9\u5e94\u7684\u8def\u7531\u5904\u7406\u5668\u4ee3\u7801\u5982\u4e0b void DispatcherImpl::dispatch ( int callId , const String & method , const ProtocolMessage & message , std :: unique_ptr < protocol :: DictionaryValue > messageObject ) { // \u67e5\u627e\u4e8c\u7ea7\u8def\u7531 std :: unordered_map < String , CallHandler >:: iterator it = m_dispatchMap . find ( method ); protocol :: ErrorSupport errors ; // \u627e\u5230\u5904\u7406\u51fd\u6570 ( this ->* ( it -> second ))( callId , method , message , std :: move ( messageObject ), & errors ); } dispatch\u7ee7\u7eed\u5bfb\u627e\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u7ec8\u627e\u5230NodeWorker.enable\u547d\u4ee4\u7684\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::enable\u3002 void DispatcherImpl::enable (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> enable (...); // \u8fd4\u56de\u54cd\u5e94\u7ed9\u547d\u4ee4\uff08\u7c7b\u4f3c\u8bf7\u6c42/\u54cd\u5e94\u6a21\u5f0f\uff09 weak -> get () -> sendResponse ( callId , response ); } \u6839\u636e\u67b6\u6784\u56fe\u53ef\u4ee5\u77e5\u9053m_backend\u662fWorkerAgent\u5bf9\u8c61\u3002 DispatchResponse WorkerAgent::enable ( bool waitForDebuggerOnStart ) { auto manager = manager_ . lock (); std :: unique_ptr < AgentWorkerInspectorDelegate > delegate ( new AgentWorkerInspectorDelegate ( workers_ )); event_handle_ = manager -> SetAutoAttach ( std :: move ( delegate )); return DispatchResponse :: OK (); } \u7ee7\u7eed\u8c03\u7528WorkerManager\u7684SetAutoAttach\u65b9\u6cd5\u3002 std :: unique_ptr < WorkerManagerEventHandle > WorkerManager :: SetAutoAttach ( std :: unique_ptr < WorkerDelegate > attach_delegate ) { int id = ++ next_delegate_id_ ; // \u4fdd\u5b58delegate delegates_ [ id ] = std :: move ( attach_delegate ); const auto & delegate = delegates_ [ id ]; // \u901a\u77e5\u5b50\u7ebf\u7a0b for ( const auto & worker : children_ ) { Report ( delegate , worker . second , false ); } ... } SetAutoAttach\u904d\u5386\u5b50\u7ebf\u7a0b\u3002 void Report ( const std :: unique_ptr < WorkerDelegate >& delegate , const WorkerInfo & info , bool waiting ) { if ( info . worker_thread ) delegate -> WorkerCreated ( info . title , info . url , waiting , info . worker_thread ); } info\u662f\u4e00\u4e2aWorkerInfo\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u521d\u59cb\u5316\u548c\u4e3b\u7ebf\u7a0b\u5efa\u7acb\u5173\u7cfb\u7684\u6570\u636e\u7ed3\u6784\u3002delegate\u662fAgentWorkerInspectorDelegate\u5bf9\u8c61\u3002 void WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) override { workers_ -> WorkerCreated ( title , url , waiting , target ); } workers_\u662f\u4e00\u4e2aNodeWorkers\u5bf9\u8c61\u3002 void NodeWorkers::WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) { auto frontend = frontend_ . lock (); std :: string id = std :: to_string ( ++ next_target_id_ ); // \u5904\u7406\u6570\u636e\u901a\u4fe1\u7684delegate auto delegate = thread_ -> MakeDelegateThreadSafe ( std :: unique_ptr < InspectorSessionDelegate > ( new ParentInspectorSessionDelegate ( id , shared_from_this ()) ) ); // \u5efa\u7acb\u548c\u5b50\u7ebf\u7a0bV8 Inspector\u7684\u901a\u4fe1\u901a\u9053 sessions_ [ id ] = target -> Connect ( std :: move ( delegate ), true ); frontend -> attachedToWorker ( id , WorkerInfo ( id , title , url ), waiting ); } WorkerCreated\u5efa\u7acb\u4e86\u4e00\u6761\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684\u901a\u9053\uff0c\u7136\u540e\u901a\u77e5\u547d\u4ee4\u7684\u53d1\u9001\u65b9\u901a\u9053\u5efa\u7acb\u6210\u529f\u3002\u8fd9\u65f6\u5019\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u7740\u770battachedToWorker\u3002 void Frontend::attachedToWorker ( const String & sessionId , std :: unique_ptr < protocol :: NodeWorker :: WorkerInfo > workerInfo , bool waitingForDebugger ) { std :: unique_ptr < AttachedToWorkerNotification > messageData = AttachedToWorkerNotification :: create () . setSessionId ( sessionId ) . setWorkerInfo ( std :: move ( workerInfo )) . setWaitingForDebugger ( waitingForDebugger ) . build (); // \u89e6\u53d1NodeWorker.attachedToWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.attachedToWorker\" , std :: move ( messageData ))); } \u7ee7\u7eed\u770bsendProtocolNotification void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662f\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u3002 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { Isolate * isolate = env_ -> isolate (); HandleScope handle_scope ( isolate ); Context :: Scope context_scope ( env_ -> context ()); MaybeLocal < String > v8string = String :: NewFromTwoByte ( isolate , message . characters16 (), NewStringType :: kNormal , message . length () ); Local < Value > argument = v8string . ToLocalChecked (). As < Value > (); // \u6536\u5230\u6d88\u606f\u6267\u884c\u56de\u8c03 connection_ -> OnMessage ( argument ); } // \u6267\u884cJS\u5c42\u56de\u8c03 void OnMessage ( Local < Value > value ) { MakeCallback ( callback_ . Get ( env () -> isolate ()), 1 , & value ); } JS\u5c42\u56de\u8c03\u903b\u8f91\u5982\u4e0b\u3002 [ onMessageSymbol ]( message ) { const parsed = JSONParse ( message ); // \u6536\u5230\u7684\u6d88\u606f\u5982\u679c\u662f\u67d0\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u6709\u4e2aid\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684id\uff0c\u5426\u5219\u5219\u89e6\u53d1\u4e8b\u4ef6 if ( parsed . id ) { const callback = this [ messageCallbacksSymbol ]. get ( parsed . id ); this [ messageCallbacksSymbol ]. delete ( parsed . id ); if ( callback ) { callback ( null , parsed . result ); } } else { this . emit ( parsed . method , parsed ); this . emit ( ' inspectorNotification ' , parsed ); } } \u4e3b\u7ebf\u7a0b\u62ff\u5230Worker Session\u5bf9\u4e00\u4e2a\u7684id\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4NodeWorker.sendMessageToWorker\u52a0\u4e0a\u8be5id\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002\u5927\u81f4\u539f\u7406\u5982\u4e0b\uff0c\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u81ea\u5df1\u7684channel\u548c\u5b50\u7ebf\u7a0b\u7684channel\u8fdb\u884c\u901a\u4fe1\uff0c\u4ece\u800c\u8fbe\u5230\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u76ee\u7684\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0bNodeWorker.sendMessageToWorker\u547d\u4ee4\u7684\u903b\u8f91\uff0c\u5bf9\u5e94\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::sendMessageToWorker\u3002 void DispatcherImpl::sendMessageToWorker (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> sendMessageToWorker ( in_message , in_sessionId ); // \u54cd\u5e94 weak -> get () -> sendResponse ( callId , response ); return ; } \u7ee7\u7eed\u5206\u6790m_backend->sendMessageToWorker\u3002 DispatchResponse WorkerAgent::sendMessageToWorker ( const String & message , const String & sessionId ) { workers_ -> Receive ( sessionId , message ); return DispatchResponse :: OK (); } void NodeWorkers::Receive ( const std :: string & id , const std :: string & message ) { auto it = sessions_ . find ( id ); it -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } sessions_\u5bf9\u5e94\u7684\u662f\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784CrossThreadInspectorSession\u3002\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684Dispatch\u65b9\u6cd5\u3002 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u518d\u6b21\u8c03\u4e86MainThreadSessionState::Dispatch void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002\u7ee7\u7eed\u770b\u5b83\u7684Dispatch\u65b9\u6cd5\u3002 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\uff0c\u6700\u7ec8\u62ff\u5230\u4e86\u4e00\u4e2a\u5408\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684channel\uff0cdispatchProtocolMessage\u65b9\u6cd5\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u8be5\u65b9\u6cd5\u4f1a\u6839\u636e\u547d\u4ee4\u505a\u4e0d\u540c\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd9\u91cc\u53d1\u9001\u7684\u662fV8\u5185\u7f6e\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002\u5f53V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u4f1a\u901a\u8fc7ChannelImpl\u7684sendResponse\u8fd4\u56de\u7ed3\u679c\u3002 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662fParentInspectorSessionDelegate\u5bf9\u8c61\u3002 void SendMessageToFrontend ( const v8_inspector :: StringView & msg ) override { std :: string message = protocol :: StringUtil :: StringViewToUtf8 ( msg ); workers_ -> Send ( id_ , message ); } void NodeWorkers::Send ( const std :: string & id , const std :: string & message ) { auto frontend = frontend_ . lock (); if ( frontend ) frontend -> receivedMessageFromWorker ( id , message ); } void Frontend::receivedMessageFromWorker ( const String & sessionId , const String & message ) { std :: unique_ptr < ReceivedMessageFromWorkerNotification > messageData = ReceivedMessageFromWorkerNotification :: create () . setSessionId ( sessionId ) . setMessage ( message ) . build (); // \u89e6\u53d1NodeWorker.receivedMessageFromWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.receivedMessageFromWorker\" , std :: move ( messageData ))); } m_frontendChannel\u662f\u4e3b\u7ebf\u7a0b\u7684ChannelImpl\u5bf9\u8c61\u3002 void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fC++\u5c42\u4f20\u5165\u7684JSBindingsSessionDelegate\u5bf9\u8c61\u3002\u6700\u7ec8\u901a\u8fc7JSBindingsSessionDelegate\u5bf9\u8c61\u56de\u8c03JS\u5c42\uff0c\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\u5c31\u4e0d\u518d\u8d58\u8ff0\u3002\u81f3\u6b64\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u5177\u5907\u4e86\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b\uff0c\u4f46\u662f\u63a7\u5236\u65b9\u5f0f\u6709\u5f88\u591a\u79cd\u3002","title":"2 \u4e3b\u7ebf\u7a0b\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#21-v8","text":"\u901a\u8fc7\u4e0b\u9762\u4ee3\u7801\u6536\u96c6\u5b50\u7ebf\u7a0b\u7684CPU Profile\u4fe1\u606f\u3002 const { Worker , workerData } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); const session = new Session (); session . connect (); let id = 1 ; function post ( sessionId , method , params , callback ) { session . post ( ' NodeWorker . sendMessageToWorker ' , { sessionId , message : JSON . stringify ({ id : id ++ , method , params }) }, callback ); } session . on ( ' NodeWorker . attachedToWorker ' , ( data ) => { post ( data . params . sessionId , ' Profiler . enable ' ); post ( data . params . sessionId , ' Profiler . start ' ); // \u6536\u96c6\u4e00\u6bb5\u65f6\u95f4\u540e\u63d0\u4ea4\u505c\u6b62\u6536\u96c6\u547d\u4ee4 setTimeout (() => { post ( data . params . sessionId , ' Profiler . stop ' ); }, 10000 ) }); session . on ( ' NodeWorker . receivedMessageFromWorker ' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); const worker = new Worker ( ' . / httpServer . js ' , { workerData : { port : 80 }}); worker . on ( ' online ' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { console . log ( err , \"NodeWorker.enable\" );}); }); setInterval (() => {}, 100000 ); \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u548c\u6570\u636e\u6536\u96c6\u3002","title":"2.1 \u4f7f\u7528\u901a\u7528\u7684V8\u547d\u4ee4"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#22","text":"\u53ef\u4ee5\u901a\u8fc7\u6267\u884c\u811a\u672c\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684WebSocket\u670d\u52a1\uff0c\u50cf\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u4e00\u6837\u3002 const { Worker , workerData } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); const session = new Session (); session . connect (); let workerSessionId ; let id = 1 ; function post ( method , params ) { session . post ( ' NodeWorker . sendMessageToWorker ' , { sessionId : workerSessionId , message : JSON . stringify ({ id : id ++ , method , params }) }); } session . on ( ' NodeWorker . receivedMessageFromWorker ' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); session . on ( ' NodeWorker . attachedToWorker ' , ( data ) => { workerSessionId = data . params . sessionId ; post ( \"Runtime.evaluate\" , { includeCommandLineAPI : true , expression : ` const inspector = process . binding ( ' inspector ' ); inspector . open (); inspector . url (); ` } ); }); const worker = new Worker ( ' . / httpServer . js ' , { workerData : { port : 80 }}); worker . on ( ' online ' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err );}); }); setInterval (() => {}, 100000 ); \u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u62ff\u5230\u4ee5\u4e0b\u8f93\u51fa { id : 1 , result : { result : { type : ' string ' , value : ' ws : //127.0.0.1:9229/c0ca16c8-55aa-4651-9776-fca1b27fc718' } } } \u901a\u8fc7\u8be5\u5730\u5740\uff0c\u5ba2\u6237\u7aef\u5c31\u53ef\u4ee5\u5bf9\u5b50\u7ebf\u7a0b\u8fdb\u884c\u8c03\u8bd5\u4e86\u3002\u4e0a\u9762\u4ee3\u7801\u91cc\u4f7f\u7528process.binding\u800c\u4e0d\u662frequire\u52a0\u8f7dinspector\uff0c\u56e0\u4e3a\u521a\u624d\u901a\u8fc7NodeWorker.enable\u547d\u4ee4\u4e3a\u5b50\u7ebf\u7a0b\u521b\u5efa\u4e86\u4e00\u4e2a\u5230\u5b50\u7ebf\u7a0bInspector\u7684channel\uff0c\u800cJS\u6a21\u5757\u91cc\u5224\u65ad\u5982\u679cchannel\u975e\u7a7a\u5219\u62a5\u9519Inspector\u5df2\u7ecf\u6253\u5f00\u3002\u6240\u4ee5\u8fd9\u91cc\u9700\u8981\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\uff0c\u76f4\u63a5\u52a0\u8f7dC++\u6a21\u5757\u5f00\u542fWebSocket\u670d\u52a1\u5668\u3002","title":"2.2 \u5728\u5b50\u7ebf\u7a0b\u4e2d\u52a8\u6001\u6267\u884c\u811a\u672c"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#3","text":"\u4e0d\u4ec5\u53ef\u4ee5\u901a\u8fc7\u4e3b\u7ebf\u7a0b\u8c03\u8bd5\u5b50\u7ebf\u7a0b\uff0c\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u3002Node.js\u5728\u5b50\u7ebf\u7a0b\u66b4\u9732\u4e86connectToMainThread\u65b9\u6cd5\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684Inspector\uff08\u53ea\u80fd\u5728work_threads\u4e2d\u4f7f\u7528\uff09\uff0c\u5b9e\u73b0\u7684\u539f\u7406\u548c\u4e4b\u524d\u5206\u6790\u7684\u7c7b\u4f3c\uff0c\u4e3b\u8981\u662f\u5b50\u7ebf\u7a0b\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684V8 Inspector\uff0c\u901a\u8fc7\u548c\u8be5Inspector\u5b8c\u6210\u5bf9\u4e3b\u7ebf\u7a0b\u7684\u63a7\u5236\u3002\u770b\u4e0b\u9762\u4e00\u4e2a\u4f8b\u5b50\u3002 \u4e3b\u7ebf\u7a0b\u4ee3\u7801 const { Worker , workerData } = require ( ' worker_threads ' ); const http = require ( ' http ' ); const worker = new Worker ( ' . / worker . js ' , { workerData : { port : 80 }}); http . createServer (( _ , res ) => { res . end ( ' main ' ); }). listen ( 8000 ); worker.js\u4ee3\u7801\u5982\u4e0b const fs = require ( ' fs ' ); const { workerData : { port } } = require ( ' worker_threads ' ); const { Session } = require ( ' inspector ' ); const session = new Session (); session . connectToMainThread (); session . post ( ' Profiler . enable ' ); session . post ( ' Profiler . start ' ); setTimeout (() => { session . post ( ' Profiler . stop ' , ( err , data ) => { if ( data . profile ) { fs . writeFileSync ( ' . / profile . cpuprofile ' , JSON . stringify ( data . profile )); } }); }, 5000 )","title":"3 \u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/","text":"\u524d\u8a00\uff1a\u8c03\u8bd5\u4ee3\u7801\u4e0d\u7ba1\u5bf9\u4e8e\u5f00\u53d1\u8fd8\u662f\u5b66\u4e60\u6e90\u7801\u90fd\u662f\u975e\u5e38\u91cd\u8981\u7684\u6280\u80fd\uff0c\u672c\u6587\u7b80\u5355\u4ecb\u7ecdvscode\u8c03\u8bd5Node.js\u76f8\u5173\u4ee3\u7801\u7684\u8c03\u8bd5\u6280\u5de7\u3002 1 \u8c03\u8bd5\u4e1a\u52a1JS \u00b6 \u8c03\u8bd5\u4e1a\u52a1JS\u53ef\u80fd\u662f\u666e\u904d\u7684\u573a\u666f\uff0c\u968f\u7740Node.js\u548c\u8c03\u8bd5\u5de5\u5177\u7684\u6210\u719f\uff0c\u8c03\u8bd5\u4e5f\u53d8\u5f97\u8d8a\u6765\u8d8a\u7b80\u5355\u3002\u4e0b\u9762\u662fvscode\u7684lauch.json\u914d\u7f6e\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"type\" : \"node\" , \"request\" : \"attach\" , \"name\" : \"Attact Program\" , \"port\" : 9229 } ] } 1 \u5728JS\u91cc\u8bbe\u7f6e\u65ad\u70b9\uff0c\u6267\u884cnode --inspect index.js \u542f\u52a8\u8fdb\u7a0b\uff0c\u4f1a\u8f93\u51fa\u8c03\u8bd5\u5730\u5740\u3002 2 \u70b9\u51fb\u866b\u5b50\uff0c\u7136\u540e\u70b9\u51fb\u7eff\u8272\u7684\u4e09\u89d2\u5f62\u3002 3 vscode\u4f1a\u8fde\u63a5Node.js\u7684WebSocket\u670d\u52a1\u3002 4 \u5f00\u59cb\u8c03\u8bd5\uff08\u6216\u8005\u4f7f\u7528Chrome Dev Tools\u8c03\u8bd5\uff09\u3002 2 \u8c03\u8bd5Addon\u7684C++ \u00b6 \u5199Addon\u7684\u573a\u666f\u53ef\u80fd\u4e0d\u591a\uff0c\u4f46\u662f\u5f53\u4f60\u9700\u8981\u7684\u65f6\u5019\uff0c\u4f60\u5c31\u4f1a\u9700\u8981\u8c03\u8bd5\u5b83\u3002\u4e0b\u9762\u7684\u914d\u7f6e\u53ea\u53ef\u4ee5\u8c03\u8bd5C++\u4ee3\u7801\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"lldb\" , \"request\" : \"launch\" , \"program\" : \"node\" , \"args\" : [ \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" ], \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, ] } 1 \u5728C++\u4ee3\u7801\u8bbe\u7f6e\u65ad\u70b9\u3002 2 \u6267\u884cnode-gyp configure && node-gyp build --debug\u7f16\u8bd1debug\u7248\u672c\u7684Addon\u3002 3 JS\u91cc\u52a0\u8f7ddebug\u7248\u672c\u7684Addon\u3002 4 \u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002 3 \u8c03\u8bd5Addon\u7684C++\u548cJS \u00b6 Addon\u901a\u5e38\u9700\u8981\u901a\u8fc7JS\u66b4\u9732\u51fa\u6765\u4f7f\u7528\uff0c\u5982\u679c\u6211\u4eec\u9700\u8981\u8c03\u8bd5C++\u548cJS\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"node\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" , \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, { \"name\" : \"Attach node C/C++ Addon\" , \"type\" : \"lldb\" , \"request\" : \"attach\" , \"pid\" : \"${command:pickMyProcess}\" } ] } \u548c2\u7684\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u70b9\u4e09\u89d2\u5f62\u5f00\u59cb\u8c03\u8bd5\uff0c\u518d\u9009\u62e9Attach node C/C++ Addon\uff0c\u7136\u540e\u518d\u6b21\u70b9\u51fb\u4e09\u89d2\u5f62\u3002 \u9009\u62e9attach\u5230hello.js\u4e2d\u3002 \u5f00\u59cb\u8c03\u8bd5\u3002 4 \u8c03\u8bd5Node.js\u6e90\u7801C++ \u00b6 \u6211\u4eec\u4e0d\u4ec5\u7528Node.js\uff0c\u6211\u4eec\u53ef\u80fd\u8fd8\u4f1a\u5b66\u4e60Node.js\u6e90\u7801\uff0c\u5b66\u4e60\u6e90\u7801\u7684\u65f6\u5019\u5c31\u5c11\u4e0d\u4e86\u8c03\u8bd5\u3002\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u65b9\u5f0f\u8c03\u8bd5Node.js\u7684C++\u6e90\u7801\u3002 . / configure -- debug && make \u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } \u5728node_main.cc\u7684main\u51fd\u6570\u6216\u4efb\u4f55C++\u4ee3\u7801\u91cc\u6253\u65ad\u70b9\uff0c\u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002 5 \u8c03\u8bd5Node.js\u6e90\u7801C++\u548cJS\u4ee3\u7801 \u00b6 Node.js\u7684\u6e90\u7801\u4e0d\u4ec5\u4ec5\u6709C++\uff0c\u8fd8\u6709JS\uff0c\u5982\u679c\u6211\u4eec\u60f3\u540c\u65f6\u8c03\u8bd5\uff0c\u90a3\u4e48\u5c31\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [ \"--inspect-brk\" , \"${workspaceFolder}/out/Debug/index.js\" ], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } 1 \u70b9\u51fb\u8c03\u8bd5\u3002 2 \u5728vscode\u8c03\u8bd5C++\uff0c\u6267\u884c\u5b8cNode.js\u542f\u52a8\u7684\u6d41\u7a0b\u540e\u4f1a\u8f93\u51fa\u8c03\u8bd5JS\u7684\u5730\u5740\u3002 3 \u5728\u6d4f\u89c8\u5668\u8fde\u63a5WebSocket\u670d\u52a1\u8c03\u8bd5JS\u3002","title":"26-vscode\u8c03\u8bd5Node.js"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#1-js","text":"\u8c03\u8bd5\u4e1a\u52a1JS\u53ef\u80fd\u662f\u666e\u904d\u7684\u573a\u666f\uff0c\u968f\u7740Node.js\u548c\u8c03\u8bd5\u5de5\u5177\u7684\u6210\u719f\uff0c\u8c03\u8bd5\u4e5f\u53d8\u5f97\u8d8a\u6765\u8d8a\u7b80\u5355\u3002\u4e0b\u9762\u662fvscode\u7684lauch.json\u914d\u7f6e\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"type\" : \"node\" , \"request\" : \"attach\" , \"name\" : \"Attact Program\" , \"port\" : 9229 } ] } 1 \u5728JS\u91cc\u8bbe\u7f6e\u65ad\u70b9\uff0c\u6267\u884cnode --inspect index.js \u542f\u52a8\u8fdb\u7a0b\uff0c\u4f1a\u8f93\u51fa\u8c03\u8bd5\u5730\u5740\u3002 2 \u70b9\u51fb\u866b\u5b50\uff0c\u7136\u540e\u70b9\u51fb\u7eff\u8272\u7684\u4e09\u89d2\u5f62\u3002 3 vscode\u4f1a\u8fde\u63a5Node.js\u7684WebSocket\u670d\u52a1\u3002 4 \u5f00\u59cb\u8c03\u8bd5\uff08\u6216\u8005\u4f7f\u7528Chrome Dev Tools\u8c03\u8bd5\uff09\u3002","title":"1 \u8c03\u8bd5\u4e1a\u52a1JS"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#2-addonc","text":"\u5199Addon\u7684\u573a\u666f\u53ef\u80fd\u4e0d\u591a\uff0c\u4f46\u662f\u5f53\u4f60\u9700\u8981\u7684\u65f6\u5019\uff0c\u4f60\u5c31\u4f1a\u9700\u8981\u8c03\u8bd5\u5b83\u3002\u4e0b\u9762\u7684\u914d\u7f6e\u53ea\u53ef\u4ee5\u8c03\u8bd5C++\u4ee3\u7801\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"lldb\" , \"request\" : \"launch\" , \"program\" : \"node\" , \"args\" : [ \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" ], \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, ] } 1 \u5728C++\u4ee3\u7801\u8bbe\u7f6e\u65ad\u70b9\u3002 2 \u6267\u884cnode-gyp configure && node-gyp build --debug\u7f16\u8bd1debug\u7248\u672c\u7684Addon\u3002 3 JS\u91cc\u52a0\u8f7ddebug\u7248\u672c\u7684Addon\u3002 4 \u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002","title":"2 \u8c03\u8bd5Addon\u7684C++"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#3-addoncjs","text":"Addon\u901a\u5e38\u9700\u8981\u901a\u8fc7JS\u66b4\u9732\u51fa\u6765\u4f7f\u7528\uff0c\u5982\u679c\u6211\u4eec\u9700\u8981\u8c03\u8bd5C++\u548cJS\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"node\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" , \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, { \"name\" : \"Attach node C/C++ Addon\" , \"type\" : \"lldb\" , \"request\" : \"attach\" , \"pid\" : \"${command:pickMyProcess}\" } ] } \u548c2\u7684\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u70b9\u4e09\u89d2\u5f62\u5f00\u59cb\u8c03\u8bd5\uff0c\u518d\u9009\u62e9Attach node C/C++ Addon\uff0c\u7136\u540e\u518d\u6b21\u70b9\u51fb\u4e09\u89d2\u5f62\u3002 \u9009\u62e9attach\u5230hello.js\u4e2d\u3002 \u5f00\u59cb\u8c03\u8bd5\u3002","title":"3 \u8c03\u8bd5Addon\u7684C++\u548cJS"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#4-nodejsc","text":"\u6211\u4eec\u4e0d\u4ec5\u7528Node.js\uff0c\u6211\u4eec\u53ef\u80fd\u8fd8\u4f1a\u5b66\u4e60Node.js\u6e90\u7801\uff0c\u5b66\u4e60\u6e90\u7801\u7684\u65f6\u5019\u5c31\u5c11\u4e0d\u4e86\u8c03\u8bd5\u3002\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u65b9\u5f0f\u8c03\u8bd5Node.js\u7684C++\u6e90\u7801\u3002 . / configure -- debug && make \u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } \u5728node_main.cc\u7684main\u51fd\u6570\u6216\u4efb\u4f55C++\u4ee3\u7801\u91cc\u6253\u65ad\u70b9\uff0c\u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002","title":"4 \u8c03\u8bd5Node.js\u6e90\u7801C++"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#5-nodejscjs","text":"Node.js\u7684\u6e90\u7801\u4e0d\u4ec5\u4ec5\u6709C++\uff0c\u8fd8\u6709JS\uff0c\u5982\u679c\u6211\u4eec\u60f3\u540c\u65f6\u8c03\u8bd5\uff0c\u90a3\u4e48\u5c31\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [ \"--inspect-brk\" , \"${workspaceFolder}/out/Debug/index.js\" ], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } 1 \u70b9\u51fb\u8c03\u8bd5\u3002 2 \u5728vscode\u8c03\u8bd5C++\uff0c\u6267\u884c\u5b8cNode.js\u542f\u52a8\u7684\u6d41\u7a0b\u540e\u4f1a\u8f93\u51fa\u8c03\u8bd5JS\u7684\u5730\u5740\u3002 3 \u5728\u6d4f\u89c8\u5668\u8fde\u63a5WebSocket\u670d\u52a1\u8c03\u8bd5JS\u3002","title":"5 \u8c03\u8bd5Node.js\u6e90\u7801C++\u548cJS\u4ee3\u7801"}]}